====
qwer
====

g++ edyProgram.cpp -o edyProgram.exe

NOTE: on orion I se >> visual studio dona problemi di license.
SOLUTION 
1) se ti compare il messaggio di errore lascialo cosi' aperto come'
2) va nell'orologio nella taskbar in basso a destra e setta la data a 2010
3) ritorna a visual studio e clicca su exit program. 
Il programma non si chiude e lo potrai utilizzare. 
Thanks Ciccio

NOTE2: soundtrack per alta concentrazione per coprire rumori usa white noise, tipo "river sound", lavora a meraviglia e ti immerge in un mondo a-spaziotemporale

[MIT course. 
Take a look in MITOpenCourseWare directory -> Introduction to C and C++ absoluely lovely, il zip downloadabile ti permette poi di visionare i documenti nel tuo browser offine, lovely!! con un extract sui Lab files li puoi estrarre nella cartella di downloadaggio ed esercitarti, creare hackerare!!! evviva! poco importa che altri "fan piu'" "son piu'" "han gia'", con la piccola 127 possiamo imparare nel nostro piccolo e creare piccole gadget amusant con arduino e trollare in internet!]
[logistic comment in Orion I aprilo con gedit]


NOTE: se trovi delle voci con numero pagina non accompagnato dal nome del libro, significa che si riferisce al Deitel book
NOTE2: study tip Quando studi con questo txt, aprine una seconda istanza con firefox, in tal modo nel text editor aggiungi le tue note, e in firefox qualora dovessi cercare notazioni dimenticate puoi effettuare delle ricerche e poi tornare al text editor senza bisogno di ritornare al punto in cui stavi scrivendo.
NOTE3: i programmini di Mike sono stati lanciati con Visual Studio 2013 on Orion1 
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug
clicca sul batch file per aprire il terminal e vedere il risultato. Per comodita' abbiamo spesso usato lo stesso file sovrascrivendo il contenuto del file lanciando precedente.
NOTE4: book accelerated / or "moo book" or "barbara book" -> means Accelerated C++ by Andrew Koenig and Barbara Moo
NOTE5: "jesse book" means -> SAMS Teach Yourself C++ in 21 days Jesse Liberty 

LA SANTA TRINITA' 

       declaration -> *.h                             definition -> *.ccp
                           instantiation -> main.ccp

Nel nome della dichirazione, della definizione e della santa istanziazione, Amen.
[trick quando fai il segno della croce ricordati dichiarazione tocca la fronte lo dichiari a Dio verso l'alto [del resto anche il suffisso *H dell'header richiama all'alto, l'H su sui ci poggia l'elicottero, la venuta del santo spirito], con definizione tocchi la pancia, definisci il corpo della dichiarazione precedentemente effettuata, con la santa istanziazione (tocco alle spalle - non dimenticare la s davanti a palle -) incarni la definizione. Il Verbo si fa di Questo MONDO. Ai ripari!!!]

ITIAF question 
) from pag 864 deitel:  I puntatori hanno un'allocazione di memoria di tipologi aidentica a quella delle variabili? Cioe' mi devo immaginare memorizzati disegnati al di sopra della grigali di memoria (vedi disegno pag 864) come una qualunque altra variabile, oppure possiedono un'allocazione speciale, al di sotto (o sopra ) della griglia delle comuni variabili mortali?

[jajaja]

>> UBIK
in vim 
	:set number
per visualizzare il numero delle linee
	:set nonumber
per non visualizzare il numero delle linee (comodo per copiare)


se vi e' spazio a disposizione contrassegniamo le righe di codice con un tab iniziale

>> ; 
semicolon character: this character is used to mark the end of a statement and it MUST be incuded at the end lf ALL expression statements in all C++ programs

>> . 
the dot member selection operator is used to access a public member
[pag378deitel]
Objects names and references can be used with the dot . member selection operator to access a public member and pointers can be used with the arrow (->) member selection operator.
pag 386deitel >> . vs -> / >> -> vs .
- The dot member selection operator . is preceded by 
	1) an object's name or 
	2) with a reference to an object to access the object's members.
- The arrow member selection operator (->) is preceded by 
	a pointer to an object to access the object's members
Example of accessing public class Members through Objects, References and Pointers
Consider an "Account" class that has a "public setBalance" member function. Given the following declarations:
[from pag386deitel]
	Account account; // an account object
	// accountRef refers to an Account object
	Account &accountRef = account; 
  	// accountPtr points to an Account object
	Account*accountPtr = &account;
You can invoke member function "setBalance" using the dot . and arrow -> member selection operators as follows:
	// call setBalance via the Account object
	account.setBalance( 127.16 );
	// call setBalance via a reference to the Account object
	accountRef.setBalance ( 127.16 );
	// call setBalance via a pointer to the Account object
	accountPrt->setBalance( 127.16 );
>> -> examples
lo trovi anche a pag 527 deitel
ex a rogram invokes a virtual function through a base-class pointer to a derived-class object (e.g. shapePtr->draw())

>> _ / >> underscore meaning 
In C++, an underscore usually indicates a private member variable
[source http://stackoverflow.com/questions/3136594/naming-convention-underscore-in-c-c-variables]
also :
- Each name that contains a double underscore (_ _) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.
- Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace
[http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier]
>> _ about the underscore ad the end of a variable [as you can find in some openFOAM header files]:
adding an underscore to member variable allows you to name your getter and setter with the 'conceptual' name of the variable.
ex:
	class MyClass
	{
	   int someMember_;

	public:
	   int someMember() const { return someMember_; }
	   void someMember( int newValue ) { someMember_ = newValue; }
	};
not that I use this style though.
[source : http://stackoverflow.com/questions/1630412/is-using-underscore-suffix-for-members-beneficial]
anyway here this use is discouraged:
	I've read The C++ Programming Language and Stroustrup doesn't use any kind of convention for naming members. He never needs to; there is not a single simple accessor/mutator, he has a way of creating very fine object-oriented designs so there's no need to have a method of the same name. He use\s structs with public members whenever he needs simple data structures. His methods always seem to be operations. I've also read somewhere that he disencourages the use of names that differ only by one character.
[http://stackoverflow.com/questions/3650623/trailing-underscores-for-member-variables-in-c?rq=1]
	The names of variables and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.
[http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Variable_Names]
[http://geosoft.no/development/cppstyle.html]
/////////////////////////////////////////////////////////////////////////

NOMENCLATURA
pag** mike = ci riferiamo al libro di Mike Beginning C++ Through Game Programming

>> * the INDIRECTION OPERATOR * / >> *
[pag337deitel]
{in Mike Programming Game, >> * is also called DEREFERENCE OPERATOR (pag121). By placing * in front of an iterator, you're saying "treat this as the thing that the iterator references, not as the iterator itself"
NOTE trick:  *  somiglia ad una stella, come la luce di una torcia che punta verso l'indirizzo di una sezione di memoria.
Supponi di avere le seguenti righe di codice:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr
	yPtr = &y;           // assign address of y to yPtr
Nella seconda riga compare the unary * operator (commonly referred as the indirection operator or dereferencing operator) that returns an lvalue representing the object to which its pointer operand points. Per esempio riprendendo l'esempio sopra 
	cout << *yPtr << endl;
display the value of variable y namely 5, just as the statement
	cout << y << endl;
Using * in this manner is called dereferencing a pointer. A dereferenced pointer may also be used on the left side of an assignment statement, as in 
	*yPtr = 9;
which would assign 9 to y. The deferenced pointere may also be used to receive an input value as in 
	cin >> *yPtr;
which places the input value in y.
NOTE1: dereferencing an uninitialized pointer results in undefined behaviour that could cause a fatal execution-time erro. This could also lead to accidentally modifying important data, allowing the program to run to completion, possibly with incorrect results.
NOTE2: dereferencing a null pointer results in undefined behavior and typically is a fatal execution-time error, so you should ensure that a pointer is not null before dereferencing it.
Per esempio pratico di utilizzo dell'indirection operator in combinazione con l'address operator see exemple fig8.4 pag 339deitel
Te lo riscrivo qui per comodita'.
// ----------------------------------------------
// Fig. 8.4: fig08_04.cpp
// Pointer operators & and *.
#include <iostream>
using namespace std;
int main()
{
   int a = 7; // assigned 7 to a
   int *aPtr = &a; // initialize aPtr with the address of int variable a

   cout << "The address of a is " << &a
      << "\nThe value of aPtr is " << aPtr;
   cout << "\n\nThe value of a is " << a
      << "\nThe value of *aPtr is " << *aPtr << endl;
} // end main
// ---------------------------------------------- fine estratto codice 
Si ottiene as output
	The address of a is 0x7fff6e3a795c
	The value of aPtr is 0x7fff6e3a795c
	The value of a is 7
	The value of *aPtr is 7
// -----------------------------------------------
   

>> & ADDRESS OPERATOR (&)   [diverso dal >> reference operator & che dev'essere sempre preceduto dal data-type name (see pag190 mike game programming)]
[yes they use & (end) like in Cosa nostra, perche' quando sanno l'ADDRESS, they come and kill you This is the &]
[pag 337deitel] the address operator & is a unary operator that obtains the memory address of its operand. For  example:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr  [il puntatore similmente a un puntatore laser * emette raggi per puntare verso un indirizzo]
	yPtr = &y;           // assign address of y to yPtr
NOTE: the use of the & in the preceding statement is not the same as the use of the & in a reference variable declaration, which is ALWAYS  preceded by a data-type name. When declaring a reference, the & is part of the type. In an expression like &y, the & is the  address operator.
NOTE2: the unary * operator (commonly referred as the indirection operator or dereferencing operator) returns an lvalue representing the object to which its pointer operand points. Per esempio riprendendo l'esempio sopra 
	cout << *yPtr << endl;
display the value of variable y namely 5, just as the statement
	cout << y << endl;
Using * in this manner is called dereferencing a pointer. A dereferenced pointer may also be used on the left side of an assignment statement, as in 
	*yPtr = 9;
which would assign 9 to y. The deferenced pointere may also be used to receive an input value as in 
	cin >> *yPtr;
which places the input value in y. 
NOTE3: memory locations are output as hexadecimal integers. The memory addresses output like a program like the following are platform dependent, so you may get different results when you run the program. 
Dal programma otterrai che l'address di a is the same as the value of aPtr, confirming that the address of a is indeed assigned to the pointer variable Ptr.
// ------------------------------------------------
// Fig. 8.4: fig08_04.cpp
// Pointer operators & and *.
#include <iostream>
using namespace std;
int main()
{
   int a = 7; // assigned 7 to a
   int *aPtr = &a; // initialize aPtr with the address of int variable a

   cout << "The address of a is " << &a
      << "\nThe value of aPtr is " << aPtr;
   cout << "\n\nThe value of a is " << a
      << "\nThe value of *aPtr is " << *aPtr << endl;
} // end main

// ------------------------------------------------
Si ottiene as output
	The address of a is 0x7fff6e3a795c
	The value of aPtr is 0x7fff6e3a795c
	The value of a is 7
	The value of *aPtr is 7
// ------------------------------------------------


>> T& / >> type / >> & [pag71 moo book]
	T&        denotes a reference to the type T. MOst commonly used to pass a parameter 
              that a function may change. Arguments to such parameters must be lvalues. 

	const T&  denotes a reference to the type T that may not be used to change the value to which the refence is bound. 
              Usually used to avoid cost of copying a parameter to a function.  
////////////////////////////////////////////////////////////////////////////////

>> #
the # (hash sign) posto ad inizio riga indica che e'  una riga di directives for the prepocessor. Those lines are not regular code lines with expressions but indications for the compiler's preprocessor.
Prepocessor directives must b specified in their own line and do NOT have to end with a semicolon (;)

>> \ 
escape character 
example 
	std::cout << "Welcome to C++!\n";
a string literal's characters normally print exactly as they appear between the double quotes. However the characters \n are not printed on the screen. When a backslash  is encountered in a string of characters, the next character is combined with the backslash to form an escape sequence. The escape sequence \n means newline.	

>> :
[pag497]
The colon (:) indicates inheritance
example
	class nomeDerivedClass : public nomeBaseClass
	{...codice...}
NOTE1 ( common programming error): when a derived class constructor calls a base class constructor, the arguments passed to the base-class constructor must be consistent with the number and types of parameters specified in one of the base-class constructors; otherwiese, a compilation error occurs.
NOTE2 (advice: initialize member objects explicitly in the member initializer): in a derived class constructor, invoking base-class constructors and initializing member objects explicitly in the member initiliazer list prevents duplicate initialization in which a default constructor is called, then data members are modified again in the derived class constructor's body.
NOTE3: if you get the error
>> error 
	... is a private member of ...
this is due to the fact that C++ rigidly enforces restrictions on accessing private data members, so that even a derived class (which is intimately related to its base class) cannot access the base class's private data.    
A DERIVED CLASS'S MEMBER FUNCTIONS CANNOT ACCESS ITS BASE CLASS'S PRIVATE DATA. In order to retrieve the values of the base class's data members 
- una soluzione e' quella di utilizzare appropriate "get" member functions.
- oppure, come a pagina 502 deitel, si puo' usare PROTECTED base class data members, instead of PRIVATE. In effetti a derived class is granted to access protected base-class data members. Objects of a derived class also can access protected members in any of that derived class's indirect base classes. MA attenzione usare "protected" presenta anche degli svantaggi come puoi trovare scritto nella voce "protected" o a pag.504 deitel
NOTE4 [pag500deitel] : it is necessary to include the Base-Class Header in the Derived Class Header with #include
This is necessary for 3 reason 
	1) for the derived class to use the base class's name, we must tell the compiler that the base class exists
	2) to determine the size of an object of that class. A client program that creates an object of a class #includes the class definition to enable the compiler to reserve the proper amount of memory for the object. When using inheritance, a derived-class object's size depends on the data members declared explicitly in its class definition AND the data members inherited from its direct and indirect base classes.
	3) to allow the compiler to determine whether the derived class uses the base class' inherited members properly.  
/////////////////////////////////////

>> ::
[pag89 deitel]
	::  e' il SCOPE RESOLUTION OPERATOR o anche scope operator [pag5 moo book]
example 
	std::cout = means "the name cout that is in the scope std"
[see also voce >> UNARY SCOPE RESOLUTION OPERATOR pag242deitel]	
It "ties" each member function to the class definition (the *.h header file), which declares the class's member functions and data members. (o detto in maniera piu' semplice [soure pag382deitel] a member function declared in a class definition may be defined outside that class definition and "tied" to the class via the "scope resolution operator")
:: esso compare quando si adotta l'approccio di separare l'interfaccia della classe [il Padre](contenente the functions prototypes that specify the interface of the class) dall'implementation della classe [Il Figlio Cristo] che contiene le member function definitions. 
Detto in parole spicciole: l'header myClasse.h contiene solo il "titolo" delle funzioni, mentre l'implementazione e' contenuta in myClasse.cpp che quindi contiene il "contenuto delle funzioni" . In tal modo quando il main.cpp program chiama la myClass.h (usando un #include) la definizione delle funzioni di myClass resta nascosta, interagisce giusto con l'interfaccia myClass che contiene giusto i "titoli" delle funzioni. L'implementazione delle funzioni e' contenuta/nascosta/protetta in myClass.ccp, ma affinche il compiler possa riconoscerle come member functions della classe myClass, each function name dev'essere preceduto da myClass:: 
Se dimenticassi myClass:: the compiler would consider those functions as free or loose functions, like "main". These are called also global functions. And global functions cannot access private data or call the class's member functions. Se per caso provassi ad accedere ad una variabile che e' stata gia' dichiarata come data member in myClass, visto che mancano i :: non la potresti vedere, dovresti redefinirla localmente in ciascuna "loose" function.  
ACHTUNG! When defining a class's member functions outside that class, omitting the class name and scope resolution operator (::) preceding the function names causes errors. 
Per ulteriori info sulla struttura generale in cui e' inserito il :: vedi voce 
>> INTERFACE OF A CLASS
-------------------------------------- 
DONE [itiaf] twaf = there was a future
OLD
che cosa indica?
ex in sintassi openFOAM del tipo 
	initialMassFluid[i] = fvc::domainIntegrate(rhoFluid[i]).value();
mia risposta [to verify]
mi sembra che sia un modo per far ereditare le proprieta' di una certa classe/library ex domainIntegrate eredita' tutte le proprieta' della classe fvc (= finite volume control) 	


>> ~ meaning
"Destructor" functions are the inverse of constructor functions. They are called when objects are destroyed (deallocated). Designate a function as a class's destructor by preceding the class name with a tilde (~). For example, the destructor for class String is declared: ~String()
[source https://msdn.microsoft.com/en-us/library/6t4fe76c.aspx]
Example from openFOAM:
	// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
	Foam::radiation::multiBandSolidTransmissivity::~multiBandSolidTransmissivity()
	{}
[]	

>> stream insertion operator 
	<<
example 
		std::cout << "Welcome to C++!\n";
the value to the operator's right ("Welcome to C++!\n" alla destra di <<) is inserted in the left  cout = output stream. 
NOTICE that the operator points in the direction of where the data goes. 
[pag42deitel]

>> stream extraction operator 
	>>
example 
	std::cin >> number1; // read first integer from user into number1
NOTE: nel caso tu voglia accedere to an Array's private data, dovrai dichiare lo stream extraction operator as "friend" of class Array
[tag >> access Array data]
[pag462deitel]
////////////////////////////////////////////

>> insertion operator cioe' "<<" 

>> >> vs << / >> << vs >> / >> stream extraction operator / >> stream insertion operator / >> extraction operator / >> insertion operator
[pag 440 deitel]
Eccoti un Ciccio trick per non confondere >> con >> 
1) leggi la riga da sinistra versio destra.                    
il flusso di informazione fluisce da sinistra verso destra 
Quando incontri l'operatore << l'informazione dal mondo del computer viene fatta uscire nel nostro mondo
                      ____________                                                          
 TRON >------------ <<____________ OUR WORLD       example  std::cout << "Welcome to C++!\n";

Quando incontri l'operatore >> l'informazione confluisce dal nostro mondo in TRON (computer)
           ______________
 OUR WORLD ______________ >> -----------> TRON     example  std::cin >> number1;

In questo modo ti dovrebbe venire automatico che quando vedi >> = into TRON , << = into our WORLD
Quando incontri l'operatore >> l'informazione dal mondo finisce in TRON (computer's world)
Inoltre la terminologia
A)	>> extraction operator
B)	<< insertion operator 
e' dal punto di vista del computer. 
A) il computer estrae informazione dal nostro mondo e' l'accumula in se >> ----> extract and brought into TRON
B) il computer inserisce l'informazione nel nostro mondo TRON ------ << OUR WORLD 
ESEMPIO PRATICO 
>> variable definition example:
---------------------------------------------------- start example
int main()
{                                                                                                  ----------
	// ask for the person's name                                                                  /          \
	std::cout << "Please enter your first name: ";   // << = (ciccio trick)   diffuse expand to <<   SCREEN   |
                                                                                                  \          / 
	// read the name                                                                               ---------- 
	std::string name;     // define `name'                                                                        ----------\
	std::cin >> name;     // read into `name'        // >> = (ciccio trick) from keyboard  focused and save into  ----------->> VARIABLE
                                                                                                                  ----------/
	// write a greeting
	std::cout << "Hello, " << name  << "!" << std::endl;
	return 0;
}
---------------------------------------------------- end example
///////////////////////////////////////////


>> AAAAAAA

>> abort 
[pag393deitel]
the function "abort" performs similarly to function "exit" but forces the program to terminate immediately without allowing the destructors of any objects to be called.
Abort is usually used to indicate an abnormal termination of the program.

>> abstract classes
[pag533 deitel]
Abstract classes are classes from which you never intend to instatntiate any objects. Such classes are called abstract classes. Because these classes norally are used as base classes in inheritance hierarchies, we refer to them as abstract base classes.
These classes cannot be used to instantiate objects, because abstract classes are incomplete, derived classes must define the "missing pieces" before objects of these classes can be instantiated.
>> CONCRETE CLASSES vs ABSTRACT CLASSES
An abstract class is a base class from which other classes can inherit. Classes that can be used to instanttiate objects are called "concrete classes" Such classes define or inherit implementations for every member function they declare. We could have an abstract base clas TwoDimensionalShape and derive such concrete classes as Square, Circle and Triangle. We could also have an abstract base class ThreeDimensionalShape and derive such concrete classes as Cube, Sphere, and Cylinder. Abstract ase classes are too generic to define real objects. We need to be more specific before we can think of instantiating objects. For example if someone tells you to "draw the 2-dimensional shape" what shape would you draw? Concrete classes provide the specifics that make it possible to instantiate objects.
An inheritance hierarchy does not need to contain any abstract classes, but many object-oriented systems have class hierarchies headed by abstracdt base classes. In some cases, abstract classes constitute the top few levels of the hierarchy.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ABSTRACT CLASSES [pag327 mike game programming]
useful when you want to define a class to act as a base for other classes, but it doesn't make sense to instantiate objects from this class because it's so generic. An abstract class is a base class only, and not meant for instantiating objects.
>> pure virtual function = [mike game programming pag 329] is one to which you don't need to give a definition. [nice spiegazione]
example 
	virtual void Greet() const = 0; // pure virtual member function
When a class contains at least one pure virtual function, it's an abstract class.
>> DERIVE FROM ABSTRACT CLASS [pag329 mike game programming]
When you derive a new class from an abstract class, you can override its pure virtual functions. If you override all of its pure virtual functions, then the new class is not abstract and you can instantiate objects from it.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> abstract base classes [pag274 moo book]
They exist only to capture an abstract interface for an inheritance hierarchy.

>> access function 
[pag386deitel]
Accesss function can read or display data. Another common use for access functios is to test the truth or falsity of conditions. Such fuctions are often called predicative functions. 
Example :
- potremmo creare a "isFull" predicate function that might test a container-class object to determine whether it has no additional room. 

>> accessor functions [pag161, 162 moo book]

>> accumulate function [pag115 moo book]
example in /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/analysis.cc
Extract:
double average(const vector<double>& v)
{
	return accumulate(v.begin(), v.end(), 0.0) / v.size();   // computing >> average
}
NOTE: this function is declared in <numeric> quindi per usarla all'inizio del programma devi mettere 
	#include <numeric>
NOTE2: accumulate function adds the values in the range denoted by its first two arguments, starting the summation with the value given by its third argument. The type of tue sum is the type of the third argument, so it is crucially important for us to use 0.0, instead of 0. Otherwise, the result would be an int, and any fractional part would be lost.
Having accumulate to generate the sum of all the elements in the range, we divide that sum by v.size(), which is the number of elements in the range. The result of that division, of course, is the average.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> ACTIVATION RECORD
[pag232deitel]
l'activation record e' anche chiamato STACK FRAME. It contains the return address that the called function needs in order to return to the calling function. 
	
>> ACTIVITY DIAGRAM 
[pag108deitel]
An activity diagram models the workflow (also called the activity) of a portion of a software system. In them you can find :                              ____
- action states [scritte in rettangoli con i bordi laterali curvati (____)  ] that represent actions to perform, calculations or input/output operations; 
- arrows transition which represent the flow of the activity; 
- the solid circle at the top of the diagram represents the activity's initial state (=the beginning of the workflow before the program performs the modeled activities);
- the solid circle surrounded by a hollow circle that appears at the bottom of the activity diagram represents the final state.
for more info see pag108deitel and visit www.deitel.com/UML/  
- the diamond or decision symbol indicates that a decision is to be made. A decision symbol indicates that the workflow will continue along a path determined by the symbol's associated guard conditions, which can be true or false. The guard condition is the condition specified in square brackets above or next to the transition arrow (see example if single selection activity diagram @ pag 111deitel)
The decisions can be passedd on conditions containing relational or equality operators. Actually in C++, a decision can be passed on ANY expression:
> if the expression evaluates to zero, it's treated as false [come Dio insomma]
> if the expression evaluates to nonzero, it's treated as true.  C++ provides the data type "bool" for variables that can hold only the values "true" and "false", each of these is a C++ keyword.
For compatibility with earlier versions of C, which used integers for Boolean values 
> the bool value "true" also can be represented by any non zero value (compilers typically use 1)
> the bool value "false" also can be represented as the value zero. 

>> ALGORITHMS
[pag105deitel]
A procedure for solving a problem in terms of 
	1. the ACTIONS to execute and 
	2. the ORDER in which the actions execute
is called algorithm.
/////////////
>> ALGORITHMS INTRODUCTION [pag649deitel]
The Standard Library provides scores of algorithms you'll use frequently to manipulate a variety of containers. Inserting, deleting, searching, sorting and others are appropriate for some or all of the sequence and associative containers.The algorithms operate on container elements onlyindirectly through iterators. Many algorithms operate on sequences of elements defined by iterators pointing to the first element of the sequence and to one element past the last element.
In chapter 15.5 the "copy" algorithm is used in many examples to copy a container's contents to the standard output. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> algorithms vs containers vs iterators [pag120 moo book]
NOTE1: Algorithms act on container elements; they do not act on containers. 
Algorithms like sort, remove_if, and partition functions all move the elements to new positions in the underlying container, but they do not change the properties of the container itself.
For example remove_if does not change the size of the container. Rather it copies each element for which the predicate is false to the beginning of the container, and left the rest of the elements alone. When we need to shorten the container to discard those elements, we must do so ourselves. We need to use "erase" to actually change the container by removing the sequence indicated by its arguments. Note that erase must be a member of the container, because it acts directly on the container, not just on its elements.
NOTE2: it is important to be aware of the interaction between iterators and algorithms, and between iterators and container operators. Operations such as erase and insert invalidate the iterator for the element erased. More important, in the case of vectors and strings, operations such as erase or insert also invalidate any iterator denonting elmeents after the one erased or inserted. Because these operations can invalidate iterators, we must be careful about saving iterator values if we are using these operations.
Similarly, functions such as "partition" or "remove_if" which can move elements around withing the container, will change which element is denoted by particular iterators. After running one of these functions, we cannot rely on an iterator continuing to denote a specific element.


>> AMPERSAND 
	&
il simbolo & e' chiamato ampersand.

>> argv vs >> argc
[http://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean]
What does int argc, char *argv[] mean?
In many C++ IDE's and compilers, when it generates the main function for you, it looks like this:
	int main(int argc, char *argv[])
When I code C++ without an IDE, just with a command line compiler, I type:
	int main()
without any parameters. What does this mean, and is it vital to my program?
ANSWER
argv and argc are how command line arguments are passed to main() in C and C++.
argc will be the number of strings pointed to by argv. This will (in practice) be 1 plus the number of arguments, as virtually all implementations will prepend the name of the program to the array.
The variables are named argc (argument count) and argv (argument vector) by convention, but they can be given any valid identifier: int main(int num_args, char** arg_strings) is equally valid.
They can also be omitted entirely, yielding int main(), if you do not intend to process command line arguments.
Try the following program:
	#include <iostream>	
	int main(int argc, char** argv) {
	    std::cout << "Have " << argc << " arguments:" << std::endl;
	    for (int i = 0; i < argc; ++i) {
	        std::cout << argv[i] << std::endl;
	    }
	}
Running it with ./test a1 b2 c3 will output
Have 4 arguments:
	./test
	a1
	b2
	c3
///////////////////////////////////////////////////////////////////////

>> ARGUMENT COERCION 
[from summary pag259deitel]
Argument coercion is an important feature of function prototypes (pag211deitel) 
Argument coercion =  forcing arguments to the appropriate types specified by the parameter declarations. 


>> ARGUMENT VS Parameter 
[pag71 deitel and pag73]
ARGUMENTS are the values that a function call supply for each of the function's parameters
	class ClassName
	{
	public:
		void functionName( string parameter1 ) const  // member function header
		{....}
	};
	int main ()
	{
		ClassName myObjectName; // creation of a ClassName object
		myObjectName.functionName( argument1 );  // function call
	}
OBSERVATIONS
- each parameter specifies a type (string nell'esempio sopra) and an identifier (parameter1) 
- the parameter variable's name (parameter1) can be the same as or different from the argument variable's name (argument1 nel nostro esempio abbiamo scelto dei nomi diversi)
- a function can specify multiple parameters by separating each from the next with a comma. 	
- the number and order of arguments in a function call must match the number and order of parameters in the parameter list of the called member function's header.
- the argument types in the function call must be consistent with the types of the corresponding parameters in the function header.		
	
>> AND logical operator: &&  / >> &&
see LOGICAL OPERATORS

>> ARRAY 
[pag279deitel]
An array is a contiguous group of memory locations that all have the same type. 
To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.
An element of an array is referred to by giving the array name followed by the particular element's position number in square brackets. ex:
	c[ 0 ]
(che si pronuncia "c sub zero")
ti donera' il primo elemento dell'array c. The position number is more formally called subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeroth element. Thus the elements of array c are c[0] (pronounced " c sub zero"), c[1], c[2] and so on.
	A subscript must be an integer or integer expression. If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a = 5 and b = 6, then the statement:
	c[ a + b ] += 2; 
adds 2 to array element c[11]
A subscripted array name is an lvalue: it can be used on the left side of an assignment, just as non-array variable names can.
	Each array knows its own size, which can be determined by calling its size member function. Ex supponendo di avere un array c, per saperne il size 
	c.size() 
NB: [from pag291deitel] When you use the [] operator to access an array element, C++ provides no automatic array bounds checking to prevent you from referring to an element that does not exist. It's important to ensure that every subscript you use to access an array element is within the array's bounds - that is, greater than or equal to 0 and less than the number of array elements.
Allowing programs to read from or write to array elements outside the bounds of arrays are common security flaws. Reading from out-of-bounds arrays elements can cause a program to crash or even appeear to execute correctly while using bad data. Writing to an out-of-bounds element (known as >> buffer overflow) can corrupt a program's data in memory, crash a program and allow attackers to explot the sstem and execute their own code. Concetto ripetuto anche nell'esempio pratico di pagina 318deitel see smiley tag
NOTE2 [pag318deitel] EXCEPTION HANDLING : in case of out-of-range subscript, we can create fault-tolerant programs with expection handling to continue executing as if no problems were encountered.
More severe problems might prevent a program from continuing normal execution, instead requiring the program to notify the user of the problem, then terminate. When a function detects a problem, such as an invalid array subscript or an invalid argument, it throws an exception (that is an expection occurs)   
To handle an expection, place any code that might throw an expection in a try statement
The try block contains the code that might throw an exception, and the catch block contains the code that handles the exception if one occurs.

>> array subscript operator / >> subscript operator
>> [] e' chiamato array subscript operator
see pag 458 deitel
example 
	integer[5] = 1000;
inizializza il sesto elemento dell'array a 1000 (sesto visto che si contano gli elementi dell'array a partire da zero 0 1 2 3 4 5)
////////////////////////////////////////////////

>> ARRAY MIkE explanation pag 91
While string objects provide a great way to work with a sequence of characters, arrays provide a way to work with elements of any type. That means you can use anarray to store a sequence of integers for, say a high score list. But it also means that you can use arrays to store elements of programmer defined types, such as a sequence of items that an Role Playing Game character might carry.
EXAMPLE:
///////////////////////////////////////
// Batman's Inventory
// Demonstrates arrays

#include <iostream>
#include <string>

using namespace std;

int main()
{
    const int MAX_ITEMS = 10;  // it's often a good idea to define a constant for the number of elements in an array. in this case the constant MAX_ITEMS represents the maximum number of items our Batman hero can carry
    string inventory[MAX_ITEMS]; // >> array initialization : type nameOfTheArray[sizeOfTheArray]
// la linea precedente declares an array inventory of MAX_ITEMS string objects. Because MAX_ITEMS is 10, that means 10 string objects.
    int numItems = 0;
    inventory[numItems++] = "sword";  // you can access any individual element of an array by providing an index number with the subscripting operator
    inventory[numItems++] = "armor"; // visto che scriviamo i piu' dopo numItems++, numItems viene incrementato dopo the assignment to the array.
    inventory[numItems++] = "shield";
/*
you can initialize an array with values when you declare it by providing an initializer list (= a sequence of elements separated by commas and surrounded by curly braces). Here's an example
	string inventory[MAX_ITEMS] = {"sword", "armor", "shield"};
The preceding code declares an array of string objects, inventory, that has a size of MAX_ITEMS. The first three elmeents of the array are initialized to "sword", "armor", "shield". 
If you omit the number of elements when using an initializer list, the array will be created with a size equal to the number of elements in the list. Here's an example:
	 string inventory[] = {"sword", "armor", "shield"};
Because there are three elements in the initalizer list, the preceding line creates an array, inventory, that is three elements in size. Its elements are "sword", "armor", and "shield".

*/
    cout << "Your items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}

    cout << "\nYou trade your sword for a battle axe.";
    inventory[0] = "battle axe";  // assegniamo un nuovo elemento al primo elemento dell'array
    cout << "\nYour items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}

    cout << "\nThe item name '" << inventory[0] << "' has ";
    cout << inventory[0].size() << " letters in it.\n";   // L'istruzione inventory[0].size() applica la member function size all'elemento dell'array inventory[0], cioe' l'istruzione ci indica il size del primo elemento dell'array, cioe' ci dona la lunghezza della string del primo elemento dell'array.

    cout << "\nYou find a healing potion.";
    if (numItems < MAX_ITEMS)
	{
        inventory[numItems++] = "healing potion";
	}
    else
	{
        cout << "You have too many items and can't carry another.";
	}
    cout << "\nYour items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}
	
	return 0;
}
/////////
OUTPUT:

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
Your items:
sword
armor
shield

You trade your sword for a battle axe.
Your items:
battle axe
armor
shield

The item name 'battle axe' has 10 letters in it.

You find a healing potion.
Your items:
battle axe
armor
shield
healing potion
----------------------------------
NOTE : >> last element accessing 
Arry indexing begins with 0, just as you say with string objects. This means that the following code defines a five element array. 
	int highScore[5];  // qui inizializzi un array di 5 elementi interi. il primo elemento avra' indice 0, l'ultimo elemento index 4
    highScore[4] = 3; // assegniamo all'ultimo dell'array il valore 3
se invece pensando di voler assegnare 3 all'ultimo elemento dell'array avessimo scritto : highScore[5] = 3; wrong there is no element highScore[5] an attempt to access highScores[5] could lead to disastrous results, including a program crash.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> array initialization 
[pag465]
	array< int, 5 > n = { 27, 46, 99, 24, 44 };
and from C++11, since it allows any objet to be initialized with a list initializers in braces, we can write:
	array< int, 5 > n{ 27, 46, 99, 24, 44 };
///////////////////////////////////////////////////////

>> array constructor 
[pag462deitel]
GOOD PROGRAMMING PRACTICE: Arrays and objects in general should be properly initialized as they're created
Example from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.cpp
	Array::Array( int arraySize )
	   : size( arraySize > 0 ? arraySize : 
	        throw invalid_argument( "Array size must be greater than 0" ) ),
	     ptr( new int[ size ] )
	{
	   for ( size_t i = 0; i < size; ++i )
	      ptr[ i ] = 0; // set pointer-based array element
	} // end Array default constructor
///////////////////////////////////

>> ARRAY COPY / >> initializing a new array with a copy of an existing array. 
[pag457deitel]

>> ARRAY DECLARATION 
[pag281deitel]
	array< type, arraySize > arrayName;
example:
	array< int, 12 > c; // c is an array  of 12 int values
-------------EXEMPLES
// initializing an array's elements to zeros and printing the array. 
// Initializing an array's elements to zeros and printing the array.
#include <iostream>
#include <iomanip>
#include <array>
using namespace std;
int main()
{
   array< int, 5 > n; // n is an array of 5 int values
   // initialize elements of array n to 0
   for ( size_t i = 0; i < n.size(); ++i )
      n[ i ] = 0; // set element at location i to 0
   cout << "Element" << setw( 13 ) << "Value" << endl;
   // output each array element's value
   for ( size_t j = 0; j < n.size(); ++j )
      cout << setw( 7 ) << j << setw( 13 ) << n[ j ] << endl;
} // end main
//------------------------------------
NOTE about size_t (>> SIZE_T):
size_t represents an unsigned integral type. This type is recommended for any variable that represents an array's size or an array's subscripts. Type size_t is defined in the std namespace and is in header <cstddef>, which is included by various other headers.
if you attempt to compile a program that uses type "size_t"  and receive errors indicating that it's not defined
SOLUTION 
Include <cstddef> in your program. 
	#include <cstddef>
li' dalle righe dove sta di solito scritto 
	#include <iostream>
[pag282deitel]

>> ARRAY DISPLAY GRAPHICALLY / using bar charts to display array data graphically
[pag287deitel]
carino l'esempio riportato ti permette di visualizzare delle bar chart con degli asterischi pari al valore assunto da una determinata variabile dell'array. Tipo 
	  0-9:
	10-19:
    20-29:
	30-39:
	40-49:
	50-59:
	60-69: *
	70-79: **
	80-89: ***
	90-99: **
	  100: *
--------------------------------------qui ti riporto il codice sorgente:
#include <iostream>
#include <iomanip>
#include <array>
using namespace std;
int main()
{
   const size_t arraySize = 11;
   array< unsigned int, arraySize > n =
      { 0, 0, 0, 0, 0, 0, 1, 2, 4, 2, 1 };
   cout << "Grade distribution:" << endl;
   // for each element of array n, output a bar of the chart
   for ( size_t i = 0; i < n.size(); ++i )
   {
      // output bar labels ("0-9:", ..., "90-99:", "100:" )
      if ( 0 == i )
         cout << "  0-9: ";
      else if ( 10 == i )
         cout << "  100: ";
      else
         cout << i * 10 << "-" << ( i * 10 ) + 9 << ": ";
      // print bar of asterisks
      for ( unsigned int stars = 0; stars < n[ i ]; ++stars )
         cout << '*';
      cout << endl; // start a new line of output
   } // end outer for
} // end main
//------------------------------------


>> ARRAY BUILT-IN ARRAYS 
in short 
	type arrayName[ arraySize ];
where arraySize must be an integer constant greater than zero.
[pag344deitel]
Ricorda le altre due vie sono:
- array class template -> represent fixed-size lists and tables of values
- vector class template -> similar to array but can also grow or shrink dynamically to accomodate more or fewer elements.
Build-in arrays are fixed-size data structures 
> INITIALIZING built-in arrays
	int n[ 5 ] = { 50, 20, 30, 10, 40 };
creates an array of 5 ints and initializes them to the value in the inizializer list.
If you provide fewer initializers than the number of elements, the remaining elements are "value initialized", fundamental numeric types are set to 0, bools are set to false, pointers are set to nullptr and class objects are initialized by their default constructors. 
You can also omit the built-in array's size, the compiler sizes the built-in array to the number of elements in the initializer list.
	int n[] = {50, 20, 30, 10, 40 };
Ma e' sconsigliato. Meglio always to specify a built-in array's size, even when providing an initializer list. This enables the compiler to ensure that you do not provide too many initializers.
As with array objects, you use the subscript ([]) operator to access the individual elements of a built-in array. Recall that the subscript [] operator does not provide bounds checking  for array objects, this is also true for built-in arrays.
> DECLARING BUILT-IN ARRAY PARAMETERS
	int sumElements( const int values[], const size_t numberOfElements )
which indicates that the function's first argument should be a one-dimensional built-in array of ints that should not be modified by the function. Unlike array objects, built-in arrays don't know their own size, so a function that process a built-in array should have parameters to receive both the built-in array and its size.
The preceding header can also be written as :
	int sumElements( const int *values, const size_t numberOfElements )
The compiler does not differenciate between a function that receives a pointer and a function that receives a built-in array. These forms of declaring a one-dimensional array are interchangeable. Ad ogni modo for clarity, Deitel consiglia di usare the [] notation when the function expects a built-in array argument.
> SORTING 
	int n[ 5 ] = { 50, 20, 30, 10, 40 };
	sort( begin( n ), end( n ) ); // sort contents of built-in array n 
C++11's new begin and end function (from header <iterator>) each receive a built0in array as an argument and return a pointer that can be used to represent ranges of elements to process in C++ Standard Library functions like sort.
Nota le differenze rispetto a quando applicavamo sort a un array della array class template
	sort (colors.begin(), colors.end() );
NOTE1: Passing built-in arrays to functions
The value of a built-in array's name is implicitly convertible to the address of the vuilt-in array's first element. So arrayName is implicitly convertible to 
	&arrayName[0]
For this reason you don't need to tkae te address (&) of a built-in array to pass it to a function YOU SIMPLY PASS THE BUILT-IN ARRAY'S NAME. And a function that receives a pointer to a variable in the caller can modify that variable in the caller. For built-in arrays, this means that the called function can modify all the elements of a built-in array in the caller- unless the function precedes the corresponding  built-in array parameter with const to indicate that the elements should not be modified.
SUSUME: applying the const type qualifier to  a built-in array parameter in a function definition to prevent the original built-in array form being modified in the function body is another example of the principle of least priviledge. Functions should not be given the capability to modify a built-in array unless it's absolutely necessary. 
// sezioni esempi
EXAMPLE1 
	int c[ 12 ]; // c is a built-in array of 12 integers
EXAMPLE2 array initialization 
	int n[ 5 ] = { 50, 20, 30, 10, 40 };

>> ARRAY BUILT-IN ARRAY LIMITATIONS
[pag346deitel]
Built-in arrays 
- cannot be compared useing the relational and equality operators- you must use a loop to compare two built-in arrays element by element
- they cannot be assigned to one another
- they don't know their own size: a function that process a built-in array typically receives both the built-in array's name and its size as arguments
- they don't provide automatic bounds checking: you must ensure that array-access expressions use subscripts that are within the built-in array's bounds.
Objects of class templates array and vector are safer, more robust and provide more capabilities than built-in arrays. Ci sono pero' dei casi in i built-in arrays must be used, vedi voce seguente.

>> ARRAY BUILT-IN ARRAY MUST BE USED WHEN
[pag346deitel]
There are cases in which built-in arrays MUST BE used, such as processing a program's command-line arguments. [>> command line arguments].
You supply command-line arguments to a program by placing them after the program's name when executing it from the command line. Such arguments typically pass options to a program. 
For example on Linux and OS X, the following command 
	ls -la
uses the "-la" argument to list the contents of the current directory with details about each file and directory
Command-line arguments (like -la) are passed to "main" as a built-in array of pointer-based strings.
[cioe' in sostanza la viene passato come una array contenente gli elementi "l" e "a" mi sembra sia per questo motivo che non ha grande importanza talvolta l'ordine con cui inserisci le opzioni talvolta scrivamo grep -nR altre volte grep -Rn il programma legge ciascuno degli elementi del built-in array e se la lettera corrisponde ad una delle opzioni previste prosegue senza errori indipendentemente dall'ordine con cui compare all'interno del built-in array]
Appendix F (deitel) shows how to process command-line arguments

>> ARRAY ELEMENTS AS COUNTERS [example of how to use the elements of an array as counters]
pag288deitel

>> ARRAY EXAMPLE SUMMARIZE SURVEY RESULTS [example of using arrays to summarize survey results]
pag289deitel

>> ARRAY INITIALIZATION elements to zero / >> ARRAY INITIALIZE ELEMENTS TO ZERO fast way
[pag283deitel]
	array< int, 5 > n = {}; // initialize elements of array n to 0
Rispetto alla tecnica sopra esposta usante il cyclo for (pag282deitel) questa fast way technique puo' essere inizializzata only in the array's declaration, whereas the initialization technique con il ciclo for can be used repeatedly during program execution to "reinitialize" an array's elements.
NOTA BENE: initializer list specified in an array declaration must be less than or equal to the array size. Per esempio se scrivessi 
	array< int, 5 > n = { 32, 27, 42, 127, 3, 7 } 
donerebbe un errore poiche' there are six initilizers and only five array elements.

>> ARRAY INITIALIZATION using list initializer
[pag283deitel]
(oltre che usando un ciclo for come scritto nell'esempio riportato sopra -pag282deitel-) The elements of an array also can be initialized in the array declaration by following the array name with an  equals sign and a brace-delimited comma-separated list of initializers. Example: 
	   array< int, 5 > n = { 32, 27, 64, 18, 95 };
che potrai utilizzare all'interno di un programma nel seguente modo:
	#include <iostream>
	#include <iomanip>
	#include <array>
	using namespace std;
	int main()
	{
	   // use list initializer to initialize array n
 		array< int, 5 > n = { 32, 27, 64, 18, 95 };
		....
	}
//-----------------------------------------------
if there are fewer initializer than array elements, the remaining array elements are initialized to zero. For example, the elements of the array n could have been initialized to zero with the declaration: 
		array< int, 5 > n = {}; // initialize elements of array n to 0
which initializes the elements to zero, because there are fewer initializers (none in this case) than array elements. 

>> ARRAY KEYBOARD INPUT / ARRAY INITIALIZATION FROM KEYBOARD 
[pag286]
example 
	for ( size_t j = 0; j < a.size(); ++j )
		cin >> a[ j ];
reads one value at a time from the keyboard and stores the value in element a[j].

>> ARRAY OPERATION on ELEMENTS / SUM ELEMENTS ARRAY / OPERATION on ARRAY ELEMENTS / SUM ARRAY ELEMENTS
[pag280deitel]
To print the sum of the values contained in the first three elements of array c, we'd write:
	cout << c[ 0 ] + c[ 1 ] + c[ 2 ] << endl;
To divide the value of c[6] by 2 and assign the result to the variable x, we would write 
	x = c[ 6 ] / 2;

>> ARRAY SIZE 
[pag280deitel]
	Each array knows its own size, which can be determined by calling its size member function. Ex supponendo di avere un array c, per saperne il size 
	c.size()

>> ASSAY SIZE specifying with constant variable
[pag283deitel]
A) You can declaring an array as seen in pag281deitel:
	array< int, 5 > s;
B) or specifying an array's size with a constant variable. 
	const size_t arraySize = 5;
	array< int, arraySize > s;
where we use a const qualifier to declare a constant variable arraySize with the value 5. A constant variable that's used to specify array's size must be initialized with a constant expression when it's declared and cannot be modified thereafter. Constant variables are also called named constants or read only variables
GOOD PROGRAMMING PRACTICE: using B) instead of A) [cioe' defining the size of an array as a constant variable instead of a literal constant] makes programs clearer. 
This technique eliminates the so called magic numbers (= numeric values that are not explained).  Using a constant variable allows you to provide a name for a literal constant and can be help explain the purpose of the value in the program.

>> ARRAY SUM ELEMENTS ARRAY 
[pag286deitel]
   // sum contents of array a
   for ( size_t i = 0; i < a.size(); ++i )
      total += a[ i ];
 

>> ARRAY vs VECTOR / ARRAYS vs VECTORS
[pag279deitel]
- Arrays are fixed-size collections consisting of data items of the same type
- Vectors are collections (also of data items of the same type) that can grow and shrink dynamically at execution time.
Both array and vector are C++ standard library class templates. To use them, you must include the <array> and <vector> headers respectively. 

>> ARRAY CLASS EXAMPLE [the most important study case in deitel book]
[pag453]
Built-in arrays have sereral limitations 
- they do not check whether subscritps fall outsdie the range of the array
- ... lunga lista vedi pag 453 deitel
- cannot assign one built-in array to another using the assignment operator
- cannot compare  two built-in arrays using equality or relational operators (because the arrays names are simply pointers to where the arrays begin in memory and two arrays will always be at different memory locations).
But we can add all these missing capabilities by creating a more powerful Array class, usando classes and operator overloading. 

>> ARRAY SIZE ASSIGNMENT 
[pag463deitel]
[from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.cpp]
	const Array &Array::operator=( const Array &right )
	{
	   if ( &right != this ) // avoid self-assignment
	   {
	      // for Arrays of different sizes, deallocate original
	      // left-side Array, then allocate new left-side Array
	      if ( size != right.size )
	      {
	         delete [] ptr; // release space
	         size = right.size; // resize this object
	         ptr = new int[ size ]; // create space for Array copy
	      } // end inner if
	
	      for ( size_t i = 0; i < size; ++i )
	         ptr[ i ] = right.ptr[ i ]; // copy array into object
	   } // end outer if
///////////////////////////////////

>> ARGUMENT COERCION : this is an important feature of function prototypes i.e, forcing  arguments to the appropriate types specified by the parameter decalrations.


>> ARGUMENT PROMOTION : sometimes, argument values that do not correspond precisely to the parameter types in the function prototype can be converted by the compiler to the proper type before the function is called. These conversions occur as specified by C++ promotion rules. The promotion rules indicate the implicit conversions that the compiler can perform between fundamental types. For example an "int" can be converted to a "double" o viceversa a double can converted to an "int" (the fractional part will be truncated). 
- Promotion rules apply also in mixed-type expressions (per esempio un espression in cui molplichi un int con un double). The type of each value in a mixed-type expression is promoted to the "highest" type in the expression (esempio l'int verra' promosso a double se moltiplicato con delle variabili double). See figure 6.6 pag212 deitel trovi la lista degli aritmetic data types from "highest type" to "lowest type".

>> ARITHMETIC OPERATORS
+  -> addition
-  -> substraction
*  -> multiplication
/  -> division
%  -> modulo   (see modulo for further info)
NB: arithmetic operators are all binary operators, cioe' operators that take two operands. For example expression number1 + number2 contains the binary operator + and the two operands number1 and number2.
NB2: integer division (i.e. where both the numerator and the denominator are integers) yields an integer quotient; for example, the expression 7 / 4 evaluates 1 , expression 17 /3 evaluates 3. Any fractional part in integer division is truncated. 
NB3: the modulus operator % yields the remainder (= resto) after integer division. The modulus operator can be used only with integer operands. Examples
	 7 % 4 yields 3 (visto che 7/4 = 1 con resto 3)
	17 % 5 yields 2 (visto che 17/5 = 3 con resto 2)
Some interesting application of the modulus operator is determining whether one number is a multiple of another (a special case of this is determining whether a number is odd or even).
[pag49deitel]
------------------------------------------------------------------------------------------------------------------------------------------
>> ARITHMETIC OPERATORS [pag13 mike]
example :
// Expensive Calculator
// Demonstrates built-in arithmetic operators

#include <iostream>
using namespace std;

int main()
{
	cout << "7 + 3 = " << 7 + 3 << endl;  // visto e' proprio come un funnel (= imbuto or channel del bob di running man) cout << parte la stringa 7 + 3 = quindi il risultato dell'operatione 7 + 3 viene << fiuuuuuuu inviato e compare su schermo, quindi endl << fiuuuu anche lui inviato su schermo e ti manda a capo per le righe successive. 
	cout << "7 - 3 = " << 7 - 3 << endl;
	cout << "7 * 3 = " << 7 * 3 << endl;

	cout << "7 / 3 = " << 7 / 3 << endl;
	cout << "7.0 / 3.0 = " << 7.0 / 3.0 << endl;

	cout << "7 % 3 = " << 7 % 3 << endl;

	cout << "7 + 3 * 5 = " << 7 + 3 * 5 << endl;
	cout << "(7 + 3) * 5 = " << (7 + 3) * 5 << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ARITHMETIC OVERFLOW 
pag123 deitel

>> assign declare variable in a single statement / >> variable assignment and initialization 
	double rocketMainEngineTemperature = 6572.89; // in Celsius 
NOTE: although you can declare a varaible without assigning it a value, it's best to initialize a new variable with a starting value whenever you can. This make your code clearer, plus it eliminates the chance of accessing an uninitialized variable, which may contain any value. 

>> ASSIGNMENT  (=)
The  assignment operator assigns a value to a variable. 
ex1 
    sum = number1 + number2;
we like to read this statement as "sum gets the value of number1 and number2"
[deitel pag47]     
ex2
	a = b;
the statement assigns to variable a the variable contained in variable b. The value that was stored until this moment in a is not considered at all in this operation, in fact that value is lost. We only assign the value of b at the moment of the assignment operation. Therefore, a later change of b will not affect the value of a.
NB: rembember always right to left rule: the assignment operation always takes place from right to left, and never the other way.
NB2: hte part at the left of the assignment operator (=) is known as the lvalue (left value) and the right one as the rvalue (right value). 
NB3: the assignment operation can be used as the rvalue ofr another assignment operation. 
ex 
	a = + (b = 5);
is equivalent to:
	b =5;
	a =2 +b;     // perche' 2? non capisco piu' da dove l'avessi copiato
The following expression is also valid in C++:
	a = b = c = 5; 
it assigns 5 to all the three variables a,b and c
NB4: place spaces on either side of a binary operator. This makes the operator stand out and makes the program more readable. so a = b better to a=b.
---------------------------------------------------
>> assign string / >> string assignment [pag21 and pag 86 mike]
	string playItAgainSam = "AiharaAsaka";
qui assegniamo AiharaAsaka alla string variable playItAgainSam
>> assign character
	char playAgain; 
	playAgain = 'y';
you can assign a character to a variable of type char by surrounding the character with SINGLE quotes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> self assignment operator / >> assignment operator
[pag73 jesse]
how to add a value to a variable and then assign the result back into the same variable 
1) first way (long way)
	int myAge = 5;
	int temp;
	temp = myAge + 2;
	myAge = temp;
2) faster way
	int myAge = 5;
	myAge = myAge + 2;
you can read the above line as : add tw to the value in myAge and assign the result to myAge
3) hyper fast way
	int myAge = 5;
	myAge += 2;  // che si legge "myAge plus equals two"
this line uses the >> self assigned addition operator (+=).
	myAge += 2 la puoi leggere : myAge prima somma (+) a myAge, il valore 2, quindi (=) assegna il risultato della somma a myAge. 
Insomma per non farti confondere, basta che leggi l'espressione da sinistra verso destra 
	+=
prima sommi il valore che sta alla destra, quindi assegni il risultato della somma alla variabile che sta a sinistra. 
Detto in parole forbite: the self assigned addition operator adds the r-value to the l-value and then reassigns the result into the l-value. This operator is pronounced plus-equals
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> bool assignment / >> assign bool value [pag21 mike]
nomeBoolVariable = true;  // per settare la variabile a true
nomeBoolVariable = false; // per settare la variabile a false
NOTE from pag 37 mike: you can represent true and false with their corresponding keywords, true and false. Although the keywords true and false are handy, any expression or value can be interpreted as true or false too. 
- ANY NON ZERO VALUE CAN BE INTERPRETED AS TRUE
- while 0 CAN BE INTERPRETED as FALSE


>> ASSIGNMENT OPERATORS for abbreviating assignment expressions / ABBREVIATION ASSIGNMENT OPERATORS
[pag139deitel]
Any statement of the form 
	variable = variable operator expression;
in which the same variable appears on both sides of the assignment operator (e dove operator e' uno dei binary operators +, -, *, /, %) can be written in the form:
	variable operator= expression;
c += 3;    <-equivale a->   c = c + 3; //tag >> +=   = aggiungi 3 a "c" e assegna il risultato della somma a "c"  
c -= 3;    <-equivale a->   c = c - 3; //tag >> -=
c *= 3;    <-equivale a->   c = c * 3; //tag >> *=
c /= 3;    <-equivale a->   c = c / 3; //tag >> /=
c %= 3;    <-equivale a->   c = c % 3; //tag >> %=
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ASSIGNMENT OPERATOR COMBINED / >> COMBINED ASSIGNMENT OPERATOR / >> +=  [pag25 mike]
Ciccio spiega
+= leggilo da sinistra a destra e il significato diventa chiaro
ex a += 10 diventa   aggiungi 10 ad "a" e assegna il risultato della somma ad "a"  
Mike spiega
The += is called a combined assignment operator because it combines an arihmetic operation (addition in this case) with assignment. This operator is shorthand for saying "add whatever's on the right to what's on the left and assign the result back to what's on the left"
EXAMPLE
// Game Stats 2.0
// Demonstrates arithmetic operations with variables

#include <iostream>
using namespace std;

int main()
{
	unsigned int score = 5000;
	cout << "score: " << score << endl;

	//altering the value of a variable
	score = score + 100;
	cout << "score: " << score << endl;

	//combined assignment operator
	score += 100;
	cout << "score: " << score << endl;

	//increment operators
	int lives = 3;
	++lives;
	cout << "lives: "   << lives << endl;

	lives = 3;
	lives++;
	cout << "lives: "   << lives << endl;

	lives = 3;
	int bonus = ++lives * 10;
	cout << "lives, bonus = " << lives << ", " << bonus << endl;

	lives = 3;
	bonus = lives++ * 10;
	cout << "lives, bonus = " << lives << ", " << bonus << endl;

	//integer wrap around
	score = 4294967295;
	cout << "\nscore: " << score << endl;
	++score;
	cout << "score: "   << score << endl;

	return 0;
}

--------------------------------------------------------------------
[OUTPUT]
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
score: 5000
score: 5100
score: 5200
lives: 4
lives: 4
lives, bonus = 4, 40
lives, bonus = 4, 30

score: 4294967295
score: 0
///////////////////////////////////////////////////////////////////////////////////////////////

>> ASSIGNMENT OPERATOR disquisitio filosofico-platonica
[pag196 moo book] 
Assignment differs from the copy constructor in that assignment always involves obliterating an existing value (the left-hand side) and replacing it with a new value (the right hand side). When we make a copy, we are creatin a new object for the first time, so there is no preexisting object to deallocate.

>> assignment vs initialization [pag199 moo book]
The difference between assignment and initialization is one of the trickier aspects of learning C++ well. The fact that the = symbol can be involved in both initialization and assignment can make the distinction harder to grasp.
- Assignment always obliterates a previous value. 
- Initialization never does so. Rather, initialization involves creting a new object and giving it a value at the same time.
Examples
	string url_ch = "void Layer Machine";  // initialization 
	string y; // initialization [invoking the default constructor to create an empty string]
	y = url_ch; // assignment 
Riassumendo 
	Constructors always control initialization 
	The "operator=" member function always controls assignment.
////////////////////////////////////////////////////////////////////////////////////////////////// 


>> ++ / >> INCREMENT OPERATOR / >> DECREMENT OPERATOR [pag26 mike] [also pag74 jesse]
	engines = 3;
	// il seguente e' un esempio di  >> prefix increment operator
	++engines;  // engines assume cosi' il valore 4
Si potrebbe anche 
	engines = 3;
	// il seguente e' un esempio di  >> postfix increment operator
	engines++;  // engines assume cosi' il valore 4
In esempi come sopra dove you only increment a single variable, both operators produce the same final result. But in a more complex expression the results can be different. 
Example 
	engines = 3;
	int fluxCapacitorPower = ++engines * 10;
A) the prefix increment operator increment a variable before the evaluation of a larger expression involving the variable. ++engines * 10 is evaluated by first incrementing engines, and then mutiplying that result by 10. Therefore, the code is equivalent to 4 * 10 =>  fluxCapacitorPower = 40.
B) the  postfix increment operator increments a variable after the evaluation of a larger expression involving the variable. 
	engines = 3;
	int fluxCapacitorPower = engines++ * 10;
questa volta fluxCapacitorPower = 30, poiche' prima si moltiplica engines=3 * 10, e solo una volta che 30 e' assegnato a fluxCapacitorPower, allora la variabile engines viene incrementata da 3 a 4. Insomma mettere ++ dopo il nome della variabile, fa si' che prima si eseguisce l'istruzione usando il valore corrente della variabile, solo una volta che l'istruzione e' eseguita, allora la variabile viene incrementata.
>> decrement operator / >> --
C++ also defines the decrement operator, --. It works just like the increment operator, except it decrements a variable. It comes in the two flavors (prefix and postfix) as well. 
NOTE >> WRAP AROUND 
what happens when you increase an integer variable beyond its maximum value? It turns out you don't generate an error. Instead the value "wrap around" to the type's minimum value. Example 
	unsigned int score = 4294967295;  // gli attribuisci il valore massimo
	cout << "\nscore: " << score << endl;
	++score;  // se lo incrementi di uno op e' come se facessi ripartire da capo il tachigrafo e riparti da zero
	cout << "score: "   << score << endl;
Donera' come risultato "score 0", becomes 0 because the value wrapped around, much like a car odometer does when it goes beyond its maximum value. 
Decrementing an integer variable beyond its minimum value "wraps it around" to its maximum
NOTE [from pag 74 jesse]
lo statement 
	variable++;
e' equivalente a 
	variable += 1;
il quale e' a sua volta equivalente a 
	variable = variable + 1;
NOTE2 as you might have guessed, C++ got its name by applying the increment operator to the name of its predecessor language: C. The idea is that C++ is an incremental improvement over C. 
Insomma 
	C++
significa 
	C = C + 1
that is C++ is simply MORE!
NOTE3 pag75 jesse >> prefix vs >> postfixing 
You can both write 
	++myAge // prefix
or
	myAge++ // postfix
Both are valid but they have a different meaning. 
++myAge // prefix -> means: increment the value in the variable and then fetch or use it. 
myAge++ // postfix -> means: fetch or use the value and then increment the original variable. 
Example1 
	int x = 5;
	int a = ++x;
in questo caso prima x verra incrementato (5+1 = 6) and then il suo valore 6 viene assegnato ad "a". Quindi dopo i due precedenti statements, sia x che a sono uguali a 6. 
Example2
	int x = 5;
	int a = x++;
in questo caso prima si assegna il valore di x (5) ad "a", quindi si incrementa il valore di x (che diventa 6). Quindi dopo i due precedenti statements, x = 6 e a = 5.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ASSOCIATIVE CONTAINERS
[pag664 deitel]
The associative containers provide directo access to store and retrieve elements via keys (often called >> search keys). The four ordered associative containers are 
	multiset 
	set 
	multimap 
	map 
Each of these maintains its keys in sorted order. There are also four corresponding unordered associative containers.
	unordered_multiset
	unordered_set
	unordered_multimap
	unordered_map
that offer the most of the same capabilities as their ordered counterparts. The primary difference between the ordered and unordered associative containers is that the unordered ones do not maintain their keys in sorted order.
PERFORMANCE
The unordered associative containers might offer better performance for cases in which it's not necessary to maintain keys in sorted order.
	1) >> multiset = provide operations for manipulation sets of values where the values are the keys (there is not a separate value associated with each key). It allows duplicate keys [da li' il nome multi].
	2) >> set = provide operations for manipulation sets of values where the values are the keys (there is not a separate value associated with each key). It does not allow duplicate keys. [see voce "set" omonima per maggiori dettagli su libro deitel p668 ]
	3) >> multimap = provide operations for manipulating values associated with keys (these values are sometimes referred to as >> mapped values). A multimap allows duplicate keys with associated values to be stored.
	4) >> map = provide operations for manipulating values associated with keys (these values are sometimes referred to as >> mapped values). map allows only unique keys with associated values.
----------------------------------------------------
>> multiset associative container 
[pag 665 deitel]
the multiset ordered associative container (from header <set>) provides fast storage and retrieval of keys and allows duplicate keys. The element's ordering is determined by a so called >> comparator function object.
For example, in an integer multiset, elements can be sorted in ascending order by ordering the keys with comparator function object less<int>.
A multiset supports bidirectional iterators (but not random-access iterators). In if the order of the keys is not important, you can use unordered_multiset (header <unordered_set>) instead.
see example /home/dia/Deitel-Code_Examples/ch15/fig15_15/Fig15_15.cpp
here some extract [i numeri sulla sinitra indicano giusto il numero di linea]
	5 #include <set> // multiset class-template definition
line 14 creates a multiset of ints ordered in ascending order, using the function object less<int>. Ascending order is the default for a multiset, so less<int> can be omitted.
	14    multiset< int, less< int > > intMultiset; // multiset of ints
NOTE lo spazio tra gli > > dopo int era obbligatorio nei C++98, non e' piu' necessario a partire da C+11, dove anche se scrivessi 
	multiset<int, less< int >> intMultiset;
compila correttamente senza problemi.
- Linea 17 uses function count (abialable to all associative containers) to count the number of occurrences of the value 15 currently in the multiset:  	
	17    cout << "There are currently " << intMultiset.count( 15 )
	18       << " values of 15 in the multiset\n";
- Lines 20 -21 use one of the several overloaded versions of function insert to add the value 15 to the multiset twice. 
	20    intMultiset.insert( 15 ); // insert 15 in intMultiset
	21    intMultiset.insert( 15 ); // insert 15 in intMultiset
A second version of insert takes 
	> an iterator 
	> a value as argument and begins the search for the insertion point from the iterator position specified.
A third versio of insert takes 
	> two iterators as arguments taht specify a range of values to add to the mutiset from another container. 
- Line 26 uses function find (available to all associative containers) to locate the value 15 in the mutiset. Function find returns an iterator or a const_iterator pointing to the location at which the value is found. 
	25    // find 15 in intMultiset; find returns iterator
	26    auto result = intMultiset.find( 15 );
If the value is not found, find returns an iteartor or a const_iterator equal to the value returned by calling end on the container.
	31    // find 20 in intMultiset; find returns iterator
	32    result = intMultiset.find( 20 );
- Line 38 Inserting elements of another container into a multiset 
Line 38 uses function insert to insert the elements of array a into the mutiset. In line 40 the copy algorithm copies the elements of the multiset to the standard output in ascending order.
	37    // insert elements of array a into intMultiset
	38    intMultiset.insert( a.cbegin(), a.cend() );
	39    cout << "\nAfter insert, intMultiset contains:\n";
	40    copy( intMultiset.cbegin(), intMultiset.cend(), output );
- Line 44 and 45 use functions lower_bound and upper_bound (available in all associative containers) to locate the earliest occurrence of the value 22 in the multiset and the element after the last occurrence of the value 22 in the multiset. Both functions return iterators or const_iterators pointing to the appropriate location or the iterator returned by end if the value is not in the multiset.
	42    // determine lower and upper bound of 22 in intMultiset
	43    cout << "\n\nLower bound of 22: "
	44       << *( intMultiset.lower_bound( 22 ) );
	45    cout << "\nUpper bound of 22: " << *( intMultiset.upper_bound( 22 ) );
- line 49 
>> equal_range [pag 667 deitel]
 47    // use equal_range to determine lower and upper bound 
 48    // of 22 in intMultiset
 49    auto p = intMultiset.equal_range( 22 );
The multiset function equal_range returns a pair containing the results of calling both lower_bound and upper_bound. Type pair contains tow public data members called first and second. Line 49 uses function euqal_range to determine the lower_bound and upper_bound of 22 in the multiset.
>> tuple [pag668 deitel]
C++ also includes class template tuple, which is similar to pair, but can hold any number of items of various types. As C++11, class template tuple has been reimplemented using >> variadic templates (= templates that can receive a variable number of arguments)
---------------------------------------
>> set [pag668 deitel] 
(interessante: con questo container a partire da un array contenente doppioni puoi eliminare tutti gli elementi ripetuti due volte)
the set asociative container (from header <set>) is used for afats storage and retrieval of unique keys. The implementation of a set is identical to that of a mutiset, except that a set must have unique keys. Therefore, if an attempt is made to insert a duplicate key into a set, the duplicate is IGNORED.
A set supports bidirectional iterators (but not radom-access iterators). If the order of the keys is not important, you can use unordered_set (header <unordered_set>) instead. 
See example: /home/dia/Deitel-Code_Examples/ch15/fig15_16/Fig15_16.cpp
Extract 
	 14    set< double, less< double > > doubleSet( a.begin(), a.end() );
line14 creates a set of doubles ordered in ascending order, using the function object less<double>. The constructor cal takes all the elements in array a and inserts them into  the set.
	 18    copy( doubleSet.begin(), doubleSet.end(), output );
line18 uses algorithm copy to output the contents of the set. Notice that the value 2.1 which appeared twice in array appears only once in doubleSet.
----------------------------------------
>> multimap associative container [pag669 deitel]
The multimap assiciative container is used for fast storage and retrieval of keys and associated values (often called key value pairs). Many of the funcions used with multisets and sets are also used with multimaps and maps. The lements of multimaps and maps are pairs of keys and values instead of individual values.
When inserting into a multimap or map, a pair object that contains the key and the value is used. 
The ordering of the keys is determined by a >> comparator function object. 
(Ciccio nota: questa tipologia di container mi sembra che sia utilizzata nei sistemi di carte bancarie ATM, itiaf da studiarsi meglio per giocare un po di crack ai sistemi bancari internet)
For example: in a multimap that uses integers as the key type, keys can be sorted in ascending order by ordering them with comparator function object less<int>.
Duplicate keys are allowed in a multimap, so multiple values can be associated with a single key. This is called a >> one to many relationship (>> one-to-many relationship). For example, in a credit card transaction processing system (wow Ciccio ci avevi ragione che fiuto!!!) one credit-card account can have many associated transactions; in a university, one student can take many courses, and one professor can teach many students; in the military, one rank (like "private") has many people. A multimap supports bidirectional iterators, but not random-access iterators. Header <map> must be included to use class multimap. If the order of the keys is not important, you can use unordered_multimap (header <unordered_map>) instead.
Example see /home/dia/Deitel-Code_Examples/ch15/fig15_17/Fig15_17.cpp
eccoti qui alcuni estratti di linee notevoli del sopra citato programma:
  9    multimap< int, double, less< int > > pairs; // create multimap
line 0 creates a multimap in which the key type is int, the type of a key's associated value is double and the elements are ordered in ascending order. 
 14    // insert two value_type objects in pairs
 15    pairs.insert( make_pair( 15, 2.7 ) );
 16    pairs.insert( make_pair( 15, 99.3 ) );
Line 15 uses function inset to add a new key-value pair to the mutimap. The expression make_pair(15, 2.7) creates a pair object in which first is the key (15) of type int and second is the value (2.7) of type double. Function make_pair automatically uses the types that you specified for the keys and values in the multimap's declaration (line 9). As of C++11, you can use list initialization ofr pair bojects, so line 15 can be simplified as  
	pairs.insert ( {15, 2.7} );
similarly C++11 enables you to use list initialization to initalize an object being returned from a function. For example, if a function returns a pair containing an int and a double, you could write:
	return {15, 2.7};
 30    // walk through elements of pairs
 31    for ( auto mapItem : pairs )
 32       cout << mapItem.first << '\t' << mapItem.second << '\n';
line 31-32: the range based for statement in lines 31-32 outputs the contents of the multimap, including both keys and values. We infer the type of the loop's control variable (a pair containing an int key and a double value) with keyword auto. Line 32 accesses the members of the current pair in each element of the multimap. Notice in the output that the keys appear in ascending order.
--------------------------------------------------------------------------------------------------
>> map associative container [pag 671 deitel] [also chapter 7 mooo book pag 124]
The map associative container (from header <map>) performs fast storage and retrival of unique keys and associated values. Duplicate keys are not allowed (a single value can be associated with each key). This is called a >> one-to-one mapping. 
For example, a commercial cargo corporation that uses unique spaceships numbers, such as 1071, 1072, 1073 may have a map that associates spaceship numbers with their propulsion system maximum thrust 2000, 5000, 8000 [unita espresse in MegaTons] respectively.
With a map you specify the key and get back the asociated data quickly. Providing the key in a map's subscript operator [] locates the value associated with that key in th map. Insertions and deletions can be made anywhere in a map. If the order of the keys is not important, you can use unordered_map (header <unordered_map>) instead.
Example see /home/dia/Deitel-Code_Examples/ch15/fig15_18/Fig15_18.cpp
Qui ti scrivo un poco di extract delle lines piu' notevoli:
	  9    map< int, double, less< int > > pairs;
	 10 
	 11    // insert eight value_type objects in pairs
	 12    pairs.insert( make_pair( 15, 2.7 ) );
	 13    pairs.insert( make_pair( 30, 111.11 ) );
	 14    pairs.insert( make_pair( 5, 1010.1 ) );
	 15    pairs.insert( make_pair( 10, 22.22 ) );
	 16    pairs.insert( make_pair( 25, 33.333 ) );
	 17    pairs.insert( make_pair( 5, 77.54 ) ); // dup ignored
	 18    pairs.insert( make_pair( 20, 9.345 ) );
	 ....
	 27    pairs[ 25 ] = 9999.99; // use subscripting to change value for key 25
	 28    pairs[ 40 ] = 8765.43; // use subscripting to insert value for key 40
Lines 27-28 use the subscript operator of class map. When the subscript is a key that's already in the map (line27) the operator returns a reference to the associated value. When the subscript is a key that's not in the map (line 18) the operator inserts the key in the map and returns a reference that can be used to  associate a value with that key. Line 27 replaces the value for the key 25 (previously 33.333 as specified in line 16) with a new value 9999.99. Line 28 inserts a new key - value pair in the map (called creating an association)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> associative container vs >> sequential containers [pag123 moo book]
Associative containers automatically arrange their elements into a sequence that depends on the values of the elements themselves, rather than the sequence in which we inserted them. Moreover, associative containers exploit this ordering to let us locate particular elements much more quickly than do the sequential containers, without our having to keep the container ordered by ourselves. 
Associative containers offer effcient ways to find an element that contains a particular value, and might contain additional information as well. The part of each container element that we can use for these efficient searches is called a key. For example, if we were keeping track of information about students, we might use the student's name as the key, so that we could find students efficiently by name.
	The most common kind of associative data structure is one that stores key (value pairs associating a value with each key), and that lets us insert and retrieve elements quickly based on their keys). When we put a particular key, (value pair into the data structure), that key will continue to be associated with the same value until we delete the pair. Such a data structure is called >> associative arrays (many languanges supports associative arrays like AWK, Perl, Sobol).
In C++ associative arrays are part of the library. The most common kind of associative array in C++ is called a map, and analogous with other containers, it is defined in the <map> header.
In many ways maps behave like vectors. One fundamental difference is that the index of map need not be an integer; it can be a string, or any other type with values that we can compare so as to keep them ordered.
Maps are used to write compact and efficient look-up intensive programs.
------------------------------------------------------------------------ EXAMPLE countn the number of times that each distinct word occurs in the input. 
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/wc.cc]
	#include <iostream>
	#include <map>
	#include <string>
	
	using std::cin;
	using std::cout;
	using std::endl;
	using std::map;
	using std::string;
	
	int main()
	{
		string s;
		map<string, int> counters; // store each word and an associated counter; we must specify the type of the objects that the map will hold [in questo caso "string"] and the type of the key ["int"]. Therefore here counter is defined as a map that holds values of type "int" that are associated with keys of type "string". We often speak of such a container as "a map from string to int", because we can use the map by giving it a string as key, and getting back the associated int data.
		// read the input, keeping track of each word and how often we see it
		while (cin >> s)
			++counters[s];
		// write the words and associated counts
	#ifdef _MSC_VER
		for (std::map<string, int>::const_iterator it = counters.begin();
	#else
		for (map<string, int>::const_iterator it = counters.begin();
	#endif
		     it != counters.end(); ++it) {
			cout << it->first << "\t" << it->second << endl;
/* 
NOTE: la linea precedente usa two elements which are named "first" and "second". These two elements are hold by a simple data structure called ">> pair", companion library of the map container. Each element in a map is really a pair, with a first member that contains the key and a second member that contains the associated value. When we dereference a map iterator, we obtain a value that is of the pair type associated with the map.
The "pair" class can hold values of various types, so when we create a pair, we say what the types of the first and second data members should be. For a map that has a key of type K and a value of Type V, the associated pair type is pair<const K, V> Because the pair key is const, we are prevented from changing the value of an element's key. If the key were not const, we might implicitly change the element's position within the map. Accordingly, the key is always const, so that if we dereference a map<string, int> iterator, we get a pair<const string, int>. Thus, it->first is the current element's key, and it->second is the associated value.  
*/
		}
		return 0;
	}
------------------------------------------------------------------------ END EXAMPLE 
NOTE: >> word counting / >> count how often a word appears in a text / >> line number : get all the line numbers on which a certain word occurred : see example pag 126 moo book 
-------------------------------------------------------------------------- here the code
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/xref.cc]
	#include <map>
	#include <iostream>
	#include <string>
	#include <vector>
	
	#include "split.h"
	
	using std::cin;            using std::cout;
	using std::endl;           using std::getline;
	using std::istream;        using std::string;
	using std::vector;         using std::map;
	
	// find all the lines that refer to each word in the input
	map<string, vector<int> >
		xref(istream& in,
		     vector<string> find_words(const string&) = split)
	{
		string line;
		int line_number = 0;
		map<string, vector<int> > ret;
	
		// read the next line
		while (getline(in, line)) {
			++line_number;
	
			// break the input line into words
			vector<string> words = find_words(line);
	
			// remember that each word occurs on the current line
	#ifdef _MSC_VER
			for (std::vector<string>::const_iterator it = words.begin();
	#else
			for (vector<string>::const_iterator it = words.begin();
	#endif
			     it != words.end(); ++it)
				ret[*it].push_back(line_number);
		}
		return ret;
	}
	
	int main()
	{
		// call `xref' using `split' by default
		map<string, vector<int> > ret = xref(cin);
	
		// write the results
	#ifdef _MSC_VER
		for (std::map<string, vector<int> >::const_iterator it = ret.begin();
	#else
		for (map<string, vector<int> >::const_iterator it = ret.begin();
	#endif
		     it != ret.end(); ++it) {
			// write the word
			cout << it->first << " occurs on line(s): ";
	
			// followed by one or more line numbers
	#ifdef _MSC_VER
			std::vector<int>::const_iterator line_it = it->second.begin();
	#else
			vector<int>::const_iterator line_it = it->second.begin();
	#endif
			cout << *line_it;	// write the first line number
	
			++line_it;
			// write the rest of the line numbers, if any
			while (line_it != it->second.end()) {
				cout << ", " << *line_it;
				++line_it;
			}
			// write a new line to separate each word from the next
			cout << endl;
		}
	
		return 0;
	}
-------------------------------------------------------------------------- End of Code
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> map vs >> hash table / >> associative containers vs hash table [pag136 moo  book]

>> map resume  pag 137 moo book 
map<K, V> is an associative array with key type K and value type V. The elements of a map are key (value pairs), which are maintained in key order to allow efficient access of elements by key. The iterators on maps are bidirectional. Dereferencing a map itertor yields a value of type pair<const K, V>.
Note:
	pair<K, V> is a simple type whose objects hold pairs of values. Access to these data values is through their names, "first" and "second" respectively. 
MAP OPERATIONS:
1) map<K, V> m;		creates a new empty ak, with keys of type const K and values of type V. 
2) map<K, V> m(cmp);		create a anew empty map with keys of type const K and values of type V, that uses the predicate cmp to determine the order of the elements.
3) m[k]		indexes the map using a key, k, of type K, and return a nlvalue of type V. If there is no entry for the given key, a new value initialized element is created and inserted into the map with this key. Because using [] to access a map might create a new element, [] is not allowed on a const map. 
4) m.begin()    m.end()
		Return iterators that can be used to access the element of a map. Note that dereferencing one of thiese iterators yeilds a key (value pair) not just a value. 
5) m.find(k)	returns an iterator referring t the element with key k, or m.end() if no such element exists.	 
For a map<K, V> and an associated iterator p, the following apply:
p->first	Yields an lvalue of type const K that is the key for the element p deonotes.
p->second   Yields an lvalue of type V that is the value part of the element that p denotes.
>> VALUE INITIALIZATION : accessing a "map" element that doesn't yet exist creates an element with a value of V(), where V is the type of the values stored in the map. Such an expression is said to be value-initialized. 

>> 
////////////////////////////////////////////////////////////////////////////////////////

>> SENTENCE GENERATION using "map" [pag 130 moo book]
/////////////////////////////////////////////////////////////////////////////////////////////////
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/grammar.cc]
	#ifdef _MSC_VER
	#pragma warning(disable:4503)      // `silence compiler complaints about generated names being too long'
	#endif
	
	#include <algorithm>
	#include <cstdlib>
	#include <iostream>
	#include <map>
	#include <stdexcept>
	#include <string>
	#include <vector>
	
	#include "split.h"
	#include <time.h>
	
	using std::istream;           using std::cin;
	using std::copy;              using std::cout;
	using std::endl;              using std::find;
	using std::getline;           using std::logic_error;
	using std::map;               using std::string;
	using std::vector;            using std::domain_error;
	using std::rand;
	
	typedef vector<string> Rule;
	typedef vector<Rule> Rule_collection;
	typedef map<string, Rule_collection> Grammar;
	
	// read a grammar from a given input stream
	Grammar read_grammar(istream& in)
	{
		Grammar ret;
		string line;
	
		// read the input
		while (getline(in, line)) {
	
			// `split' the input into words
			vector<string> entry = split(line);
	
			if (!entry.empty())
				// use the category to store the associated rule
				ret[entry[0]].push_back(
					Rule(entry.begin() + 1, entry.end()));
		}
		return ret;
	}
	
	void gen_aux(const Grammar&, const string&, vector<string>&);
	
	int nrand(int);
	
	vector<string> gen_sentence(const Grammar& g)
	{
		vector<string> ret;
		gen_aux(g, "<sentence>", ret);
		return ret;
	}
	
	bool bracketed(const string& s)
	{
		return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
	}
	
	void
	gen_aux(const Grammar& g, const string& word, vector<string>& ret)
	{
	
		if (!bracketed(word)) {
			ret.push_back(word);
		} else {
			// locate the rule that corresponds to `word'
			Grammar::const_iterator it = g.find(word);
			if (it == g.end())
				throw logic_error("empty rule");
	
			// fetch the set of possible rules
			const Rule_collection& c = it->second;
	
			// from which we select one at random
			const Rule& r = c[nrand(c.size())];
	
			// recursively expand the selected rule  / >> recursive call example see comments pag 134 moo book
			for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
				gen_aux(g, *i, ret);  // ecco qui la recursive call. Siamo all'interno della funzione gen_aux e in questa linea la funzione chiama se stessa "gen_aux" e funziona! Sembra quasi una sorta di codice frattale!
		}
	}
	
	int main()
	{
		// generate the sentence
		vector<string> sentence = gen_sentence(read_grammar(cin));
	
		// write the first word, if any
	#ifdef _MSC_VER
		std::vector<string>::const_iterator it = sentence.begin();
	#else
		vector<string>::const_iterator it = sentence.begin();
	#endif
		if (!sentence.empty()) {
			cout << *it;
			++it;
		}
	
		// write the rest of the words, each preceded by a space
		while (it != sentence.end()) {
			cout << " " << *it;
			++it;
		}
	
		cout << endl;
		return 0;
	}
	
	// return a random integer in the range `[0,' `n)'
	int nrand(int n)  // >> random : this function is used to select a random element from a vector
	{
		if (n <= 0 || n > RAND_MAX)
			throw domain_error("Argument to nrand is out of range");
	
		const int bucket_size = RAND_MAX / n;
		int r;
	
		do r = rand() / bucket_size;
		while (r >= n);
	
		return r;
	}
	

/////////////////////////////////////////////////////////////////////////////////////////////////

>> at 
[pag435 deitel]
member function of the string class. "at" return  the character at a specific index  in a string (after checking that the index is in range)
example from : /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
   // test subscript out of range with string member function "at"
   try                                                               
   {                                                                 
      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
   } // end try 
NOTE [from pag348 deitel]: member function "at" provide bounds checking, cioe' it throws an exception if its argument is an invalid sbuscript. If the subscript is valid, function at returns the character at thespecified location as a modifiable lvalue or an nonmodifiable lvalue (e.g., a const reference), depending on the context in which the call appears. 
//////////////////////////////////////////////////////////////////

>> AUTO keyword 
[pag 306 deitel e esempio pratico pag305deitel start tag]
C++11 "auto" keyword tells the compiler to infer (determine) a variable's data type based on the variable's initializer value. 
- EXAMPLE di auto in action: i due seguenti nested for sono equivalenti, usando auto la scrittura si semplifica
[pag306deitel]
Sommare tutti gli elementi di un 2D array (insomma di un tensore 2 o la nostra tradizionale matrice)
	total = 0;
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			total += a[ row ][ column ];
usando il C++11 "auto" keyword il precedente nested loop puo' essere riscritto come 
	total = 0;
	for ( auto row : a ) // for each row
		for ( auto column : row ) // for each column in row 
			total += column;


>> BBBBBBB

>> branch of an if statement cioe' ciascuno dei blocchi in cui si entra a seconda che la condizione sia vera o meno, branch visto che il flusso logico si branch si ramifica a seconda delle condizioni settate
[pag26 moo book]

>> BREAKPOINT in visual studio 
1) clicca di sinistro sul numero di riga che sta scritto accanto alla riga in cui vuoi mettere il toogle. La riga verra' cosi' evidenziata in azzurro. 
[cioe' se vuoi breakare alla linea "21" clicca su quel 21 in modo che vedrai la riga colorarsi si azzurro]
2) menu DEBUG -> Toggle Breakpoint [or simply press F9] [or even more simply premi giusto nella striscia grigia accanto alla linea in cui vuoi mettere il breakpoint]
3) starta il debug con debug menu -> debug (or press F5)
4) press CONTINUE per far continuare il programma oltre il breakpoint
Nota come in basso nella finestrella Call Stack vedi la lista di chiamate delle funzioni, e a sinistra nella finestrella Autos vedi il valore che il parametro di input della funziona sta assumendo
[Ciccio courtesy]

> BUILT IN TYPE / >> BUILT-IN TYPE [pag106 mike]: built int types are types that are always available in any C++ program (senza bisogno di usare alcun include), per esempio int and char are built in types. On the contrary "string" type, on the other hand, is not a built-in type. It's defined as a part of the standard library in the file string. 
-----------------------
>> BUILT-IN TYPE vs >> CLASS TYPES [pag155 moo book]
C++ has two kinds of types: built-in types and class types. Built-in types, so called because they are defined as part of the core language, include char, int and double. The types used from the library, such as "string", "vector", "istream" are all class types.
At its most fundamental level, a class type is a mechanism for combining related data values into a data structure, so that we can treat that data structure as a single entity.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CLASS [pag140 jesse]
A class is just a collection of variables (often of different types) combined with a set of related functions. 
For example you can think of levitational hoverboard like a collection of bearing, board, power generator, visibility lights and so forth. Another way is to think avout what a hoverboard can do: it can levitate, speed up, climbing, slow down, landing, and so forth. A class enables you to encapsulate or bundle, these various parts and various functions into one collection, which is called an object. 
Encapsulating everthing you know about an hoverboard into one class has a number of advantages for a programmer. Everything is in one place, which makes it easy to refer to, copy, and call on functions that manipulate data. Likewise, >> clients of your class (= the parts of the program that use your class) can use your object without worrying about what is in it or how it works. 
A class can consist of any combination of the variable types and also other class types. The variables in the class are referred to as the >> member variables or >> data members. A HoverBoard class might have member variables representing the gyroscope, flux capacitor, anticollition system and so forth. 
Member variable also known as data members, are the variables in your class. Member variables are part of you class just as the board and the power unit are part of your hoverboard. 
A calls cal also contain functions called >> member functions or methods. Member functions are as much a part of your class as the member variables. They determine what your class can do. 
The member functions in the class typically manipulate the member variables. For example, methods of the HoverBoard class might include Start() and Levitate(). A Cat class might have data members that represent age and weight; its methods might include Sleep(), Meow() and ChaseMice().

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> BINARY ASCII CONVERTER
[from NEC-radar-antenna.html
procediamo allora in questo modo: aggiungiamo la creazione di un file in parallelo a quello binario gia' creato :
void NasFEMReader::WriteGeoFile( )
{
 ofstream output;
 // ciccio
 ofstream ciccioFile;
 string name = fileName+".txt";
 output.open(name.c_str());
 ciccioFile.open ("ciccio.txt");   // OK il file viene correttamente creato
 ciccioFile << "Ciao Ciccio stiamo testando se si riesce a far ballare i binary in ASCII. \n";
NOTE: OK siamo riusciti a comprendere il perche' in notepad2 ci venivano all'inizio quella serie di NULNUL
E' dovuto al fatto che al posto di usare delle stringe si usano dei character sequences da 80 caratteri:
char Description[80] ="Nastran To Ensight Conversion";
Quindi una volta che i primi 30 caratteri sono occupati da "Nastran To Ensight Conversion" i restanti 50 restano vuoti, per questo sono occupati da NUL, ed in effetti quando ne fai un copy and paste da notepad2 a bluegriffon e come se non vi fossero, non creano alcuno spazio.
creiamo un file in parallelo a quello binario
 output.write((char*) &Npoints ,sizeof(int));   // questa e' la riga originale che crea il tutto in binario
 ciccioFile << "Total points in Nastran file: " << Npoints << " \n";   // questa e' la nostra riga aggiuntiva che printa in ASCII il numero di nodi all'interno del ciccioFile ottenendo :
    Total points in Nastran file: 3833
[sfortunatamente i file originali sono stati portati via da una tempesta di caos biluniano, spero che gli appunti qui sopra ti possano essere di aiuto a navigare oltre l'oceano del disordine
OK te l'ho ritrovato te l'ho salvato in :
G:\Cplusplus-code\NEC-FEAMapper\mapper-with-ASCII-output-binaryASCII-converter]
//////////////////////////////////////////////////////////////////////////////////////////// porzione completa della conversione binary ascii
void NasFEMReader::WriteGeoFile( )
{
 ofstream output;
 ofstream ciccioFile;
 string name = fileName+".txt";
 output.open(name.c_str());
 ciccioFile.open ("outputASCII.txt");   // OK il file viene correttamente creato
 //ciccioFile << "Ciao Ciccio stiamo testando se si riesce a far ballare i binary in ASCII. \n";
 char Title[80] ="Eri and Yui Queens of Prairies";
 //string TitleCiccio = "Eri and Yui Queens of Prairies. \n";
 string TitleCiccio = "BINARY ASCII CONVERTER \n";
 char Description[80] ="Nastran To Ensight Conversion";
 string DescriptionCiccio = "Nastran To Ensight Conversion. \n";
 char Company[80] ="Nihon ESI";
 string CompanyCiccio = "Nihon ESI \n";
 char  NodeId[80] = "node id given";// ode id <off/given/assign/ignore>
 string NodeIdCiccio = "node id given \n";
 char   EleId[80] = "element id given";// ode id <off/given/assign/ignore>
 string EleIdCiccio = "element id given \n";
 char   Gen[80] ="part";
 string GenCiccio = "part \n";
 int  PartId;
 output.write(Title, 80);
 ciccioFile << TitleCiccio;
 output.write(Description,80);
 ciccioFile << DescriptionCiccio;
 // ciccio
 // cout<<"Ciccio why is still binary??"<<endl;  // ok compare!
 //
 output.write(Company,80);
 ciccioFile << CompanyCiccio;
 output.write(NodeId,80);
 ciccioFile << NodeIdCiccio;
 output.write(EleId,80);
 ciccioFile << EleIdCiccio;
 output.write(Gen,80);
 ciccioFile << GenCiccio;
 PartId =1;
 char Des[80]="NewPart";
 string DesCiccio = "NewPart  ";
 output.write((char*)&PartId,sizeof(int));
 output.write(Des,80);
 // le due righe precedenti se scritti in normale formato txt sono riassumibili con 
 ciccioFile << DesCiccio << PartId << " \n";
 memcpy(Des,"coordinates",80);
 output.write(Des,80); 
 //ciccioFile << "Coordinates \n";
 //total points in Nastran file
 output.write((char*) &Npoints ,sizeof(int));
 ciccioFile << "Total points in Nastran file: " << Npoints << " \n";
 map<unsigned int, DefVarType* > ::iterator itC ;// =  NodeCorrdInfo;

 ciccioFile << "Node ID ---------------- next \n"; 

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     int a = (*itC).first;
     a =  MapNodeIdToConsecutive.find((*itC).first)->second; //giving consecutive  node id as ensight does not read missing id
     output.write((char*)&a,sizeof(int));
	 ciccioFile << a << " \n";
 }

ciccioFile << "X Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float x = (*itC).second[0];
    // float theta = (*itC).second[1];
 //    x= x* cos(theta*PI/180.0); 
     output.write((char*)&x,sizeof(float));
	 ciccioFile << x << " \n";
 }

ciccioFile << "Y Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float y = (*itC).second[1];
   
  //   float r = (*itC).second[0];
   //  y = r*sin(y*PI/180.0);


     output.write((char*)&y,sizeof(float));
	 ciccioFile << y << " \n";

 }

 ciccioFile << "Z Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float z = (*itC).second[2];
     output.write((char*)&z,sizeof(float));
	 ciccioFile << z << " \n";
 }
 memcpy(Des,"quad4",80);
 output.write(Des,80);
 ciccioFile << "QUAD4 ---------------- next \n"; 
 map<unsigned int,vector<Ele* > > ::iterator  it1;
 //map<int ,DefVarType*  > ElementCGInfo;
   //*it1.first will give part id write 
 //check for null element in vector and write element id 
//writing only 1 part  
 
   output.write((char*)&NumberOfQuadElement,sizeof(int));
   ciccioFile << "Number of Quad Elements \n" << NumberOfQuadElement << "\n";
   ciccioFile << "QUAD4 contID ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     //number Quad of element 
     
     for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) &&  ((*it1).second[i]->NumberOfNode==4)) 
       {
          int ele  = (*it1).second[i]->EleId;
          int contId = MapEleIdToConsecutive.find(ele)->second;
          output.write((char*)&contId,sizeof(int));
		  ciccioFile << contId << " \n";
       }
     }

}
 ciccioFile << "QUAD4 Part element info ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
    for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) && ((*it1).second[i]->NumberOfNode==4))
       {
         for(int j=0;j<4;j++) 
         {
    	       int nodeId  = (*it1).second[i]->NodeId[j];
                nodeId = MapNodeIdToConsecutive.find(nodeId)->second; 
               output.write((char*)&nodeId,sizeof(int));
			   ciccioFile << nodeId << " \n";
        }
       } 
     }
} 
 memcpy(Des,"tria3",80);
 output.write(Des,80);
     output.write((char*)&NumberOfTriElement,sizeof(int));
 ciccioFile << "Number of TRIA Elements \n" << NumberOfTriElement << "\n";
  ciccioFile << "TRIA3 contID ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     //number Quad of element
//     int a = NumberOfQuadElement ;//one is null element
     for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) &&  (*it1).second[i]->NumberOfNode==3)
       {
          int ele  = (*it1).second[i]->EleId;
          int contId =   MapEleIdToConsecutive.find(ele)->second;
          output.write((char*)&contId,sizeof(int));
		  ciccioFile << contId << " \n";
        //  output.write((char*)&ele,sizeof(int));
//           cout<<"id  "<<contId<<endl;    
       }
     }
}
  ciccioFile << "TRIA3 Part element info ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     for(int i =0;i<((*it1).second).size();i++)
     {
       if( ((*it1).second[i]!=NULL) &&  (*it1).second[i]->NumberOfNode==3)
       {
         for(int j=0;j<3;j++)
         {
               int nodeId  = (*it1).second[i]->NodeId[j];
               nodeId = MapNodeIdToConsecutive.find(nodeId)->second;
               output.write((char*)&nodeId,sizeof(int));
			   ciccioFile << nodeId << " \n";
 //              cout<<nodeId<<"  ";
        }
//       cout<<endl;
       }
       
     }
  }


 // ubik
 output.close();
 ciccioFile.close();

}
////////////////////////////////////////////////////////////////////////////////////////////

>> BINARY_SEARCH 
	binary_search
function to determine whether a value is in the array.
[pag302deitel]
Note: the linear search for searching an unordered array is simple but slow compared to the more complex but much faster binary search for searching an ordered array.
example pag303:
   // search for "indigo" in colors
   bool found = binary_search( colors.begin(), colors.end(), "indigo" );
   cout << "\n\n\"indigo\" " << ( found ? "was" : "was not" ) 
      << " found in colors" << endl;
[from fig07_18.cpp]
IMPORTANT: to use binary_search the sequence of values must be sorted in ascending order first.
NOTE: bool found = binary_search( A, B, "C" ); A e B represent the range of elements to search and "C" indicates the search key, cioe' the value to locate in the array. The function returns a bool indicating whether was found.

>> block [chiamato anche "compound statement"]
tutto cio' che e' contenuto tra {}
per esempio un blocco if con multipli statements
	if (conditione)
	{
		statement1;
		statement2;
	} 
[see esempio pratico pag94deitel]
NB [da pag115deitel]: a block can be placed anywhere in a program that a single statement can be placed. 
Just as a block can be placed anywhere a single statement can be placed, it's also possible to have no statement at all, which is called a null statement or an empty statement. Then null statement is represented by placing a semicolon ; where a statement would normally be. [from pag 116 deitel]
mio esempio pratico 
if (condition)
{
	statement1;
	statement2;
}
else
	;  // che poi in questo mio esempio e' puramente accademico tanto vale allora non mettere l'else
///////////////
ATTENTION : [pag116] placing a semicolon after the condition in an if statement leads to 
- a logic error in single selection if statements 
- a syntax error in double-selection if...else statements (when the if part contains an actual body statement)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> bitset [pag677 deitel]
Class bitset makes it easy to create and manipulate bit sets, which are useful for representing a set of bit flags. bitsets are fixed in size at compile time. Class bitset is an alternate tool for bit manipulation, discussed in chapter 22 deitel.
- The declaration 
	bitset< size > b;
creates bitset b, in which every on of the size bits is initially 0 ("off")
- The statement
	b.set ( bitNumber );
sets bit bitNumber of bitset b "on". The expression b.set()  sets all bits in b "on"
- The statement
	b.reset( bitNumber);
"flips" bit bitNumber of bitset b (e,g, if the bit is "on", flip sets it "off"). The expression b.flip() flips all bit in b.
- The statement
	b[ bitNumber ];
returns a reference to the bit bitNumber of bitset b. Similarly
	b.st ( bitNumber );
performs range checking on bitNumber first. Then, if bitNumber is in range, at returns a reference to the bit. Otherwise, at throws an out_of_range exception
- The statement
	b.test( bitNumber );
performs range checking on bitNumber first. If bitNumber is in range, test returns true if the bit is on, false it's off. Otherwise, test throwns an out_of_range exception. 
- The expression 
	b.size()
returns the number of bits in bitset b
- The expression 
	b.count()
returns the number of bits that are set in bitset b
- The expression 
	b.any()
returns true if any bit is set in bitset b
- The  expression 
	b.all()
returns true if all of the bits are set in bitset b. 
- The expression 
	b.none()
returns true if none of the bits is set in bitset b.
- The expressions 
	b == b1
	b != b1
compare the two bitsets for equality and inequality, respectively.
Each of the bitwise assignment operator &=, |= and ^= (discussed in detail in section 22.5 deitel) can be used to combine bitsets. For example
	b &= b1;
performs a bit-by-bit logical AND between bitsets b and b1. The result is stored in b. 
Bitwise logical OR and bitwise logical XOR are performed by 
	b |= b1;
	b ^= b2;
The expression 
	b >>= n;
shifts the bits in bitset b right by n positions. 
The expression
	b <<= n;
shifts the bits in bitset b left by n positions. 
The expressions
	b.to_string()
	b.to_ulong()
convert bitset b to a string and an unsigned long, respectively.   
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> bool : boolean value. It can take one of two values: true or false
size 1 byte 

>> BOOL type 
C++ provides the data type "bool" for variables that can hold only the values "true" and "false", each of these is a C++ keyword.
For compatibility with earlier versions of C, which used integers for Boolean values 
> the bool value "true" also can be represented by any non zero value (compilers typically use 1)
> the bool value "false" also can be represented as the value zero. 
[pag111deitel]

>> BREAK statement
pag178deitel
nice example pag 179deitel
...[ricopiato da Code_Examples/ch05/fig05_13/fig05_13.cpp]
 10    for ( count = 1; count <= 10; ++count ) // loop 10 times
 11    {
 12       if ( 5 == count ) // if count is 5,
 13          break; // break loop only if x is 5
 14
 15       cout << count << " ";
 16    } // end for
 17
 18    cout << "\nBroke out of loop at count = " << count << endl;
 19 } // end main
Observation [from 180deitel]
Even if the use of break in switch statements is acceptable, the effects of break and continue can be achieved by structured programming techniques. Diciamo che structure programming techniques guarantee quality. While break and continue possono improve performance. Quality and performance non sempre vanno a braccetto. Spesso uno e' ottenuto a scapito dell'altro. As a general guideline: first make your code simple and correct (structured program); then make it fast and small, but only if necessary.

>> BREAK and >> CONTINUE STATEMENTS [mike pag55]
In the following example the number 5 is skipped with a continue statement, and the loop ends with a break statement:
	// Finicky Counter
	// Demonstrates break and continue statements
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int count = 0;
		while (true)   // questo technically creates an infinite loop. In realta il loop non e' veramente infinito visto che poi nel suo body vi e' un break che rompera' il loop una volta che count diventa piu' grande di 10
		{
			count += 1;
	
			//end loop if count is greater than 10
			if (count > 10)
			{
				break;
			}
	
			//skip the number 5
			if (count == 5)
			{
				continue;    // it makes you jump directly to the top of the loop
			}                // visto che e' messo prima del cout << quando count == 5  the program goes right back to the top of the loop, il programma se count == 5 non raggiunge quindi l'istruzione cout che viene quindi skipped and never displayed.
	
			cout << count << endl;
		}
	
	    return 0;
	}
//
--------------------------
OUTPUT del programma
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
1
2
3
4
6
7
8
9
10
---------------------------
NOTE: you can use break and continue in any loop you create; but you should use them sparingly. Both break and continue can make it harder for programmers to see the flow of a loop.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> BREAKPOINT / >> DEBUGGING with breakpoint in visual studio 
durante il debug di un console program i breakpoint sono utili per metter in pause in modo da poter vedere l'output nella finestra dos prima che si chiuda.
In Visual Studio 
- clicca dove vuoi inserire il breakpoint, 
- Debug -> Toggle breakpoint (or F9)
- si fa partire il debug
- F5 (or Debug -> Continue) to close the dos window and finish the debug.[nb F5 da premersi una volta cliccato sulla finestra visual e non restando sulla DOS windows] 

>> BUFFERED vs UNBUFFERED STREAM
- when a stream is unbuffered , characters are intended to appear from the source as soon as possible
- when a stream is fully buffered characters are intended to be trasnmitted as a block when a buffer is filled. When a stream is line buffered, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encoutered. 

[COUT << = Character Output Stream pronuncitato see-out]

>> BUFFER FLUSH 
A buffer flush is the transfer of computer data from a temporary storage area to the computer's permanent memory. Here's one example of a buffer flush: when you make changes on a word document, the canges you see on your computer screen are stored temporarily in a buffer. When you save your work, the changes that you've made to your document  since the last time you saved it are flushed from the buffer to permanent storage on the hard disk. ]

>> BUFFER / >> FLUSH [pag 11 moo book] 
In general the input output library saves its output in an internal data structure called a buffer, which it uses to optimize output operatios. Most systems take a significant amount of time to write characters to an output device. To avoid the overhead of writing in response to each output request, the input output library uses the buffer to accumulate the characters to be written, and flushes the buffer, by writing its contents to the output device, only when necessary. 

>> BUILD menu: per vedere il menu BUILD
- Tools -> Setting menu and select Expert Settings

>> BUILDING YOUR OWN COMPUTER !!! 
[pag370deitel] machine language programming!!! 
To dig in itiaf

>> boolalpha
[pag585deitel]
C++ provides data type bool, whose values may be false or true, as a preferred alternative to the old style of using 0 to indicate false and nonzero to indicate true. A bool variable ouputs as 0 or 1 by default. However, we can use stream manipulator boolalpha to set the output stream to display bool values as the string "true" or "false". 
Use [tag >> noboolalpha] noboolalpha to set the output stream to display bool values as integers (i.e. the default setting). 
example from pag 586
////////
	bool booleanValue = true;	
	   // display default true booleanValue
	   cout << "booleanValue is " << booleanValue << endl;
	   // display booleanValue after using boolalpha
	   cout << "booleanValue (after using boolalpha) is "
	      << boolalpha << booleanValue << endl << endl;
/////////
donera' in print:
	 booleanValue is 1
	 booleanValue (after using boolalpha) is true
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> BYTE  = unit of digital information.
Consists of EIGHT BITS 

>> CCCCCCC

>> call by value [pag53 moo book] when the function's parameters are initialized to COPIES of the arguments's value, and do NOT refer DIRECTLY to the arguments themselves. This behaviour is called call by value, because the parameter takes on a copy of the value of the argument. 

>> clear vector [pag57 moo book]
	nomevettore.clear()
utile to get rid of previous contents inside the vector.
/////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CALLING FUNCTIONS / >> COMPUTER MEMORY EXPLAINED / >> RAM and >> STACK POINTER [see bella spiegazione pag 130 jesse]
Explains well what are 
	>> register
	>> code space
	>> stack
>> register are a special area of memory built right into the central processing unit (or CPU).
There is a set of registers responsible for pointing, at any given moment, to the next line of code. These registers, together, can be called the >> instruction pointer. It is the job of the instruction pointer to keep track of which line of code is to be executed next. 
>> code space is that part of memory set aside to hold the binary form of the instructions you created in your program. 
Each line of source code is translated into a series of instructions, and each of these instructions is at a particular address in memory. The instruction pointer has the address of the next instruction to execute. 
>> stack = is a special area of memory allocated for your program to hold the data required by each of the functions in your program. It is called a stack because it is a last-in, first out queue, much like the stack dishes at a cafeteria. 
>> last in first out means that whatever is added to the stack last is the first thing taken off. It is like a stack of coins: if you stack 10 coins of euros on a tabletop and then take some back, the last three you put on top are the first three you take off. 
/////////////////////////////////////////////////////////////////////////////////////////////////

>> clear input / >> clear istream objects [example from pag57 moo book]
nomeinputStream.clear()
utile to disregard whatever condition caused the intput attempt to fail, be it end-of-file or invalid input. We do so by calling nomeinputStream.clear() to reset the error state inside nomeinputStream, which tells the library that input can continue despite the failure.
-----------------------------------------------------------
// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}
------------------------------------------
NOTE: from pag 58 moo book: for istream objects, "clear" resets any error indications so that input can continue; for vector objects, "clear" discards any contents that the vector might have had, leaving us with a empty vector again. 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> CALL BASE CLASS COSTRUCTOR [pag318 mike game programming ]
Being able to call a base class constructor is useful when you wnat to pass specific values to it. 
Here's an example:
	Boss::Boss(int damage): 
	    Enemy(damage)            //call base class constructor with argument
	{}
from the following program
-------------------------------------------------------------------------------------
[full program]
	//Overriding Boss
	//Demonstrates calling and overriding base member functions
	
	#include <iostream>
	
	using namespace std;
	
	class Enemy
	{
	public:
	    Enemy(int damage = 10);
	    void virtual Taunt() const;     //made virtual to be overridden
	    void virtual Attack() const;    //made virtual to be overridden
	 
	private:
	    int m_Damage;
	};
	
	Enemy::Enemy(int damage): 
	    m_Damage(damage)
	{}
	
	void Enemy::Taunt() const
	{
	    cout << "The enemy says he will fight you.\n";
	}  
	
	void Enemy::Attack() const
	{
	    cout << "Attack! Inflicts " << m_Damage << " damage points.";
	}
	
	class Boss : public Enemy
	{
	public:
	    Boss(int damage = 30);
	    void virtual Taunt() const;      //optional use of keyword virtual
	    void virtual Attack() const;     //optional use of keyword virtual
	};
	
	Boss::Boss(int damage): 
	    Enemy(damage)            //call base class constructor with argument
	{}
	
	void Boss::Taunt() const     //override base class member function
	{
	    cout << "The boss says he will end your pitiful existence.\n";
	}  
	
	void Boss::Attack() const    //override base class member function
	{
	    Enemy::Attack();         //call base class member function 
	    cout << " And laughs heartily at you.\n";
	}   
	
	int main()
	{
	    cout << "Enemy object:\n";
	    Enemy anEnemy;
	    anEnemy.Taunt();
	    anEnemy.Attack();
	
	    cout << "\n\nBoss object:\n";
	    Boss aBoss;
	    aBoss.Taunt();
	    aBoss.Attack(); 
	    
	    return 0;
	}
	

[end full program]
-------------------------------------------------------------------------------------

>> CALL BASE CLASS MEMBER FUNCTION [mike pag320 game programming]
You can directly call a base class member function from any function in a derived class. All you have to do is prefix the class name to the member function name with the scope resolution operator "::" example :
	void Boss::Attack() const    //override base class member function
	{
	    Enemy::Attack();         //call base class member function 
	    cout << " And laughs heartily at you.\n";
	}   // in this way when a Boss Attack the boss does exactly what an enemy does and then adds a laugh
TRICK [pag321 mike il seguente mi sembra un suggerimento utile durante code customization]: you can extend the way a member function of a base class works in a derived class by overriding the base class method and then explicitly calling the base class member function from this new definition in the derived class and adding some functionality 
////////////////////////////////////////////////////////////////////////////////////////////////////

>> CHAIN input operations [pag37 moo book]
You can chain input operations just like you can chain output operations so 
	cin >> variableA >> variableB;
has the same effect of 
	cin >> variableA;
	cin >> variableB;
>> CHAIN OF STRING [pag37 moo book] / >> READABILITY SUSUME 
Two or more string literals in a program, separated by whitespace, are automatically concatenated
	cout << "Enter all your homework grades, "
	        "followed by end-of-file: ";
has the same effect of 
	cout << "Enter all your homework grades, followed by end-of-file: ";
Spezzando le linee in tal modo permetti di ottenere dei programmi piu' leggibili.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> CORE LANGUAGE vs >> STANDARD LIBRARY [pag2 moo book]
In C++ many funcdamnetal facilities such as input output are part of the standard library, rather than being part of the core language. This distinction is important because the core language is always available to all C++ programs, but you must explicitly ask for the parts of the standard library that you wish to use.
///////////////////////////////////////////////////////////////////////////////////////

>> CASCADING / >> CASCADE 
example pag 443 deitel
cioe' cin >> phone1 >> phone2; 
viene a coincidere [se ho ben capito itiaf check] con 
	cin >> phone1;
	cin >> phone2

>> cascaded array assignment / >> cascaded assignment
[pag464deitel]

>> pointers why do you need them
Trovi una bella spiegazione @pag134 jesse book 
The changes to the value of function arguments are not reflected in the calling function. This is because arguments passed to a function are passed by value. That means that the argument in the function is actually a copy of the original value. 
So if the argument are passed by value, what do I do if I need to reflect the changes back in the calling function?
You use POINTERS or REFERENCES, in this way you can reflect the changes in the calling function. 
/////////////////////////////////////////////////////////////////////////////////////////

>> C string / >> pointer-based strings
[pag358]
A pointer-based string is a built-in array of characters ending with a null character ('\0')
which marks where the string terminates in memory. A string is accessed via a pointer to its first character. 
Nota come 
	char color[] = "blue";
e 
	char color[] = {'b', 'l', 'u', 'e', '\0' };
sono equivalenti. DIciamo che la seconda rende ancora piu' evidente che la C string altri non e' che un built-in array of characters ending with a null character.
NOTE1: when declaring a built-in array of chars to contain a string, the built-in array must be large enough to store the string AND its terminating null character.
NOTE2: deitel sconsiglia di usare C strings: C++'s string class is preferred for use in new programs, because it eliminates many of the security problems and bugs that can be caused by manipulating C strings [molti programmatori finiti all'ospedale con le mani ustionate, sono vere e proprie mine vaganti]
NOTE3: [pag360] because a C string is a built-in array of characters, we can access individual characters in a string directly with array subscript notation. For example, if we declare:
	char color[] = "blue"; 
color[0] is the character 'b', color[2] is 'u' and color[4] is the null character  
NOTE4: to input an entire line of text into a built-in array of chars [pag360deitel]
For this purpose, the cin object provides the member function "getline", which takes three arguments:
- a buil-in array of chars in which the line of text will be stored
- a length 
- a delimiter character
For example:
	char sentence[ 80 ];
	cin.getline( sentence, 80, '\n' );
declare "sentence" as a built-in array of 80 characters and read a line of text from the keyboard into the built-in array.
The function stops reading characters when 
- the delimiter character '\n' is encountered, 
- when the end-of-file indicator is entered 
- or when the number of characters read so far is one less than the length specified in the second argument (80 nell'esempio sopra)
The last character in the built-in array is reserved for the terminating null character.
NOTE5: [pag361deitel] 
> DISPLAYING C strings
A built-in array of chars representing a null-terminated string can be output with cout and << 
The statement
	cout << sentence;
displays the built-in array sentence. Like cin, cout does not care how large the built-in array of chars is. The characters are output until a terminating null character is encoutered; the null character is not displayed. 
"cin" and "cout" assume that built-in array of chars should be processed as strings terminated by null characters; cin and cout do not provide similar input and output processing capabilities for other built-in array types.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C string vs string object [pag106 mike]
You should opt for string objects whenever possible. String objects have advantages over C-style strings. The most obvious is that they are dynamically sizeable. You don't have to specify a length limit when you create one. 

>> C string mike explanation [pag96 mike]
	char phrase[] = "Game Over!!!";
C stype string terminate with a  character called the null character to signify their end. You can write the null character as "\0". We didn't need to use the null character in the previous code because it is sotred at the end of the string for me. So technically phrase has 13 elements  (however functions that work with C style strings will say that phrase has a length of 12, which makes sense and is in line with how string objects works)
	char phrase[81] = "Game Over!!!";
The previous code creates a C style string that can hold 80 printable characters (plus it terminating null character).
A nice about string objects is that thye're desinged to work seamlessly with C style strings. 
C style string have the same shortcomings as arrays. One of the biggest is that their lengths are fixed. So the moral is :
- use string objects whenever possible, but be prepared to work with C style strings if necessary.


 FUNCTIONS / >> CONVERT FUNCTION  
[pag870 deitel] (un simile ai giochini che gia' facevamo in python)
	>> convert NUMERIC VALUES TO STRING OBJECTS : C++11 to_string function (from the <string> header ) returns the string representation of its numeric argument. 
	>> convert STRING Objects to Numeric Values : C++ provies eight functions for convertin string objects to numerica values. Each function attempts to convert the beginning of its string argument to a numeric value. If no conversion can be performed, each function throws an invalid_argument exception. If the result of the conversion is out of range for the function's return type, each function throws an out_of_range exception. If the result of the conversion is out of range ofr the function's return type, each function throws an out_of_range expection  
FUNCTIONS that convert from string to numeric types:
1) functions that convert to integral types
Function     Return type
stoi         int              [memo trick st = string , o = output , i= int]
stol         long             [memo trick st = string , o = output , l= long]
stoul        unsigned long    [memo trick st = string , o = output , u= unsigned , l= long ]
stoll        long long        
stoull       unsigned long long
2) function that convert to floating point types
stof         float
stod         double
stold        long double
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////    


>> CANOVACCIO per buildare piccoli sorgenti tipo quelli from Deitel Book
// Fig. 17.5: fig17_05.cpp
// Demonstrating standard new throwing bad_alloc when memory
// cannot be allocated.
#include <iostream>
#include <new> // bad_alloc class is defined here
using namespace std;

int main()
{
	double *ptr[50];

	// aim each ptr[i] at a big block of memory
	try
	{
		// allocate memory for ptr[ i ]; new throws bad_alloc on failure
		for (size_t i = 0; i < 50; ++i)
		{
			ptr[i] = new double[50000000]; // may throw exception
			cout << "ptr[" << i << "] points to 50,000,000 new doubles\n";
		} // end for
	} // end try
	catch (bad_alloc &memoryAllocationException)
	{
		cerr << "Exception occurred: "
			<< memoryAllocationException.what() << endl;
	} // end catch
	std::cin.ignore();
} // end main


/***************************************************************************
* Canovaccio Ciccio prima della } di chiusura del blocco main aggiungi     *
* aggiungi la seguente linea in modo da poter vedere l'output nel terminal * 
* /////////////////////                                                    *
* std::cin.ignore();                                                       *
* /////////////////////                                                    *
* Per copiare l'output dal command prompt                                  *
* Alt+Space keyboard combination to bring up the window menu,              *
* then hit the E key, and then the K key to copy.                          *
* vedrai il cursore grigio all'interno della command prompt, draggalo      *
* in modo da selezionare tutta la regione che vuoi copiare, quindi click   *
* destro. Infine CTRL+V nel text editor in cui vuoi copiare il testo.      *
***************************************************************************/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> CATCH exception example 
see pag384 deitel in cui utilizza catch e la member function >> what = member function that displays the exception's error message 
	// attempt to set the time with invalid values
   try
   {
      t.setTime( 99, 99, 99 ); // all values out of range
   } // end try
   catch ( invalid_argument &e )
   {
      cout << "\n\nException: " << e.what() << endl;
   } // end catch
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> Cascading  stream insertion operations 
example 
	std::cout << "Sum is " << number1 + number2 << std::endl;
you can use multiple stream insertion operators << and also perform calculation in output statements. 
A powerful feature of C++ is that you can create your own data types called classes. You can  then "teach" C++  how to input and output values of these new data types using << and >>  operators	 
[pag48deitel]

>> cerr 
utile per display a warning message 
example @ pag 94 deitel
	cerr << "Name \"" << name << "\" exceeds maximum length (25).\n"
         << "Limiting courseName to first 25 characters.\n" << endl;

>> char = Character or small integer, size 1byte, 
signed -128 to 127 (oh lovely! 127!)
unsigned 0 to 255

>> character
to represent a single character we enclose it between single quotes ('), ex: 
'z'
'p'
- Notice that to express a string (which is generally more than one character) we enclose it between double quotes ("") and not ''.
- strings literals can extend to more than a single line of code by putting a backlash sign at the end of each unfinished line. ex scrivendo 
cout << "string express in \ 
two lines "; 
otterrai nella DOS window:
string expressed in two lines 
[cioe' ti permette di scrivere nel sourde code la stringa su piu' righe, anche se poi su schermo tutto apparira' come una singola riga]
- you can also concatenate several string constants separating them by one or several blank spaces. ex
scrivendo 
cout << "this form" " a single" " string";
otterrai su schermo:
this form a single string
- There are characters that have certain pecularities, like the escape codes. These characters are preceded by a backlash like newline \n or tab (\t nella tastiera jp il bachlash coincide con \)
ex : 
cout << "one\ntwo\nthree";
produrra' su schermo 
one 
two 
three
- Here'a list of some of such escape codes:
\n  newline
\r  carriage return
\t  tab
\v  vertical tab
\b  backspace
\f  form feed (page feed)
\a  alert (beep)
\'  single quote (')
\"  double quote (")
\? question mark (?)
\\ backslash (\)
-----------------------------------------------------------------------------------------------------

>> CHARACTER HANDLING LIBRARY / >> character string manipulation 
[pag897 deitel]
The character handling library includes several functions that perform useful tests and manipulations of character data.
Character are often manipulated as integers.
NOTA come il nome delle funzioni sia costituito da "is" + "tipo del carattere" di cui vuoi effettuare la verifica
Prototype                   Description 
int isdigit (int c)         return 1 if c is a digit and 0 otherwise
int isalpha (int c)         return 1 if c is a letter and 0 otherwise
int isalnum (int c)         return 1 if c is a digit or letter and 0 otherwise
int isxdigit (int c)         return 1 if c is a hexadecimal digit and 0 otherwise
int islower (int c)         return 1 if c is a lowercase letter and 0 otherwise
int isupper (int c)         return 1 if c is a uppercase letter and 0 otherwise
per gli altri ti rimando alla tabella di pag898 deitel fig 22.17
NOTE: from pag 903 >> tokenizing strings = separating strings into logical pieces such as the separate words in a sentence
--------------------------------------------------------------------------------------------------------------------------
>> C string manipulation functions [pag903 deitel]
 (ti scrivo qui quelle che ritengo ci possano venire piu' utili, per la lista completa see pag903 deitel)
	char *strcat( char *s1, const char *s2);
		Appends the string s2 to s1. The first character of s2 overwrites the terminating null character of s1. The value of s1 is returned.
	char *strtok( char *s1, const char *s2)
		A sequence  of calls to strtok break string s1 into >> tokens (= logical peces such as words in a line of text + pag 908 deitel). The string is broken up based on the characters contained in string s2 [somiglia un poco | grep 'Solving for Ux' | cut -d' ' che usiamo nei residual files]. For instance, if we were to break the string "this:is:a:string" into tokens based on teh character ':', the resulting tokens would be "this", "is", "a" and "string". Function strtok returns only one token at a time (= the first call contains s1 as the first argument, and sbusequent calls to continue tokenizing the same string contain NULL as the first argument). A pointer to the current token is returned by each call. If there are no more tokens when the function is called, NULL is returned.
Altre funzioni presentate nelle pagine 903 deitel e seguenti:
	strcpy 
	strncpy
	strcat
	strncat
	strcmp
	strncmp
	strtok
	strlen
NOTE1: forgetting to include the <cstring> header when usin functions from the string-handling library causes compilation errors.
NOTE2: function >> strcpy [pag904 deitel] copies its scond argument (= a string) into its first argument (= a character array that must be large enough to store the string and its terminating null character - which is also copied -).
NOTE3: [pag908 deitel] >> COMPARING STRING / >> COMPARE CHARACTERS : how does the computer know that one letter comes before another? All characters are represented inside the computer as numeric codes; when the computer compares two strings, it actually compares the numeric codes of the characters in the strings.
NOTE4: >> tokeninzing more info pag908 deitel: function strtok breaks a string into a series of tokens. A token is a sequence of characters separated by delimiting charactesr (usually spaces or punctuations marks). For example in a line of text, each word can be considered a token, and the spaces separating the words can be considered delimiters.
-----------------------------------------------------------------------------------------------------
>> C string conversion functions [pag910 deitel] ti scrivo qui giusto il nome delle funzioni presentate e ti rimando direttamente al libro per la spiegazione piu' esauriente
	atof   -> converts its argument (a string that represent a floating point number) to a double value [gia' in maniera un po' simile a quanto facevamo nei programmi python]
	atoi   -> converts a string of digit that represents an integer to an int value. 
	atol   -> converts a string of digits representing a long integer to a long value
	strtod 
	strtol
	strtoul
>> SEARCH FUNCTIONS OF THE C STRING HANDLING LIBRARY [pag915 deitel]
	strchr  
		esempio di utilizzo char *strch (const char *s, int c )    Locates the firs occurrence of character c in string s. If c is found, a pointer to c in s is returned. Otherwise, a null pointer is returned [carino! qui si tocca con mano la funzione del pointer, il pointer ti indica do sta cio che cerchi E' una sorta di Navigator!]
	strrchr
	strspn
	strpbrk
	strcspn
	strstr
Sono delle funzioni utili per dirti. L'ultima parola della stringa contenente la lettera "z" e' .... ve ne sono in tutte le salse per maggior info take a look at the pages 910 et seguenti.
-----------------------------------------------------------------------------------------------------
>> MEMORY FUNCTIONS OF THE C STRING HANDLING LIBRARY
pag919 deitel
[detto in parole spiccie sono funzioni che ti permettono ad esempio di copiare gli ultimi ex 10 byte di un array x into the first 10 bytes of array x]
The string handling library functions presented in this section facilitate manipulating, comparing and searching blocks of memory.The functions tresat blocks of memory as arrays of bytes. These functions can manipulate any block of data.
Example 	
	void *memcpy( void *s1, const void *s2, size_t n )    copies n characters from the object pointed to by s2 into the object pointed to by s1. A pointer to the resulting object is returned. The area from which characters are copied is not allowed to overlap the area to which characters are copied. 
NOTE: the pointer parameters to these functions are declared void*. In chapter 8, we saw that a pointer to any data type can be assigned directly to a pointer of type void *. For this reason, these functions can receive pointers to any data type. Remember that a pointer of type void * cannot be assigned directly to a pointer of any other data type. Because a void * pointer cannot be dereferenced, each function receives a size argument that specifies the number of characters (bytes) the function will process. For simplicity, the examples in this section (pag920 deitel) manipulate character arrays (block of characters). 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> CHARACTER CONSTANTS
[pag358lala]
A character constant is an integer value reprenseted as a character in single quotes.
The value of a character constant is the integer value of the character in the machine's character set. 
For example
	'z'
represents the integer value of z (122 in the ASCII character set)
and 
	'\n'
represents the integer value of newline (10 in the ASCII character set)
>> STRINGS
A differenza delle character constant, le Strings usano le double quotation marks " " and sono costituite da una serie di characters treated as a single unit
Example of strings
	"22-50-2nd Street" 


>> CIN  
Character INput
ex
	cin >> first_reactor
ex2
	std::cin >> number1; 
uses the standard input stream object cin (of the namespace std) and the stream extraction operator >> to obtain a value from the keyboard. We like to pronouce the preceding statement as "std::cin gives a value to number1" or simply "std::cin gives number1".
[pag46deitel]
NOTE from pag34 MIKE : >> cin is an object defined in the file iostream, that's used to get data from the standard input stream. 

>> cin.get()
[example pag 173deitel]
esempio 
	int level; // level entered by the user
	level = cin.get()
the cin.get function reads one character from the keyboard and stores that character in integer variable level.	
OBSERVATION from pag 173deitel
nell'esempio si legge un carattere da tastiera e lo si stora in un integer variable. Strano vero? il fatto e' che characters can be stored in any integer  data type, because types short, int, long, and long long are guaranteed to be at least as big as type char. Thus we can treat a character either as an integer of as a character, depending on its use.
See appendix B for the characters and decimal equivalents from the ASCII character set: per esempio a viene rappresentato come 97: 97 is the numerical representation di "a" in the computer.  

>> Client code
per client code si intende per esempio la function main che utilizza una determinata classe. il concetto compariva nel discorso sulla reusability: in order to promote reusability separate the class definition fro mthe client code (e.g. function main)  that uses the class.
[pag86deitel]

>> close file 
[pag605 deitel]
TO close a file you can use the member function close, for example
	// ofstream constructor opens the file
	ofstream ciccioFile("NTTData.txt", ios::out );
	...
	// close the file
	ciccioFile.close();
///////////
NOTE: Error prevention 
always close a file as soon as it's no longer needed in a program.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CMATH [pag204deitel]
the <cmath> header provides a collection of functions that enable you to perform common mathematical calculations.
from fig6.2pag204deitel
	ceil( x )    -> rounds to the smallest integer not less than x   example: ceil(9.2) is 10.0, ceil(-9.8) = -9.0
    floor( x )   -> rounds x to the largest integer not greater than x, example floor(9.2) is 9.0, floor(-9.8) is -10.0
	sin( x )     -> sin di x, x in radiants
	cos( x )     -> cos di x, x in radiants
	tan( x )     -> tangent di x, x in radiants
	exp( x )     -> exponential function e^x  example exp(1.0) = 2.718282
	log( x )     -> natural logarithm of x (base e): example log( 2.718282 ) is 1.0
	log10( x )   -> logarithm of x (base 10) example log10(100) is 2.0
	fabs( x )    -> absolute value of x , example fabs(4.2) is 4.2, fabs(-9.76) is 9.76
	fmod( x, y ) -> remainder of x/y as floating-point number ex: fmod( 2.6, 1.2) is 0.2
	pow( x, y )  -> x raised to power y  ex pow( 2, 7 ) is 128
 	sqrt( x )    -> square root of x (where x>=0)



>> COMMA OPERATOR (,)
The comma operator is used to separate two or more expressions that are included where only one expression is expected. When the set of expression has to be evaluated fora value only the rightmost expression is considered. 
Example:
	a = (b=3, b+2);
prima si assegna il valore 3 a b, quindi si assegna b+2 alla variabile che alla fine conterra' il valore 5, mentre b conterra' il valore 3. 
See also pag161deitel-> comma-separated list of expressions
The comma operator is often used in for statements; its primary application is to enable you to use multiple initialization expression and/or multiple increment expressions. -> see esempio pratico pag 165 deitel [te lo rescrivo qui sotto per comodita']
example 
for ( unsigned int number = 2; // initialization
	  number <= 20; // loop continuation condition
	  total += number, number +=2 )
; //empty body [usando il comma operator sei cosi' in grado di gli even integer from 2 to 20 tutto all'interno del for header]
1 OSSERVAZIONE e consiglio da pag165deitel: e' sconsigliato pero' ai fini della chiarezza, modificazione e debug mergere the statements of the body of a for loop into its header: si puo' fare ma poi risulta piu' difficile da comprendere
2 OSSERVAZIONE [from pag 208]: le virgole usate tra gli arguments di una funzione non sono dei comma operators. 
Example la funzione:
	maximumTonnaggio = maximum( TonsCargo1, TonsCargo2, Tons-Cargo3);
the order of evalution of a function's arguments it's not specified by the C++ standard, thus different compilers can evaluate function arguments in different orders (non necessariamente from left to right). Sometimes when a function's arguments are expressions, such as those with calls to other functions, the order in which the compiler evaluates the arguments could affect the values of one or more of the argumetns. If the evaluation order changes between compilers, the argument values passed to the function could vary, causing subtle logic errors. 
SOLUTION: if you have doubts about the order of evaluation of a function's arguments and whether the order would affect the values passed to the function:
- evaluate the arguments in separate assignment statements before the function call, 
- assign the result of each expression to a local variable, 
- then pass those variables as arguments to the function.

  
 

>> COMMENTS : 
Two ways 
1) // 
// discards everything from where the // is found up to the end of the same line. (non necessariamente devi porlo a inizio di una nuova linea, poi anche sistemarlo dopo il semicolo di un'istruzione, rendendo il tutto piu' compatto) 
2) /* block comment */
discards everything between the /* characters and the first appearance of the */ characters, with the possibility of inlcuding more than one line. 

>> COMPILE LINK and execute a simple program in Linux from command line 
in SHORT:
	g++ edyProgram.cpp -o edyProgram.exe
[l'estensione exe non e' obbligatoria, giusto una nostra abitudine per localizzare meglio i files eseguibili]
o nel caso di multipli files (hearders, main ect) basta che li metti in lista prima dell' "-o" [ciccio courtesy!]
	g++ Array.h Array.cpp fig10_09.cpp -o executable
[source pag11 programming principle bjarne]
ex: execute a simple program consisting of two source files, my_file1.ccp and my_file2.ccp, using the GNU C++ compiler, g++ on a Linux/Unix system:
	g++ -o my_program my_file1.ccp my_file2.ccp
	./my_program
that's all folks!
EXAMPLE with HEADER FILE 
supponi di avere vari files: 
	Array.cpp  Array.h fig10_09.cpp
per compilarli linkarli e creare l'eseguibile:
	g++ Array.h Array.cpp fig10_09.cpp -o executable
[l'ordine con cui elenchi i files da buildare e linkare non e' importante]
In tal modo ti ritroverai l'eseguibile "executable" che potrai lanciare con 
	./executable
[anche il seguente ordine e' valido:
	g++ edyProgram.cpp -o edyProgram
this command compiles the application and produces an executable file called edyProgram
To run the executable type
	./edyProgram
and press enter.
pag23 deitelC++
]  
////////////////////////////////////////////////////////////////////////////////

>> COMPILE in Visual Studio [tested at Orion 1 with visual studio 2013 (quando avevamo ancora tutti i denti!)]
New Project -> Win 32 console application
next => in application settings uncheckiamo il "security development lifecycle", unchecked precompiled header
Next => ti si apre il text editor con il programma => cancella tutto il contenuto copiaci dentro il codice sorgente
Menu Build F7
OK it just works!!!
/////////////////////////////////////////////////////////////////////////////////

>> COMPILING and BUILDING EXAMPLE [from NEC feamapper] / >> BUILDING on linux with cmake 
>> COMPILE / >> BUILD / >> cmake
in short from pawan:
Source code that i send you is compiled in linux.
Code are same except cmakefile And few file in openfoam folder..
      Step 1 create build folder and go inside the folder

     Step 2  run command
                  cmake ../source  
     Step 3 build
IN DETAIL BY CICCIO
Step by step by ciccio:
	pwd 
		/home/serena/edylab/Linux-SourceCode-pawan-150408
	tree -L 2
la struttura e' la seguente:
		--- Source
		|?? -- CMakeLists_12.txt
		|?? -- CMakeLists.txt
		|?? -- CVS
		|?? -- General_Bottom.cmake
		|?? -- General_Top.cmake
		|?? -- README
		|?? -- src
		|?? -- window
		--- Source.tgz
	mkdir built-ciccio
	cd built-ciccio
	cmake ../Source
otterrai:
		-- Configuring done
		-- Generating done
		-- Build files have been written to: /home/serena/edylab/Linux-SourceCode-pawan-150408/built-ciccio
Quindi build with make:
	pwd 
		/home/serena/edylab/Linux-SourceCode-pawan-150408/built-ciccio
	make	
Otterrai come messaggio 
	[ 20%] Building CXX object CMakeFiles/FEAMapper.dir/src/main/main.o
	[ 40%] Building CXX object CMakeFiles/FEAMapper.dir/src/NastranReader/cxx/NastranReader.o
	[ 60%] Building CXX object CMakeFiles/FEAMapper.dir/src/NastranReader/cxx/NastranReader_FEAMesh.o
	[ 80%] Building CXX object CMakeFiles/FEAMapper.dir/src/OpenFOAMReader/cxx/OpenFOAMReader.o
	[100%] Building CXX object CMakeFiles/FEAMapper.dir/src/Octree/cxx/Octree.o
	Linking CXX executable FEAMapper
	[100%] Built target FEAMapper
Otterrai cosi' il nuovo file FEAMapper:
	ls
		CMakeCache.txt  CMakeFiles  cmake_install.cmake  FEAMapper  Makefile
Quindi abbiamo copiato l'eseguibile nella cartella dei files openFOAM (si puo' rinominare l'eseguibile nessun problema)
	mv FEAMapper FEAMapper-linux
	chmod 777 FEAMapper-linux
	./FEAMapper-linux Pipe_Simple_PID2040_OrigR.dat . 1000 static\(p\)_coeff partInfo 0 0
dove abbiamo mettere le parentesi prima di ( e ) per evitare errori. 
tested on VM centOS6.6
[nice esempio di cmake and building here 
http://wiki.blender.org/index.php/Dev:Doc/Building_Blender/Linux/Ubuntu/CMake]
///////////////////////////////////////////////////////////////////

>> COMPILER REQUIRED FOR Deitel Programs / >> programs deitel 
- gnu C++ 4.7 [benche' updatato ed installatolo in Orion1 ubuntu la compilazione ci dava talvolta degli errori]
- microsoft visual C++ 2012
- apple LLVM in Xcode 4.5

>> ERROR CMAKE / >> CMAKE ERROR 
	is not a full path and was not found in the PATH.
	
	Tell CMake where to find the compiler by setting either the environment
	variable "CC" or the CMake cache entry CMAKE_C_COMPILER to the full path to
	the compiler, or to the compiler name if it is in the PATH.
SOLUTION: capita quando utilizzi in windows un cmakelists settato per linux. 
Visto che linux utilizza per i path /../../ bisogna sostituirli con i \..\..\ richiesti da windows. 
///////////////////////////////////////////////////////////////////


>> ERROR STATE STREAM / >> STREAM ERROR STATES 
[pag588 deitel]
The state of a stream may be tested through bits in class ios_base.
Example from pag 588 
////////////
   // display results of cin functions
   cout << "Before a bad input operation:"
      << "\ncin.rdstate(): " << cin.rdstate()
      << "\n    cin.eof(): " << cin.eof()
      << "\n   cin.fail(): " << cin.fail()
      << "\n    cin.bad(): " << cin.bad()
      << "\n   cin.good(): " << cin.good()
      << "\n\nExpects an integer, but enter a character: ";

   cin >> integerValue; // enter character value
   cout << endl;

   // display results of cin functions after bad input
   cout << "After a bad input operation:"
      << "\ncin.rdstate(): " << cin.rdstate()
      << "\n    cin.eof(): " << cin.eof()
      << "\n   cin.fail(): " << cin.fail()
      << "\n    cin.bad(): " << cin.bad()
      << "\n   cin.good(): " << cin.good() << endl << endl;

   cin.clear(); // clear stream
/////////////
Donera' in print 
	Before a bad input operation 
    cin.rdstate(): 0
       cin.eof() : 0
       cin.fail(): 0
        cin.bad(): 0
       cin.good(): 1
    Expects an integer, but enter a character: A
	After a bad input operation:
    cin.rdstate(): 2
       cin.eof() : 0
       cin.fail(): 1
        cin.bad(): 0
       cin.good(): 0
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> COMMENTS in options file 
[non lo so se sia vero, ci veniva ancora errore]
[cioe' il file options che trovi all'interno della Make directory]
You can include comments in your options file by starting each comment line with a pound sign (#)
	#comment here
	EXE_INC = \
		-I.. \
		-I$(LIB_SRC)/transportModels/twoPhaseMixture/lnInclude \
		-I$(LIB_SRC)/transportModels \
	...

>> COMPOSITION 
[pag378 introduction]
Composition is a form of a reuse in which a class can have objects of other classes as members.
>> COMPOSITION vs INHERITANCE / >> INHERITANCE vs COMPOSITION
pag385deitel
Often, classes do not have to be created "from scratch". Rather, they can include objects of other classes as members or they may be derived from other classes that provide attributes and behaviors the new classes can use. Such software reuse can greatly enhance productivity and simplify code maintenance. 
- INCLUDING CLASS OBJECTS  as member of other classes is called COMPOSITION (or >> AGGREGATION)
- DERIVING NEW CLASSES from existing classes is called INHERITANCE
[pag404deitel]
Composition is the capability for a class to have objects of other classes as members. 
A common form of software reusability is composition, in which a class has objects of other types as members.		

>> COMPOUND ASSIGNMENT OPERATORS (+=, -=, /=, *=)
They are useful when we want to perform an operation on the value currently stored in that variable. 
    Expression:        | Is equivalent to:
    value += increase; | value = value + increase;
    a -= 5;            | a = a - 5;
    a /= b;            | a = a / b;
    price *= units +1; | price = price * (units +1);
NB notare come sebbene la right left rule sia sempre valida, l'operatore doppio viene letto nella direzione left->right (a -=5 : prima sottrai [-] 5 ad a quindi assegni [=] il risultato ottenuto ad a

 OPERATION [tipo per convertire un "char" in "int" ect] / >> CAST OPERATOR
[pag 467 deitel]
You can use "cast operators" to force conversions among fundamental types.
A conversion operator (also called a cast operator) can be used to convert an object of one class to another type. Such conversion operator must be a non-static member function. 
Nel caso di conversione tra user-defined types (cioe' type che sono stati definiti dall'utente) since the compiler cannot know in advance how to convert something defined by the user, we need to use a conversion constructor 
NOTE: from pag 468 deitel
Onde evitare indotti da implicit conversions, meglio usare >> explicit constructors example
	explicit Array (int = 10) ; 
the reason to declare every single argument contructor preceded by the keyword explicit is to suppress implicit conversions via conversion constructors when such conversion should not be allowed.
In tal modo anziche' cadere nella nebbia confusa della conversione implicita, con l'esplicito, qualora avvenisse una conversione non ammessa ti esce bello chiaro un messaggio di errore.
Tipo [pag 470]
>> ERROR
cannot convert parameter ... Reason: cannot convert from 'int' to 'const Array'
Constructor from class 'Array' is declared 'explicit'    
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 USER DEFINED / >> USER DEFINED CONVERSION [pag214 moo book]
User defined conversion say how to transform to and from objects of class type. As with built-in conversions, the compiler will apply user defined conversions to convert a value into the type that is needed.

 operators [pag222 moo book] 
A conversion operator says how to convert an object from its type to a target type.

>> CONDITIONAL OPERATOR ?:
[pag113 deitel] [see also >> conditional ternary operator pag 94 jesse ]
Example
	cout << ( antiGrav >= 1000 ? "Levitating" : "Not levitating");
the first operand is a condition, the second operand is the value for the entire conditional expression if the condition is true and the third operand is the value for the entire conditional expression if the condition is false. 
The conditional operator is l'unico operatore ternario in C++, cioe' l'unico operatore che prenda 3 operandi. The operands, together with the conditional operator, form a CONDITIONAL EXPRESSION.
NB: le parentesi tonde nell'espressione sopra sono necessarie visto che la priorita' del conditional operator e' bassa (the precedence of the conditional operator is low).
Se non vuoi usare le parentesi puoi anche scriverlo nel seguente modo 
	antiGrav >= 1000? cout << "Levitating" : cout << "Not levitating";
[questa sintassi e' valida visto che the values in a conditional expression also can be actions to execute]
la precedente espressione e' letta: se antiGrav > 1000 then cout << "Levitating"; otherwise cout << "Not levitating"
ADDITIONAL INFO from stackoverflow
>> ? meaning
 http://stackoverflow.com/questions/795286/what-does-do-in-c

condition ? result_if_true : result_if_false

... if the condition evaluates to true, the expression evaluates to result_if_true, otherwise it evaluates to result_if_false.

quindi le due forme sottostanti sono del tutto equivalenti 
	int qempty()
	{
		return (f == r ? 1 : 0);
	}
equivale a :
	int qempty()
	{
	  if(f == r)
	  {
		  return 1;
	  }
	  else
	  {
		  return 0;
	  }
	}
/////////////////////////////////////////////////////////////////////////

>> CONSOLE PROGRAM : it is a program that uses text to communicate with the user and to show their results (per esempio attraverso una delle classiche DOS black windows)

>> CONST 
with the const prefix we can declare constants with a specific type in the same way as you would do with a variable: 
ex
	const int pathwidth = 100; 
	const char tabulator = '\t';
- here pathwidth and tabulator are treated just like regular variables except that their values cannot be modified after their definition

>> const object and >> const Member functions
[pag402deitel]
You may use keyword "const" to specify that an object is not modifiable and that any attempt to modify the object should result in a compilation error. The statement
	const Time noon( 12, 0, 0);
declares a "const" object noon of class "Time" and initializes it to 12 noon. It's possible to instantiate "const" and "non-const" objects of the same class.
PERFORMANCE: declaring variables and objects "const" when appropriate can improve performance: compilers can perform optimization on constants that cannot be performed on non-const variables.
NOTE: C++ disallows member function calls for "const" objects unless the member functions themselves are also declares "const". This is true even for "get" member functions that do not modify the object. This is also a key reason for declaring as "const" all member-functions that do not modify the objects on which they're called.
Note2: defining as "const" a member function that modifies a data member of the object is a compilation error. 
Note3: defining as const a member function that calls a non-csont member function of the class on the same object is a compilation error.
Note4: invoking a non-const member function on a const object is a compilation error.
Note5: an interesting problem arises for constructores and destructors, each of which typically modifies objects. A constructor must be allowed to modify an object so that the object can be initialized properly. A destructor must be able to perform its termination housekeeping chores before an object's memory is reclaimed by the system. Attempting to declare a constructor or destructor const is a compilation error.

>> CONSTANT VARIABLES
[pag284deitel] 
Constant variables (also called "named constant" or "read-only variables") must be initialized when they are declared and cannot be modified thereafter. 
Example 1 [corretto] 
#include <iostream>
using namespace std;
int main()
{
   const int x = 7; // initialized constant variable
   cout << "The value of constant variable x is: " << x << endl;
} // end main
// ------------------------------------------------------------
Example 2 [incorretto]
int main()
{
   const int x; // Error: x must be initialized
   x = 7; // Error: cannot modify a const variable
} // end main
// ------------------------------------------------------------
/////////////////////////
Altro esempio from Mike pag29
	const int ALIEN_POINTS = 150;
una volta definita tale costante possiamo usare ALIEN_POINTS just like any integer literal. Also notice that the name we chose for the constant is in all CAPITAL LETTERS. This is just a convention, but it's a common one. An identifier in all caps tells a programmer that it represents a constant value. 
NOTE: you can't assign a new value to a constant. If you try, you'll get a compile error.
	

	vedi anche voce >> ASSAY SIZE specifying with constant variable

>> CONSTRUCTOR [pag190 moo book]
The role of any constructor is to ensure that the object is correctly initialized. 

>> CONSTRUCTOR 
[pag79deitel]
A constructor can be used to initialize an object of the class when the object is created. 
A constructor is a special member function that must be defined with the SAME NAME as the class, so that the compiler can distinguish it from the class's other member functions
See example pag 80 
- An important difference between constructors and other functions is that constructors cannot return values, so they cannot specify a return type (not even void).
- Also a constructor cannot be declared const (because initializing an object modifies it)
> INITIALIZING OBJECTS with constructors see pag 81
Observation
- notice that both the constructor and the member function (like line 21 pag80) can use the same parameter. You can use the same parameter names in different functions because the parameters are local to each function - they do not interfere with one another.
- Constructor notation in UML diagram [pag83]
1) to distinguish a constructor from a class's operations, the UML places the word "constructor" between << >> before the constructor's name. Example
	<<constructor>> + GradeBook( name : String )
2) By convection, you list the class's constructor before other operations in the third compartment.
- DEFAULT CONSTRUCTOR (pag82) = a default constructor is any constructor that takes no arguments. 
EXAMPLES
- pag 300 bel esempio pratico di applicazione lessicale "constructor, data member" : 
Come al solito abbiamo i tre personaggi 
un GradeBook.cpp where the classes are defined
un GradeBook.h where the classes are declared
un main.cpp where the classes are used
> the class constructor is DECLARED in the GradeBook.h
> the class constructor is DEFINED in the GradeBook.cpp
> the program that contains the main{} creates a GradeBook object and passes an existing int array to the constructor, which copies the array's values into the DATA MEMBERS grades (in the *.cpp module, where the functions are defined)
[see also 
http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
http://www.tutorialspoint.com/cplusplus/cpp_constructor_destructor.htm
salvati in blackbird]

>> CONSTRUCTOR with DEFAULT ARGUMENTS
[pag387 deitel]
Esempio di constructor with default argument [gli arguments vengono settati di default all'interno dell'header file]
A) Extract from the Time.h in directory fig09_04_06
	public:
	   explicit Time( int = 0, int = 0, int = 0 ); // default constructor
e il suo relativo main ccp file Time.cpp: 
	// Time constructor initializes each data member 
	Time::Time( int hour, int minute, int second ) 
	{ 
	   setTime( hour, minute, second ); // validate and set time
	} // end Time constructor
B) Extract from the Time.h [esempio di constructor senza default parameters] in dir fig09_01_03
	public:
   		Time(); // constructor
e il suo relativo main ccp file Time.cpp file:
	// Time constructor initializes each data member to zero.
	Time::Time() 
	   : hour( 0 ), minute( 0 ), second( 0 )
NOTE: quali sono i vantaggi di assegnare default arguments to the constructor come nell'esempio A?
	explicit Time( int = 0, int = 0, int = 0 );
The default arguments  to the constructor ensure that, ven if no values are provided in a constrcutor call, the constructor still initializes data members. A constructor that defaults all its arguments is also a default constructor (that is a constructor that can be invoked with no arguments). There can be at most one default constructor per class.
NOTE2[pag388deitel]: any change to the default argument values of a function requires the client code to be recompiled (to ensure the program still functions correctly)
NOTE3: pag391deitel If a member function of a class already provides all or part of the functionality required by a constructor (or other member function) of the class, call that member function from the constructor (or other member function). This simplifies the maintenance of the code and reduces the likehood of an error if the implementation of the code is modified. As a general rule : Avoid repeating code. AVOID REPEATING CODE. 
//////////////////////////////////////////////////////////////////////////////////

>> CONSTRUCTOR [pag 164 moo book]
We know that the library guarantees that when we create an object of a library calss, the object starts with an appropriate value. For example when we define a string or a vector without an initial value, we get an empty string or vector. 
Constructors are special member functions that define how objects are initiazed. There is no way to call a constructor explicitly. Instead, creatin an object of class type cals the approrate constructor automatically as a side effect.
The synthesized constructor will initialize the data members to a value that depends on how the object is being created. [the rules are a bit complicated for the details please see star tag at pag 164 we gotta go for topology quantum gravity and navier stokes smoothness]
Quando non si usano constructor, al momento della creazione dell'oggetto si avra' una default initialization, this can give to the object undefined values, meaning they will hold whatever garbage happens to be in memory when the object is created. Cio' e' del tutto harmless a patto che prima di effettuare delle operazioni sugli oggetti non ci dimentichiamo di inizializzarli assegnando loro delle valori appropriati. 
However it is normally good practice to ensure that every data member as a sensible value at all times. For example, it is possible that later we (or a subsequent maintainer of our code) will add operations that examine these data members. If we don't initialize them in the constructor, then these new operations might cause future failures. 
CONSTRUCTORS are distinguished from other member functions in two ways: 
1) They have the same name as the name of the class itself.
2) They have no return type.
>> DEFAULT CONSTRUCTOR [pag165 moo book]
The constructor that takes no arguments is known as the default constructor. Its job is normally to ensure that its object's data members are properly initialized. 
In the case of Student_info objects (example at pag165) we want the "homework" member to be an empty vector, the n member to be an empty string, and the midterm and final members to be initialized to zero
	Student_info::Student_info(): midterm(0), final(0) { }
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter09/Student_info.cc]
The constructor definition uses some new syntax. Between the : and the { is a sequence of >> constructor initializers, which tell the compiler to initialize the given members with the values that appear between the corresponding parentheses [cioe' i valori compresi tra le parentesi tonde "0" e "0" verranno assegnati rispettivamente a midterm e final]
Understading constructor initializers is crucial to understading how to create and iniliaze objects. 
When we create a new class object, several steps happen in sequence:
	1) the implementation allocates memory to hold the object
	2) it initializes the object using initial values as specified in the initializer list
	3) it executes the construtor body.
Cioe' detto con una metafora sociologica
	1) prepari le culle
	2) ci metti dentro i pargoli (~ valori initiali)
	3) fai andare i pargoli a scuola, in modo da modificarli e renderli utili alla "societa'" del programma.
The constructor body may change these initial values subsequently, but the initialization happens before the constructor body begins execution. It is usually better to give a member an initial value explicitly, rather than assigning to it in the body of the constructor. By initializing rather than assigning a value, we avoid doing the same work twice.
>> CONSTRUCTORS WITH ARGUMENTS [pag166]
example in  /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter09/Student_info.cc]
	Student_info::Student_info(istream& is) { read(is); }	
this constructor delegates the real work to the "read" function. The constructor has no explicit initializer, so the homework and n members will be initialized by the default constructors for vector and string respectively. The midterm and final members will have explicit initial values only if the object is being value-initialized. This lack of initialization doesn't matter, because read immediately gives these variables new values.
//////////////////////////////////////////////////////////////////////////////////


>> CALL FUNCTION / >> MAIN FUNCTION [pag2 moo book]   
A function is a piece of program that has a name, and that another part of the program can CALL, or cause to run. Every C++ program must contain a function named "main". When we ask the C++ implementation to run a program, it does so by calling the "main" function.
The main function is required to yield an integer as its result, the purpose of which is to tell the implementation whether the program ran successfully. A zero value indicates success; any other value means there was a problem. 
Example 	
	int main()
to say that we are defining a function named main that returns a value of type int.

>> CALL FUNCTION simple example from SAMS Jesse Book [pag35 jesse]
#include <iostream>
  
// function Demonstration Function
// prints out a useful message
void DemonstrationFunction()    // header of the function = return_type FUNCTION_NAME (parameters to that function)
{
   std::cout << "In Demonstration Function\n";
}
  
// function main - prints out a message, then
// calls DemonstrationFunction, then prints out
// a second message.
int main()
{
    std::cout << "In main\n" ;
    DemonstrationFunction();
    std::cout << "Back in main\n";
    return 0;
}
////////////////////////////////////////////////////////////////////////////////////


>> constructors and destructors for local objects // >> local object constructor deconstructors // >> deconstructors local objects // >> call constructors and destructors 
[pag394deitel]
The constructor for a local object is called when execution reaches the point where that object is defined.
The corresponding destructor is called when execution leaves the object's scope (i.e. the block in which that object is defined has finished executing). Constructors and destructors for local objects are called each time execution enters and leaves the scope of the object. Destructors are not called for local objects if the program terminates with  call to function "exit" or function "abort"
IN SOSTANZA: come spiegato nell'esempio di pagina 395-396deitel l'oggetto il cui constructor verra' chiamato per primo, sara' quello il cui destructor sara' chiamato per ultimo. Cioe' che accade nelle pagine 395-396 fig 9.9 sara' schematizzabile cosi'
---- global object "first" -- constructor chiamato per primo -----------------------------|
---- local object "second" -- constructor chiamato per secondo --------------------|      |
---- static object "third" -- constructor chiamato per terzo -------------|        |      |
---- local object "fourth" -- constructor chiamato per ultimo --|         |        |      |
                                                             fourth     third    second  first
----------------------------- destructor chiamato per primo ----|         |        |      |
----------------------------- destructor chiamato per secondo ------------|--------|      |
----------------------------- destructor chiamato per terzo --------------|               |
 ---------------------------- destructor chiamato per ultimo -----------------------------|
NOTE: global is called before any statements in main execute and its destructor is called at program termination after the destructors for all objects with automatic storage duration have run.
NOTE2: lo static object "third" sopravvive a "second" visto che non e' local bensi "static". A "static" object exists until program termination. The destructor for object third is called before the destructor for global object "first" but after all other objects are destroyed.
//////////////////////////////////////////////////////////////////////////////////////////

>> constructors and destructors for static objects
[pag394deitel]
The cosntructor for a static local object is called only "once", when the execution first reaches the point where the object is defined. The corresponding destructor is called when main terminates or the program calles function exit. Global and static objects are destroyed in the reverse order of their creation. Destructors are not called for static objects if the program terminates with a call to function "abort".
>> CONSTRUCTOR AND DECONSTRUCTOR CALLING DEMONSTRATION -> see CreateandDestroy.h chapter 9 [/home/dia/Deitel-Code_Examples/ch09/fig09_07_09/]

>> CONSTRUCTORS [PAG246 MIKE game programming]
when you instantiate objects, you often want to do some initialization (usually assigning values to data members). Luckily, a class has a special member function known as a constructor that is called automatically every time a new object is instantiated. This is a big convenience because you can use a constructor to perform initialization of the new object.
NOTE: the constructor has no return type. And you have to give it the same name as the class ifself.
HINT: [pag248 mike game programming] A default constructor requires no arguments. If you don'T define a default constructor, the compiler defines a minimal one for you that simply calls the default constructors of any data members of the class. If you write your own constructor, then the compiler won't provide a default constructor for you. It's usually a good idea to have a default constructor, so you should make sure to supply your own when necessary. One way to accomplish this is to supply default arguments for all parameters in a constructor definition.
--------------------------------------------------------------- FULL EXAMPLE  [from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/constructor_critter.cpp]
	//Constructor Critter
	//Demonstrates constructors	
	#include <iostream>
	using namespace std;
	class Critter
	{
	public:
	    int m_Hunger;
	    // >> DECLARE CONSTRUCTOR EXAMPLE in the following line / >> CONSTRUCTOR DECLARE / >> CONSTRUCTOR PROTOTYPE
	    Critter(int hunger = 0);       // constructor prototype
// NOTE about the line precedente where we declare a constructor
// the constructor has no return type. It can't; it's illegal to specify a return type for a construtor. Also you have no flexibility when naming a constructor. And you have to give it the same name as the class ifself.
	    void Greet();
	};
	
    // >> DEFINE CONSTRUCTOR EXAMPLE in the following line / >> CONSTRUCTOR DEFINE
	Critter::Critter(int hunger)       // constructor definition
	{
	    cout << "A new critter has been born!" << endl;
	    m_Hunger = hunger;
	}
    // >> END CONSTRUCTOR DEFINITION
	// note: the constructor initializes the oject's m_Hunger data member with the argument value passed to the constructor. IF NO VALUE IS PASSED, then the constructor uses the default argument value of 0.
	
	void Critter::Greet()             
	{
	    cout << "Hi. I'm a critter. My hunger level is " << m_Hunger << ".\n\n";
	}
	
	int main()
	{    
// calling a constructor automatically: you don't explicitly call a constructor; however, whenever you instantiate a new object, its constructor is automatically called. We put the constructor into action with the following code:
	    Critter crit(7); 
// NOTE: when "crit" is instantiated its constructor is automatically called and the message "A new critter has been born!" is displayed
// then the constructor assigns 7 to the object's m_Hunger data member.	
	    crit.Greet(); // to prove that the constructor worked, back in main(), we call the object's Greet() member function and sure enough, it displays "Hi. I'm a critter. My hunger level is 7."

	    return 0;
	}
--------------------------------------------------------------- END FULL EXAMPLE
OUTPUT of the program:
	A new critter has been born!
	Hi. I'm a critter. My hunger level is 7.
---------------------------------------------------------------
>> MEMBER INITIALIZATION / >> MEMBER INITIALIZERS [pag248 mike game programming]
You can use member initializers as a shorthand way to assign value to data members in a construtor. To write a member initialiser, start with a colon after the constructor's parameter list. Then type the name of the data member you want to initialize, followed by the expression you want to assign to the data member, surrounded by parentheses. If you have multiple initializers, separate them with commas. This is much simpler than it sounds (and it's really useful too). Here's an example that assigns hunger to m_Hunger and boredom to m_Boredom. Member initializers are especially useful when you have many data members to initialize.
	Critter::Critter(int hunger = 0, int boredom = 0):
		m_Hunger(hunger),
		m_Boredom(boredom)
	{} // empty constructor body 
///////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINER 
[pag213deitel]
Containers store data during program execution. There are various headers of the C++ standard library che implementano containers.
- <array>         |
  <vector>        |
  <list>          |
  <forward_list>  |
  <deque>         |
  <queue>         |----> these headers contain classes 
  <stack>         |      that implement the C++ standard library 
  <map>           |      containers [anche qui navi portacontainers]. 
  <unordered_map> |      
  <unordered_set> |
  <set>           |
  <bitset>        |  
/////////////////////////////////////////////
>> performance and choosing the appropriate container [pag 649 deitel]
Each container typically provides a variety of other capabilities. Many of these are common to several containers, but they're not always equally efficient for each container.
NOTE1: it's usually preferable to reause Standard Library containers, rather than developing customized templatized data structures. For novice, "vector" is typically satisfactory for most applications.
NOTE2 performance tip: insertion at the back of a "vector" is efficient. The vector simply grows, if necessary, to accommodate the new item. It's expensive to insert (or delete) an element in the middle of a "vector" (the entire portion of the vector after the insertion (or deletion) point must be moved, because vector elements occupy contiguous cells in memory)
NOTE3: applications that require frequent insertion and deletions at both ends of a container normally use a "deque" rather than a vector. Although we can insert and delete elements at the fron and back of both a vector and a deque, class deque is more efficient than vector for doing insertions and deletions at the front.
NOTE4: applications with frequent insertion and deletions in the middle and or at the extremes of a container normally use a "list", due to its efficient implementation of insertion and deletion anywhere in the data structure.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINERS and ITERATORS resume / >> CONTAINERS SUMMARY [pag96 moo book]
The standard library is designed so that similar operations on different containers have the same interface and the same semantics.
I container presentati a pag 96 97 moo book, sono dei sequential containers. 
All the sequential container and the "string" type provide the following operations: 
	container<T>::iterator
	container<T>::const_iterator
			The name of the type of the iterator on this container.
	container<T>..size_type
			The name of the appropriate type to hold the size of the largest possible instance of this container.
	c.begin()
	c.end()      Iterator referring to the last and (one past) the last element in the container
	c.rbegin
	c.rend()     Iterator referring to the last and (one beyond) the first element in the container that grant access to the container's elements in reverse order. 
	container<T> c;
	container<T> c(c2);   Defines c as a container that is empty or a copy of c2 if given
	container<T> c(n);    Defines c as a continer with n elements that are value-initialized according to the type of T. If T is a clas type, that type will control how to initialize the elements. If T is a built-in arithmetic type, then the elements will be initialized to 0.
	container<T> c(n, t); Defines c as a container with n elements that are copies of t.
	container<T> c(b, e); Creates a container that holds a copy of the elements denoted by iterators in the range [b, e). 
	c = c2       Replaces the contents of container c with a copy of the container c2
	c.size()     Returns the number of elements in c as a size_type
	c.empty()    Predicate that indicates whether c has no elements 
	c.insert(d, b, e)     Copies elements denoted by iterators in the range [b, e) and inserts them into c immediately before d.	
	c.erase(it)	
	c.erase(b, e)  Removes the element denoted by "it" or the range of elements denoted by [b, e) from the container c. Returns an iterator referring to the position immediately after the erasure. This operation is fast for list, but can be slow for vector and string, because for these types it involves copying all the elements after the one(s) removed. Invalidates any iterators referring to the element(s) that are erased, and , if the container is "vector" or "string" also invalidates all iterators referring to elements after the erasure.
	c.push_back(t)    Append an element with the value t to the end of c
Containers that support random access, and the string type, also provide the following:
	c[n]    =  the container element ( which is a single character if c is a string) at position n in the container c. The initial element is positioned at 0 [cioe' detto in parole povere, c[n] ti dona l'n-esimo elemento del container c]
ITERATOR OPERATIONS 
	*it     Dereferences the iterator "it" to obtain the value stored in the continer at the position that "it" denotes. This operation is often combined with "." to obtain a member of a class object, as in (*it).x, which yields the member x of the object denoted by the iterator "it".
	it->x   Equivalent to (*it).x, which returns the member x denoted by the object obtained by deferencing the iterator "it". Same precedence as the . operator.
	++it 
	it++    Increments the iterator so that it denotes the next element in the container
	b == e  
	b != e  Compares two iterators for equality or inequality
STRING TYPE
The string type offers iterators that support the same operations as do iterators on vectors. In particular, string supports full random access. In addition to the operations on containers, string also provides:
	s.substr(i, j)   Creates a new string that holds a copy of the characters in "s" with indices in the range [i, i+j)
	getline(is, s)   Reads a line of input from "is" and stores it in "s"
	s += s2     Replaces the value of s by s+s2
VECTOR TYPE
The vector type offers the most powerful iterators, called random-access iterators, of any of the library containers. 
Although all the functions we've written have relied on dynamically allocating our vector elements, there are also mecanis for preallocatin elements, and an operation to direct the vecotr to allocate, but not to use, additional memory in order to avoid the overhead of repeated memory allocations.
	v.reserve(n)	Reserves space to hold n elements, but does not initialize them. This operation does not change the size of the container. It affects only the frequency with "vector" may have to allocate memory in response to repeated calls to insert or push_back. 
   v.resize(n) 		Gives v a new size equal to n. If n is smaller than the current size of v, elements beyond n are removed from the vector. If n is greater than the current size, then new elements are added to v and initialized as appropriate to the type in v. 
LIST TYPE 
The list type is optimzed for efficiently inserting and deleting an elements at any point in the container. Among the list operations we also have 
	l.sort()	
	l.sort(cmp)		Sorts the elements in l using the < operator for the type in the list, or the predicate cmp
>> CCTYPE header [pag98 moo book]
The <cctype> header provides useful functions for manipulating character data:
	isspace(c)	true if c is a whitespace character
	isalpha(c)  true if c is an alphabetic character
	isdigit(c)  true if c is a digit character
	isalnum(c)  true if c is a letter or a digit
	ispunct(c)  true if c is a punctuation character
	isupper(c)  true if c is an uppercase letter
	islower(c)  true if c is a lowercase letter
	toupper(c)  Yields the uppercase equivalent to c
	tolower(c)  Yields the lowercase equivalent to c
-----------------------------------------------------------------------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINER ADAPTER / >> container adapters
[pag673 deitel]
The three container adapters are 
    - stack, 
	- queue and 
	- priority_queue. Container adapters are not first-calls containers, because they do not provide the actual data structure implementation in which elements can be stored and because adapters do not support iterators. The benefit of an adapter class is that you can choose an appropriate underlying data structure. All three adapter classes provides member functions push and pop that properly inset an lement into each adapter data structure and properly remove an element from each adapter structure. The next several subsections provide examples of the adapter classes.
[nota come le parole "container adapter" richiamo il significato della loro funzione: (>> itiaf: mia interpretazione itiaf verificami se corretta) sono degli adattatori di containers, un po' come l'adapter di un hard disk, l'adapter ciuccera' l'energia (~ informazione) dalla presa e la stora nel container (data structure) che gli viene abbinato ]
-------------------------------
>> STACK ADAPTER [commonly referred as >> last in first out data structure]
Class stack (from header <stack>) enables insertions into and deletions from the underlying container at one end called the top, so a stack is commonly referred to as a last-in first-out data structure.
A stack can be implemented with vector, list or deque. This example creates three integer stacks, using vector, list and deque as the underlying data structure to represent the stack. By default, a stack is implemented with a deque. 
The stack operations are :
- push to insert an element at the top of the stack (implemented by calling function push_back of the underlying container), 
- pop to remove the top element of the stack (implemented by calling function pop_back of the underlying container), 
- top to get a reference to the top element of the stack (implemented by calling function back of the underlying container), 
- empty to determine whether that stack is empty (implemented by the calling function empty of the underlying container) and
- size to get the number of elements in the stack (implemented by calling function size of the undrelying container)
Example /home/dia/Deitel-Code_Examples/ch15/fig15_19/Fig15_19.cpp + explanation pag 673 e 675 deitel star tag
-------------------------------
>> queue Adapter 
[pag 675 deitel]
A queue is similar to a waiting line. The item that has been in the queue the lingest is th next one removed [esattamente come accade nella coda di uno sportello de la Poste], so a queue is referred to as a first-in first out (>> FIFO / >> first in first out) data structure. 
Class queue (from header <queue>) enables insertions at the back of the underlying data structure and deletions from the front. 
A queue can store its elements in objects of the Standard Library's list or deque containers. Bu default, a queue is implmented with a deque. The common queue operations are 
- >> push to insert an element at the back of the queue (implemented by calloing function push_back of the underlying container).
- >> pop to remove the element at the front of the queue (implemented by calling function pop_front of the underlying container) [da qui si tocca con mano il significato semantico di pop, simile a po up qualcosa che viene fuori da un container.]
- >> front to get a reference to the first element in the queue (implemented by calling function front of the underlying container) 
- >> back to get a reference to the last element in the queue (implemented by calling function back of the underlying container)
- >> empty to determine whether the queue is empty (implemented by calling function empty of the underlying container)
- >> size to get the number of elements in the queue (implemented by calling function size of the underlying container).
See example /home/dia/Deitel-Code_Examples/ch15/fig15_20/Fig15_20.cpp  + pag675-676 per un commento delle lines notevoli del programma.
>> priority_queue Adapter
[pag676 deitel]
Class priority_queue (from header <queue>) provides functionality that enables insertions in sorted order into the underlying data structure and deletions from the front of the underlying data structure. 
By default a priority_queue's elements are stored in a vector. When elements are added to a priority_queue, they're inserted in prioprity order, such that the highest priority element (ie.e the largest value) will be the first element removed from the priority_queue. This is usually accomplished by arranging the elements in a data structure called a heap (not to be confused with the heap for dynamically allocated memory) that always maintains the largest value (i.e. highest-priority element) at the front of data structure. 
The comparison of elements is performed with comparator function object less<T> by default, but you can supply a different comparator.
There are several common priority_queue operations. 
- >> push function inserts an element at the appropriate location based on priority order of the priority_queue (implmented by calling function push_back of the underlying container, which then reorders the elements in priority order)
- >> pop functionremoves the highest-priority element of the priority_queue (implemented by calling function pop_back of the underlying container after removing the top element of the heap).
- >> top gets a reference to the top element of the priority_queue (implemented by calling function front for the underlying container)
empty determines whether the priority_queue is empty (implemented by calling function empty of the underlying container).
- >> size tets the number of elements in the priority_queue (implemented by calling function size of the underlying container).
See example /home/dia/Deitel-Code_Examples/ch15/fig15_21/Fig15_21.cpp
[visto che non e' molto lungo te lo ricopio qui sotto]
	// Fig. 15.21: fig15_21.cpp
	// Standard Library adapter priority_queue test program.
	#include <iostream>
	#include <queue> // priority_queue adapter definition
	using namespace std;
	int main()
	{
	   priority_queue< double > priorities; // create priority_queue
	   // push elements onto priorities
	   priorities.push( 3.2 );
	   priorities.push( 9.8 );
	   priorities.push( 5.4 );
	   cout << "Popping from priorities: ";
	   // pop element from priority_queue
	   while ( !priorities.empty() ) 
	   {
	      cout << priorities.top() << ' '; // view top element
	      priorities.pop(); // remove top element
	   } // end while
	   cout << endl;
	} // end main
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> CONTINUE STATEMENT 
pag179deitel
example 


>> CONTROL STRUCTURES
Bohm and Jacopini's work demonstreted that all programs could be written in terms of only 3 control structures, namely: 
	1) the sequence structure 
	2) the selection structure 
	   2A-> if (single selection statement)
       2B-> if else (double-selection statement)
       2C-> switch (multi-selection statement) [pag109deitel] 
	3) the repetition structure 
	   3A-> while (performs the action 0 or more times a seconda che condizione sia soddisfatta)
	   3B-> do while (performs the action at least once)
       3C->	for
The term "control structure"  comes from the field of computer science. When we introduce C++'s implementations of control structures, we'll refer to them in the terminology of the C++ standard documents as "control statements" 
[pag107deitel + trovi nice discussio of goto statement, spaghetti code, goto-less programming]
Control statements can be connected only in two ways: [pag110deitel]
A- control statement stacking 
B- control statement nesting
Control statement stacking consiste nel connettere l'exit point di un control statement con l'entry point of the next control statement. This is similar to the way a child stacks building blocks, that's why is called control-statement stacking
I MAGNIFICI SETTE
	Any C++ program can be constructed from only seven different types of control statements ("sequence", "if", "if...else", "switch", "while", "do...while", "for") combined in only two ways (control-statement stacking and control-statement nesting)

>> COUNTER CONTROLLED REPETION / DEFINITE REPETITION 
[pag118deitel]
The counter-controlled repetition uses a variable called a counter to control the number of times group of statements will execute. 
Counter-controlled repetition is often called definite repetition becuase the number of repetition is known before the loop begins executing. 
EXAMPLE see pag159deitel  (example while cycle / while loop)
	unsigned int counter = 1;
	while ( counter <= 10 )
	{
		cout << counter << " ";
		++counter;
	}
	cout << endl;
o in maniera piu' condensata 
	counter = 0;
	while (++counter <= 10)
		cout << counter << " ";
//------------------------------------
ATTENTION : in counting loops only use integer variables as control variable, not floating point number
In maniera ancora piu' concisa possiamo scrivere the counter controlled repetition in ONE line using the for repetition statement:
	for ( unsigned int counter = 1; counter <= 10; ++counter )
[pag159deitel]
@pag161deitel trovi bel confronto for vs while loop structure

>> cout << "Hello World!";
IN SHORT from mike pag34 : cout is an object, defined in the file iostream, that's used to send data to the standard output stream (generally the computer screen)  
IN LONG
COUT represents the standard output stream in C++, and the meaning of the entire statement is to insert a sequence of charactes  (in this case the Hello World sequence of characters) into the standard output stream (which usually is the scream). To use cout we must declare at the beginning of the program: 
#include <iostream>
using namespace std;
[see also STANDARD OUTPUT]
---------------------------
>> << / >> standard output / >> output mike pag8
	std::cout << "TRON is IGNITE!" << std::endl;
"TRON is IGNITE" is a string, technically a string literal, meaning it's literally the characters between the quotes. 
>> cout is an object, defined in the file iostream, that is used to send data to the standard output stream. In most programs (including this one), the standard output stream simply means the console window on the computer screen. 
We use the output operator << to send the string to cout. You can think of the output operator like a funnel (= imbuto): it takes whatever is on the open side and funnels it to the pointy side. So the string is funneled to the standard output, the screen.
example :
// visto e' proprio come un funnel (= imbuto or channel del bob di running man) cout << parte la stringa 7 + 3 = quindi il risultato dell'operatione 7 + 3 viene << fiuuuuuuu inviato e compare su schermo, quindi endl << fiuuuu anche lui inviato su schermo e ti manda a capo per le righe successive.
We use std to prefix cout to tell the compiler that we mean cout from the standard library. std is a >> namespace [mike pag9]. You can think of a namespace like an area code of a phone number (cioe' puoi pensare uno namespace come fosse il prefisso di un numero telefonico), it identifies the group to which something belongs [l'elenco telefonico in C++ style userebbe 0171::260911].
[
	>> namespace [pag3 moo book definition] = a namespace is a collection of related names. Quindi quando vedi scritto 
	std::cout means cout is part of the namespace std = collezione di tutti i nomi definiti nella standard library
]
The std::endl. >> endl [mike pag9] is defined in iostream and is also an object in the std namespace. Sending endl to the standard output acts like pressing the Enter key in the console window. In fact, if we were to send another string to the console window, it would appear on the next line. 
    ___________ STANDARD C++ __________
    |                                  |
	|         Standard Library         |
    |                                  |
    |   |--------------------------|   |
    |   |                          |   |
    |   |         iostream         |   |
    |   |                          |   |
    |   |   |-----------------|    |   |
    |   |   |       cout      |    |   |
    |   |   |-----------------|    |   |
    |   |                          |   |
    |   |--------------------------|   |
    |                                  |
    |----------------------------------|

>> statement [mike pag9] : is the basic unit controlling the execution flow. All of your statements must end with a semicolon ;
example 
	return 0;
this is a statement that return 0 to the operating system.
Returning 0 from main() is a way to indicate that the program ended without problem. The operating system doesn't have to do anything with the return value.
-----------------------------------
>> namespace / >> using directive
// TRON 2.0
// Demonstrates a >> using directive

#include <iostream>
using namespace std;   // con questo statement non hai piu' bisogno di mettere std:: davanti a cout
// >> using directive gives me direct access to elements of the std namespace. se facciamo la metafore che il namespace sia come un prefisso telefonico, then this line says that all of the elements in the std namespace should be like local phone numbers to us now. That is, we don't have to use their area code (the std:: prefix) to access them. 
int main()
{
	cout << "TRON IGNITION!" << endl;
	return 0;
}
///////////////////////////////////
-----------------------------------
Un altra maniera e':
-----------------------------------
// TRON 3.0
// Demonstrates >> using declarations

#include <iostream>

using std::cout;	 
using std::endl;  // the advantage of this technique is that it clearly spells out those elements we plan to use. Plus, it doesn't make local a bunch of other elements that I have no intention of using. 
int main()
{
	cout << "TRON IGNITION!" << endl;
	return 0;
}
/////////////////////////////////
---------------------------------
But which is the best technique? A language purist would say you should always prefix each and every element from a namesapce with its identifier. But that's like calling your best fiend by his first and last name all the time. It just seems a little too formal. 
If you have typing you can employ the using directive come in TRON 2.0 sopra. A decent compromise is to employ using declarations. 
//////////////////////////////////////////////////////////////////////////////////////////////////////

>> function [mike pag8] a function is group of programming code that can do some work and return a value. All function headers have a pair of parenthesis after the function name 
example 
	int main()
All C++ programs must have a function called main() which is the starting point of the program. 
All function are delimited by a pair of {} (= curly braces), and everything between them is part of the function. 
Code between curly braces is called a >> block and is usually indented to show that it forms a unit. The block of code that makes up an entire function is called the >> body of the function. 

>> CUSTOM TEMPLATE / >> CUSTOM CLASS TEMPLATE
[pag766 deitel]
Function templates and class templates enable you to conveniently specify a variety of related (overloaded) functions (called >> function template specializations) or a variety of related classes (called >> class template specializations)
cioe'
	
	Function template  -> define related overloaded function -> function template specializations
    class template     -> define related classes -> class template specializations

This is called >> generic programming.
Function templates and class templates are like stencils out of which we trace shapes; function template specializations and clas template specializations are like the separate tracings that all have the same shape, but could, for example, be dranw in different colors and textures.
>> CLASS TEMPLATES 
It's possible to understand the concept of a stack (a data structure into which we insert items only at the top and retrieve those items only from the top in last-in, first-out order independent of the type of hte items bein placed in the stack). However, to instantiate a stack, a data type must be specified. This creates a nice opportunity for software reusability.
Class templates are called >> parameterized types, because they require on or more type parameters to specify now to customize a generic class template to form a class template specialization.
When a particular secialization is needed, you use a concise, simple notation, and the compiler writes the specialization source code. One Stack class template, for example, could thus become the basis for creating many Stack class template specializations used in a program.
NOTE: To create a template specialization with a userfefined type, the user defined type must meet the template's requirements. If the user defined type does not overload the required operator or provide the required functions, compilation errors occur.
>> template< typename T >  [pag 767 deitel]
[from /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/]
All class templates begin with keyword template followed by a list of template parameters enclosed in >> angle brackets (< and >); each template parameter that represents a type must be preceded by either of the interchanegable keywords typename or class. The type parameter T acts as a placeholder for the Stack's element type. The names of type parameters must be unique inside a template definition. You need not specifically use identifier T (any valid identifier can be used).
NOTE Software Engineering information: templates are typically defined in headers, which are then #included in the appropriate client source-code files. For class templates, this means that the member functions are also defined in the header- tipically inside the class definition's body. 
Extract from /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/
	// Fig. 18.1: Stack.h
	// Stack class template.
	#ifndef STACK_H
	#define STACK_H
	#include <deque>
	
	template< typename T >
	class Stack 
	{
	public:
	   // return the top element of the Stack
	   T& top()
	   {
	      return stack.front();
	   } // end function template top
	
	   // push an element onto the Stack
	   void push( const T &pushValue ) 
	   {
	      stack.push_front( pushValue );
	   } // end function template push
	
	   // pop an element from the stack
	   void pop()
	   {
	      stack.pop_front();
	   } // end function template pop
	
	   // determine whether Stack is empty
	   bool isEmpty() const 
	   { 
	      return stack.empty(); 
	   } // end function template isEmpty
	
	   // return size of Stack
	   size_t size() const
	   {
	      return stack.size();
	   } // end function template size
	
	private:
	   std::deque< T > stack; // internal representation of the Stack
	}; // end class template Stack	
	#endif
--------------------------------------------------------------------------------
NOTE1: vector vs deque / >> deque vs vector [pag768 deitel]
In line 42 we use a deque as the underlying container for our Stack class. 
A deque is the default representation for the Standard Library's stack adapter because a deque grows more efficiently than a vector. 
1) a vector is maintained  as a contiguous block of memory: when that block is full and a new element is added, the vector allocates  alarger contiguous block of memory and copies the old elements into that new block. 
2) A deque, on the other hand is typically implemented as list of fixed-size, built-in arrays. : new fixed size built-in arrays are added as necessary and none of the existing elements are copied when new items are added to the front or back. 
NOTE2: The member function definitions of a class template are function templates, but are not preceded with the template keyword and template parameters in angle brackets when they're defined within the class template's body.
Our Stack class template does not define it's own constructos : the default constructor provided by the compiler will invoke the deque's default constructor.
Nota come le member function dell'esempio sopra (top, push, pop, isEmpty, size) delegates its responsibility to the appropriate member function of class template deque.
NOTE3: declaring a class template's member functions outside the class template definition
Member function definitions can also appear outside a class template definition. If you do this, each must begin with the template keyword followed by the same set of template parameters as the class template. If you do this, each must begin with the template keyword followed by the same set of template parameters as the class template. In addition, the member functions must be qualified with the class name and scope resolution operator. For example, you can define the pop function outside the class template definiftion as follows:
	template< typename T >
	inline void Stack<T>::pop()
	{
		stack.pop_front();
	} // end function template pop
-------------------------------------
Stack<T>:: indicates that pop is in the scope of class Stack<T>. The Standard Library's container classes tend to define all their member functions inside their class definitions.
NOTE4: >> pronunciation Stack<double> is pronounced Stack of double come ad esempio in 
/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/fig18_02.cpp
--------------------------------------
	int main()
	{
	   Stack< double > doubleStack; // create a Stack of double 
Similmente line 
 34    Stack< int > intStack; // create a Stack of int
"Stack< int > intStack" si pronuncia "intStack is a Stack of int"
-------------------------------------- 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> generic functions  and >> template functions [chapter 8 pag 139 moo book]
A generic function is a function with arugment and return types that we do not know until we use the functions. For example "find" function, takes two iterators and a value as arguments. We can use the same find function to find values of any appropriate type in any kind of container. This usage implies that we do not know what find's argument or result types will be until we use it. Such function is called a generic function.
The language feature that implements generic functions is called >> TEMPLATE FUNCTIONS [pag140 moo book]
Templates let us write a single definition for a family of functions that behave similarly, except for differences that we can attribute to the types of their template parameters. 
	They key idea behind templates is that objects of different types may nevertheless share common behaviour. Template parameters let us write programs in terms of that common behviour, even though we do not know the specific types that correspond to the template parameters when we define the template.  
>> TEMPLATE HEADER [pag141 moo book]
--------------------------------------------------------- 
extract from [/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter08/median.h]
	template <class T>
	T median(vector<T> v)
	{
	        typedef typename std::vector<T>::size_type vec_sz;
		vec_sz size = v.size();
		if (size == 0)
			throw domain_error("median of an empty vector");
	
		sort(v.begin(), v.end());
	
		vec_sz mid = size/2;
	
		return size % 2 == 0 ? (v[mid] + v[mid-1]) / 2 : v[mid];
	}
------------------------------------------------------------
The first novelty here are the template header 
	template <class T>
and the use of T in the parameter list. THe template header tells the implementation that we are defining a template function, and that the function will take a "type parameter". Type parameters operate much like function parameters: they define names that can be used within the scope of the function. HOWEVER, type parameters refere to types, not to variables. Thus wherever T appears in the function, the implementation will assume that T names a type. In the median function, we use the type parameter explicitly to say what type of objects the vector named "v" holds, and to specify the return type of the function.
When we call this median function, the implementation will bind T to a type that it determines at that point, during compilation. For example,we might take the median of a vector<int> obejct named vi by calling median(vi). From this call, the implmentation can infer that T is int. Wherever we use T in this function, the implementation generates code as if we had written int. In effect the implementation instantiates our code as if we had written a specific version of median that took a vector<int> and returned an int. 
	The next novelty is the use of typename in the definition of vec_sz. It is there to tell the implementation that "vector<T>::size_type" is the name of a type, even though the implementation doesn't yet know what type T represents. Whenever you have a tpye, such as vector<T>, that depends on a template parameter, and you want to use a member of that type, such as size_type, that is itseflt a type, you must precede the entire name by typename to let the implementation know to treat the name as a type. Although the standard library ensures that vector<T>::size_type is the name of a type for any T, the implementation, having no special knowledge of the standard library types, has no way of knowing this fact.  
>> TEMPLATE INSTATIATION observations [from pag142 moo book]:
When we call "median" [see example above] on behalf of a vector<int>, the implementation will effectively create and compile an instance of the function that replaces every use of T by "int". If also call "median" for a vector<double>, then the implementation will again infer the types from the call. In this case, T will be bound to "double", and the implementation will generate another version of "median" using "double" in place of T.
	The C++ standard says nothing about how implementations should manage template instantiation, so every implementation handles instaintiation in its own particulat way. Keep in mind that the definition of the template, not just the declaration, has to be accessible to the implementation. Generally, this requirement implies access to the source files that define the template, as well as the header file. Many implementation expect the header file for the template to include the source file, either directly or via #include.
>> ITERATOR CATEGORIES [pag145 moo book]
The C++ library defines FIVE iterator categories, each one of which corresponds to a specific collection of iterator operations. The iterator categories give us a way to understand which containers can use which algorithms [cioe' detto in parole spicciole se prendi un algoritmo tipo per esempio "sort" potrai richidergli di ordinarti "vectors" and "strings" e lo fara' usando operations su una specifica CATEGORIA di iteratori che permetterranno l'accesso e il riordino degli elementi all'interno di un vector/string]
At pag 145 they describe each access strategy, show an algorithm that uses it, and describe the corresponding iterator category.
1) SEQUENTIAL READ-ONLY ACCESS [pag145 moo book]
that is to access a sequence by reading its elements sequentially. Among the library functions that does so is "find"
	>> input operator definition pag 146 moo book
2) SEQUENTIAL WRITE-ONLY ACCESS [pag146 moo book]
	like the >> copy function [pag146 moo book]
	pag147 moo book : >> output iterator definition and requirements.
3) SEQUENTIAL READ-WRITE ACCESS [pag147 moo book]
	Suppose we want to be able to read and write the elements of a sequence, but only seqeuntially: we intend to advance iterators forward but never backward. An example of a library function that does so is replace, from the <algorithm> header.
	>> FORWARD ITERATOR requirements [pag148 moo book]
4) REVERSIBLE ACCESS [pag148 moo book]
	Some functions need to get at a container's elements in reverse order. The most straightforward example of such a function is "reverse", which the standard library defines in the <algorithm> header.
	>> BIDIRECTIONAL ITERATOR requirements [pag148 moo book]
5) RANDOM ACCESS [pag148 moo book]  
Some functionsneed to be able to jump around in a container. One good example of such a function is the classical binary search algorithm. One of the standard library implementation of this algorithm is "binary_search".
NOTE: the "vector" and "string" iterators are random-access iterators. However the "list" iterator is not; it supports only bidirectional iterators. Why?
The essential reason is that lists are optimized for fast insertion and deletion. Hence, there is no quick way to navigate to an arbitrary element of the list. The only way to navigate through a list is to look at each element in sequence.
NOTE2: in the above algorithms, usually they use the convention to take two arguments to specify ranges. The first argument refers to the first element of the range; the second argument refers to one past the last element of the range. Why do we specify one past the end of the range? 
Mainly for 3 reasons -> see them at pag 149-150 book     
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> template class definition [pag188 moo book]
When we define a template class, we have to signal that the class is a template, and list the type parameters that will be used in the class definition:
	template <class T> class Vec {
	public:
		// interface 
	private:
		// implementation 
	};
This code says that Vec is a template class, with one type parameter named T. As with other class types, we can assume that there will be public and private parts that define the interface and implementation respectively.
For example you can implement a vector by storing the initial element address, and one past the address of the last element (queste due informazioni ti saranno poi sufficienti per ricavarti il size del vettore): then our vector class would become 
	template <class T> class Vec {
	public:
		// interface 
	private:
		T* data; // first element in the Vec
		T* limit; // one past the lsat element in the Vec 
	};
[qui sotto segue una bella esemplificazione della >> <> notation (tipo Vec<int> v;) che si ritrova spesso]
This class definition says that Vec is a template type, and that it takes a single type parameter. In the body of the class definition, we'll call that type T. Whenever we use T, the compiler will replace it with whatever type the user names when creating a Vec. So for example if we write 
	Vec<int> v;
this definition will cause the compiler to instantiate a version of the Vec class in which it replaces each reference to T by "int".
Because we used the type parameter T in the declaration of data and limit, the type of these pointers depends on the type of the objects that the Vec will hold. 
This type is not known until the definition of a Vec is instantiated. Once we say that we want a Vec<int>, the types of data and limit are known: They will be int* for this instance of Vec. 


>> custom templatized data structures / >> data structures custom templatized [pag778 deitel]
in this chapter are discuss several popular and important data structures and implement programs that create and manipulate them:
    >> linked lists: are collections of data items logically lined up in a row"  (insertions and removals are made anywhere in a linked list)
        >> node [pag780 deitel] : a linked list is a linear collection of self referential class objects called nodes connected by pointer links.
    >> stacks are important in compilers and operating systems : insertions and removals are made only at one end of a stack (its top) [see also pag795 deitel]
    >> queues present waiting lines; insertions are made at the back (also referred to as the tail) of a queue and removals are made from the front (also referred to as the head) of a queue
    >> binary trees facilitate searching and sorting data, duplicate elimination and compiling expressions into machine code. [see pag803deitel]
NOTE: from pag 780 deitel: stacks and queues are linear data structures and they can be viewed as constrained versions of linked lists. Trees are nonlinear data structures.
NOTE2: basic terminology dei trees structures [from pag803 deitel]
	>> root node	deitel p803
	>> child node 	deitel p803
	>> siblings 	deitel p803
	>> leaf node 	deitel p803
	>> left child	deitel p803  non nel senso di bambino lasciato solo, ma di "bambino sul lato sinistro
	>> right subtree deitel p803
	>> left subtree	deitel p803
Linked lists provide several advantages over array objects and built-in arrays. A linked list is appropriate when the number of data elements is unpredictable. Linked lists are dynamic, so the length of a list can increase or decrease as necessary.
- Array non puoi cambiare il size <-> mentre con le list possono cambiare in size [ti aiutano ad evitare sprechi di memoria]
- insertion and deletion in a sorted arrays can be time consuming <-> mentre a linked list allows efficient insertion operations anywhere in the list
- the elements of an array object or built-in array are stored contiguously in memory. This allows immediate access to any element, because an element's address can be calculated directly based on its position relative to the beginning of the array. <-> Linked lists do not afford such immediate direct access to their access, so accessing individual elements can be considerably more expensive.
Linked-list nodes typically are not stored contiguously in memory, but logically they appear to be contiguous.
---------------
>> forward declaration [pag785 deitel] tells the compiler that a type exists, even if it has not yet been defined.
>> predicate function [pag786 deitel] 
>> insert node at front of a list [nice explanation at pag 789deitel con tuo esempio carino del treno, vagoni e locomotiva]
>> insert node to the end of a list [pag790 deitel] carina la tua analogia di lastPtr come "fanalino rosso di coda" che sposti dall'ex ultimo vagone al nuovo vagone che attracchi in coda.
>> remove node from the front of a list [pag791 deitel]
>> singly linked list [pag792 deitel]
a singly linked list begins with a pointer to the first node, and each node contains a pointer to the next node in sequence. This list terminates with a node whose pointer member has the value nullptr. A singly linked list may be traversed in only one direction. 
>> circular singly linked list / >> circular list [pag793 deitel] = begins with a pointer to the first node, and each node contains a pointer to the next node. The last node does not contain nullptr; rather the pointer in the last node points back to the first node, thus closing the circle.
>> doubly linked list [pag793 deitel] = allows traversals both forward and backward. Such a list is often implemented with two start pointers :
- one that points to the first element of the list to allow front-to-bakc traversal of the list and 
- one that points to the last element of the list to allow back-to-front traversal. 
Each node has both a >> forward pointer to the next node in the list in the forward direction and a backward pointer to the next node in the list in the backward direction. 
>> circular doubly linked list [pag794 deitel] = the forward pointer of the last node points to the first node, and the backward pointer of the first node points to the last node, thus closing the "circle".
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> DDDDDDD

>> DANGLING POINTER [pag237 mike programming game] : a dangling pointer is a pointer to an invalid memory address. Dangling pointers are often caused by deleting an object to which a pointer pointed. Dereferencing such a pointer can lead to disastrous results.

>> DANGLING-ELSE problem
[pag115 deitel]
C++ compiler always associate an else with the immediately preceding if unless to do otherwise by the placement of braces {}
Example se volessi eseguire
if (x > 5)
	if ( y > 5)
		cout << "x and y are > 5";
else  // dove desideriamo che questo else sia associato alla (condizione x > 5) 
	cout << "x is <=5";
in realta il compiler interpretes the statement as:
if (x > 5)
	if ( y > 5)
		cout << "x and y are > 5";
	else
		cout << "x is <=5";
quindi supponi che x > 5, allora si checka se y sia > 5 e se non lo e' viene printato x <=5 perche' l'else e' stato come di regola associato all'if immediatamente precedente. 
therefore the CORRECT WAY is :
if (x > 5)
{
	if ( y > 5)
		cout << "x and y are > 5";
}
else
	cout << "x is <=5";
//////////////////////////////////


>> DANGLING POINTER
[pag463deitel]
if the copy constructor simply copied the pointer in the source object to the target object's pointer, the nboth would point to the same dynamically allocated memory. The first destructor to execute would delete the dynamically allocated memory, and the other object's ptr would point to memeory that's no longer allocated, a situation called dangling pointer -> this would likely result in a serious runtime error (such as early program termination)
 

>> DANGLING REFERENCES [pag240deitel]
Functions can return references, but this can be dangerous. When returning a reference to a variable declared in the called function, unless the variable is declared as "static", the reference refers to an automatic variable that's discarded when the function terminates. An attempt to access such a variable yields undefined behaviour. References to undefined variables are called dangling references.	

>> DATA MEMBER 
When each object of a class maintains it own copy of an attribute, the variable that represents the attribute is known as a data member [each object (instance) of the class has a separate copy of the variable in memory.]
There are variable for which each object of a class does not have a separate copy. That is the case with static data members, which are also known as class variables. 
When objects of a class containing static data members are created, all the objects share ony copy of the class's static data members.  static data member can be accessed within the class definition and the member-function definitions like any other data member.  A public static data member can be also accessed outside of the class, even when no objects of the class exist, using the class name followed by the scope resolution operator (::) and the name of the data member. 
[from pag300 recall also section 3.4 pag74deitel]

>> DATA STRUCTURES 
[pag279deitel] 
Data structures = collections of related data items

>> DEBUGGING
the program /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp [itiaf]
[2004 fig10_01] >> g++ -o string-test-prog fig10_01.cpp 
fig10_01.cpp: In function ?eint main()?f:
fig10_01.cpp:75:12: error: expected type-specifier before ?eout_of_range?f
fig10_01.cpp:75:25: error: expected ?e)?f before ?e&?f token
fig10_01.cpp:75:25: error: expected ?e{?f before ?e&?f token
fig10_01.cpp:75:26: error: ?eex?f was not declared in this scope
fig10_01.cpp:75:29: error: expected ?e;?f before ?e)?f token
////////////////////////////////////////////////

>> DEFAULT VALUE [pag116 jesse]
A default value is a value to use if none if supplied example 
	long myFunction (int x = 50);
This prototype says "myFunction() returns a long and takes an integer as parameter. If an argument is not supplied, use the default value of 50.
Restriction : if any of the parameters does not have a default value, no previous parameter can have a default value 
If the function prototype looks like 
	long myFunction (int Param1, int Param2, int Param3);
you can assign a default value to Param2 only if you have assigned a default value to Param3. You can assign a default value to Param1, only if you've assigned default values to both Param2 and Param3. 
NOTE1: don't try to create a default value for a first parameter if no default value exists for the second 
NOTE2: don't forget that arguments passed by value cannot affect the variables in the calling function.
Here's a full example demonstrating default values:
------------------------------------------------------------------------------------------------
// Listing 5.7 - demonstrates use
// of default parameter values
#include <iostream>
  
int AreaCube(int length, int width = 25, int height = 1);  // prototype of the function AreaCube
  
int main()
{
   // inizializzi i parametri di input
   int length = 100;
   int width = 50;
   int height = 2;
   int area;
  
   area = AreaCube(length, width, height); // calling the function AreaCube
	// gli stai passando tutti e 3 i valori quindi usa 100 * 50 * 2 e ti dona in output 10000
   std::cout << "First area equals: " << area << "\n";
  
   area = AreaCube(length, width); // in questo caso gli stai solo donando i primi due parametri, quindi come terzo parametro utilizzera' l'altezza di default
	// quindi il risultato di output sara' 100 * 50 * 1 = 5000
   std::cout << "Second time area equals: " << area << "\n";
  
   area = AreaCube(length); // in questo caso gli doni come parametro di input giusto la lunghezza
	// quindi il risultato di output sara' 100 * 25 * 1 = 2500
   std::cout << "Third time area equals: " << area << "\n";
   return 0;
}
  
AreaCube(int length, int width, int height)   // definition of the function AreaCube
{
  
   return (length * width * height);
}

////////////////////////////////////////////////////////////////////////////////////////////////


>> DECLARATION OF A CLASS / >> CLASS DECLARATION / >> DECLARATION CLASS
[pag141 jesse]
Declaring a class tells the compiler about the class. To declare a class use the "class" keyword followed by the class name, an opening brace, and then a list of the data members and methods of that class. End the declaration with a closing bracket and the semicolon 
example 
	class LevitatingMachine
	{
		unsigned int QuantumStateNumber;
		unsigned int RiderWeight;
		void Levitate();
	};
Declaring thsi class does not allocate memory for "LevitatingMachine". It just tells the compiler what a "LevitatingMachine" is, what data members it contains (QuantumStateNumber and RiderWeight), and what it can do [Levitate()]. Although memory is not allocated, it does let the compiler know how big a "LevitatingMachine"  is, that is how much room the compiler must set aside for each "LevitatingMachine" that you will create. 
>> CLASS NAMING CONVENTIONS [pag141 jesse]
Many programmers name the member variables with the prefix my (tipo myWeight, mySpeed). This helps to distinguish member variables from nonmember variables. 
Many programmers also use the convention to name all classes with initial capitalization tipo LevitatingMachine (insomma usa la prima lettera maiuscola se e' il nome di una classe.)
>> OBJECT DEFINE / >> DEFINE OBJECT 
After you declare a class, you can then use it as a new type to declare variables of that type. You declare an object of your new type the same as you declare an integer variable.
	unsigned int GrossWeight;  // define an unsigned integer
	LevitatingMachine McFly; // define a LevitatingMachine
This code defines a variable called GrossWeight, whose type is an unsigned integer. It also defines "McFly", which is an object whose class (or type) is LevitatingMachine.
NOTE: >> classes versus objects / >> objects vs classes [pag142 jesse]
You never recharge the definition of a LevitatingMachine, you recharge a specific, concrete levitating machines. You draw a distinction between the idea of a levitating machine, and the particular levitating machine that right now is staying in your backyard. In the same way C++ differentiates between the class LevitatingMachine which is the idea of a levitating machine, and each individual LevitatingMachine object. Thus "McFly" is an object of type "LevitatingMachine" in the same way that GrossWeight is a variable of type unsigned int;
An >> object is an individual instance of a class
---------------------------------------------------
>> Access class members / >> class members access [pag142 jesse]
After you defined an actual object "LevitatingMachine" for example 
	LevitatingMachine McFly; 
you use the dot operator (.) to access the members of that object. Therefore to assign 50 to McFly's RiderWeight member variable you would write:
	McFly.RiderWeight = 50;	
In the same way, to call the "Levitate()" function you would write
	McFly.Levitate();
When you use a class method, you call the method. In this example, you are calling "Levitate()" on "McFly".
NOTE from pag 143 jesse
In C++ you don'T assign values to types; you assign values to variables. For example 
	int = 5;  // wrong !!!!!
you can't assign 5 to an integer. Rather, you must define an integer variable and assign 5 to that variable. For example, 
	int x; // define x to be an int  
	x = 5; // set x's value to 5
This a shorthand way of saying "assign 4 to the variable x, which is of type int". In the same way, you wouldn't write 
	LevitatingMachine.RiderWeight = 5; // wrong!!
Instead you should write:
	LevitatingMachine McFly; // just like int x;
	McFly.RiderWeight = 5;	 // just like x = 5;
NOTE from pag 144 jesse: don't confuse a declaration with a definition. A declaration says what a class is. A definition sets aside memory for an object. 
/////////////////////////////////////////////////////////////////////////////////////////////////

>> DECLARATION of VARIABLE
- bisogna specificare un type e un identifier, for example:
	int a; 
dove int e' il type e a e' l'identifier.
To declare more variable of the same type: 
	int a, b, c;
si possono dichiare in a single statement, by separating their identifiers with commas
- mentre dichiari una variabile puoi anche inizializzare il suo valore, example: 
		inter number1 = 0;
although it's not always necessary to initialize every variable explicitly, doing so will help you avoid many kinds of problems. 
- All variables must be declared with a name and a data type before they can be used in a program. (=> Dichirazione variabile E' obbligatoria, mentre la sua inizializzazione e' opzionale)
- Good programming practice: declare only one variable in each decalration and provide a comment that explains the variable's purpose in the program. 
- Placement of variable declaration : can be placed almost anywhere in the program, but they must appear before their correspoding variables are used in the program. 
- [pag121deitel] in general variables should be declared just before they're used. Declare each variable on a separate line with its own comment for readability. 
- always initialize variables when they are declared. 

>> DEFAULT ARGUMENTS
[pag240deitel]
It's common for a program to invoke a function repeatedly with the same argument value for a particular parameter. In such cases, you can specify that such a parameter has a default argument, i.e. a default value to be passed to that parameter.
Example 
	// function prototype that specifies default arguments
	unsigned int boxVolume( unsigned int length = 1, unsigned int width = 1,
	   unsigned int height = 1 );
	....
	// function boxVolume calculates the volume of a box
	unsigned int boxVolume( unsigned int length, unsigned int width,
	   unsigned int height )
	{
	   return length * width * height;
	} // end function boxVolume
Quindi se poi usi un programma dove la funzione viene chiamata omettendo gli argument per i parameters, allora si useranno quelli di default
Example 
	cout << " The default box volume is: " << boxVolume();
ti printera' visto il modo in cui sono stati specificati i default arguments:
	The default box volume is: 1
OSSERVAZIONI : the default arguments must be the rightmost (trailing) arguments in a function's parameter list.	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DEFAULT ARGUMENTS [pag162 mike programming game]
When you write a function in which a parameter almost always gets passed the same value, you can save the caller the effort of constantly specifying this value by using a "default argument"	
EXAMPLE 
	int askNumber(int high, int low = 1);
the second parameter low it's assigned the value 1. The 1 is default argument, meaning that if a value isn't passed to low when the function is called, low is assigned 1. 
NOTE: once you specify a default argument in a list of parameters, you must specify default arguments for all remaining parameters. So the following prototypes is valid 
	void setDisplay (int height, int width, int depth = 32, bool fullScreen = true);  // OK!
while the following one is illegal:
	void setDisplay (int height, int width, int depth = 32, bool fullScreen);@@// DAME!
NOTE: you don't repeat the default argument in the function definition, as you can see in the function defition of askNumber () below
FULL EXAMPLE 
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int askNumber(int high, int low = 1);  // i default parameters li definisci in fase di prototipazione della funzione 
		
		int main()
		{
		    int number = askNumber(5);
		    cout << "Thanks for entering: " << number << "\n\n";
		    
		    number = askNumber(10, 5);
		    cout << "Thanks for entering: " << number << "\n\n";
		
		    return 0;
		}
		
		int askNumber(int high, int low)      // mentre in fase di definition della funzione non bisogna piu' specificare i valori dei default arguments
		{
		    int num;
		    do
		    {
		        cout << "Please enter a number" << " (" << low << " - " << high << "): ";
		        cin >> num;
		    } while (num > high || num < low);
		
		    return num;
		}

---------------------------------------------------------------------------------------------
OUTPUT:
	[2037 chapter05] >> ./give_me_a_number 
	Please enter a number (1 - 5): 0     // finche non immetti un numero compreso tra 1 e 5  ti ripete la domanda
	Please enter a number (1 - 5): 3
	Thanks for entering: 3
	
	Please enter a number (5 - 10): 13   // ora avendo usato number = askNumber(10, 5); ti chiede un numero compreso tra 5 e 10
	Please enter a number (5 - 10): 7
	Thanks for entering: 7
NOTE: when you are calling a function with default arguments, once you omit an argument, you must omit arguments for all remaining parameters. For example, given the prototype:
	void setDisplay (int height, int width, int depth = 32, bool fullScreen = true);  
a valid call to the function would be
	setDisplay(1680, 1050);
while an illegal call would be
	setDisplay(1680, 1050, false);
perche' una volta che hai saltato "depth" non e' piu' lecito specificare "fullScreen"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	


>> DELEGATING CONSTRUCTOR 
[pag392deitel]
Just as a constructor can call a class's other member functions to perform tasks, C++11 allows constructors to call other constructors in the same calss. The calling constructor is known as delegating constructor = it delegates its work to another constructor. This is useful when overloaded constructors have common code that previously would have been defined in a "private" utility function and called by all the constructors.
see example pag 393 deitel


>> #DEFINE
you can define your own names for constants that you use very often without having to resort to memory consuming variables. ex
	#include <iostream>
	using namespace std;
	#define PI 3.14159
	#define NEWLINE '\n'
	int main()
	{
		double r=5.0;
		double circle;
		circle = 2 * PI * r;
    	cout << circle;
    	cout << NEWLINE; 
    	return 0;
	p
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




>> deque sequence container = Double Ended QUEue sequence container
[pag 662 deitel]
Class deque provides many of the benefits of a vector and a list in one container. The term deque is short for double ended queue.
Class deque is implemented to provide efficient indexed access (using subscripting) for reading and modifying its elements, much like a vector.
Class deque is alos implemented for efficient insertion and deletion operations and its front and back, much like a list (although a list is also capable of efficient insertions and deletion in the middle of the list). 
One of the most common uses of a deque is to maintain a first-in first-out queue of elements.
Due to the noncontiguous memory layout of a deque, a deque iterator must be more intelligent than the pointers that are used to iterate through vectors, arrys or built-in arrays.
NOTE1 performance
	in general, deque has higher overhead than vector
NOTE2 performance
	insertions and deletions in the middle of a deque are optimized to minimize the number of elements copied, so it's more efficient than a vector but less efficient than a list for this kind of modification.
	vector < deque < list da un punto di vista dell'efficiency middle insertion/deletion
Class deque provides the same basic operations as class vector, but like list adds member functions push_front and pop_front to allow insertion and deletion at the beginning of the deque respectively. 
NOTE3: nella sezione degli include dovrai scrivere 
	#include <deque>
in order to use class deque
esempio pratico /home/dia/Deitel-Code_Examples/ch15/fig15_14/Fig15_14.cpp
    // Fig. 15.14: Fig15_14.cpp
	// Standard Library deque class template.
	#include <iostream>
	#include <deque> // deque class-template definition
	#include <algorithm> // copy algorithm
	#include <iterator> // ostream_iterator
	using namespace std;
	int main()
	{ 
	   deque< double > values; // create deque of doubles   // <--- >> deque instantiation example 
	   ostream_iterator< double > output( cout, " " );
	   // insert elements in values
	   values.push_front( 2.2 );
	   values.push_front( 3.5 );
	   values.push_back( 1.1 );
	   cout << "values contains: ";
	   // use subscript operator to obtain elements of values
	   for ( size_t i = 0; i < values.size(); ++i )   // in this way we ensure that we do not attempt to access an element outside the bounds of deque
	      cout << values[ i ] << ' ';
	   values.pop_front(); // remove first element
	   cout << "\nAfter pop_front, values contains: ";
	   copy( values.cbegin(), values.cend(), output );
	   // use subscript operator to modify element at location 1
	   values[ 1 ] = 5.4;
	   cout << "\nAfter values[ 1 ] = 5.4, values contains: ";
	   copy( values.cbegin(), values.cend(), output );
	   cout << endl;
	} // end main
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DESTRUCTOR
[pag378deitel]
A destructor is a special member function that is part of every class and is used to perform "termination housekeeping" on an object before it's destroyed.
[pag304 mike game programming definition]
A destructor ia a member function that 's called just before an object is destroyed. If you don't write a destructor of your own, the compiler will supply a default destructor for you.
[see also http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
http://www.tutorialspoint.com/cplusplus/cpp_constructor_destructor.htm]
[pag393deitel]
A destructor is a type of special member function. The name of the destructor for a class is the tilde character (~) followed by the class name.
The destructor is the complement of the constructor. 
The destructor itself does not actually release the object's memory, it performs termination housekeeping before the object's memory is reclaimed, so the memory may be reused to hold new objects.
If you do not explicitly define a destructor, the compiler defines an "empty" destructor. 
[la seguente e' davvero una bella frase, quasi poetica] Constructors and destructors are called implicitly by the compiler. The order in which these function calls occur depends on the order in which execution enters and leaves the scopes where the objects are instantiated. Generally destructor calls are made in the revers order of the corresponding constructor calls. 
>> ~  quando vedi questo simbolo seguito da il nome di una classe ex ~nomeClasse() significa che ti trovi davanti a un destructor
>> DESTRUCTOR pag 200 moo book
Like constructors, which say how to create objects, there is a special member function, called a destructor, that controls what happens when objects of the type are destroyed. Destructors have the same name as the name of the class prefixed by a tilde (~). Destructors take no arguments and have no return value
The work of the destructor is to do any cleanup that should be done whenever an object goes away. Typically, this clean up involves releasing resources, such as memory, that the constructor has allocated.
	template <class T> class Vec {
	public:
		~Vec() {uncreate(); }
		// as before
	};
------------------------------------------------------------
>> DEFAULT CONSTRUCTOR / >> DEFAULT OPERATIONS [pag201 moo book]
If you not explicitly define a copy constructor, assignment operator, or destructor, the compiler synthesiszes default versions of the unspecified operations.
It is important to note that if a class defines any constructor explicitly, even a copy constructor, then the compiler will not synthesize a default constructor for that class. 
>> MEMORY ALLOCATION MANAGEMENT / >> RULE OF THE THREE / >> RULE OF THE 3 / >> THREE RULE / >> 3 rule [pag201 moo book]
Classes that manage resouces such as memory require close attention to copy control. In general, the default operations will not suffice for such classes. Failure to control every copy can confuse users of the class and often will lead to run time errors.
[...]
For example if we do not define a destructor, then the default destructor will be used. That destructor will destroy the pointer, but destroying a pointer does not free the space to which it points. The result will be a memory leak: the space consumed will never be reclaimed.
If we fix the leak by providing a destructor, but we do not also add the copy constructor and assignment operator, then we set things up so that a crash is likely. In such flawed implementation, it would be possible for two objects to share the same underlying storage, and when of one of those objects is destroyed, the destructor will destroy that shared storage. 
Classes that allocate resources in their constructors required that every copy deal correctly with those resources. Such classes almost surely need a destructor to free the resources. If the class needs a destructor, it almost surely needs a copy constructor, as well as an assignment operator. Copying or assigning objects of classes that allocate resources, usually allocates those resources in the same way that creating an object from scractch does.  To control how every object of class T deals with its resources, you need:
	T::T()                    one or more constructors, perhaps with arguments 
	T::~T()                   the destructor
    T::T(const T&)            the copy constructor 
	T::operator=(const T&)    the assignment operator
Once we have defined these operations, the compiler will invoke them whenever an object of your type is created, copied, assigned, or destroyed. Remember that objects may be created, copied or destroyed implicitly. Whether implicitly or explicitly, the compiler will invoke the appropriate operation. 
Because the copy constructor, destructor and assignment operator are so tightly coupled, the relationsihp among them has become known as the 
RULE OF THREE: "If you class need a destructor, it probably needs a copy constructor and an assignment operator too. "
	1) DESTRUCTOR 
	2) COPY CONSTRUCTOR
	3) ASSIGNMENT OPERATOR 
se hai bisogno di definire 1) [visto che magari hai bisogno di liberare memoria] allora anche 2) e 3) vanno definiti. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DO...WHILE REPETITION STATEMENT / DO WHILE / WHILE LOOP
[from pag168deitel]   / >> do while loop  also at pag 137 moo book
Similar to the while statement but the loop body always execute at least once. 
example 
	unsigned int counter = 1; initialize counter
	do 
	{
		cout << cout << " "; // display counter
	} while (counter <= 10 );
[nota come a differenza dell'header del for  a destra della ) ci sia il ; ]



>> DOWNCASTING 
pag526 deitel
downcasting is a potentially dangerous operation

>> DRIVER PROGRAM 
[pag84deitel]
il driver program altri non e' che il source-code file *.cpp containing function "main" and used to test our classes. A source-code file with "main" can use the class definition found in a header to create objects of a class. 

>> double : double precision floating point number
size: 8byte 
range: +/-1.7e+308 =(~15 digits)
NOTE: [advice from p37 moo book] for floating point computation use double, much better than using >> float (= single precision floating point type. Usato nei tempi antichi quando le memorie dei computer erano piccole e care.)
On modern computer double is usually much more accurate than float and not much slower. Sometimes double is even faster.

>> doxygen 
te reinvio alla voce >> doxygen in the OpenFOAM txt file

>> DYNAMIC BINDING / >> DYNAMIC BINDING / >> STATIC BINDING [pag527 deitel]
+ pag 547 example of static binding Each member function invocation in lines 32-37 is an example of static binding- at compile time, because we are using name handles (not pointers or references that could be set at execution time), the compiler can identify each object's type to determine which print and earnings functions are called.
>> DYNAMIC BINDING under the hood -> nice picture pag 551
>> OVERHEAD OF POLYMORPHISM pag550 in terms of additional memory consumption and processor time.
- virtual functions and dynamic binding enable polymorphic programming as an alternative to switch logic programming. Optimizing compilers normally generate polymorphic code that's nearly as efficient as hand-coded switch-based logic. Polymorphism's oeverhead is acceptable for most applications. In some situations (such as real-time applications) with stringent performance requirements - polymorphism's overhead may be too high.

>> OVERHEAD [in senso generale]
In informatica, la parola inglese overhead (letteralmente in alto, che sta di sopra) serve per definire le risorse accessorie, richieste in sovrappi rispetto a quelle strettamente necessarie per ottenere un determinato scopo in seguito all'introduzione di un metodo o di un processo pi evoluto o pi generale.
Nei linguaggi di programmazione ad alto livello, un esempio di overhead riguarda il tempo di esecuzione dei sottoprogrammi: al tempo da questi impiegato per svolgere il loro compito (ad esempio il calcolo di una radice quadrata) si aggiunge infatti il tempo necessario a gestire il meccanismo stesso di chiamata a sottoprogramma attraverso record di attivazione. Questo tempo aggiuntivo pu essere ridotto con un uso accorto di specifiche tecniche di ottimizzazione, ma non pu essere eliminato del tutto.
[source https://it.wikipedia.org/wiki/Overhead]

>> dynamic_cast 
[pag556 deitel]

>> DYNAMIC MEMORY ALLOCATION / >> unique_ptr
[pag755 deitel]
A common programming practice is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory and >> deallocate the memory with delete when the memory is no longer needed. 
If an exception occurs after successful memory allocation but before the delete statement executes, a >> memory leak could occur. 
C++11 provides class template >> unique_ptr in header <memory> to deal with this situation. 
An object of class >> unique_ptr maintains a pointer to dynamically allocated memory. When a unique_ptr object destructor is called (for example, when a unique_ptr object goes out of scope), it performs a delete operation on its pointer data member. Class template unique_ptr provides overloaded operator * and -> so that a unique_ptr object can be used just as a regular pointer variable is.
See example /home/dia/Deitel-Code_Examples/ch17/fig17_07_09/fig17_07_09.cpp
NOTE [from pag757 deitel]
The class is called unique_ptr because only one unique_ptr at a time can own a dynamically allocated object. By using its overloaded assignment operator or copy constructor, a unique_ptr can transfer ownership of the dynamic memory it manages. The last unique_ptr object that maintains the pointer to the dynamic memory will delete the memory. 
This makes unique_ptr an ideal mechanism for returning dynamically allocated memory to client code. When the unique_ptr  goes out of scope in the client code, the unique_ptr's destructor destroys the dynamically allocated object and deletes its memory.
NOTE2: you can also use a unique_ptr to manage a dynamically allocated built-in array. For example consider the statement:
	unique_ptr< string [] > ptr ( new string [ 10 ] );
which dynamically allocates an array of 10 strings managed by ptr. The type string[indicates that the managed memory is a built-in array containing strings. When a unique_ptr that manages an array goes out of scope it deletes the memory with delete []  so taht every element of the array receives a destructor call.
A unique_ptr that manages an array provides an overloaded [] operator for accessing the array's elements. For example, the statement
	ptr [2] = "hello";
assign "hello" to the string at ptr[2] and the statement
	cout << ptr[2] << endl;
displays that string.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY MANAGEMENT 
[pag451deitel]
You can control the allocation and deallocation of memory in a pogram for objects and for arrays of any built-in or user-defined type. This is known as dynamic memory management and is performed with the operators >> new and >> delete. 
Un poco di terminologia
>> allocate = reserve (a certain amount of memory)
The new operator can be used to dynamically allocate the exact amount of memory required to hold an object or built-in array at execution time. The object or built-in array is created in the >> free store (also called the >> heap), that is a region of memory assigned to each program for storing dynamically allocated objects [operator "new" could fail to obtain the needed memory, in which case  a "bad_alloc" exception will occur]
Once memory is allocated in the free store, you can access it via the pointer that operator "new" returns. When you no longer need the memory, you can return it to the free store by using the "delete" operator to >> deallocate (= release) the memory, which can be reused by future new operations 
- Obtaining dynamic memory with "new"
	Time *timePtr = new Time(); [example e spiegazione di tale espressione pag451]
- Releasing Dynamic Memory with delete
To destroy a dynamically allocated object and free the space for the object, use the delete operator as in the following example
	delete timePtr;
This statement first calls the destructor for the object to which timePtr points, then deallocates the memory associated with the object, returning the memory to the free store.
WARNINGS
1) >> memory leak : not releasing dynamically allocated memory when it's no longer needed can causes the system to run out of memory prematurely. This is sometimes called a "memory leak".
2) Do not delete memory that was not allocated by "new". Doing so results in undefined behaviour
3) After you delete a block of dynamically allocated memory be sure not to delete the same block again. One way to guard against this is to immediately set the pointer to nullptr. Delete a "nullptr" has no effect.
- Initializing dynamic memory [pag452deitel]
example
	double *ptr = new double ( 3.14159 );
which initializes a newly creatd double to 3.14159 and assigns the resulting pointer to "ptr". 
- >> Dynamically allocating built-in arrays with new[]
example: allocate a 10-element integer array can be allocated and assigned to gradesArray as follows:
	int *gradesArray = new int[ 10 ]();
which declares "int" pointer "gradesArray" and asignes to it a pointer tothe first element of a dynamically allocated 10-elements array of ints. The parentheses following new int[10] value initialize the array's elements (fundamental numeric types are set to 0, bools are set to false, pointers are set to nullptr and class objects are initialized by their default constructor). 
The size of an array created at compile time must be spcified using an integral constant expression [una volta che l'hai compilato quel size resta e non lo si puo' modificare]
However, a dynamically allocated array's size can be specified using any non negative integral expression that ca be evaluated at execution time. [<= questo e' davvero utile!!! puoi immaginare per esempio di calcolare dopo un cyclo for quale sia il numero N di elementi da detectare, e allocare un array di dimensione pari a N (essendo variabile usi bene le risorse della memoria, senza rischiare di allocare un vettore troppo piccolo o troppo grande)] 
NOTE [pag453]:  in C++11 you can use a list initilizer to initialize the elements of a dynamically allocated built-in array, as in 
	int *gradesArray = new int [ 10 ]{};
in the braces {} you can also write a comma-separated list of initializers for the arra's elements. Se la lasci vuota come nell'esempio sopra, inidicates that default initialization should be used for each element.
>> RELEASE Dynamically allocated built-in arrays with delete[] / >> delete[]
[pag453deitel]
supponi di aver inizializzato dinamicamente int *gradesArray = new int [ 10 ]{};
To deallocate the memory to which "gradesArray" points, use the statement:
	delete [] gradesArray;
The statement first calls the destructor for every object  in the array, then deallocates the memory. 
COMMON PROGRAMMING ERROR: using "delete" instead of delete[] for built-in arrays of objects can lead to runtime logic errors. To ensure that every object in the array receives a destructor call, always delete memory allocated as an array with operator delete[].
>> unique_ptr [pag453 deitel] 
C+11 unique_ptr is a smart pointer for managing dynamically allocated memory. When a unique_ptr goes out of scope, its destructor automatically returns the managed memory to the free store. 
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY [mike pag269 game programming] + >> Dynamic Allocate Memory pag277 mike game programming
C++ gives a game programmer a highdegree of control over the computer. One of the most fundamental abilities is direct control over memory, like for example dynamically allocate and free memory. But with great power comes great responsability, in the following comments we will show you the pitfalls of dynamic memory and how to avoid them.
>> AGGREGATION [pag269 mike programming] = combining of objects so that one is part of another. 
Game objects are often composed of other objects. For example, in a racing game, a drag racer could be seen as a single object composed of other individual objects, such as a body, four tires and an engine.
--------------------------------------------------------------FULL EXAMPLE START critter_farm.cpp
	//Critter Farm
	//Demonstrates object containment
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	class Critter
	{
	public:
	    Critter(const string& name = "");
	    string GetName() const;  
	   
	private:
// one way to use aggregation when defining a class is to declare a data member that can hold another object. 
// that's what we do in the following line. 
	    string m_Name; // we declare the data member m_Name to hold ... jump to "UBIKstring"
	};
	
	Critter::Critter(const string& name):
	    m_Name(name)   // ... UBIKstring m_Name to hold a string object.
// Generally, you use aggregation when an object has another object. In this case critter has a name. These kind of relationships are called a >> has-a / >> has a relationships. 
	{}
	
	inline string Critter::GetName() const 
	{
	    return m_Name;
	}
	
	class Farm
	{
	public:
	    Farm(int spaces = 1); 
	    void Add(const Critter& aCritter);
	    void RollCall() const;
	    
// >> CONTAINER DATA MEMBERS example [pag273 mike game programming]
	private:
	    vector<Critter> m_Critters;  // this data member is simply a vector that holds Critter objects called m_Critter
	};
	
	Farm::Farm(int spaces)  // quando nel main viene lanciato il comando Farm "myFarm(3);" spaces diventa uguale a 3. 
	{
	    m_Critters.reserve(spaces);  // and this line allocates memory for 3(=spaces) Critter objects in the Farm object's m_Critter vector. 
	}
	
	void Farm::Add(const Critter& aCritter) // next we add three critters to the farm by calling the Farm objectfs Add() member function.
	{
	    m_Critters.push_back(aCritter);
// note : push_back() adds a copy of an object to a vector [this means that I create an extra copy of each Critter object every time I call Add()]. This is not big deal in the Critter Farm program, but if we were adding many large objects, it could become a performance issue. You can reduce this overhead by using, say, a vector of pointers to objects.
	}
	
	void Farm::RollCall() const
	{
	    for (vector<Critter>::const_iterator iter = m_Critters.begin(); 
	         iter != m_Critters.end(); 
	         ++iter)
		{
	        cout << iter->GetName() << " here.\n";
		}
	}
	
	int main()
	{
	    Critter crit("Poochie");
	    cout << "My critter's name is " << crit.GetName() << endl; 
	
	    cout << "\nCreating critter farm.\n";
	    Farm myFarm(3);
	    
	    cout << "\nAdding three critters to the farm.\n";
	    myFarm.Add(Critter("Moe"));
	    myFarm.Add(Critter("Larry"));
	    myFarm.Add(Critter("Curly"));
	
	    cout << "\nCalling Roll...\n";
	    myFarm.RollCall();
	       
	    return 0;
	}

--------------------------------------------------------------END FULL EXAMPLE START critter_farm.cpp
OUTPUT of the program:
	My critter's name is Poochie
	
	Creating critter farm.
	
	Adding three critters to the farm.
	
	Calling Roll...
	Moe here.
	Larry here.
	Curly here.
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMICALLY ALLOCATE MEMORY / >> DYNAMIC MEMORY ALLOCATION [pag277 mike game programming]
So far, whenever you've declared a variable, C++ has allocated the necessary memory for it. When the function that the variable was created in ended, C++ freed the memory. This memory, which is used for local variables, is called the >> STACK. But there's another kind of memory that persists independent of the functions in a program. You the programmer, are in charge of allocating and freeing this memory, collectively called the >> HEAP (or >> FREE STORE / >> FREESTORE - termine che tra l'altro ritrovi anche in alcune pagine doxygen di OF).
At this point, you might be thinking "Why bother with another type of memory? THe stack works just fine, thank you." Using the dynamic memory of the heap offers great benefits that can be summed up in one word: EFFICIENCY. By using the heap, you can use only the amount of memory you need at any given time. If you have a game with a level that has 100 enemies, you can allocate the memory for the enemies at the beginning of the level and free the memory at the end. The heap also allows you to create an object in one function that you can access even after that function ends (without having to return a copy of the object). Dynamic memory is an important tool in writing any significant game.
PUNTI SALIENTI DEL PROGRAMMA SOTTOSTANTE
>> NEW / >> new [pag280 mike game programming]: new operator allocates memory on the heap and returns its address. You use "new" followed by the type of value you want to reserve space for:
	 int* pHeap = new int;
The new int part of the statement allocates enough memory on the heap for one "int" and returns the address on the heap for that chunk of memory. The other part of the statement int* pHeap, declares a local pointer, pHeap, which points to the newly allocated chunk of memory on the heap.
By using pHeap, we can manipulate the chunk of memory on the heap reserved for an integer. That's what we can do with 
	*pHeap = 10;
we assign 10 to the chunk of memory and then we display that value stored on the heap, as we would with any other pointer to int. The only difference is that pHeap points to a piece of memory on the heap, not the stack.
HINT: you can initialize memory on the heap at the same time you allocate it by palcing a value, surrounded by parentheses, after the type. For example:
	int* pHeap = new int(10);
this line allocates a chunk of memory on the heap for an int variable and assigns 10 to it. The statement then assigns the address of that chunk of memory to pHeap.
One of the major advantages of memory on the heap is that it can persist beyond the function in which it was allocated, meaning that you can create an object on the heap in one function and return a pointer or reference to it. That's what we can demonstrate with the line:
	 int* pHeap2 = intOnHeap();
The statements calls the function intOnHeap(), which allocates a chunk of memory on the heap for an int and assigns 20 to it.
	int* intOnHeap()
	{
	    int* pTemp = new int(20);
	    return pTemp;
	}
Then the function returns a pointer to this chunk of memory. Back in main() the assignment statement assigns the address of the chunk of memory on the heap to pHeap2. Next we use the returned pointer to display the value.
	cout << "*pHeap2: " << *pHeap2 << "\n\n";
HINT: up until now (chapter 1-8 mike programming) , if you wanted to return a value created in a function, you had to return a copy of the value. But by using dynamic memory, you can create an object on the heap in a function and return a pointer to the new object.
>> DELETE OPERATOR [pag281 mike game programming]
Ulike storage for local variables on the stack, memory that you've allocated on the heap must be explicitly freed. When you're finished with memory that you've allocated with "new", you should free it with "delete". That's what we do with the line 
	delete pHeap;
which frees the memory on the heap that stored 10.
That memory is returned to the heap for future use. The data tha was stored in it is no longer available.
TRICK: because you need to free memory that you've allocated once you're finished with it, a good rule of thumb is that every "new" should have a corresponding "delete". In fact, some programmers write the "delete" statement just after writing the "new" statement whenever possible, so they don't forget it.
NOTE: an important point to understand here is that the two previous statements free the memory on the heap, but they do not directly affect the local variables pHeap and pHeap2. This creates a potential problem because pHeap and pHeap2 now point to memory that has been returned to the heap, meaning that they point to memory that the computer can use in some other way at any time. Pointers like this are called
	>> DANGLING POINTERS [pag 280 mike game programming]
and they are quite dangerous. You should never attempt to dereference a dangling pointer. One way to deal with dangling pointers is to assign 0 to them, and that's what we do with the lines 
	pHeap = 0;
	pHeap2 = 0;
Another good way to deal with a dangling pointer is to assign a valid memory address to it.
TRAP: using delete on a dangling pointer can cause your program to crash. Be sure to set a dangling pointer to 0 or reassign it to point to a new, valid chunk of memory.
>> MEMORY LEAKS AVOIDANCE / >> LEAKED MEMORY [pag282 mike game programming]
One problem with allowing a programmer to allocate and free memory is that he might allocate memory and lose any way to get at it, thus losing any way to ever free it. When memory is lost like this, it's called a MEMORY LEAK. Given a large enough leak, a program might run out of memory and crash. As a game programmer, it's your responsability to avoid memory leaks.
Here's an example of what you should NOT do:
	void leak1()
	{
	    int* drip1 = new int(30);
	}
this function leak1() simply allocates a chunk of memory on the heap for an int value and then ends. 
If we were to call this function, memory would be lost foverer (okay, it would be lost until the program ended). The problem is that "drip1" which is the only connection to the newly acquired chunk of memory on the heap, is a local variable and ceases to exist when the function leak1() ends. There is no way to free the allocated memory. To avoid this memory leak, we could do one of two things: 
- use delete to free the memory in leak1()
- return a copy of the pointer drip1. If we choose the second option, we have to make sure to free this memory in some other part of the program.
Here's another example that creates a memory leak:
	void leak2()
	{
	    int* drip2 = new int(50);
	    drip2 = new int(100);
	    delete drip2;
	}
This memory leak is a little more subtle but there is still a leak. The line "int* drip2 = new int(50);" allocates a new piece of memory on the heap, assigns 50 to it, and has drip2 point to that piece memory. 
The second line "drip2 = new int(100);"  points drip2 to a new piece of memory on the heap, which stores the 100. The problem is taht the memory on the heap that stores 50 now has nothing pointing to it, so there is no way for the program to free that memory. As a result, that piece of memory has essentially leaked out of the system. The last statement "delete drip2;" frees the memory that stores 100, so this won't be the source of another memory leak. But remember, the memory on the heap that stores 50 has still leaked out of the system. Also we don't worry about drip2, which technically has become a dangling pointer, because it will cease to exist when the function ends.
-------------------------------------------------------------------------- START FULL EXAMPLE DYNAMIC MEMORY ALLOCATION 
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/heap.cpp]
	// Heap
	// Demonstrates dynamically allocating memory
	
	#include <iostream>
	
	using namespace std;
	
	int* intOnHeap();  //returns an int on the heap
	void leak1();      //creates a memory leak
	void leak2();      //creates another memory leak
	
	int main()
	{
	    int* pHeap = new int; // il programma dynamically allocates memory on the heap for an integer variable
	    *pHeap = 10; // assigns it a value 
	    cout << "*pHeap: " << *pHeap << "\n\n"; // and then display it 
	    
	    int* pHeap2 = intOnHeap(); // call of the function intOnHeap that dynamically allocates memory on the heap for another integer variable [vedi la sua definizione sotto]
	    cout << "*pHeap2: " << *pHeap2 << "\n\n"; // displayin the value of the returned pointer 
	    
	    cout << "Freeing memory pointed to by pHeap.\n\n";
	    delete pHeap;  // frees the allocated memory on the heap
	
	    cout << "Freeing memory pointed to by pHeap2.\n\n";
	    delete pHeap2;
	    
	    //get rid of dangling pointers
	    pHeap = 0; 
	    pHeap2 = 0;
	   
	    return 0;
	}
	
	int* intOnHeap()   // this the function that dyanmically allocates memory on the heap for an integer variable and assigns it a value
	{
	    int* pTemp = new int(20);  
	    return pTemp;   // return a pointer 
	}
	
	void leak1() // function to demonstrate the misuse of dynamic memory
	{
	    int* drip1 = new int(30);
	}
	
	void leak2() // function to demonstrate the misuse of dynamic memory
	{
	    int* drip2 = new int(50);
	    drip2 = new int(100);
	    delete drip2;
	}
	

-------------------------------------------------------------------------- FINE  FULL EXAMPLE DYNAMIC MEMORY ALLOCATION 
///////////////////////////////////////////////////////////////////////////////////////////

>> MEMORY MANAGEMENT  / >> FLEXIBLE MEMORY MANAGEMENT  [pag203 moo book]
There are standard library facilities designed to support flexible memory management.  The core language itself does not have any notion of memory allocation, because the properties of memory are too variable to wire into the language itself.
For example, modern computers have many kinds of memory. There may be many different speeds of memory on the machine. There may be memory with special properties, such as graphical buffers or shared memory. There may be memory that is persistent across power failures. Because users might want to allocate any of these (or other) kinds of memory, it is best left to the library to specify how we allocate and manage memory. The standard library doesn't support all these kinds of memory; instead, it offers a facility to manage memory along with a uniform interface for memory managers. As with the decision to make input-output a library rather than a language facility, the decision to make memory management part of the library gives us greater flexibility in using these different kinds or memory.
>> ALLOCATOR class see pag204 moo book
>> CLASS INVARIANT see pag206 moo book
//////////////////////////////////////////////////////////////////////////////////////////////////

>> DATA MEMBERS and HEAP / >> HEAP DATA MEMBERS [pag284 mike game programming]
You've seen how you can use aggregation to declare data members that store objects, but you can also declare data members that are pointers to values on the heap. You might use a data member that points to a value on the heap for some of the reasons your would use pointers in other situations. For example, you might want to declare a data member for a large 3D scene; however, you might only have access to the 3D scene through a pointer. Unfornately problems can arise when you use a data member that points to a value on the heap because of the way that some default object behaviour work. But you can avoid these issues by writing member functions to change these default behaviours.
In the example below "heap_data_member.cpp" the program defines a new type of critter with a data member that is a pointer, which points to an object stored on the heap. The class defines a few new member functions to handle situations in which an object is destroyed, copied, or assigned to another object. The program destroys, copies, and assigns objects to show that the objects behave as you'd expect, even with data members pointing to values on the heap.
NOTE: >> DESTRUCTORS DEFINITION / >> DESTRUCTORS DECLARATION [pag288 mike game programming]
One problem that can occur when a data member of an object points to a value on the heap is a memory leak. That's beacuse when the object is deleted, the pointer to the heap value disappears along with it (quindi perdi l'informazione di dove sia il campo di memoria che avevi allocato, quindi leakka, bye bye is over e andato finche' il programma non termina). If the heap value remains, it produces a memory leak. To avoid a memory leak, the object should clean up after itself before it is destroyed by deleting its associated heap value. 
[>> DESTRUCTORS why we need them]
Fortunately, there's a member function, the destructor, that's called just before an object is destroyed, which can be used to perform the necessary cleanup.
A default destructor, which is created for you by the compiler if you don't write your own, DOES NOT attempt to free any memory on the heap that a data member might point to. This behaviour is usually fine for simple classes, but when you have a class with data members that point to values on the heap, YOU SHOULD WRITE your OWN DESTRUCTOR so you can free the memory on the heap associated with an object before the object disappears, avoiding a memory leak.
As you can see in the program below first si dichiara il destructor all'interno della class definition. Il destructor has the sname of the class preceded by ~ and does not have any parameters or return value 
	class Critter   // class definition begins 
	{
     ...
	    ~Critter();  // >> DESTRUCTOR DECLARATION 
     ...
	}
--------------------------------------------------
>> COPY CONSTRUCTORS [pag289 mike game programming]
Sometimes an object is copied automatically for you. This occurs when an object is 
	- passed by value to a function
	- returned from a function 
	- initialized to another object through an initializer
	- provided as a single argument to the object's constructor
The copying is done by a special member function called the "COPY CONSTRUCTOR". Like constructors and destructors, a default copy constructor is supplied for you if you don't write one of your own. The default copy constructor simply copies the value of each data member to data members fo the same name in the new object ( a member wise copy)
For simple classes, the default copy constructor is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing you own copy constructor. Why? Imagine a Critter object that has a data member that's apointer to a string object on the heap. With only a default copy constructor, the automatic copying of the object would result in a new object that points to the same single "string" on the heap because the pointer of the new object would simply get a copy of the address stored in the pointer of the original object. [>> SHALLOW COPY] This member wise copying produces a shallow copy in which the pointer data members of the copy point to the same chunks of memory as the pointer data members in the original object. Why this is a problem? Perche' una volta che il destructor free the memory on the heap, the pointer della shallow copy finirebbe per diventare un dangling pointer (= point to memory that has been freed) [see full explanation pag 290 mike game programming].
[>> DEEP COPY mike game programming pag 291] What you really need is a copy constructor that produces a new object with its own chunk of memory on the heap for each data member that points to a heap object (= a deep copy).
That's what we do when we define a copy constructor for the class, which replaces the default one provided by the compiler. First inside the class definition we declare the copy constructor:
	Critter(const Critter& c);    //copy constructor prototype
Next, outside the class definition, we define the copy constructor:
	Critter::Critter(const Critter& c)        //copy constructor definition
	{
	    cout << "Copy Constructor called\n";
	    m_pName = new string(*(c.m_pName));
	    m_Age = c.m_Age;
	}
Just like this one, a copy constructor must have the same name as the class. It returns no value, but accepts a reference to an object of the class (the object that needs to be copied). The reference should be made a constant reference to pretext the original object from being changed during the copy process.
The job of a copy constructor is to copy any data members from the original object to the copy object. If a data member of the original object is a pointer to a value on the heap, the copy constructor should request memory from the heap, copy the original heap value to this new chunk of memory, and then point the appropriate copy object data member to this new memory.
NOTE from pag 292 mike game programming figure 9.10: With a proper copy constructor, the original and the copy each point to their own chunk of memory on the heap. Then, when the copy is destroyed, the original is unaffected.
HINT: when you have a class with data members that point to memory on the heap, you should consider writing a copy constructor that allocates memory for a new object and creates a deep copy.
>> WISE COPY vs DEEP COPY / >> DEEP COPY vs WISE COPY 
[pag304 mike game programming ]
The copy constructor is a member function that's invoked when an automatic copy of an object is made. A default copy constructor is supplied for a class if you don't write one of your own. 
	The default copy constructor simply copies the value of each data member to data members with the same names in the copy, producing a member wise copy. 
	[>> member wise copy pag 304 mike game programming]
	Member wise copying can produce a shallow copy of an object, in which the pointer data members of the copy point to the same chunks of memory as the pointers in the original object. 
	[>> deep copy]
	A deep copy is a copy of an object that has no chunks of memory in common with the original.
 ASSIGNMENT OPERATOR (cioe' operatore = , il segno uguale che assegna al membro sinistro il membro a destra) [from pag 293 mike game programming and search "//overloaded assignment op" per ritrovarlo nel programma qui sotto] When both side of an assignment statement are object of the same class, the class' assignment operator member function is called. Like a default copy constructor, a default assignment operator member function is supplied for you if you don't write one of your own. Also like the default copy constructor, the default assignment operator provides only member-wise duplication. 
For simple classes, the default assignment operator is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing an overloaded assignment operator of your own. If you don't, you'll end up with shallow copies of objects when you assign one object to another. To avoid this problem, we overload the assignment operator for Critter. First, inside the class definition, we write the declaration:
	  Critter& Critter::operator=(const Critter& c);  //overloaded assignment op
Next, outside the class definition, we write the member function definition
	Critter& Critter::operator=(const Critter& c)  //overloaded assignment op def
// nota come questa member function operator=() abbia il goal to assign the values of all the data members of a critter object to another critter object, while making sure each critter object has its own chunks of memory on the heap for any pointer data members.
	{
	    cout << "Overloaded Assignment Operator called\n";
	    if (this != &c) // this condition checks whether the address of crit1 is not equal to the address of crit2. That is, it tests if the object isn't being assigned to ifself. 
	    {
	        delete m_pName; // frees the memory on the heap
	        m_pName = new string(*(c.m_pName)); // allocate new chunk of memory on the heap, get a copy of the object and copies into the new heap memory, and points the m_pName data member ... descrizione dettagliata continua a pag 294 mike game programming -> ti rimando alla lettura diretta del libro
	        m_Age = c.m_Age;
	    }
	    return *this; // the member function returns a reference to a Critter object. For robust assignment operation, return a reference from the overloaded assignment operator member function.
	}
------------------------------------------------------------------------------------------- START heap_data_member.cpp program
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/heap_data_member.cpp]
	//Heap Data Member
	//Demonstrates an object with a dynamically allocated data member
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Critter   // CLASS DEFINITION BEGINS
	{
	public: 
	    Critter(const string& name = "", int age = 0);  
	    ~Critter();                   //destructor prototype  : qui si dichiara il destructor all'interno della class definition. Il destructor has the sname of the class preceded by ~ and does not have any parameters or return value 
	    Critter(const Critter& c);    //copy constructor prototype
	    Critter& Critter::operator=(const Critter& c);  //overloaded assignment op
	    void Greet() const; 
	
	private:
// to declare a data member that points to a value on the heap we first need to declare a data member that's a pointer, as done in the
// following line:
	    string* m_pName;
	    int m_Age;
	};               // CLASS DEFINITION ENDS
	
// start constructor definition 
	Critter::Critter(const string& name, int age)
	{
	    cout << "Constructor called\n";
// with the following line we allocate memory on the heap, assign a value to the memory and then point a pointer data member to the memory.
	    m_pName = new string(name); // we allocate memory for a string object, assigns "name" to it, and points the pointer "m_pName" to that chunck of memory on the heap. 
	    m_Age = age;  
	}
// end constructor definition	

	Critter::~Critter()                        //destructor definition
	{
	    cout << "Destructor called\n";
	    delete m_pName;
	}
	
	Critter::Critter(const Critter& c)        //copy constructor definition
	{
	    cout << "Copy Constructor called\n";
	    m_pName = new string(*(c.m_pName));
	    m_Age = c.m_Age;
	}
	
	Critter& Critter::operator=(const Critter& c)  //overloaded assignment op def
	{
	    cout << "Overloaded Assignment Operator called\n";
	    if (this != &c)
	    {
	        delete m_pName;
	        m_pName = new string(*(c.m_pName));
	        m_Age = c.m_Age;
	    }
	    return *this;
	}
	
	void Critter::Greet() const
	{
	     cout << "I'm " << *m_pName << " and I'm " << m_Age << " years old. ";
	     cout << "&m_pName: " << &m_pName << endl;
	}
	
	void testDestructor();
	void testCopyConstructor(Critter aCopy);
	void testAssignmentOp();
	
	int main()
	{
	    testDestructor();  
	    cout << endl;
	    
	    Critter crit("Poochie", 5);
	    crit.Greet();
	    testCopyConstructor(crit);
	    crit.Greet();
	    cout << endl;
	    
	    testAssignmentOp();
	
	    return 0;
	}
	
	void testDestructor()
	{
	    Critter toDestroy("Rover", 3);
	    toDestroy.Greet();
	}
	
	void testCopyConstructor(Critter aCopy)  
	{
	    aCopy.Greet();
	}
	
	void testAssignmentOp()
	{
	    Critter crit1("crit1", 7);
	    Critter crit2("crit2", 9);
	    crit1 = crit2;
	    crit1.Greet();  
	    crit2.Greet();
	    cout << endl;
	        
	    Critter crit3("crit", 11);
	    crit3 = crit3;
	    crit3.Greet();
	}
------------------------------------------------------------------------------------------- END heap_data_member.cpp program
OUTPUT PROGRAM:
non venuto ci veniva l'errore:
[2084 chapter09] >> g++ heap_data_member.cpp -o heap_data_member
heap_data_member.cpp:15:14: error: extra qualification eCritter::f on member eoperator=f [-fpermissive]
ITIAF...extra qualification Critter my ass! Alien Reply omage
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY IN ACTION, PRACTICAL EXAMPLE  from mike game programming pag296
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/game_lobby.cpp]
---------------------------------------------------------------------------------- START game_lobby.cpp
	//Game Lobby
	//Simulates a game lobby where players wait
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Player
	{
	public:  
	    Player(const string& name = "");
	    string GetName() const;
	    Player* GetNext() const;
	    void SetNext(Player* next);
	    
	private:
	    string m_Name;
	    Player* m_pNext;  //Pointer to next player in list
	};
	
	Player::Player(const string& name): 
	    m_Name(name), 
	    m_pNext(0) 
	{}
	
	string Player::GetName() const
	{
	    return m_Name;
	}
	
	Player* Player::GetNext() const
	{
	    return m_pNext;
	}
	
	void Player::SetNext(Player* next)
	{
	    m_pNext = next; // [pag 298 mike game programming] each Player object has an m_pNext data member, therefore you can link 
						// a bunch of Player objects in a >> linked list. Individual elements of linked lists are often called nodes.
    					// see bella figura pag 298 mike game programming o la nostra piccola text art figure qui sotto 
						// One way to think about the player nodes is as a group of train cars (= vagoni del treno) that carry cargo 
						// and are connected. In this case the train cars carry a name as a cargo and are linked through a pointer data
						// member, m_pNext

//
//          m_pHead
//          ---------
//          |       |
//          ----|----
//              |              COME I VAGONI DI UN TRENO 
//              V           
//          ---------                  ----------                  ----------
//  m_Name  | "Mike"|          m_Name  | "Steve"|          m_Name  | "Larry"|
//          ---------                  ----------                  ----------
//  m_pNext |    ---|------->  m_pNext |   -----|------->  m_pNext |    ----|------> NULL     
//          ---------                  ----------                  ----------
//
//
//

	}
	
	class Lobby    // the Lobby class allocates memory on the heap for each Player object in the list
	{
	    friend ostream& operator<<(ostream& os, const Lobby& aLobby);
	    
	public:
	    Lobby();
	    ~Lobby();
	    void AddPlayer();  // AddPlayer istanzia a Player object on the heap and adds it to the end of the list. 
	    void RemovePlayer(); // RemovePlayer() removes the first Player object in the list, freeing the allocated memory.
	    void Clear();
	    
	private:
	    Player* m_pHead;  // the data member m_pHead is a pointer that points to a Player object, which represents the first person in line. 
                          // m_pHead represents the head of the line.
	};
	
	Lobby::Lobby():    // questo e' il >> constructor: it simply initializes the data member m_pHead to 0, making it a null pointer.
	    m_pHead(0)
	{}
	
	Lobby::~Lobby()    // questo e' il >> destructor. The destructor simply calls Clear(), which removes all the Player objects 
	{                  // from the list, freeing the allocated memory.
	    Clear();
	}
	
	void Lobby::AddPlayer()  // pag299 mike game programming. The Lobby::AddPlayer() member function adds a player to the 
	{                        // end of the line in the lobby.
	    //create a new player node
	    cout << "Please enter the name of the new player: ";
	    string name;
	    cin >> name;
	    Player* pNewPlayer = new Player(name);
	
	    //if list is empty, make head of list this new player
	    if (m_pHead == 0)
	    {
	        m_pHead = pNewPlayer;
	    }
	    //otherwise find the end of the list and add the player there
	    else
	    {
	        Player* pIter = m_pHead;
	        while (pIter->GetNext() != 0)
	        {
	            pIter = pIter->GetNext();       
	        }
	        pIter->SetNext(pNewPlayer);
	    }
	}
	
	void Lobby::RemovePlayer()
	{
	    if (m_pHead == 0)
	    {
	        cout << "The game lobby is empty.  No one to remove!\n";
	    }
	    else
	    {
	        Player* pTemp = m_pHead;
	        m_pHead = m_pHead->GetNext();
	        delete pTemp;
	    }
	}
	
	void Lobby::Clear()
	{
	    while (m_pHead != 0)
	    {
	        RemovePlayer();
	    }
	}
	
	ostream& operator<<(ostream& os, const Lobby& aLobby)
	{
	    Player* pIter = aLobby.m_pHead;
	
	    os << "\nHere's who's in the game lobby:\n";
	    if (pIter == 0)
	    {
	        os << "The lobby is empty.\n";
	    }
	    else
	    {
	        while (pIter != 0)
	        {   
	            os << pIter->GetName() << endl;
		        pIter = pIter->GetNext();
	        }
	    }
	
	    return os;
	}
	
	int main()
	{
	    Lobby myLobby;
	    int choice;
	    
	    do
		{
		    cout << myLobby;
	        cout << "\nGAME LOBBY\n";
	        cout << "0 - Exit the program.\n";
	        cout << "1 - Add a player to the lobby.\n";
	        cout << "2 - Remove a player from the lobby.\n";
	        cout << "3 - Clear the lobby.\n";
	        cout << endl << "Enter choice: ";
	        cin >> choice;
	
	        switch (choice)
	        {
	            case 0: cout << "Good-bye.\n"; break;
		        case 1: myLobby.AddPlayer(); break;  
	            case 2: myLobby.RemovePlayer(); break;
	            case 3: myLobby.Clear(); break;
	            default: cout << "That was not a valid choice.\n";
	        }
		}
	    while (choice != 0);
	    
	    return 0;
	}

---------------------------------------------------------------------------------- END game_lobby.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> EEEEEEE

>> end line / >> line end [pag 3 moo book]
usa std::endl = ends the current line of output
example 
	std::cout << "Hello, world!" << std::endl;
NOTE: ricordati di includere 
	#include <iostream>
nell'inizio del programma

>> EOF / >> end of file signal [pag36 moo book]
CTRL + z in windows systems
CTRL + d in linux systems

>> expression [pag4 moo book] = asks the implementation to compute something.
Expression contains operators and operands
Example in the expression 
	std::cout << "Hello, world!" << std::endl;
the operands are 
	std::cout
	"Hello, world!"
	std::endl
mentre << is an operator. 
Every operand has a type. 
>> type : a type denotes a data structure and the meanings of operations that make sense for that data structure.
///////////////////////////////////////////////////////////////////////


>> else clause 
[mike pag43]
You can add an else clause to an if statement to provide code that will only be executed if the tested expression is false. Here's the form of an if statement that includes an else clause:
	if (expression)
		statement1;
	else
		statement2;
If expression is true, statement1 is executed. Then the program skips statement2 and executes the statement following the if suite. IF expression is false, statement1 is skipped and statement2 is executed. After statement2 completes, the program executes the statement following the if suite.
Example 
	// Score Rater 2.0
	// Demonstrates an else clause
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int score;
		cout << "Enter your score: ";
		cin >> score;
	
	    if (score >= 1000)
		{
	        cout << "You scored 1000 or more. Impressive!\n";
		}
		else
		{
			cout << "You scored less than 1000.\n";
		}
	
	    return 0;
	}
/////////////////////////////////////////////////////////////////////////////

>> executable creation process [mikepag3]
editor -> source code -> compiler (translate the source code *.cpp into an object file *.obj)-> object code -> linker (link the object file to any external files as necessary, then creates the executable file, which generally ends with the extension .exe) -> executable file
To help automate this process, it's common for a programmer to use an all in one tool for development, called an >> IDE = integrated development environment. An IDE typically combinesan editor, a compiler and a linker along with other tools. 

>> COMPILE HOW TO
//                 ,  ,
//                / \/ \,'| _
//               ,'    '  ,' |,|
//              ,'           ' |,'|
//             ,'                 ;'| _
//            ,'                    '' |
//           ,'                        ;-,
//          (___                        /
//        ,'    `.  ___               ,'
//       :       ,`'   `-.           /
//       |-._ o /         \         /
//      (    `-(           )       /                 To compile the files type in the terminal:
//     ,'`.     \      o  /      ,'                 g++ file_name.C -o executable_name
//    /    `     `.     ,'      /
//   (             `"""'       /
//    `._                     /
//       `--.______        '"`.
//          \__,__,`---._   '`;
//               ))`-^--')`,-'
//             ,',_____,'  |
//             \_          `).
//               `.      _,'  `
//               /`-._,-'      \
//
//
//*********************************************************************************************************************************




>> ERROR TYPES [mike pag4]
	>> Compile errors = these occur during code compilation. As a result, an object file is not produced.
	>> link errors = these occur during the linking process and may indicate that something the program references externally can't be found. These errors are usually solved by adjusting the offending reference and startin the compile link process again. 
	>> run time erros = these occur when the executable is run. If the program does something illegal, it can crash abruptly. But a more subtle form of run-time error, a logical error, can make the program simply behave in unintended ways.

>> empty 
empty is a member function of the string class. "empty" determines  whether a string is empty.
[pag435 deitel]
/home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
line 11
		string s3; // creation of an empty string ; ricorda come l'inizializzazione di una string non empty fosse string s3("nanika");
line 27
	   if ( s3.empty() )	
	   {
	      cout << "s3 is empty; assigning s1 to s3;" << endl;
	      s3 = s1; // assign s1 to s3
	      cout << "s3 is \"" << s3 << "\"";
	   } // end if
/////////////////////////////////////////////////////////////

>> EMPTY PARAMETER LISTS
[pag235]
In C++ an empty parameter list is specified by writing either void or nothing at all in parentheses.
Per esempio per dichiarare and use functions with empty parameter lists we can
	void function();
or also 
	void function( void );
Queste righe un po come le suore che bastino si mettono sui banconi vicino all'altare del prete per svolgere la loro funzione, si mettono giusto prima dell'int main {...}  

>> endl 
	endl 
stands for end line 	
example 
	std::cout << "Sum is " << sum << std::endl; // display sum, end line
endl is a stream manipulator that belongs to the namespace std. The std::endl outputs a newline, then "flushes the output buffer". This simply means that, on some system where outputs accumulate in the machine until there are enough to "make it worthwhile" to display them on the screen, std::endl forces any accumulated outputs to be displayed at that moment.  

>> ENLIGHTMENT / >> ZEN MOMENT >> UNDERSTANDING what classes and object technology is all about / >> OBJECT and CLASSES an enlightment case study
[pag434deitel and pag 453deitel] this is one of the most important case studies in deitel book. Many students have indicated that the Array case study is their ">> light bulb moment" in truly understanding what classes and object technology are all about.
Once you master this Array class, you'll indded understand the essence of object technology (crafting, using and reusing valuable classes)

>> ENUM / >> ENUMERATION 
[pag222deteil + pag29 mike]
IN SHORT [pag34 mike]: an enumeration is a sequence of unsigned int constants.
IN LONG
a user-defined type called an enumeration is 
    introduced by the keyword enum 
and followed by a type name (in the example Status) 
// -------------------------------------------------------
                and a set of integer constants represented by identifiers (che nell'esempio sono CONTINUE WON e LOST)  
 // enumeration with constants that represent the game status
    enum Status { CONTINUE, WON, LOST }; // all caps in constants
 ...
 Status gameStatus = CONTINUE;
// -------------------------------------------------------
The values of this enumeration constants start at 0 unless specified otherwise and increment by 1. Quindi in the preceding enumeration: 
- the constant CONTINUE has the value 0, 
- WON has the value 1
- LOST has the value 2
OSSERVAZIONE 
> variable of user-defined type Status (gameStatus in the above example) can be assigned only one of the three values (CONTINUE or WON or LOST) declared in the enumeration
> capitalize the first letter of an identifier used as a user-defined type name (mi sembra si riferisca a "Status" nell'esempio sopra) 
> use only uppercase letters in enumeration constant names. This makes these constants stand out in a program and reminds you that enumeration constants are not variables.
EXAMPLE 2 Month enumeration 
	enum Months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
which creates user-defined type Months with enumeration constants representing the months of the year. The first value in the preceding enumeration is explicitly set to 1, so the remaining values increment from 1, resulting in the values 1 through 12. Any enumeration constant can be assigned an integer value in the enmeration definition, and subsequent enumeration constants each have a value 1 higher than the preceding constant in the list until the next explicit setting. 
Quindi mi sembra di capire che se per esempio scrivessi
	enum Months { JAN = 1, FEB, MAR, APR = 7, MAY, JUN};
otterrei JAN = 1, FEB = 2, MAR = 3, APR =7, MAY =8, JUN=9 
OBSERVATION 
- the previous enums are also called unscoped enums per differenziarli dagli scoped enums introdotti con C++11
The problem with unscoped enums is that multiple enums may contain the same identifiers. Using such enums in the same program can lead to naming collisions and logic errors. To eliminate these problems, C++11 introduces  so-called scoped enums, which are declared with the keywords enum class (or the synonym enum struct). For example the previous example enum Status { CONTINUE, WON, LOST }; becomes
	enum class Status { CONTINUE, WON, LOST };
- To reference a scoped enum constant, you must qualify the constant with the scoped enum's type name (Status) an the scope-resolution operator (::) , as in Status::CONTINUE. This explicitly identifies CONTINUE as a constant in the scope of enum class Status. Thus, if another scoped enum contains the same identifier for one of its constants, it's always clear which version of the constant is being used.
- Use scoped enums to avoid potential naming conflicts and logic errors from unscoped enums that contain the same identifiers.
- [pag223] C++11 allows you to specify an enum's underlying integral type by following the enum's type name with a colon (:) and the integral type. For example, we can specify that the constants in the enum class Status should have type unisgned int, as in 
	enum class Status : unsigned int { CONTINUE, WON, LOST };
Attention : a compilation error occurs if an enum constant's value is outside the range that can be represented by the enum's underlying type. see nostro esempio pag224 deitel [ad ogni modo il limite e' talmente grande che in liste normali e' improbabile che lo possa superare.]
----------------------------------------------------------------------------------------------------------------------------------------
>> enumeration from pag29 mike
An enumeration is a set of unsigned int constnats, called enumerators. Usually the enumerators are related and have a particular order. Here's an example of enumeration:
	enum difficulty {NOVICE, EASY, NORMAL, HARD, UNBEATABLE};
This defines an enumeration named difficulty. By default, the value of enumerators begins at zero and increases by one. So NOVICE is 0, EASY is 1, NORMAL is 2, HARD is 3, UNBEATABLE is 4. Next we can create a variable of this new enumeration type.
	difficulty myDifficulty = EASY;
The variable myDifficulty is set to EASY which is equal to 1. myDifficulty is of type difficulty, so it can only hold one of the values defined in the enumeration. That means myDifficulty can only be assigned NOVICE, EASY, NORMAL, HARD, UNBEATABLE, 0, 1, 2, 3, 4. 
see program /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/game_stats3.cpp
Nello stesso programma trovi anche questo tipo di enumerator:
	enum shipCost {FIGHTER_COST = 25, BOMBER_COST, CRUISER_COST = 50};
this line of code ddefines the enumeration shipCost, which represents the cost for three kind of spaceships in a strategy game. In it, we assign specific integer values to some of the enumerators. The numbers represent the Resource Point value of eac ship. You can assign values to the enumerators if you want. Any enumerators that are not assigned values get the value of the previous enumerator plus one. Because we didn't assign a value to BOMBER_COST, it's initialized to 26. 
Next we define a variable of type "shipCost" e le assegniamo il valore BOMBER_COST
	shipCost myShipCost = BOMBER_COST;   // visto l'enumerator definito sopra ora myShipCost = 26
	cout << "\nTo upgrade my ship to a Cruiser will cost " 
         << (CRUISER_COST - myShipCost) << " Resource Points.\n";    // since CRUISER_COST = 50 and myShipCost = 26 we need : 50 -26 = 24
Esattamente come viene outputtato dal programma:
	To upgrade my ship to a Cruiser will cost 24 Resource Points.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> ENUMERATION see also pag.61 jesse book 
example1 
	enum COLOR { RED, BLUE, GREEN, WHITE, BLACK };
this statement performs two tasks:
	1) it makes COLOR the name of an enumeration; this is a new type
	2) it makes RED a symbolic constant with the value 0, BLUE a symbolic constant with the value 1, GREEN a symbolic constant with the value 2, and so forth. If you don't specify otherwise, the first constant has the value 0, and the rest count up from there. Any one of the constants can be initialized with a particular value, however, and those that are not initialized count upward from the ones before them. Thus, if you write
	enum Color { RED=100, BLUE, GREEN=500, WHITE, BLACK=700 };
then RED has value 100, BLUE the value 101, GREEN the value 500, WHITE the value 501, and BLACK the value 700.
You can define variables of type COLOR, but they can be assigned only one of the enumerated values (in this case RED, BLUE, GREEN, WHITE or ahinoi BLACK.)
-------------------------------------------
example:
-------------------------------------------
#include <iostream>
int main()
{
   enum Days { Sunday, Monday, Tuesday,
            Wednesday, Thursday, Friday, Saturday };
  
   Days today;
   today = Monday;
 
    if (today == Sunday || today == Saturday)
      std::cout << "\nGotta' love the weekends!\n";
   else
      std::cout << "\nBack to work.\n";
  
    return 0;
}
----------------------------------------------------------------------------------------------------------------
NOTE se al posto delle enumerated constants volessi usare le tradizionali constant integers allora il programma diviene:
#include <iostream>
int main()
{
   const int Sunday = 0;
   const int Monday = 1;
   const int Tuesday = 2;
   const int Wednesday = 3;
   const int Thursday = 4;
   const int Friday = 5;
   const int Saturday = 6;
  
   int today;
   today = Monday;
  
   if (today == Sunday || today == Saturday)
      std::cout << "\nGotta' love the weekends!\n";
   else
      std::cout << "\nBack to work.\n";
  
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> EOF end of file
[pag173deitel]
EOF is a symbolic integer constant that is included into the program via the <iostream> header.
EOF can be used as a sentinel value to terminate for example a while loop cycle come nell'esempio di pag 172deitel
- in OS X / linux/UNIX systems end-of-file is entered by typing CTRL+d
- in windows by typing CTRL + z
NOTE in some cases you must press ENTER after the preceding key sequence
NOTE2: quindi quando in un programma vedi richiesto
	Enter end-of-file to end input
significa premere CTRL + Z in windows e CTRL + D in mac/linux
PORTABILITY : testing for the symbolic constant EOF rather than -1 makes programs more portable.


>> eof 
[pag589 deitel]
The eofbit is set for an input stream after end-of-file is encountered. A program can use member function eof to determine whether end-of-file has been encountered on a nstream after an attempt to extract data beyond the end of the stream. The call 
	cin.eof()
returns true if end-of-file has been encountered on cin and flase otherwise.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> ERROR compiling 
You attempt to compile a program that uses type "size_t"  and receive errors indicating that it's not defined
SOLUTION 
Include <cstddef> in your program. 
	#include <cstddef>
li' dalle righe dove sta di solito scritto 
	#include <iostream>
[pag282deitel]

>> ERROR 
	g++ -o hello Hello.ccp 
gives:
	Hello.ccp: file not recognized: File format not recognized
	collect2: ld returned 1 exit status
SOLUTION 
mv Hello.ccp Hello.cpp
/////////////////////////////////////////////////////////////// 
 
>> ESCAPE SEQUENCE
The escape sequence is a pair of characters that begins with a backslash \, which represent special printable characters.
Alcuni esempi di escape sequence da usarsi all'interno di string literals.
	\n     
newline
	\t     
horizontal tab. move the screen cursor to the next tab stop  [ >> \t]
	\r     
carriage return. Position the screen cursor to the beginning of the current line; do not advance to the next line
	\a 
alert. sound the  system bell
	\\
backslash. Used to print a backslash character
	\'
single quote. Used to print a single quote character
	\"
double quote. Used to print a double quote character 	
	\0 
null character
	\b
backspace
	\f
form feed
	\t
horizontal tab
	\v
vertical tab
	\x
hexadecimal number
[pag42deitel and pag22 mike]
And example from pag22 mike
	cout << "\nscore: " << score << endl;
in this example the escape sequence is \n which represents a new line. When sent to cout as part of a string, it's like pressing the Enter key in the console window. 



>> ESCAPE CHARACTER / >> skip character

[http://stackoverflow.com/questions/10220401/c-string-literals-escape-character]

>> EXAMPLE NICE 
Ti elenco qui alcuni nice example che magari ti potrebbero tornare in mente e se ti domandassi "ah dov'era gia' che l'avevo visto, ecco cerco qui di darti un aiutino.
- Example of print bar in chart, printare un tot di asterischi a seconda della frequenza con cui un evento si ripete
	  0-9 :   
	10-20 : **
	20-30 : *****
	30-40 : ***
	40-50 : *
see pag296 e relativo codice pagina 299

>> EXCEPTION HANDLING 
[pag318deitel + pag741 deitel]
In case of out-of-range subscript, we can create fault-tolerant programs with expection handling to continue executing as if no problems were encountered.
More severe problems might prevent a program from continuing normal execution, instead requiring the program to notify the user of the problem, then terminate. When a function detects a problem, such as an invalid array subscript or an invalid argument, it throws an exception (that is an expection occurs)   
To handle an expection, place any code that might throw an expection in a try statement
The try block contains the code that might throw an exception, and the catch block contains the code that handles the exception if one occurs.
Example from fig07_25.cpp [pag316deitel]
   header <stdexcept>
   ....
   vector< int > integers( 10 ); // 10-element vector< int >
   ....
   try 
   {   
      cout << "\nAttempt to display integers.at( 15 )" << endl;
      cout << integers.at( 15 ) << endl; // ERROR: out of range visto che il nostro vettore ha solo 10 elementi
   } // end try
   catch ( out_of_range &ex )
   {   
      cerr << "An exception occurred: " << ex.what() << endl;
   } // end catch
//--------------------------------------------------------------
Nota come nella riga "cout << integers.at( 15 )", the vector member function "at" provides bounds checking and throws an exception if its argument is an invalid subscript. Nell'esempio sopra "at" lancera' un out_of_range exception (from header <stdexcept>) to notify that 15 is out of the range of array "integers" (il cui range e' 10, e' solo un array di 10 elementi)
At this point the try block terminates immediately and the catch block begins executing.
The catch block declares a type (out_of_range) and an exception parameter (ex) that it receives as a reference. The catch block can handle exceptions of the specified type. Inside the block, you can use the parameter's identifier to interact with a caught exception object.
Note2: nella riga ex.what(): this line calls the exception object's "what" member function to get the error message that is stored in the exception object and display it. Once the message is displayed in the example, the exception is considered handled and the program continues with the next statement after the catch block's closing brace. 
////////////////////////////////////////////////////////////////
>> EXCEPTION HANDLING [pag72 moo book]
try { // code  Initiates a block that might throw an exception 
{ catch(t) { /* code */}
			   Concludes the try block and handles excpetions that match the type t. 
			   The code following the catch performs whatever action is appropriate to handle the exception reported in t. 
throw e        Terminates the current function; throws the value e back to the caller
---------------
Exception classes :the library defines several expcetion classes whose names suggest the kinds of problems they might be used to report:
	logic_error 
	domain_error
	invalid_argument
	length_error
	out_of_range
	runtime_error
	range_error
	overflow_error
	underflow_error
e.what()   returns a value that reports on what happened to cause the error.
////////////////////////////////////////////////////////////////
>> exception handling 
[pag741 deitel]
Exception handling enables you to create applications that can resolve (or handle) exceptions. The feautre presented in chapter 17 deitel enable you to write robust and fault-tolerant programs that can deal with problems and continue executing or terminate gracefully.
NOTE
Incorporate your exception-handling strategy into your system from its inception. Including  effective exception handling after a system has been implmented can be difficult.
NOTE2 (from pag 750 deitel): when to use exception handling
Exception handling is designed to process >> synchronous errors, which occur when a statement executes, such as 
	- out of range array subscripts 
	- arithmetic overflow
	- division by zero
	- invalid function parameters 
	- unsuccessful memory allocation (due to lack of memory) 
Execption handling is not desinged to process errors associatd with >> asynchronous events (e.g. disk I/O completions, netword message arrivals, mouse clicks and keystrokes), which occur in parallel with and independent of the program's flow of control.  
EXAMPLES 
- exception handling division by zero -> pag 741-742 deitel
[/home/dia/Deitel-Code_Examples/ch17/fig17_01_02/fig17_01_02.cpp]
nota: l'abbiamo lanciato in visualstudio abbiamo carito il main come al solito in canovaccio.cpp, quindi dall'esplorer tree sulla sinitra -> click destro su header e abbiamo selezionato -> add quindi abbiamo selezionato l'*.h che avevamo copiato nella stessa cartella contenente il main.
	double quotient( int numerator, int denominator )
	{
	   // throw DivideByZeroException if trying to divide by zero
	   if ( denominator == 0 )
	      throw DivideByZeroException(); // terminate function
	
	   // return division result
	   return static_cast< double >( numerator ) / denominator;
	} // end function quotient
in this example (fig17_01_02.cpp line 10) we define a function named quotient that receives two inteegers input by the user and divides its first int parameter by its second int parameterBefore performing the devision , the function casts the first int parameter's value to type double. Then, the second int parameter's value is (implicitly) promoted to type double for the calculation. So function quotient actually performs the division using two double values and returns a double result.
The example consists of two files DivideByZeroException.h defines an exception class that represents the type of the problem that might occur in the example, and fig17_02.cpp (fig17.2) defines the quotient function and the main function that calls it. Function main contains the code that demonstrates exception handling.
[segue extract from /home/dia/Deitel-Code_Examples/ch17/fig17_01_02/DivideByZeroException.h]
	class DivideByZeroException : public std::runtime_error 
	{
	public:
	   // constructor specifies default error message
	   DivideByZeroException()
	      : std::runtime_error( "attempted to divide by zero" ) {}
	}; // end class DivideByZeroException
///////////////////////////
DivideByZeroException.h defines class DivideByZeroException as a derived class of Standard Library class runtime_error (from header <stdexcept>). Class runtime_error (a derived class of exception) (from header <exception>) is the C++ standard base class for representing runtime errors. Class exception is the standard C++ base class for exception in the C++ Standard Library. 
Every exception class that derives directly or indirectly from exception contains the virtual function what, which returns an exception object's error message. You're not required to derive a custom exception class, such as DivdieByZeroException, from the standard exception classes provided by C++. However, doing so allows you o use the virtual function what to obtain an appropriate message error.
------------------------
Qualche osservazione sul programma principale /home/dia/Deitel-Code_Examples/ch17/fig17_01_02/fig17_01_02.cpp: 
 32       try
 33       {
 34          double result = quotient( number1, number2 );
 35          cout << "The quotient is: " << result << endl;
 36       } // end try
 37       catch ( DivideByZeroException &divideByZeroException )
 38       {
 39          cout << "Exception occurred: "
 40             << divideByZeroException.what() << endl;
 41       } // end catch
Nota come in questo esempio, because the invocation of function quotient (line34) can throw an exception, we enclose this function invocation ina a try block. The as seen in section 7.10 at least one "catch" handler must immediately follow each try block.
An exception parameter should always be declared as a reference to the type of exception the catch handler can process (DivideByZeroException in this case). This prevents copying the exception boejct when it's caught and allows a catch handler to properly catch derived-class  expcetions as well.
NOTE1: it'a sintax error to place code between a try block and its corresponding catch handlers or between its catch handlers.
NOTE2: Each catch handler can have only a single parameter; specifying a comma-separated list of exception parameters is a syntax error.
------------------------------------------------
Termination model of exception handling
If an exception occurs as the result of a statement in a try block, the try block expires (i.e. terminates immediately). Next, the program searches for the first catch handler that can process the type of eception that occurred. THe program locates the matching catch by comparing the thrown exception's type to each catch's exception-parameter type until the program finds a match. A match occurs if the types are identical or if the thrown exception's type is a derived class of the exception-parameter type. 
When a match occurs, the code in the matching catch handler executes. 
When a catch handler finishes processing by reaching its closing right brace (}) the exception is considered handled and the local variables defined within the catch handler (including the catch parameter) go out of scope. Program control does not return to the point at which the exception occured  (known as >> throw point), because the try block has expired. Rather control resumes with the first statement (line 43) after the lastcatch handler following the try block.  
This is known as the 
	>> termination model of exception handling. 
Some languages use the 
	>> resumption model of exception handling, in which after an exception is handled, control resumes just after the throw point. As with any other block of code, when a try block terminaes, local variables defined in the block go out of scope.
 27    // enable user to enter two integers to divide
 28    while ( cin >> number1 >> number2 )
 29    {
 30       // try block contains code that might throw exception
 31       // and code that will not execute if an exception occurs
 32       try
 33       {
 34          double result = quotient( number1, number2 );
 35          cout << "The quotient is: " << result << endl;
 36       } // end try
 37       catch ( DivideByZeroException &divideByZeroException )
 38       {
 39          cout << "Exception occurred: "
 40             << divideByZeroException.what() << endl;
 41       } // end catch
 42 
 43       cout << "\nEnter two integers (end-of-file to end): ";
 44    } // end while
NOTE: logic errors can occur if you assume that after an exception is handled, control will return to the first statement after the throw point.
If the try block completes its execution successfully (= no exceptions occur in the try block) then the program ignores the catch handlers and program control continues with the first statement after the last catch following that try block.
NOTE2: >> stack unwinding : If an exception that occurs in a try block has no matching catch handler, or if an exception occurs in a statement that is not in a try block, the function that contains the statement terminates immediately, and the program attempts to locate an enclosing try block in the calling function. This process is called stack unwinding. 
NOTE3: To throw an exception we uses the keyword throw followed by an operand of the type of exception to throw. Normally, a throw statement specifies one operand. (in section 17.3 we discuss how to use a throw statement with no operand). The operand of a throw can be of any type (but it must be copy constructable). If the operand is an object, we call it an >> exception object (in the example above the exception object is of type DivideByZeroException)
 10 double quotient( int numerator, int denominator )
 11 {
 12    // throw DivideByZeroException if trying to divide by zero
 13    if ( denominator == 0 )
 14       throw DivideByZeroException(); // terminate function
 15 
 16    // return division result
 17    return static_cast< double >( numerator ) / denominator;
 18 } // end function quotient
NOTE4: when line 14 throws the exception, function quotient exits immediately. So, line 14 throws the exception before function quotient can perform the division in line 17. This ia a central characteristic of exception handling: If your program explicitly throws an exception, it should do so before the error has an opportunity to occur.
------------------------------------------------------------------------------------
>> Exception rethrowing / >> rethrowing an exception
[pag747 deitel]
EXAMPLE
/home/dia/Deitel-Code_Examples/ch17/fig17_03/fig17_03.cpp
NOTES: a function might use a resource (like a file) and might want to >> release the resource (i.e. close the file) if an exception occurs. An exception handler, upon receviving an exception, can release the resource then notify its caller than an exception occurred by rethrowing the exception via the statement
	throw;
Regardless of whether a handler can process an exception, the handler can rethrow the exception for further processing outside the handler. The next enclosing try block detects the rethrown exception, which a catch handler listed after that enclosing try block attemps to handle. 
ATTENTION: executing an empty throw statement outside a catch handler abandons exception processing and terminates the program immediately.
-------------------------------------------------------------------------------------------------------------
>> stack unwinding
[pag748 deitel]
When an exception is thrown byt not caught in a particular scope, the function call stack is "unwound" and an attempt is made to catch  the exception in the next outer try...catch block. Unwinding the function call stack means that the function in which the exception was not caught terminates, and control returns to the statement that originally invoked that function. If a try block encloses that statement, an attempt is made to catch the exception. If a try block does not enclose that statement, stack unwinding occurs again. If no catch handler ever catches this exception, the program terminates.
EXAMPLE:
	/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_04/fig17_04.cpp
OUTPUT 
function1 is called inside main
function2 is called inside function1
function3 is called inside function2
In function 3
Exception occurred: runtime_error in function3
Exception handled in main
------------------------------------------------------------------------
>> exeception handling destructors constructors / >> constructors and exception handling / >> destructors and exception handling
[pag751 deitel] 
How should an object's constructor respond when it receives invalid data?
The preferred way is to require the constructor to throw an exception that contains the error information, thus offering an opportunity for the program to handle the failure.
- Destructor should catch exceptions to prevent program termination.
- Do not throw exceptions from the constructor of an object with static storage duration. Such exception cannot be caught.
------------------------------------------------------------------------
>> exception and inheritance / >> inheritance and exception 
[pag752 deitel]
If a catch handler catches a reference to an exception object of a base-class type, it also can catch a reference to all objects of classes publicly derived from that base class - this allows for polymorphic processing of related exceptions.
--------------------------------------------------------------------------
>> bad_alloc / >> failures processing 
[pag752 deitel]
When operator new fails, it throws a bad_alloc exception (defined in header <new>). 
A) >> new throwing bad_alloc on failure [pag752 deitel]
EXAMPLE 
	/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_03/fig17_03.cpp
///////////////////////////////////
	// Fig. 17.3: fig17_03.cpp
	// Rethrowing an exception.
	#include <iostream>
	#include <exception>
	using namespace std;
	
	// throw, catch and rethrow exception
	void throwException() 
	{
	   // throw exception and catch it immediately
	   try 
	   {
	      cout << "  Function throwException throws an exception\n";
	      throw exception(); // generate exception
	   } // end try
	   catch ( exception & ) // handle exception
	   {
	      cout << "  Exception handled in function throwException"
	         << "\n  Function throwException rethrows exception";
	      throw; // rethrow exception for further processing
	   } // end catch
	
	   cout << "This also should not print\n";
	} // end function throwException
	
	int main()
	{
	   // throw exception
	   try 
	   {
	      cout << "\nmain invokes function throwException\n";
	      throwException();
	      cout << "This should not print\n";
	   } // end try
	   catch ( exception & ) // handle exception
	   {
	      cout << "\n\nException handled in main\n";
	   } // end catch
	
	   cout << "Program control continues after catch in main\n";
	} // end main
////////////////////////////////
OUTPUT [su orion I]
	ptr[0] points to 50,000,000 new doubles
	ptr[1] points to 50,000,000 new doubles
	ptr[2] points to 50,000,000 new doubles
	ptr[3] points to 50,000,000 new doubles
	Exception occurred: bad allocation
------------------------
NB: the output shows that the prorgam performed only four iterations of the loop before new failed and threw the bad_alloc excetion. Your output might differ based on the physcal memory, disk space available for virtual memory [cioe' quello che mi sembra si chiami swap memory] on your system and the compiler you're using. 

B) >> new returning nullptr on failure [pag753 deitel]
The C++ standard specifies that programmers can use an older version of new that returns nullptr upon failure. For this purpose, header <new> defines object nothrow (of type nothrow_t) which is used as follows:
	double *ptr = new( nothrow ) double [ 50000000 ];
MA :
CONSIGLIO: to make programs more robust, use the version of new that throws bad_alloc exceptions on failure (cioe' l'opzione A) esposta poco sopra).
C) >> set_new_handler [pag754 deitel] / >> handling new failures using function set_new_handler
[pag754 deitel]
An additonal feature for handling new failures is function set_new_handler (prototyped in standard header <new>).
This function takes as its argument a pointer to a function that takes no arguments and returns void. This pointer points to the function that will be called if new fails. This provides you with a uniform approach to handling ALL "new" failures, regardless of where a failure occurs in the program. Once set_new_handler registers a new handler in the program, operator new does not throw bad_alloc on failure; rather, it defers the error handling to the new-handler function.
- If new allocates memory successfully, it returns a pointer to that memory. 
- If new allocates memory successfully, it returns a pointer to that memory. If new fails to allocate memory and set_new_handler did not register a new-handler function, new throws a bad_alloc exception.
See example : /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_06/fig17_06.cpp
-------------------------------------------------------------------------------------------------
>> EXCEPTION HIERARCHY / >> STANDARD LIBRARY EXCEPTION HIERARCHY
[pag758 deitel]
Some of the standard library exception classes
    
                                 exception
                                     |
            ---------------------------------------------------
            |                        |                        |
        runtime_error                |                   logic_error
            |                        |                        | 
    -------------------              |           -------------------------------
    |                 |              |           |            |                |
overflow_error    underflow_error    |    invalid_argument   length_error   out_of_range
                                     |
            -------------------------------------------
            |           |            |                |
         bad_alloc   bad_cast     bad_type_id     bad_exception

The Standard library includes a hierarchy of exception classes, some of which are shown in the sketch above [Thanks Ciccio]
This hierarchy is headed by base-class exception (defined in header <exception>), which contains virtual function what that derived classes can override to issue appropriate error messages. 
-------------------------
[vediamo il ruolo di alcune delle classi presentatenell'esempio sopra]
>> invalid_argument [vedi sopra] = indicates that a function received an invalid agurment.
>> length_error indicates that a length larger than the maximum size allowed for the object being manipulated was used for that objects.
>> out_of_rage = indicates that a value, such as a subscript in to an array, exceeded its allowed range of values. 
>> overflow_error = describes an arithmetic overflow error (i.e. the result of an arithmetic operation is larger than the largest number that can be stored in the computer)
>> underflow_error = describes an arithmetic underflow error (i.e. the result of an arithmetic operation is smaller than te smallest number that can be stored in the computer)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C# [pag34 mike]: C# is a progamming language created by Microsoft intended to be both simple and general purpose. C# was influenced by and bears much similarity to C++ but the two are separate and distinct languages. 


>> EXIT 
[pag 392deitel]
the function exit forces a program to terminate immediately and does not execute the destructors of local objects. 
The "exit" function often is used to terminate a program when a fatal unrecoverable error occurs.

>> EXPONENTIAL COMPLEXITY 
[nell'ambito delle recursive functions]
[pag255deitel]
A word of caution is in order about recursive programs like the one we used (pag253) to generate Fibonacci numbers. The number of recursive calls that are required to calculate the nth Fibonacci number is on the order of 2^n.
Calculating the 30th Fibonacci number would require on the order of 2^30 or about a billion calls. Computer scientists refer to this as exponential complexity. Problems of this nature humble even the world's most powerful computers! Complexity issues in general, and exponential complexity in particular, are discussed in detail in the upper-level computer science course generally called "Algorithms".


>> FFFFFFF

>> failbit 
[pag589 deitel]
failbit is set for a stream when a format error occurs on the stream and no characters are input (e.g. when you attempt to read a number and the user enters a string). When such an error occurs, the characters are not lost. The fail member function reports whether a stream operation has failed. Usually recovering from such errors is possible.
>> badbit is set for a stream when an error occurs that results in the loss of data. The "bad" member function reports whether a stream operation failed. Generally such serious failures are not recoverable.
>> goodbit [pag589 deitel]
>> rdstate [pag589 deitel]
>> clear : clear member function is used to restore a stream's state to "good" so that I/O may proceed on the stream. The default argument for clear is goodbit, so the statement 
	cin.clear()
clear cin and sets goodbit for the stream. The statement
	cin.clear(ios::failbit)
sets the failbit.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> false true and difference between equality (==) and assignment (=) operators.
In C++ any expression that produces a value can be used in the decision portion of any control statement. It the value of the expression is zero, it's treated as the value false, and if the value is nonzero, it's treated as the value true.
Per evitare di confondere == equality con = assignment un possibilita' e' quella di non scrivere x == 7 bensi' 7 == x 
in tal modo you'll be protected by the compiler if you accidentally replace the == operator with =. In effetti 7 == x e' corretto (si sta giusto verificando se x sia uguale a 7) mentre 7 = x dona errore visto che una costante non puo' essere modificata. 
Nomenclatura:
lvalues = variable names are said to be lvalues (for left values) because they can be used on the left side of an assignment operator. Constant are said to be rvalues (for right values) because they can be used on only the right side of an ssignment operator. Lvalues can also be used as rvalues but not vice versa. 
[pag185deitel] 

>> FRAME GREETING / >> SIZE ADJUSTABLE FRAME GREETING [pag12 moo book]
---------------------------------------------------------------------- START 
// ask for a person's name, and generate a framed greeting
#include <iostream>
#include <string>

int main()
{
	std::cout << "Please enter your first name: ";
	std::string name;
	std::cin >> name;

	// build the message that we intend to write
	const std::string greeting = "Hello, " + name + "!";

	// build the second and fourth lines of the output
	const std::string spaces(greeting.size(), ' ');  // nota come il secondo parametro di spaces sia un ' ' character literal. 
    // A >> character literal [pag14 moo book] is always enclosed in single quotes; 
    // a string is always enclosed in double quotes.
    // The type of a character literal is the built-in char.
	// A character literal represents a single character. 	
	// The characters that have special meaning inside a string literal have the same special 
	// meaning in a character literal 
	// thus if we want ' or \ we must precede it by \.
	const std::string second = "* " + spaces + " *";    // >> CONCATENATE STRING / >> CONCATENATE STRING example 
                             // questo e' anche un esempio pratico di  [pag13 moo book]: when an operator has different meanings for operands of different types, we say that the operator is overloaded. 

	// build the first and fifth lines of the output
	const std::string first(second.size(), '*');   

	// write it all
	std::cout << std::endl;
	std::cout << first << std::endl;
	std::cout << second << std::endl;
	std::cout << "* " << greeting << " *" << std::endl;
	std::cout << second << std::endl;
	std::cout << first << std::endl;

	return 0;
}
----------------------------------------------------------- END
OUTPUT 
Please enter your first name: EriKlein_DialinEastWood_YuiLee

******************************************
*                                        *
* Hello, EriKlein_DialinEastWood_YuiLee! *
*                                        *
******************************************
verykool!!!
------------------------------------------
Trovi anche un altro esempio di Framing a picture a pag 92 moo book 
Gli dai in input un vettore di stringe per esempio un vector string is cui elementi sono 
	"this is an"
	"example"
	"to"
	"illustrate"
	"framing"
e ti dona in output 
    **************
	* this is an *
	* example    *
	* to         *
	* illustrate *
	* framing    *
    **************	
in modo che la stringa piu' lunga del vettore stringa, impartisce la larghezza del frame.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C++ FEATURES from chapter 23 Jordan deitel [pag939]
the following interesting features are presented :
	>> const_cast operator [deitel p939]: this operator allows you to add or remove the const qualification of a variable. 
	[>> volatile pag939 deitel]
		C++ provides the const_cast operator for casting away const or volatile qualification. You declare a variable with the >> volatile qualifier when you expect the variable to modified by hardware or other programs not known to the compiler. Declaring a variable volatile indicates that the compiler should not optimize the use of that variable because doing so could affect the ability of those other programs to access and modify the volatile variable.
		DEMO: DANGER! in general it's dangerous to use the const_cast operator, because it allows a program to modify a variable that was declared const. There are cases in which it's desirable, or even necessary to cast away const-ness. Example you could pass non const data to a function that treats the data as if it were constant, then returns that data as a constant. In such cases, you might need to cast away the const-ness of the returned data. [>> cast away the const-ness = gettar via, buttar via la "const"anza della variabile, renderla quindi modificable da altri operatori/programmi]
		In conclusione: in general a const_cast should be used only when it is known in advance that the original data is not constant. Otherwise, unexpected results may occur.
	>> namespaces : can be used to ensure that every identifier in a program has a unique name and can help resolve naming conflicts caused by using libraries that have the same variable, function or class names.
	>> operator keywords: useful for programmers who have keyboards that do not support certain characters used in operator symbols, such as !, &, ^, ~ and | . 
	>> multiple inheritance : enables a derived class to inherit the members of several base classes. As part of this introduction, we discuss potential problems with multiple inheritance and how virtual inheritance can be used to solve them. 
---------------------------------------------------------------------------------------------------
	>> mutable class members [deitel pag941]: consider a lined list that maintains its contents in sorted order. Searching through the  linked list does not require modifications to hte data of the linked list, so the search function could be a const member function of the linked list class. However, it's conceivable that a linked-list object, in an effort to make future searches more efficient, might keep track of the location of the last successful match. If the next search operation attempts to locate an item that appears later in the list, the search could begin from the location of the last successufl match, rather than from the beginning of the list. To do this, the const member function that performs the search must be able to modify the data member that keeps track of the last successful search. 
If a data member such as the onle described above should always be modifiable, C++ provides the storage-class specifier mutable as an alternative to const_cast. A mutable data member is always modifiable, even in a const member function or const object. 
	mutable and const_cast are used in different context. FOr a const objectwith no mutable data members, operator const_cast must be used every time a member is to be modified. This greatly reduces the chance of a member being accidentally modified because the member is not permanently modifiable. Operations involving const_cast are typically hidden in a member function's implementation. The user of a class might not be aware that a member is being modified. 
NOTE: mutable members are useful in classes that have "secret" implementation details that do not contribute to a client's use of an object of the class.
EXAMPLE 
	#include <iostream>
	using namespace std;
	// class TestMutable definition
	class TestMutable
	{
	public:
	   TestMutable( int v = 0 )
	   {
	      value = v;
	   } // end TestMutable constructor
	
	   int getValue() const
	   {
	      return value++; // increments value
	   } // end function getValue
	private:
	   mutable int value; // mutable member
	}; // end class TestMutable
	int main()
	{
	   const TestMutable test( 99 );
	
	   cout << "Initial value: " << test.getValue();
	   cout << "\nModified value: " << test.getValue() << endl;
	} // end main
///////////////////////////////////////////////////////////////
Output 
Initial value: 99
Modified value: 100
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> FINAL member function 
pag532deitel
In C++11 a base class virtual function that's declared final in its prototype, as in 
	virtual someFunction (parameter) final;
cannot be overridden in any derived class.

>> file 
[pag600 deitel]
C++ views file simply as a sequence of bytes. Each file ends either with an end-of-file marker or at a specific byte number recorded in an operating system maintained, administrative data structure.
When a file is opened, an object is created and a stream is associated with the object.
>> file processing [pag 600 deitel]
to perform file processing in C++ headers <iostream> and <fstream> must be included. 
see fig 14.2 pag 601 per una rappresentazione della strem I/O template hierarchy
NOTE: C++ imposes no structure on a file. Thus, a concept  like that of a >> record does not exist in  C++ file. You must structure files to meet the application's requirements. The example 14.3 pag 602 deitel shows how you can impose a simple record structure on a file. 
At line 
   // ofstream constructor opens file                
   ofstream outClientFile( "clients.txt", ios::out );
we can see that two argument are passed to  the object's constructor: 
	- the filename 
	- the open mode
For an ofstream object, the file-open mode can be either ios::out (the default) to output data to a file or ios::app to append data to the end of a file (without modifying any data already in the file). Since ios::out is the default, the second constructor argument in line 12 is not required. Existing files opened with mode ios::out are >> truncated = all data in the file is discarded. If the specified file does not yet exist, then the ofstream object creates the file, using that filename. 
NOTE: use caution when opening an existing file for output (ios::out) especially when you want to preserve the file's contents, which will be discarded without warning.
The line 
   ofstream outClientFile( "clients.txt", ios::out );
[from fig 14.3 pag 602 deitel] creates an ofstream object named outClientFile associated with the file clients.txt that's opened for output. The arguments "clients.txt" and ios::out are passed to the ofstream constructor, which opens the file (this establishes a line of communication with the file). By default, ofstream objects are opened for output, so the previous line could also been written by simply using
   ofstream outClientFile( "clients.txt");
to open clients.txt for output. There are other file-open mode:
[>> FILE OPEN MODES pag 603 deitel]
	>> ios::app		append all output to the end of the file
	>> ios::ate		open a file for output and move to the end of the file (normally used to append data to a file). Data can be written anywhere in the file
	>> ios::in 		open a file for input
	>> ios::out 	open a file for output
	>> ios::trunc 	discard the file's contents (this also is the default action for ios::out)
	>> ios::binary  open a file for binary, i.e. nontext, input or output
NOTE puoi anche aprire un file usando the open Member function. See voce FILE OPEN
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> Flag meaning in C++
ASNWER1
[also: http://www.dreamincode.net/forums/topic/260211-what-does-flag-really-mean/]
a flag is a boolean variable, and a boolean variable is a variable that has only two possible values: true or false.
It is used when you want your program to make a decision based on the answer to a question that must be answered only 'yes' or 'no'.
For example, if you want your program to continue asking the user for input as long as the user has input to enter, you might write (in pseudocode)
1    my_flag_variable <= "yes"
2     
3    while my_flag_variable is "yes"
4        print "please enter input"
5        process user's input
6        print "do you want to continue?" (yes or no)
7        my_flag_variable <= user's response
8     
9    finished with input; do something else
In that example I used "yes" to represent true and "no" to represent false. In actual code you would use the constants true and false, or you might use 1 to represent true and 0 to represent false. Theoretically the specific values don't matter, as long as there are only 2 possibilities.
The point is that the program makes a decision (keep asking for input, or stop) based on the yes/no value of the flag variable.
ANSWER2
[source : http://forum.codecall.net/topic/41978-what-is-the-meaning-of-flag-in-c/]
A flag, or sentinel, is any variable that's sole purpose is to indicate when a key point in the processing has been reached. This include things like breaking out of a loop, being able to access a resource shared between threads, etc.
the code would resemble this:
	bool isprime=true;
	for (int i=2;i<n;i++){
	  if n%i == 0 then isprime=false;
	}
	if isprime cout<<n<<" is prime"
	else cout<<n<<" is not prime";
in this case, isprime is a flag
ANSWER3
Flags can also be fixed values for indicating state, mode, behavior, or similar. A fine example is the modes given to fstream:: open in C++. One can pass either ios_base::app, ios_base::ate, ios_base::binary, ios_base::in, ios_base:: out, ios_base::trunc or even several of them together. Each of them will change how the file is being opened.

>> float : floating point number; 4 bytes; 
range +/-3.4e  +/-38 (~7digits)
ex
3.14159
6.02e23  // questa notazione = 6.02*10^23
            [e' il mitico numero di Avogadro!]
1.6e-19  // = 1.6*10-19 [charge of an electron]
- NB: the default type for floating point literals is double. If you explicity want to express a float or long double numerical literal :
3.14159L // long double 
6.02e23f // float  
[le lettere L e f le puoi sia scrivere in minuscole che maiuscole, e' indifferente.]

>> FOR LOOP / FOR CYCLE
esempio un ciclo for che viene ripetuto 10 volte
	for ( unsigned int counter = 1; counter <= 10; ++counter )   // for header
	{
          ...istruzioni;
	}
[pag159deitel]
non devi necessariamente scrivere tutte e tre gli statements all'interno delle ()@del for cycle
Per esempio se vuoi creare un infinite loop puoi omettere la condition
	for ( unsigned int counter = 1; ; ++counter ) // infinite loop
    {
		..istruzioni;
    }
ATTENTION: DO NOT write a ; after the ) of a for header because the ; would make the body of that "for" statement an empty statement.
[pag162deitel]
altro esempio questa volta from pag28 moo book, usando un integer counter:
	for (int i = 0; i != limit; ++i)    // >> for header 
	{
		... istruzioni        // >> for body
	}

NOTE: "i" will take the range [0,limit) cioe' un >> half open range dove [,) la parentesi quadra a sinistra sta ad indicare che i assume il valore 0, mentre ) sta ad indicare che "i" non riesce mai ad assumere il valore limit. 
NOTE: strong advice [from pag 30 31 moo book] meglio sempre usare contatori che partono da 0, e non da 1, evita confusione ed e' piu' chiaro. Vedi ragioni a pag30-31 moo book
NOTE: il precedente ciclo for e' la forma piu' compatta e del tutto equivalente del seguente ciclo while:
	int i = 0;
	while (i != limit) 
	{
		...istruzioni 
		++i;
	}
------------------------------------
Other observations from pag162deitel
- for statement  can contain arithmetic expressions
- the increment of a for statement can be negative => the loop actually counts downwards.
- if the loop-continuation condition is initially false, the body of the for statement is not performed. Instead execution proceeds with the statement following the for
- although the value of the control variable can be changed in the body of a for statement, avoid doing so, because this can lead to subtle logic errors.
- do not use equality operators != or == in a loop continuation condition if the loop's control variable increments or decrements by more than 1 (reason -> see star tag @pag164deitel)
- SOME FOR STATEMENT EXAMPLE pag163deitel
esempio 1
	for (unsigned int i = 1; i <= 100; ++i ) // vary the control variable from 1 to 100 in increments of 1
esempio 2 : vary the control variable from 100 down to 0 in decrements of 1. 
	for ( int i = 100; i >= 0; --i)
Notice we use type int poiche' la condition does not becomes false until control variable i contains -1, so the control variable must be able to store both positive and negative numbers.
esempio 3
	for (unsigned int i = 7; i <= 77; i += 7 ) // pag164deitel
vary control variable from 7 to 77 in steps of 7
esempio 4
	for (unsigned int i = 20; i >= 2; i -= 2 )
vary the control variable from 20 to 2 in steps of -2
------------------------------------------------------------------------------------
>> FOR LOOP MIKE pag 77
Like its cousin while loop, the for loop lets you repeat a section of code, but for loops are particularly suited for counting an moving through a sequence of things (like the items ina an Role Playing Game character's intentory). 
The generic form of for loop is:
	for (initialization; test; action)
		statement;
initialization is a statement that setps up some initial condition ofr the loop. (for example it might set a counter variable to 0). The expression test is tested each time before the loop body executes, just as in a while loop. If test is false, the program moves on to the statement after the loop. If test is true, the program executes statement. Next, action is executed (which often involves incrementing a counter variable). The cycle repeats until test is false, at which point the loop ends.
Example:
////////
// Counter
// Demonstrates for loops

#include <iostream>

using namespace std;

int main()
{
    cout << "Counting forward:\n";
    for (int i = 0; i < 10; ++i)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting backward:\n";
    for (int i = 9; i >= 0; --i)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting by fives:\n";
    for (int i = 0; i <= 50; i += 5)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting with null statements:\n";
    int count = 0;
    for ( ; count < 10; )   // anche questa forma e' del tutto legale, visto che in questo caso initializzi il count prima del loop e incrementi la variabile all'interno del loop body
    {
        cout << count << " ";
        ++count;
    }   // il risultato di un loop del genere finisce quindi per essere 
        // del tutto equivalente al primo loop scritto sopra  
        // for (int i = 0; i < 10; ++i)	{   cout << i << " ";}

	// >> nested loop example
    cout << "\n\nCounting with nested for loops:\n";
    const int ROWS = 5;
    const int COLUMNS = 3;
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << i << "," << j << "  ";
		}

        cout << endl;
    }

	return 0;
}
--------------------------------------------------------- OUTPUT

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
Counting forward:
0 1 2 3 4 5 6 7 8 9

Counting backward:
9 8 7 6 5 4 3 2 1 0

Counting by fives:
0 5 10 15 20 25 30 35 40 45 50

Counting with null statements:
0 1 2 3 4 5 6 7 8 9

Counting with nested for loops:
0,0  0,1  0,2
1,0  1,1  1,2
2,0  2,1  2,2
3,0  3,1  3,2
4,0  4,1  4,2

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>pause
sL[ . . .
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> FOO meaning 
ASNWER1
Used very generally as a sample name for absolutely anything, esp. programs and files (esp. scratch files). 
    First on the standard list of metasyntactic variables used in syntax examples. See also bar, baz, qux, quux, garply, waldo, fred, plugh, xyzzy, thud.
    When 'foo' is used in connection with 'bar' it has generally traced to the WWII-era Army slang acronym FUBAR ('Fucked Up Beyond All Repair' or 'Fucked Up Beyond All Recognition'), later modified to foobar. Early versions of the Jargon File interpreted this change as a post-war bowdlerization, but it it now seems more likely that FUBAR was itself a derivative of 'foo' perhaps influenced by German furchtbar (terrible) - 'foobar' may actually have been the original form.
    For, it seems, the word 'foo' itself had an immediate prewar history in comic strips and cartoons. The earliest documented uses were in the Smokey Stover comic strip published from about 1930 to about 1952. Bill Holman, the author of the strip, filled it with odd jokes and personal contrivances, including other nonsense phrases such as "Notary Sojac" and "1506 nix nix". The word "foo" frequently appeared on license plates of cars, in nonsense sayings in the background of some frames (such as "He who foos last foos best" or "Many smoke but foo men chew"), and Holman had Smokey say "Where there's foo, there's fire".
    According to the Warner Brothers Cartoon Companion Holman claimed to have found the word "foo" on the bottom of a Chinese figurine. This is plausible; Chinese statuettes often have apotropaic inscriptions, and this one was almost certainly the Mandarin Chinese word fu (sometimes transliterated foo), which can mean "happiness" or "prosperity" when spoken with the rising tone (the lion-dog guardians flanking the steps of many Chinese restaurants are properly called "fu dogs"). English speakers' reception of Holman's 'foo' nonsense word was undoubtedly influenced by Yiddish 'feh' and English 'fooey' and 'fool'.
    Holman's strip featured a firetruck called the Foomobile that rode on two wheels. The comic strip was tremendously popular in the late 1930s, and legend has it that a manufacturer in Indiana even produced an operable version of Holman's Foomobile. According to the Encyclopedia of American Comics, 'Foo' fever swept the U.S., finding its way into popular songs and generating over 500 'Foo Clubs.' The fad left 'foo' references embedded in popular culture (including a couple of appearances in Warner Brothers cartoons of 1938-39; notably in Robert Clampett's "Daffy Doc" of 1938, in which a very early version of Daffy Duck holds up a sign saying "SILENCE IS FOO!") When the fad faded, the origin of "foo" was forgotten.
    One place "foo" is known to have remained live is in the U.S. military during the WWII years. In 1944-45, the term 'foo fighters' was in use by radar operators for the kind of mysterious or spurious trace that would later be called a UFO (the older term resurfaced in popular American usage in 1995 via the name of one of the better grunge-rock bands). Because informants connected the term directly to the Smokey Stover strip, the folk etymology that connects it to French "feu" (fire) can be gently dismissed.
    The U.S. and British militaries frequently swapped slang terms during the war (see kluge and kludge for another important example) Period sources reported that 'FOO' became a semi-legendary subject of WWII British-army graffiti more or less equivalent to the American Kilroy. Where British troops went, the graffito "FOO was here" or something similar showed up. Several slang dictionaries aver that FOO probably came from Forward Observation Officer, but this (like the contemporaneous "FUBAR") was probably a backronym . Forty years later, Paul Dickson's excellent book "Words" (Dell, 1982, ISBN 0-440-52260-7) traced "Foo" to an unspecified British naval magazine in 1946, quoting as follows: "Mr. Foo is a mysterious Second World War product, gifted with bitter omniscience and sarcasm."
    Earlier versions of this entry suggested the possibility that hacker usage actually sprang from FOO, Lampoons and Parody, the title of a comic book first issued in September 1958, a joint project of Charles and Robert Crumb. Though Robert Crumb (then in his mid-teens) later became one of the most important and influential artists in underground comics, this venture was hardly a success; indeed, the brothers later burned most of the existing copies in disgust. The title FOO was featured in large letters on the front cover. However, very few copies of this comic actually circulated, and students of Crumb's oeuvre have established that this title was a reference to the earlier Smokey Stover comics. The Crumbs may also have been influenced by a short-lived Canadian parody magazine named 'Foo' published in 1951-52.
[source http://www.catb.org/jargon/html/F/foo.html]
nice website about jargon actually http://www.catb.org/jargon/html/index.html
ANSWER2
It's a metasyntactic variable. A metasyntactic variable is a placeholder name used in computer science, a word without meaning intended to be substituted by some objects pertaining to the context where it is used. The word foo as used in IETF Requests for Comments is a good example.
By mathematical analogy, a metasyntactic variable is a word that is a variable for other words, just as in algebra letters are used as variables for numbers.[1] Any symbol or word which does not violate the syntactic rules of the language can be used as a metasyntactic variable. For specifications written in natural language, nonsense words are commonly used as metasyntactic variables.
Metasyntactic variables have a secondary, implied meaning to the reader (often students), which makes them different from normal metavariables. It is understood by those who have studied computer science that certain words are placeholders or examples only and should or must be replaced in a production-level computer program
[sources http://en.wikipedia.org/wiki/Metasyntactic_variable]
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////


>> FOR STATEMENT MULTIDIMENSIONAL ARRAY / >> for statement 2-D arrays / >> for 2-D arrays / >> for 2d arrays
[pag306deitel]
We use a nested loop in which the outer loop iterates through the rows and the inner loop iterates through the columns of a given row.
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
	{
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			cout << a[ row ][ column ] << ' ';
		cout << endl;
	} // end outer for 
[see example pratico pag305]

>> FOR STATEMENT UML activity diagram
see pag 163deitel

>> FORMAL PARAMETER 
cioe' i parametri che trovi all'interno delle parentesi ( ) quando si chiama una funzione
vedi per esempio line 56 pag 20deitel
nella linea 56 trovi la function call
	maximumGrade = maximum (grade 1, grade2, grade3 );
e a partire dalla linea 60 comincia la function definition 
	int GradeBook::maximum( int x, int y, int z ) const
nota come there must be one argument in the function call for each parameter (also called  formal parameter) in the function definition.
Inoltre la riga 60 della function definition matches the function prototype and indicates that the parameter names are x, y, z. 

>> FORMAT NUMERIC OUTPUT 
[see pag167deitel]
trovi esempi utili su come giustificare dei numeri a destra, sinistra, allinearli in modo da far coincidere il punto decimale ect.

>> format resetting / >> fmtflags />> flags
[pag586 deitel]
Puoi use flags al fine di return an output stream's format to its default state after having applied several manipulations.
Member function flags without an argument return the current format settings as an fmtflags data type (of class ios_base) [fmtflags = format flags], which represent the format state. Member function flags with an fmtflags argument sets the format state as specified by the argument and return the prior state settings.
Ex fig 13.21 pag 587 uses member function flags to save the stream's original format state (line 17)
///////
   // use cout flags function to save original format
   ios_base::fmtflags originalFormat = cout.flags();
   cout << showbase << oct << scientific; // change format
///////
then restore the original format setting (line25)
///////
   // display flags value, int and double values (original format)
   cout << "The restored value of the flags variable is: " 
      << cout.flags()
///////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> FRIEND FUNCTIONS / >> FRIEND CLASSES 
[pag410 deitel]
A friend function of a class is a non-member fuction that has the right to access the public and non-public class members. 
To declare a function as a "friend" of a class, precede the function prototype in the class definition with keyword "friend". To declare all member functions of ClassTwo as friends of ClassOne, place the declaration of the form
	friend class ClassTwo;
in the definition of class ClassOne.
NOTE: 
- Friendship is granted, not taken: for class B to be a friend of class A, class A must explicitly declare that class B is its friend. 
- Friendship is not symmetric: if class A is a friend of class B, you cannot infer that clas B is friend of class A. 
- Friendship is not transitive: if class A is a friend of class B and class B is friend of class C, you cannot infer that class A is a friend of class C. 
See example fig 9.22 pag 410 deitel
/////////////////////////////////////////////////////////////////


>> FRIEND FUNCTIONS and >> OPERATOR OVERLOADING [pag274 mike game programming]
Friend functions have complete access to any member of a class. Operator overloading allows you to define new meanings for built-in operators as they relate to objects of your own classes. You can use friend functions and operator overloading together.
----------------------------------------------- EXAMPLE  FRIEND FUNCTION AND OPERATOR OVERLOADING
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/friend_critter.cpp]
	//Friend Critter
	//Demonstrates friend functions and operator overloading
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Critter
	{
	    //make following global functions friends of the Critter class
// >> FRIEND FUNCTION EXAMPLE 
	    friend void Peek(const Critter& aCritter);  // global function Peek() is a friend of Critter. This means Peek() can access any member of Critter even though it's not a member function of the class.
	    friend ostream& operator<<(ostream& os, const Critter& aCritter);
// >> note: you specify that a function is a friend of a class by listing the function prototype preceded by the keyword "friend" inside 
// the class definition.	    
	public:
	    Critter(const string& name = "");
	     
	private:
	    string m_Name;
	};
	
	Critter::Critter(const string& name):
	    m_Name(name)
	{}
	
	void Peek(const Critter& aCritter);
	ostream& operator<<(ostream& os, const Critter& aCritter);
	
	int main()
	{
	    Critter crit("Poochie");
	
	    cout << "Calling Peek() to access crit's private data member, m_Name: \n";
	    Peek(crit);
	    
	    cout << "\nSending crit object to cout with the << operator:\n";
	    cout << crit;
	    
	    return 0;
	}
	
	//global friend function that can access all of a Critter object's members
	void Peek(const Critter& aCritter)
	{
	    cout << aCritter.m_Name << endl;
	}
	
	//global friend function that can access all of Critter object's members
	//overloads the << operator so you can send a Critter object to cout
// qui overloaddiamo the "<<" operator, by defining a function named "operator<<"
	ostream& operator<<(ostream& os, const Critter& aCritter)
	{
	    os << "Critter Object - ";
	    os << "m_Name: " << aCritter.m_Name;
	    return os;
	}
// >> OVERLOAD OPERATOR pag276 mike game programming: Operator overloading lets you give meaning to built-in operators used with new types that you define. For example, you could overload the multiplication operator * so that when it is used with two 3D matrices (objects instantiated  from some class that you've defined), the result is the multiplication of the matrices. 	

----------------------------------------------- END EXAMPLE  FRIEND FUNCTION AND OPERATOR OVERLOADING
OUTPUT 
	Calling Peek() to access crit's private data member, m_Name: 
	Poochie
	Sending crit object to cout with the << operator:
	Critter Object - m_Name: Poochie 
/////////////////////////////////////////////////////////////////


>> FRIENDSHIP 
[pag378deitel]
We use friendship to specify that a nonmember function can also access a class's non-public members (a technique that is often used in operator overloading for performance reasons)

>> FRIEND OF A CLASS pag 217 moo book 

>> FUNCTION 
General observation 
- [from pag98deitel] A function that does not, and should not, modify the object on which it's called should be declared "const"
- [from pag203deitel] functions allow you to modularize a program by separating its tasks into self-contained units. 
To promote software reusability, every function should be limited to performing a single, well-defined task, and the name of the function should express that task effectively.
- a function is invoked by a function call, and when te called function completes its task, it either returs a result or simply returns control to the caller. The caller does not know how the function performs its designated tasks. This hiding of implementation details promotes good software engineering. 

>> FUNCTION CALL 
[pag 300 deitel star tag]
le function calls sono quelle righe in cui di solito vedi scritto 
	nomeFunzione();
le parentesi non sono vuote nel caso in cui la funzione richieda dei parametri di input

>> function call operator () / >> ()
[pag470deitel]
il function operator altri non e' che ()
Esempio 
instead of using C++'s double square bracket notation, such as in chess-Board[row][column], you might prefer to overload the function calloperator to enable the notation chessBoard(row, column), where chessBoard is an object of a modified two-dimensional Array class.
///////////////////////////////////////////////////////////////////////////

>> FUNCTION OVERLOADING / FUNCTION OVERLOADED / OVERLOADED FUNCTION
[pag243deitel]
C++ enables several functions of the same name to be defined, as long as they have different signatures. This is called function overloading. The C++ compiler selects the proper fuction to call by examining the number, types and order of the arguments in the call. 
Function overloading is used to create several functions of the same name that perform similar tasks, but on different data type.
Example: many functions in the math library are overloaded for different data types (the C++ standard requires float, double and long double overloaded versions of the math library functions)
- Overloading functions that perform closely related tasks can make programs more readable and understandable
- overloaded functions are distinguished by their signatures. A signature is a combination of a function's name and its parameter types (in order). The compiler encodes each function identifier with the types of its parameters (sometimes referred to as "name mangling" or "name decoration" ) to enable type-safe linkage. Type-safe linkage ensures that the proper function is called and that the types of the arguments conform to the types of the parameters.
- puoi vedere un nice esempio di mangled functions names produced in assembly language by GNU C++ @pag244-245deitel.
	example di mangled functions name (con cui si puo' assicurare il type-safe linkage)
	__Z8federicaciRfRd
e' il mangled name che si produce per la funzione
	int federica( char a, int b, float &c, double &d ) 
__Z8 perche' il nome della funzione federica ha 8 lettere.
	c = character
	i = int
	Rf = represent a float & (i.e. a reference to a float)
	Rd = represent a double & (i.e. a reference to a double)	
altre lettere che puoi trovare nella coda delle mangled functions names:
	Ri = represent a int & (i.e. a reference to an integer)
- Creating overloaded functions with identical parameter lists and different return types is a compilation error.
- function main is not mangled, because it cannot be overloaded.
- the compiler uses only the parameter lists to distinguish between overloaded functions. Such functions need not to have the same number of parameters. Use caution when overloading function with default parameters, because this may cause ambiguity. A function with default arguments omitted might be called identically ot another overloaded function; this is a compilation error.
For example, having a program that contains both a function that explicitly takes no argumets and a function of the same name that contains all default arguments results in a compilation error when an attempts is made to use that function name in a call passing no arguments. The compiler cannot determine which version of the function to choose.

>> FUNCTION PROTOTYPES / >> PROTOTYPE
[pag87deitel]
Function prototypes describe the class's public interface without revealing the class's member-funtion implementations. Cioe' in sostanza come nell'esempio di pag 88 fig3.11 non hanno un body, giusto una declaration that tells the compiler the function's name, its return type and the types of its parameters.
[pag210deitel]
Function prototypes (also called a function declaration) tells the compiler 
- the name of a function
- the type of data it returns
- the number of parameters it expects to receive
- the types of those parameters
- the order in which the parameters of those types are expected.
Use #include proprocessing directives to obtain function prototypes for the C++ Standard library functions. Ex by writing 
	#include <cmath>
[come nell'esempio di pag 165 fig 5.6]
potrai usare sqrt function. in effetti unless you define the function before it is used, devi fornire una function prototype. Since the prototype for sqrt e' contenuto nell'header <cmath> by writing at the beginning of the code #include <cmath>, potrai allora usare direttamente sqrt
Also use #include to obtain headers containing function prototypes written by you or other programmers.
[altre info from 210deitel]
- if a function is defined before it's invoked, then its definition also serves as the function's prototype, so a separate prototype is unnecessary. Ad ogni modo ti consiglio to always provide function prototypes, even though it's possible to omit them when funtions are defined before they're used. Providing the prototypes avoids tying the code to the order in which functions are defined (which can easily change as a program evolves)
- if a function is invoked before it's defined, and that function does not have a function prototytpe, a compilation error occurs.
> Observation from 211deitel
ARGUMENT COERCION : this is an important feature of function prototypes i.e, forcing  arguments to the appropriate types specified by the parameter decalrations.
ARGUMENT PROMOTION : sometimes, argument values that do not correspond precisely to the parameter types in the function prototype can be converted by the compiler to the proper type before the function is called. These conversions occur as specified by C++ promotion rules. The promotion rules indicate the implicit conversions that the compiler can perform between fundamental types. For example an "int" can be converted to a "double" o viceversa a double can converted to an "int" (the fractional part will be truncated). 
- Promotion rules apply also in mixed-type expressions (per esempio un espression in cui molplichi un int con un double). The type of each value in a mixed-type expression is promoted to the "highest" type in the expression (esempio l'int verra' promosso a double se moltiplicato con delle variabili double). See figure 6.6 pag212 deitel trovi la lista degli aritmetic data types from "highest type" to "lowest type".
  


>> FUNCTION PROTOTYPE, CALL, DEFINITI		ON 
bell'esempio chiarificatore a pag206deitel 
[altro bell'esempio pag300 deitel]
- Nota come la function prototype si trovi nell'*.h file (= interface of the class)
- mentre the calling of the function and its definition si trovino nel *.cpp file (= implementation of the class)
Altre osservazioni sul codice delle pagine 206 e 207
nella linea 56 trovi la function call
	maximumGrade = maximum (grade 1, grade2, grade3 );
e a partire dalla linea 60 comincia la function definition 
	int GradeBook::maximum( int x, int y, int z ) const
- nota come there must be one argument in the function call for each parameter (also called  formal parameter) in the function definition.
- nella function definition anche se i parametri hanno lo stesso "type", devi specificarlo davanti a ciascun parametro 
quindi 
	OK -> int GradeBook::maximum( int x, int y, int z ) const
	ERRATO -> int GradeBook::maximum( int x, y, z ) const
- Inoltre la riga 60 della function definition matches the function prototype and indicates that the parameter names are x, y, z. 
- [from pag209deitel] the compiler refers to the function prototype to check that calls to "maximum" contain the correct number and type of arguments and that the types of the arguments are in the correct order. [da qui si comprende la presenza dei due :: quando la funzione viene chiamata il compiler sa dalla linea 60 che il prototipo della funzione lo trova in GradeBook.h (che e' stato tra l'altro incluso nella riga 7 #include "GradeBook.h") e puo' cosi' controllare che il numero di tipo di argument sia coerente a quanto definito dal prototipo della funzione in GradeBook.h]
- in addition the compiler uses the prototype to ensure that the value returned by the function can be used correctly in the expression that called the function (cioe' controlla che nella linea 56 il valore che viene donato a maximumGrade sia cosistente con il type di maximumGrade: nel GradeBook.h, "maximumGrade" e' definito come intero, quindi il compiler controlla che gli sia donato un intero.
If the arguments passed to a function do not match the types specified in the function's prototype, the compiler attempts to convert the arguments to those types.  

>> FUNCTION PROTOTYPE SCOPE / FUNCTION PROTOTYPE SCOPE
the only identifiers with function-prototype scope are those used in the parameter list of a function prototype. As mentioned previously, function prototypes do not require names in the parameter list- only types are required. Names appearing in the parameter list of a function prototype are ignored by the compiler. Identifiers used in a function prototype can be reused elsewhere in the program without ambiguity.   


>> FUNCTION SIGNATURES 
[pag211deitel]
we call the function signature (or simply "signature") the portion of a function prototype that includes the name of the function and the types of its arguments. The function signature does not specify the function's return type. Functions in the same scope must have unique signatures. The scope of a function is the region of a program in which the function is known and accessible.

>> FUNCTION SCOPE 
[211deitel]
The scope of a function is the region of a program in which the function is known and accessible.
Functions in the same scope must have unique signatures. 
[pag228deitel]
Labels (identifiers followed by a colon such as 
	start:
or a "case" label in a "switch" statement) are the only identifiers with function scope. Labels can be used anywhere in the function in which they appear, but cannot be referenced outside the function body.

>> FUNCTION SIGNATURE 
[pag244deitel]
overloaded functions are distinguished by their signatures. A signature is a combination of a function's name and its parameter types (in order).
>> Function-Call Stack
[pag232deitel]
Function Call Stack (sometimes referred to as the program execution stack) supports the function call/return mechanism. 
As each function is called, it may in turn call other functions, which may in turn call other functions. Each function eventually must return control to the function that called it. So we must keep track of the return addresses that each function needs to return control to the function that called it. Each time a function calls another function, an entry is pushed onto the stack. This entry, called a 	
	"stack frame" or 
	"activation record".
If a function makes a call to another function, a stack frame for the new function call is simply pushed onto the call stack. Thus the return address required by the newly called function to return to its caller is noew located at the top of the stack.  
La chiamata di una funzione e il ritorno alla caller function, e' proprio simile ad una pila di piatti. Alla base della pila ci sta il main. Poi il main chiama un altra function, a stack frame or activation record is pushed onto the stack. The activation record contains the return address that the called function needs in order to return to the calling function. E la funzione chiamata puo' chiamare una altra funzione. Piu' una funzione chiama altre funzioni piu' la pila si allunga.
Se lo vedessi dinamicamente il programma somiglia ad una pila di piatti con main alla base che chiama funzioni che chiamano a loro volta altre funzioni, una pila che si alza, s'abbassa, si rialza e cosi' via.
                                                                          functionD
                                                               functionC  functionC    functionC  
                 function2                          functionB  functionB  functionB    functionB   functionB
      function1  function1  function1   functionA   functionA  functionA  functionA    functionA   functionA  functionA 
Main  Main       Main       Main        Main        Main       Main       Main         Main        Main       Main        Main end of Program.
STACK FRAMES and AUTOMATIC VARIABLES
Another important responsability of the stack frames is to reserve the memory for the called function's automatic variables. 
Most functions have automatic variables (like parameters and any local variables the function declares). Automatic variables need to exist while a function is executing. They need to remain active if the function makes calls to other functions. But when a called function return to its caller, the called function's automatic variables need to "go away". 
The called funcion's stack frame is a perfect place to reserve the memory for the called function's automatic variables. That stack frame exists as long as the called function is active. When that function returns (and no longer needs its local automatic variables) its stack frame is popped from the stack, and those local variables are no longer known to the program.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> function objects
[pag726 deitel]
Many standard library algorithms allow you to pass a function pointer into the algorithm to help the alfoirthm perform its task. For example, the binary_search algorithm that we diescced in section 16.3.6 is overloaded with a version that requires as its fourth parameter a function pointer that takes two arugments and returns a bool value. The algorithm uses this function to compres the search key to an element in the collection. The unction return true if the search key and elemnet bein compared are equal: otherwise, the function return false. This enables binary_search to search a collection of elements for which the lement type does not proved an overloaded equality < operator.
Any algorithm that can reveive a function pointer can also receive an object of a class that overloads the function call operator (parenthesis) with a function named operator(), provided that the overloaded operator meets the requirements of the algorithm [in the case of "binary search" it must receive two arguments and return a bool. An object of such a class is known as a function object and can be used syntactically and semantically like a function or function pointer.
- ADVANTAGES of FUNCTION OBJECTS OVER FUNCTION POINTERS 
Function objects provide several advantages over function pointers. The compiler can inline a funcion objects'overloaded operator() to improve performance. Also, since they're objects of classes, function objects can have data members that operator() can use to perform its task. 
- PREDEFINED FUNCTION OBJECTS FO THE STANDARD TEMPLATE LIBRARY
Many predefined function objects can be found in the header <functional>, for example :
	   FUNCTION OBJECT    |  TYPE 
	>> divides< T >       |  arithmetic  
	>> equal_to< T >      |  relational
	>> greater< T >       |  relational
	>> greater_equal< T > |  relational
	>> less< T >          |  relational
	>> less_equal< T >    |  relational
	>> logical_and< T >   |  logical 
	>> logical_not< T >   |  logical 
	>> logical_or< T >    |  logical
	>> minus< T >         |  arithmetic        
	>> modulus< T >       |  arithmetic
	>> negate< T >        |  arithmetic
	>> not_equal_to< T >  |  relational
	>> plus< T >          |  arithmetic  
	>> multiplies< T >    |  arithmetic
EXAMPLE: we use the >> accumulate algorith to calculate the sum of the squares of the elements in an array. 
[/home/dia/Deitel-Code_Examples/ch16/fig16_15/fig16_15.cpp]
This program uses the accumulate numeric algorithm (introduced in fig16.5 pag 703 line 55) to calculate the sum of the squares of the elements in an array. The function accumulate is demonstrated twice, once with a function pointer and once with a function object.
OUTPUT :
	array integers contains:
	1 2 3 4 5 6 7 8 9 10
	
	Sum of squares of elements in integers using binary
	function sumSquares: 385
	
	Sum of squares of elements in integers using binary
	function object of type SumSquaresClass< int >: 385
COMMENTS:
lines 13-16:
	// binary function adds square of its second argument and the
	// running total in its first argument, then returns the sum 
	int sumSquares( int total, int value ) 
	{ 
	   return total + value * value; 
	} // end function sumSquares
define a function sumSquares that squares its second argument value, adds that square and its first argument total and returns the sum.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> modulus / >> % 
[pag 73 jesse]
the modulus operator (%) tells you the remainder after an integer division. Example: the remainder of 21 divided by 4 is 1. 
Finding the modulus can be very useful. For example, you might want to print a statement on every 10th action. Any number whose values is 0 when you modulus 10 with that number is an exact multiple of 10. Thus 1 % 10 is 1, 2 % 10 is 2, and so forth, until 10 % 10 whose result is 0. 11 % 10 is back to 1, and this pattern continues until the next multiple of 10, which is 20, 20 % 10 = 0 again. Quindi usando "%10" e checkando che il modulo sia nullo puoi individuare tutte le actions every 10. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> FUNCTION TEMPLATES 
[pag246deitel]
If the program logic and operations are identical of each data type,overloading can be performed more compactly and convieniently by using function templates. You writes a single function template definition. Given the argument types provided in calls to this function, C++ automatically generates separate "function template specializations" to handle each type of call appropriately. 
  1 // Fig. 6.25: maximum.h
  2 // Function template maximum header.
  3 template < typename T >  // or template< class T >
  4 T maximum( T value1, T value2, T value3 )
  5 {
  6    T maximumValue = value1; // assume value1 is maximum
  7
  8    // determine whether value2 is greater than maximumValue
  9    if ( value2 > maximumValue )
 10       maximumValue = value2;
 11
 12    // determine whether value3 is greater than maximumValue
 13    if ( value3 > maximumValue )
 14       maximumValue = value3;
 15
 16    return maximumValue;
 17 } // end function template maximum
//
- line 3 All function template begin with a template keyword followed by a template parameter list to the function template enclosed in angle brackets <>
- line 6 T is a formal type parameter (ci puoi mettere un nome di tuo piacere) usato come placeholder for fundamental types or user-defined types. 
A function template is defined like any other function, but uses the formal type parameters as placeholders for actual data types.

>> FUNDAMENTAL TYPES (like int, double, char)
Fundamental-type names consist of one or more keywords and therefore must appear in all lowercase letters. here's the C++ fundamental types list:
Integral types:
	bool
	char
	signed char
	unsigned char
	short int 
	unsigned short int
	int
	unsigned int
	long int
	unsigned long int
	long long int
	unsigned long long int
	char16_t
	char32_t
	wchar_t
Floating-point types
	float
	double
	long double
[nota come i fundamental types possano essere composti da una o piu' keyboards sempre scritte in lettere minuscole]	

NB: non confondere "identifier" with fundamental type ex:
	int number1 = 0;
number1 is the identifier. con un identifier puoi usare sia lettere maiuscole che minuscole (C++ is case sentitive), giusto non devi farlo cominciare con un digit. Mentre le keywords che compongono i fundamental type names devono sempre essere scritte in minuscolo. 	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ABSTRACTION 
[pagxii moo book]
Abstraction is selective ignorance = concentrating on the ideas that are relevant to the task at hand, and ignoring everything else. This is the most important idea in modern programming. The key to writing a successful program is knowing which parts of the problem to take into account, and which parts to ignore.
If abstractions are well designed and well chosen, we believe that we can use them even if we don't understand all the details of how they work. We do not need to be aerospace engineers to fly and airplane, nor do we need to understand everything about how C++ works before we can use it.

>> FUNCTIONS [mike programming game pag144]
Before you can call a function you have written, you have to declare it. 
Two ways to declare a function:
A) 
One way to declare a function is to write a function prototype (= code that describes the function)
You write a prototype by listing
- the return value of the function (or void if the function returns no value)
- followed by the name of the function 
- followed by a list of parameters between a set of parenthesis
Example
	void         instruction();  // se tra le parentesi non vi sta nulla significa che la function non ha bisogno di parametri
    |            |
  return value   function name   
Full Example of function prototype from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/instructions.cpp
			// Instructions
			// Demonstrates writing new functions
			
			#include <iostream>
			
			using namespace std;
			
			// function prototype (declaration)  : you need to write the function prototype BEFORE the main() function
			void instructions();  // questa e' una semplice funzione che non prende values in input, e does not return a value
			
			int main()
			{
			    instructions();
			
			    return 0;
			}
			
			// function definition
			void instructions()
			{
			    cout << "Welcome to the most fun you've ever had with text!\n\n";
			    cout << "Here's how to play the game...\n";
			}
-------------------------------------------------
B) second way to declare a function: let the function definition act as its own declaration. TO do that, you simply have to put your function definition before the call to the function. 
HINT: although you don't have to use prototypes, they offer a lot of benefits, not the least of which is making your code clearer.
--------------------------------------------------
>> FUNCTION DEFINITION / >> DEFINE FUNCTION [pag146 mike programming game] / >> FUNCTION HEADER / >> FUNCTION BODY
			// function definition
			void instructions()                                                     // this is the function HEADER
			{                                                                       // this is the function body
			    cout << "Welcome to the most fun you've ever had with text!\n\n";   // this is the function body
			    cout << "Here's how to play the game...\n";                         // this is the function body
			}                                                                       // this is the function body
NOTE: the function header is exactly like the function prototype, except you don't end the line with a semicolon. The function header is made by the return value of the function, the name of the function and the list of parameters between ()
NOTE: the function body is the block within {} curly braces that contains the instructions to be executed when the function is called. 
>> FUNCTION CALL / >> CALL FUNCTION [mike programming game pag146]
You call your own functions the same way you call any other function (by writing the function'sname followed by a pair of parentheses that encloses a valid list of arguments) ex from the above program:
			int main()
			{
			    instructions();   // here we call the function "instruction"
			    return 0;
			}
------------------------------------
When a function finishes, control returns to the calling code. In this case, it means control returns to main(). 
NOTE: [from pag150 mike programming game] A functions ends whenever it hits a return statement. It's perfectly acceptable for a function to have more than one return. This just means that the function has several points at which it can end. 
NOTE: you don't have to return a value with a return statement. You can use "return" by itself in a function that returns no value (one that indicates void as its return type) to end the function. 
>> ABSTRACTION [mike (pence 2016) programming game pag147]
By writing and calling functions you practice what's known as abstraction. Abstraction lets you think about the big picture without worrying about the details. In this program, we can simply use the function "instructions()" without worrying about the details of displaying the text. All we have to do is call the function with one line of code, and it gets the job done. 			
>> RETURN VALUE from function to the calling code. 
You can return a value from a function to send information back to the calling code. As shown in the example below, e' gia' a livello della function propotype prima del main() [see char askYesNo1(); below] che puoi specificare che tipo di value vuoi donare indietro.
[NOTE from pag826 jesse: any function that does not explicitly declare a return type returns "int". You should always declare the return type as a matter of good programming practice]
>> PARAMETER FUNCTION / >> FUNCTION PARAMETER 
As shown in the example below "char askYesNo2(string question);" i parametri che vuoi specificare come input della funzione li devi specificare tra le parentesi (). You don't have to use paraemter names in a prototype. Tipo usare "char askYesNo2(string);" va anche bene. Even though you don't have to use parameter names in prototypes, it's a good idea to do so. It makes your code clearer, and it's worth the minor effort. 
NOTE: con i prototypes specificare il nome del parametro e' facoltativo. MENTRE in the function definition 
	 char askYesNo2(string question)
you must specify parameter names in a function definition. You use a paramenter name inside a function to access the parameter value.
NOTE: the parameter types specified in a function prototype must match the parameter types listed in the function definition. If they don't you'll generate a nasty compile error.
------------------------------------------------------------------------------------------------------------
example :
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		char askYesNo1(); // this function prototype indicates that the function askYesNo1 will return a char value. 
		char askYesNo2(string question); // this function accepts a value into a parameter. specifically it accepts a value of type string.
		
		int main()
		{
		    char answer1 = askYesNo1();  // here we call the function askYesNo1; la variabile answer1 si vedra' assegnato il valore (either "y" or "n" che la funzione dona in ritorno)
		    cout << "Thanks for answering: " << answer1 << "\n\n";
		
		    char answer2 = askYesNo2("Do you wish to save your game?"); // this statement calls askYesNo2() and passes the string literal argument "Do you wish to save your game?"
		    cout << "Thanks for answering: " << answer2 << "\n";
		
		    return 0;
		}
		
		char askYesNo1()
		{
		    char response1;
		    do
		    {
		        cout << "Please enter 'y' or 'n': ";
		        cin >> response1;
		    } while (response1 != 'y' && response1 != 'n');
		
		    return response1;  // Notice that response1 is a char value. It has to be because that's what I promised to return in both the function prototype and function definition. 
		}
		
		char askYesNo2(string question)
		{
		    char response2;
		    do
		    {
		        cout << question << " (y/n): ";  // visto quanto passato da main in questo caso "question" == "Do you wish to save your game?"
		        cin >> response2;
		    } while (response2 != 'y' && response2 != 'n');
		
		    return response2;
		}
-----------------------------------
>> ENCAPSULATION [mike programming game pag152]
Why you need to return the values when using your own functions? Because no variable you create in a function, including its parameters, can be directly accessed outside its function. This is a good thing, and it is called encapsulation. Encapsulation keep independent code truly separate by hiding or encapsulating the details. That's why you use parameters and return values to communicate only the information that needs to be exchanged. Plus you don't have to keep track of variables you create within a function in the rest of your program. As your programs get large, this is a great benefit. 
Encapsulation might sound a lot like abstraction. Abstraction saves you from worrying about the details, while encapsulation hides the details from you.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> FUNCTION observation from pag 112 jesse book / >> FUNCTION SIZE
Although no limit exists to the size of a function in C++, well-designed functions tend to be small. Many programmers advise keeping your functions short enough to fit on a single screen so that you can see the entire function at one time. This a rule of thumb often broken by very good programmers, but it is true that a smaller function is easier to understand and maintain. Each function should carry out a single, easily understood task. If your functions start to getting large, look for places where you can divide them into component tasks.

>> FUNCTION observation from pag 72 moo book 
A function must be declared in every source file that uses it, and defined only once. The delcations and defintions have similar forms. 
	ret-type function-name (parm-decls) ;   // function declaration 
		[inline] ret-type function-name (parm-decls) {  // function definition
	}
Here ret-type is the type that the fucntion returns, parm-decls is a comma separated list of the type for the parameters of the function. Functions must be declared before they are called. Each argument's type must be compatible with the corresponding parameter. A different syntax is necessary to declare or define functions with sufficiently complicated return types. 
Function names may be overloaded: the same function name may define multiple functions so lons as the functions differ in the number or types of the parameters. The implementation can distinguish between a reference and a const reference to the same type.
We can optionally qualify a function definition with "inline", which asks the compiler to expand calls to the function inlne when appropriate (that is to avoid function call overhead by replacing each call to the function by a copy of the function body, modified as necessary). TO do so, the compiler needs to be able to see the function definition, so inlines are usually defined in header files, rather than in source files. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> GGGGGGG

>> GAMING / GAME [mike game programming]
C++ (@2015) is the game industry standard

>> GAME LOOP [mike pag 67]
The game loop is a generalized representation of the flow of events in a game. Although the implementation might be quite different from game to game, the fundamental structure is the same for almost all games across genres.

		    SET UP
		  	  |
        	  |
			  V
 /--->  GET PLAYER INPUT
 |		  	  |
 |       	  |
 |			  V             
 |   UPDATE GAME INTERNALS
 |		  	  |
 |       	  |
 |			  V  
 |      UPDATE DISPLAY
 |		  	  |
 |       	  |
 |			  V  
 \-- NO <- GAME OVER ?
              |
              |
              V
          SHUT DOWN

Here's an explanation of the part of the game loop:
- Setup: this often involves accepting initial settings or loading game assets, such as sound, music and graphics. The player might also be presented with the game backstory and his objectives.
- Getting player input: whether it comes from the keyboard, mouse, or joystick, trackball, or some other device, input from the player is captured
- Updating game internals: the game logic and rules are applied to the game world, taking into account player input. This might take the shape of a physcis system determining the interaction of objects or it might involve calculations of enemy (for some, not form me viva Palpetine!) Dark Sidius, for example.
- Updating the display : in the majority of games, this process is the most taxing on the computer hardware because it often involves drawing graphics. However,this process can be as simple as displaying a line of text.
- Checking whether the game is over. If the game isn't over (the player's character is still alive and the aplyer hasn't quit, for example) control branches back to the getting player input stage. If the game is over, control falls through to the shutting down stage.
- Shutting down: At this point, the game is over. The player is often given some final information, such as his score. The program frees any resources, if necessary, and exits.
-----------------------------------
EXAMPLE Guess my number
///////////////////////
// Guess My Number
// The classic number guessing game

#include <iostream>
#include <cstdlib> // we inclue cstdlib because we plan to generate a random number.
#include <ctime>   // we include ctime because we want to seed the random number generator with the current time

using namespace std;

int main()
{
    srand(static_cast<unsigned int>(time(0)));  //seed random number generator

	int secretNumber = rand() % 100 + 1;  // random number between 1 and 100
	int tries = 0;
	int guess;
    
	cout << "\tWelcome to Guess My Number\n\n";

	do
	{
		cout << "Enter a guess: ";
		cin >> guess;
		++tries;   

		if (guess > secretNumber)
		{
			cout << "Too high!\n\n";
		}
		else if (guess < secretNumber)
		{
			cout << "Too low!\n\n";
		}
		else
		{
			cout << "\nThat's it! You got it in " << tries << " guesses!\n";
		}

	} while (guess != secretNumber);

    return 0; // once the player has guessed the secret number, the loop and game are over. All that's left to do is end the program.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> GETLINE
[pag72deitel]
getline reads characters (including the space characters that separate the words in the input) from the standard input stream object cin (i.e., the keyboard) until the newline character is encountered. The <string> header must be included in the program to use function getline
	#include <string>
	using namespace std;
    ...
	getline( cin, nameNavigatorFlightSchedule );
[trovi esempio a pag71]
rispetto al semplice 
	cin >> nameNavigatorFlightSchedule
che reads characters until the first white-space character is reached.	

>> giustificazione a sinistra / >> giustificazione a destra. / >> justification left / >> justification right
[pag 581 deitel]
Trovi un esempio a pagina 581


>> GLOBAL FUNCTIONS 
global functions are functions, such as main, that are not member of a class. Like a class's member functions, the function prototypes for global fucntions are placed in headers, so that the global functions can be reused in any program that includes the header and that can link to the function's object code. 
[see also pag100 jesse]

>> GLOBAL VARIABLES [pag157 mike game programming]
to declare a global variable, you simply declare the variable outside of any function in your program file.
example 
	using namespace std;
	
	int glob = 10;  // global variable
	
	int main()
	{
	...
	}
Full example in 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/global_reach.cpp
NOTE: 
>> HIDE GLOBAL VARIABLE
then if you want to hide a global variable within a function, you simply decalre a new variable with the same name withing that function
	void hide_global()
	{
	    int glob = 0;  // hide global variable glob
	    cout << "In hide_global() glob is: " << glob << "\n\n";
	}
quando poi sei uscito dallo scope della function, glob continuera' ad assumere il valore originale della global variable.
NOTE:
>> ALTER GLOBAL VARIABLE / >> MODIFY GLOBAL VARIABLE
Just as you can access a global variable from anywhere in your program, you can alter one from anywhere in your program, too.
example from@/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/global_reach.cpp
void change_global()
{
    glob = -10;  // change global variable glob
    cout << "In change_global() glob is: " << glob << "\n\n";
}
WARNING: in general global variables make programs confusing because it can be difficult to keep track of their changing values. You should limit your use of global variables as much as possible.
-------------------------------------------------------
>> GLOBAL VARIABLE [further explanations from pag 110 jesse]
Local variables with the same name as global variables do not change the global variables. A local variable with the same name as a global variable hides the global variable however. If a function has a variable with the same name as a global variable, the name refers to the local variable (not the global) when used within the function.  
CAUTION : in C++ global variables are legal, but they are almost never used. Globals are denagerous because they are shared adata, and one function can change a global variable in a way that is invisible to another function. This can and does create bugs that are very difficult to find.
Example
//////////////////////////////////////////////////////
	#include <iostream>
	void myFunction();           // prototype
	  
	int x = 5, y = 7;            // global variables
	int main()
	{
	   using namespace std;
	  
	   cout << "x from main: " << x << endl;
	   cout << "y from main: " << y << endl << endl;
	   myFunction();
	   cout << "Back from myFunction!" << endl << endl;
	   cout << "x from main: " << x << endl;
	   cout << "y from main: " << y << endl;
	   return 0;
	}
	  
	void myFunction()
	{
	   using std::cout;
	 
	   int y = 10;
	  
	   cout << "x from myFunction: " << x << endl;
	   cout << "y from myFunction: " << y << endl << endl;
	}

//////////////////////////////////////////////////////
-------------------------------------------------------
>> GLOBAL CONSTANT [pag161 mike programming game]
Unlike global variables, which can make your programs confusing, global constants (= constants that can be accessed from anywhere in your program) can help make programs clearer. 
You declare a global constant much like you're declaring a global variable, by declaring it outside of ANY function. And because you're declaring a constant, you need to use the "const" keyword.
Example 
	const int MAX_SPACESHIPNUMBER = 10;
NOTE TRAP: just like global variables, you can hide a global constant by declaring a local constant with the same name. However, you should avoid this because it can lead to confusion. 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> GLOBAL NAMESPACE SCOPE 
[228deitel]
an identifier declared outside any funtion or class has global namespace scope. Such an identifier is "known" in all functions from the point at which it's declared until the end of the file. Global variables, function definitions and function prototypes placed outside a function all have global namespace scope. 
Example : see pag 395 deitel 
in fig9.9 puoi vedere come the object "first" di line 10 e' un global object. Visto che the object is defined outside the main() function e si trova al di fuore di qualsiasi altra funzione, il suo scope e' global

>> HHHHHHH

>> H EXTENSION 
by convention include files are given a .h extension
- in linux li puoi visionare comodamente con gedit oppure clic destro sul file e apri con "netbeans"
- a header cannot be used as complete program because it does not contain a "main" function. To test it you must write a separate source code file containing a main function that instantiates and uses objects of the class. 

>> header of a function = return_type FUNCTION_NAME (parameters to that function)
[pag36 jesse]
example 
a function named Sum that receives tow integer values (first and second) and also returns an integer value:
	int Sum (int first, int second)
NOTE: a >> parameter is a declaration of what type of value will be passed in; the actual value passed in when the function is called is referred to as an >> argument. The distinction between these two terms is not critical to your programming C++, so you sholdn't worry if the works get interchanged. 
////////////////////////////////////////////////////////////////////////////

>> HEADERS 
Some advices
- [pag85deitel] use std:: with standard library components in headers. Throughout the header, we use std:: when referring to "string", "cout" and "endl" , headers should never contain "using" directives and "using" declarations 
Detto in parole spicciole: usa std::string, std::cout come nell'esempio fig3.9 pag 84, e non usare la tecnica delle "using" declarations [spiegate a pag55deitel]
- How headers are located [pag86deitel] Notice that the name of the myClassName.h header (in the ccp file containing the main function) is enclosed in quotes "" rather than angle brackes (<>)
	#include "NuclearReactor.h"
Normally, a program's source-code files an user-defined headers are placed in the same directory, When the preprocessor encounters a header name in quotes , it attempts to locate the header in the same directory as the file in which the #include directive appears. If the preprocessor cannot find the header in that directory, it searches for it in the same location(s) as the C++ Standard Library headers. When the proprocessor encounters a header name in angle brackets (e.g. <iostream>), it assumes that the header is part of the C++ Standard Library and does not look in the directory of the program that's being preprocessed.   
In sostanza: to ensure that the preoprocessor can locate headers correctly #include preprocessing directories should place user-defined headers names in quotes (e.g. "VoidLayerMachine.h") and place C++ Standard Library headers names in angle brackets (e.g. <iostream>) 
- Why to hide the class implementation to the client code. When your custom class is defined in a header, the class is reusable. Unfortunately , placing a class definition in a header still reveals the entire implementation of the class to the class's clients. 
Conventional software engineering wisdom says that to use an object of a class, the client code (e.g., function main) needs 
1- to know only what member functions to call, 
2- what arguments to provide to each member function 
3- and what return type to expect from each member function 
The client code does not need to know how those functions are implemented. 
Hiding the class's implementation details makes it easier to change the class's implementation while minimizing, and hopefully eliminating, changes to the client code.
in conclusione: spezza il tuo programma in the cpp file with the main function and the classes in files differenti, in modo che:
A) the class is reusable
B) the clients of the class know what member functions the class provides, how to call them and what return types to expect, and 
C) the clients do not know how the class's member functions are implemented. 
>> NOTA bene da pag 209 mi sembra che quando si parla di FUNCTION HEADER ci si riferisce alla prima linea della definition della funzione all'interno del cpp file e non al *.h header file esempio 
	int GradeBook::maximum( int x, int y, int z ) const
[da pag207 line 60] itiaf verificami in futuro se abbiamo ragione

>> HELPER FUNCTION 
[pag378deitel] 
helper function = a private member function that supports the operation of the class's public member functions, but is not intended for use by clients of the class.

>> HEAPSORT
[pag721 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp
this example demonstrates the standard library algorithms for performing the heapsort sorting algorithm, in which an array of elements is arranged into a data structured called a >> heap. Heapsort is discussed in detail in computer sciences courses called "Data Structures" and "Algorithms". For more information see 
	en.wikipedia/wiki/Heapsort
-------------------------------------------------------------------------------
>> make_heap algorithm 
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
[pag 723 deitel]
 20    make_heap( a.begin(), a.end() ); // create heap from array "a"
line 20 uses the make_heap algorithm to take a sequence of values in the range from a.begin() up to, but not including, a.end() and create a heap that can be used to produce a sorted sequence (per esempio usando sort_heap vedi voce poco piu' sotto). The two iterator arguments must be random-access iterators, so this algorithm will work only with array, vectors and deques. A second version of this algorithm takes as a thid argument a binary predicate function for comparing values.
[nota bene: heap = mucchio, cumulo, ammasso, catasta/ in ambito computeristico indica area used for dynamic memory allocation [fonte dizionario zanichelli]]
>> sort_heap 
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
 24    sort_heap( a.begin(), a.end() ); // sort elements with sort_heap
line 24 uses the sort_heap algorithm to sort a sequence of values in the rage from a.begin() up to, but not including a.end() tha are already arranged in a heap. The two iterator arguments must be random-access iterators. A second version of this algorithm takes as a third argument a binary predicate function for comparing values.
>> push_heap
[pag724 deitel]
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
 37    for ( size_t i = 0; i < init.size(); ++i )
 38    {
 39       v.push_back( init[ i ] );
 40       push_heap( v.begin(), v.end() );
 41       cout << "\nv after push_heap(init[" << i << "]): ";
 42       copy( v.cbegin(), v.cend(), output );
 43    } // end for
line 40 uses the push_heap algorithm to add a new value intp a heap. We take one element of array init at a time, append it to the end vector v and perform the push_heap operation. If the appended element is the only element in the vecotr, the vector is already a heap. Otherwise, push_heap rearranges the vector elements into a heap. Each time push_heap is called, it assumes that the last element currently in the vector (i.e. the one that's appended before the push_heap call) is the element being added to the heap and that all other elements in the vector are already arranged as a heap.
[non molto ben chiaro questo heap itiaf]
OUTPUT 
[init e' il container da cui prendiamo gli elementi che andiamo a stivare in "v" la push_heap e' un po' come la gru di un porto, prende gli elementi di init lasciati dai camion porta-container e li pusha nella stiva della nave porta-container.]
	Array init contains: 3 100 52 77 22 31 1 98 13 40	
	v after push_heap(init[0]): 3
	v after push_heap(init[1]): 100 3
	v after push_heap(init[2]): 100 3 52
	v after push_heap(init[3]): 100 77 52 3
	v after push_heap(init[4]): 100 77 52 3 22
	v after push_heap(init[5]): 100 77 52 3 22 31
	v after push_heap(init[6]): 100 77 52 3 22 31 1
	v after push_heap(init[7]): 100 98 52 77 22 31 1 3
	v after push_heap(init[8]): 100 98 52 77 22 31 1 3 13
	v after push_heap(init[9]): 100 98 52 77 40 31 1 3 13 22
-------------------------------------------------------------------------------
>> pop_heap algorithm
 47    // remove elements from heap in sorted order
 48    for ( size_t j = 0; j < v.size(); ++j )
 49    {
 50       cout << "\nv after " << v[ 0 ] << " popped from heap\n";
 51       pop_heap( v.begin(), v.end() - j );
 52       copy( v.cbegin(), v.cend(), output );
 53    } // end for
[pag724 deitel]
Line 51 uses pop_heap to remove the top heap element.  This algorithm assumes that the elements in the range specified by its two random-access iterator arguments are already a heap. Repeatedly removing the top heap element results in a sorted sequence of values.
>> is_heap / >> is_heap_until 
[pag724 deitel]
The is_heap algorithm returns true if the elements in the specified range represent a heap.
-------------------------------------------------------------------------------
FULL OUTPUT EXAMPLE [from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
	Array a before make_heap:
	3 100 52 77 22 31 1 98 13 40
	Array a after make_heap:
	100 98 52 77 40 31 1 3 13 22
	Array a after sort_heap:
	1 3 13 22 31 40 52 77 98 100
	
	Array init contains: 3 100 52 77 22 31 1 98 13 40
	
	v after push_heap(init[0]): 3
	v after push_heap(init[1]): 100 3
	v after push_heap(init[2]): 100 3 52
	v after push_heap(init[3]): 100 77 52 3
	v after push_heap(init[4]): 100 77 52 3 22
	v after push_heap(init[5]): 100 77 52 3 22 31
	v after push_heap(init[6]): 100 77 52 3 22 31 1
	v after push_heap(init[7]): 100 98 52 77 22 31 1 3
	v after push_heap(init[8]): 100 98 52 77 22 31 1 3 13
	v after push_heap(init[9]): 100 98 52 77 40 31 1 3 13 22
	
	v after 100 popped from heap
	98 77 52 22 40 31 1 3 13 100
	v after 98 popped from heap
	77 40 52 22 13 31 1 3 98 100
	v after 77 popped from heap
	52 40 31 22 13 3 1 77 98 100
	v after 52 popped from heap
	40 22 31 1 13 3 52 77 98 100
	v after 40 popped from heap
	31 22 3 1 13 40 52 77 98 100
	v after 31 popped from heap
	22 13 3 1 31 40 52 77 98 100
	v after 22 popped from heap
	13 1 3 22 31 40 52 77 98 100
	v after 13 popped from heap
	3 1 13 22 31 40 52 77 98 100
	v after 3 popped from heap
	1 3 13 22 31 40 52 77 98 100
	v after 1 popped from heap
	1 3 13 22 31 40 52 77 98 100
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> IIIIIII

>> ignore 
[pag442deitel]
the function ignore discards the specified number of characters in the input stream (one character by default) 

>> ISO [mike pag5] = international organization for standardization 
	- describes how the language should work. 
	- defines a group of files, called the standard library, that contain building block for common programming tasks, such as I/O (= getting input and displaying output).

>> INCREMENT OPERATOR / DECREMENT OPERATOR / INCREMENT AND DECREMENT OPERATORS
[PAG141deitel]
increment operator ++
decrement operator --
we have 4 cases:
1) preincrement    ++a   increment "a" by 1 then use the new value of "a" in the expression in which "a" resides.
2) postincrement   a++   use the current value of "a" in the expression in which "a" resides, then increment "a" by 1.
3) predecrement    --b   decrement "b" by 1 then use the new value of "b" in the expression in which "b" resides.
4) postdecrement   b--   use the current value of "b" in the expression in which "b" resides, then decrement "b" by 1.
nomenclature 
++a chiamato anche prefix increment operator
--b prefix decrement operator
a++ postfix increment operator
b-- postfix decrement operator
Observation : le e linee seguenti sono equivalenti:
	counter = counter +1;
	counter +=1;
	++counter
A) NB: when you increment (++) or decrement (--) an integer variable in a statement by itself, the preincrement and postincrement forms have the same logical effect (cioe' quando la variable si trova da sola ++i oppure i++ hanno lo stesso effetto). E' solo quando a variable appears in the context of a larger expression that preincrementing or postincrementing the variable has different effects.
[cioe' con i++ verra' usata nell'espressione che la contiene il valore della variabile prima dell'incremento.
i++ prima usi i (da sola o all'interno di un espressione) e poi la incrementi 
++i priam incrementi i e poi la usi all'interno dell'espressione che la contiene]
B) ++ e -- have right to left associativity  [see pag143deitel]
ATTENZIONE: ++ e -- sono unary operators. Attempting to use the increment or decrement operator on an expression other than a modifiable variable name ex ++(x+1) is a syntax error.
 
>> type which is the best choice between int unsigned int double ect
- If you need an integer type, you're probably best off using int. That's because int is generally implemented so that it occupies an amount of memory that is most efficienly handled by the computer. 
- If you need to represent integer value greater than the maximum int or values that will never be negative, feel free (U2) to use an unsigned int.
- If you need a floating point number you're probably best off using float, which again is likely to be implemented so that it occupies an amount of memory that is most efficiently handled by the computer.


            
>> I/O type safe / >> type safe / >> type-safe
[pag572 deitel]
C++ offers  type-safe I/O. The << and >> operators are overloaded to accept data items of specific types. If unexpected data is processed, various error bits are set, which the user may test to determine whether an I/O operation suceeded or failed. If operators << and >> have not been overloaded  for a user-defined type and you attempt to input into or output the contents of an object of that user-defined type, the compiler reports an error. 
[pag563 deitel]
C++ uses type-safe I/O. Each I/O operation is executed in a manner sensitive to the data type. If an I/O function has been defined to handle a particular data type, then that member function is called to handle that data type. If there is no match between the type of the actual data and a function for handling that data type, the compiler generates an error. Thus improper data cannot "sneak" through the system.
C++ I/O occurs in >> streams . Streams are sequences of bytes. In input operations, the bytes flow from a device (eg. a keyboard, a disk drive a network connection etc) to main memory. In output operations, bytes flow from main memory to a device (e.g. a display screen, a printer, a disk drive, a network connection etc).
An application associates meaning with bytes. The bytes could represent characters, raw data, graphics images, digital speech, digital video or any other information an application may require. The system I/O mechanism should transfer bytes from devices to memory (and viceversa) consistently and reliably. Such transfers ofter involve some mechanical motion., such as the rotation of a disk or a tape, or the typing of keystrokes at a keyboard. The time these transfers take typically is far greater than the time the processor requires to manipulate data internally. Thus I/O operations require careful planning and tuning to ensure optimal perfomance.
C++ provides both >> low level and >> high level I/O capabilities. Low level I/O capabilities (i.e. >> unformatted I/O) specify that some number of bytes should be transferred device-to-memory  or memory-to-device. In such transfers, the individual byte is the item of interest. Such low-level capabilities provide high-speed, high-volume transfers but are not particularly convinient. [unformatted I/O is not protable across all platforms. Inoltre (from pag572) unformatted input output is performed using the read and write member functions of istream and ostream respectively See voce unformatted I/O for more information]. 
Programmers generally prefer a higher level view of I/O (i.e >> formatted I/O) in which bytes are grouped into meaningful units, such as integers, floating-point numbers, characters, strings and user-defined types. These type-oriented capabilities are satisfactory for most I/O other than high-volume file processing.
>> classic stream vs >> standard stream
In the past, the C++ >> classic stream libraries enabled input and ouptu of chars. Because a char normally occupies one byte, it can represent only a limited set of characters (such as those in the ASCII character). However, many languages use alphabets that contain more chracters then a single-byte char can represent. The ASCII character set does not privode these characters.
>> UNICODE / >> character set unicode 
The >> unicode character set does. Unicode is an extensive international character set that represents the majority of the world's "commercially viable" languages mathematical symbols and much more (for more info see www.unicode.org)
C++ includes the >> standard stream libraries, which enable developers to build systems capable of performing I/O operations with Unicode characters. For this purpose, C++ includes the type 
	>> wchar_t, 
which among the other uses can store Unicode characters.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> invariant // >> loog invariant [pag20 moo book]
detto in parole semplici l'invariant, loop invariant is a property that we assert will be true about a "while" each time it is about to test its conditions. cioe' e' la variabile incrementata all'interno del loop che finche' al di sotto di una certa soglia, permette di mantere a true (invariata) la condizione del ciclo while e di continuare a farlo looppare.

>> iostream library headers >> <iostream>
The C++ iostream libray provides hundreds of I/O capabilities. Several headers contain portions of the library interface. 
Most C++ programs include the <iostream> header, which declares baseic services required for all stream I/O operations.
The <iostream> header defines:
	>> cin  = standard input stream
example ---------------------------------------------------------------------
		// Hezbollah subroutine all rights reserved
		int rocketNumber;
		cout << "\nHow many rocket you need to launch? ";
		cin >> rocketNumber;   // >> extraction operator altri non e' che ">>" estrae il valore dallo standard input (la tastiera e lo inserisce nella variabile)
		cout << "number of rockets to be launched: " << rocketNumber << endl;
-----------------------------------------------------------------------------
	>> cout = standard output stream
	>> cerr = unbuffered standard error stream
	>> clog = buffered standard error stream
Both unformatted and formatted I/O stream are provided.
The >> <iomanip> / >> iomanip header declares services useful for performing formatted I/O with so called parameterized stream manipulators, such as setw and setprecision.
The >> <fstream> / >> fstream  header declares services for file processing. 
[pag565 deitel]
The iostream library provides many tempaltes for handling common I/O operations. For example, we have the following  class templates:
	>> basic_istream  = support stream-input operations
	>> basic_ostream  = support stream-output operations
	>> basic_iostream = supports both stream input and stream output operations  
Each template has a predefined template specialization that enables char I/O. In addition, the iostream library provides a set  of >> typedefs that provide aliases for these template specializations. 
>> typedef
example 	
	typedef unsigned short int ushort; 
this code defines the identifier "ushort" as another name for the type "unsigned short int"
Mike spiega [pag22 mike]:
To define new names for existing types, use typedef followed by the current type, followed by the new name. "typedef" is often used to create shorter names for types with long names. You can use your new type name just like the original type. 
Deitel spiega
The typdef specifier declares synonyms (aliases) for data types. You'll sometimes use typdef to create shorter or more readable type names. For example the statement:
	typdef Card *CardPtr;
defines an additional type name CardPtr as a synonum for type Card *. Creating a name using typedef does not create a data type; it creates only a new type name. 
The typedef istream represents a basic_istream<char> that enables char input.
Similarly the typedef ostream represents a basic_ostream<char> that enables char output.
Also the typedef iostream represents a basic_iostream<char> that enables both char input and output.
>> Stream I/O template hierarchy portion / >> inheritance relationships of stream-I/O templates / >> UML stream I/O inheritance relationships
[pag566 e 567 deitel]
>> standard input device = is usually the keyboard.
////////////////
>> cin [pag 566 deitel] = predefined objecdt cin is an istream instance and is said to be connected to the standard input device, which usually is the keyboard. The stream extraction operator  (>>) as used in the following statement causes a value for integer variable grade (assuming that grade has been declared as an int variable) to be input from cin to memory:
	cin >> grade; // data flows in the direction of the arrows. Vedi anche nostro trick pag 441 deitel
The compiler determines the data type of grade and selects the appropriate overloaded strem extraction operator. Assuming that grade has been declared properly, the stream extraction operator does not require additional type information. The >> operator is overloaded to input data items of fundamental types, strings and pointer values.
>> cout [pag566 deitel]
The predefined object cout is an ostream instance and is said to be "connect to" the >> standard output device, which is usually the display screen. The stream insertion operator <<  as used in the following statament, causes the value of variable grade to be output from memory to the standard output device:
	cout << grade; // data "flows" in the direction of the arrows. Vedi anche nostro trick pag 441 deitel
The compiler determines the data type of grade (assuming grade has been declares properly) and selects the appropriate stream insertion operator. The << operator is overloaded to output data items of fundamental types, strings and pointer values.
>> cerr [pag567 deitel]
The predefined object cerr is an ostream instance and is said to be connecte to the standard error device, normally the screen.
Outputs to object cerr are unbuffered, implying that each stream insertion to cerr causes its ouput to appear immediately (this is appropriate for notifying a user promptly about errors) 
[>> unbuffered meaning = cioe' che compare direttamente su schermo, senza essere confezionato "buffered" in un'area della memoria.]
>> clog [pag 567 deitel]
The predefined object clog is an instance of the ostream class and is said to be "connected to" the standard error device. Outputs to clog are buffered. This means that each insertion to clog could cause its output to be held in a buffer (that is an area in the memory) until the buffer is filled or until the buffer is flushed. Buffering is an I/O performance-enhancement technique discussed in operating systems courses.
>> file processing templates.
	>> ifstream = is a typedef represents a basic_ifstream<char> that enables char input from a file.
	>> ofstream = is a typedef that represents a basic_ofstream<char> that enables char output to a file.
	>> fstream = is a typedef that represents a basic_fstream<char> that enables char input from and output to a file
>> stream ouput 
pag567 deitel
Formatted and unformatted output capabilites are proveded by ostream. Capabilities include output of standard data types with the stream insertion operator (<<); output of characters via the "put" member function; unformatted output via the write member function. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





>> IDE integrated development environment for linux
- NetBeans (from Sun microsystem now Oracle)
- Eclipse (eclipse platform and Java IDE)
- Kdevelop (integrated development environment in ambiente KDE)
- Anjuta (in ambiente gnome)

>> IDENTIFIER 
A valid identifier is a valid sequence of one or more letters, digits or underscore characters (_)
Spaces, punctuation marks or symbols are not ammitted. Only letters, digits, and single underscore characters are valid.
Example 
	int number1 = 0;
number1 is the identifier of the variable, int is the fundamental type of the variable	
Other constraints:
- they have to begin with a letter, in no case they can begin with a digit.
- they cannot match any keyword of the C++ language which are reserved keywords (as break, do, delete, for, goto, if, int, long, new, try, while ect ect)
- remember the C++ is a "case sensitive" language.  That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters. (RESULTS Results  results)  
ex of a valid identifier:  C_127 = 1; 
C_127 is a valid identifier,certainly iiis, C127 is number one in the Vplus plus kingdom, the last refuge of  speedfreaks
NB: lunghezza massima: USE IDENTIFIERS of 31 characters or fewer to ensure portability; in effetti C++ allows identifiers of any length, but your C++ implementation may restrict identifier lengths. 
NB2: choosing meaningful identifiers makes a program self-documenting. Avoid using abbreviation in identifiers, this improves program readability. 
NB3: do not use identifiers that begin with underscore and double underscore, because C++ compilers may use names like that for their own purposes internally. This will prevent the names you choose from being confused with names the compilers choose. 

>> IF CONDITIONAL OPERATOR    [used as mikepag37 said "to branch section of code"]
IN SHORT mike pag3
	if (expression)
		statement;
if expression is true, then statement is executed. Otherwise, statement is skipped and the program branches to the statement after the if suite.
In maniera piu' generale 
	if (expression)   // dopo (expression) non ci va il ;
		{
			statement1;
			statement2;
			...
			statementn;
		}   // dopo } non ci va il ;
///////////////////////////////////////////////////////////////////
NOTE1 [from pag41 mike]: you can interpret any value as true or false. Any non zero value can be interpreted as true, while 0 can be interpreted as false. example 
	int score = 1000;
	if (score)
	{
		cout << "At least you didn't score zero.\n\n";
	}
NOTE2: 
IL SEGUENTE E' SBAGLIATO: 
if (false);
{ 
	cout <<"This is never displayed.\n\n";
}
Mettendo il ; dopo (false); => the if statement sees the false value and skips the next statement (che e' un empty statement) quindi procede con lo statement after if cioe' { cout <<"This is never displayed.\n\n";} che verra' printato su schermo! Non vedrai nessun compiler error! E otterrai un risultato sbagliato!
IN LONG
The conditional operator evaluates an expression returning a value if that expression is true and a different one if the expression is evaluated as false. Its format is: 
	condition ? result1 : result2
If condition is true the expression will return result1, if it is not it will return result2. 
Examples:
	7==5 ? 4 : 3   //return 3, since 75
    7==5+2 ? 4 :3  //return 4, since 7==5+2 is true 	5 > 3 ? a : b  //return the value of a 
    a > b ? a : b  //returns whichever is greater
                       a or b 
Example 2:
	int a,b,c;
	a=2;
	b=7;
	c = (a>b) ? a : b;
    cout << c;	
otterrai...
c = 7
----------------------------------------------------------------------
NOTE3: 
che quando si usa if else if le istruzioni vanno racchiuse tra {}  example:

        if (distanceSquare < first)
        {
            second = first;
            centerP2 = centerP1;
            first = distanceSquare;
            centerP1 = mesh.Cf().boundaryField()[patchI][i];
            //Info<< "center P1 is: " << centerP1 << endl;
            //Info<< "center P2 is: " << centerP2 << endl;
            //Info<< "first is: " << first << endl;
            //Info<< "distanceSquare is: " << distanceSquare << endl;
        }
 
        // If distanceSquare is in between first and second
        // then update second
        else if ( (distanceSquare < second) && (distanceSquare != first) )
        {   
            second = distanceSquare;
            centerP2 = mesh.Cf().boundaryField()[patchI][i];
            Info<< "CICCIO" << endl;
            Info<< "center P2 is: " << centerP2 << endl;
        }  
//!!!! 30 minuti che non capivamo perche senza {} dopo else if le istruzioni venivano eseguite comunque!
Se non le racchiudi tra {}, non da nessun errore, la riga che segue immediatamente verra' eseguita o meno a seconda che la condizione dell'else if sia vera o no, mentre tutte le righe che seguono "centerP2..." "Info<<Ciccio.." verranno sempre eseguite, visto che risultato all'esterno del blocco condizionale.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> IF CONDITION compact style 
extract from /home/dia/Deitel-Code_Examples/ch10/fig10_01
   string s1( "happy" );
   string s2( " birthday" );
   string s3;
   // test overloaded equality and relational operators
   cout << "s1 is \"" << s1 << "\"; s2 is \"" << s2
      << "\"; s3 is \"" << s3 << '\"' 
      << "\n\nThe results of comparing s2 and s1:"
      << "\ns2 == s1 yields " << ( s2 == s1 ? "true" : "false" )
      << "\ns2 != s1 yields " << ( s2 != s1 ? "true" : "false" )
      << "\ns2 >  s1 yields " << ( s2 > s1 ? "true" : "false" ) 
      << "\ns2 <  s1 yields " << ( s2 < s1 ? "true" : "false" )
      << "\ns2 >= s1 yields " << ( s2 >= s1 ? "true" : "false" )
      << "\ns2 <= s1 yields " << ( s2 <= s1 ? "true" : "false" );
//////////////////
il precedente estratto dara' in standard output:
	s1 is "happy"; s2 is " birthday"; s3 is ""	
	The results of comparing s2 and s1:
	s2 == s1 yields false
	s2 != s1 yields true
	s2 >  s1 yields false
	s2 <  s1 yields true
	s2 >= s1 yields false
	s2 <= s1 yields true
///////////////////////////////////////////////

>> IF statement IF single statement
nella forma piu' semplice "se condizione soddisfatta fai, se non soddisfatta non far nulla" if puo essere scritto giusto in due linee:
example 
	if ( number1 == number2 )
		cout << number1 << " == " << number2 << endl;
printera la linea solo se i due numeri sono uguali. 
example2
	if (purgeForce >= 7000 )
		cout << "Void Layer machine is flying";
[pag55deitel]
NB: il semicolon si mette solo dopo lo statement e NON dopo le parentesi tonde dell'IF		
placing a semicolon immediately after the right parenthsis after the condition in an if statement is often a logic error (although not a sintax error). The semicolon causes the body of the if statement to be empty, so the if statement performs no action, regardless of whether or not its condition is true. Worse yet, the original body statement of the if statement now becomes a statement in sequence with the if statement and always executes, often causes the program to produce incorrect results. 
Trovi un esempio pratico delle tragiche conseguenze di mettere un ; dopo "if()" a pag83 jesse book 
Se scrivessi 
if (SomeValue < 10);
	SomeValue = 10;
running this code show that SomeValue is always set to 10! The if statement terminates with the semicolon, e come se avessi scritto
if (Some Value < 10) // test
; // do nothing
SomeValue = 10; // assign
To minimize the chances of this problem, you can always write your if statements with braces, even when the body of the if statement is only one line:
if (SomeValue < 10)
{
	SomeValue = 10;
}
////////////////////////////////////////////////////////////////////////////////////////

>> IF ELSE double selection statement
[pag112 deitel] 
pseudo code example
	if antiGravitationalField is greater than or equal to 1000
		print "Levitating"
	else
		print "Not levitating"
in C++ becomes 
	if ( antiGravitationalField >= 1000 )
		cout << "Levitating";
	else
		cout << "Not levitating";
vi e' un'altra maniera piu' concisa per esprimere la precedente, utilizzando il conditional operator ?:
	cout << ( antiGravitationalField >= 1000 ? "Levitating" : "Not levitating");
[vedi anche voce : CONDITIONAL OPERATOR]

>> IF STATEMENT NESTED / >> if nested 
[pag 113]
[spiegato anche a pag87 jesse]
Example in pseudo code:
	if velocity is greater than or equal to 3400
		print "hypersonic speed reached"
	else
		if velocity is greater than or equal to 340
			print "sonic speed reached"
		else
			if velocity is greater than or equal to 100
				print "take-off speed reached"
			else
				print "unable to take off"
in C++ becomes :
	if (speed >= 3400)
		cout << "hypersonic speed reached";
	else
		if (speed >= 340)
			cout << "sonic speed reached";
		else
			if (speed >= 100)
				cout << "take-off speed reached";
			else
				cout << "unable to take-off";
Most programmers write the preceding statement as:
	if (speed >= 3400)
		cout << "hypersonic speed reached";
	else if (speed >= 340)
		cout << "sonic speed reached";
	else if (speed >= 100)
		cout << "take-off speed reached";
	else
		cout << "unable to take-off";
che trovo anche piu' carina ed elegante da leggere. Notare come a differenza del matlab non ci sia un end di conclusione.
NB : [Performance] a nested  if...else statement can perform much faster than a series of single-selection if statements, because of the possibility of early exit after one of the conditions is satisfied.
NB2 : metti all'inizio le condizioni che are more likely to be true  at the beginning of the nested statement. In tal modo la probabilita' che si esca prima aumenta, piu' veloce di cominciare con testare unfrequently occurring cases.
NB3 : C++ compiler always associate an else with the immediately preceding if unless to do otherwise by the placement of braces {} ->> see >> DANGLING-ELSE problem
NB4: [pag115deitel] the if selection statement expects only one statement in its body. Similarly the if and else parts of and if...else statement each expect only one body statement.  To include several statements in the body of an if or in either part of an if..else, enclose the statements in braces ({ and }). A statement contained within a pair of braces is called a block. 
example pratico 
if ( antiGrav >= 1000)
	cout << "Levitating successfully.\n";
else
{
	cout << "Power unsufficient.\n";
	cout << "Realign the Carbon-Carbon layers and exponentiate the orbital energy level 27.\n";
}
//////////////////////////////////////

>> else clause 
[mike pag43]
You can add an else clause to an if statement to provide code that will only be executed if the tested expression is false. Here's the form of an if statement that includes an else clause:
	if (expression)
		statement1;
	else
		statement2;
If expression is true, statement1 is executed. Then the program skips statement2 and executes the statement following the if suite. IF expression is false, statement1 is skipped and statement2 is executed. After statement2 completes, the program executes the statement following the if suite.
Example 
	// Score Rater 2.0
	// Demonstrates an else clause
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int score;
		cout << "Enter your score: ";
		cin >> score;
	
	    if (score >= 1000)
		{
	        cout << "You scored 1000 or more. Impressive!\n";
		}
		else
		{
			cout << "You scored less than 1000.\n";
		}
	
	    return 0;
	}
/////////////////////////////////////////////////////////////////////////////

>> IF sequence with else clauses pag 46 mike 
if (expression1)
	statement1;
else if (expression2)
	statement2;
...
else if (expressionN)
	statementN;
else
	statementN+1;
Example pratico:
// Score Rater 3.0
// Demonstrates if else-if else suite

#include <iostream>
using namespace std;

int main() 
{
	int score;
	cout << "Enter your score: ";
	cin >> score;

    if (score >= 1000)
	{
        cout << "You scored 1000 or more. Impressive!\n";
	}
	else if (score >= 500)
	{
        cout << "You scored 500 or more. Nice.\n";
	}
	else if (score >= 250)
	{
        cout << "You scored 250 or more. Decent.\n";
	}
	else
	{
		cout << "You scored less than 250. Nothing to brag about.\n";
	}

    return 0;
}




>> #include<iostream> :
tells the preprocessor to include the iostream standard file. This specific file (iostream) includes the declarations fo the basic standard input-output library in C++
[NB iostream sta per input output stream: uno "stream" in C++ is a convenient abstraction to perform input and output operations in sequential media such as the screen or the keyboad. A stream is an object where a program can either insert or extract characters to/from it.]

>> INCREASE DECREASE OPERATOR
increase operator (++) e descrease operator (--)
increase or reduce by one the value stored in a variable, They are equivalent to +=1 and -=1, respectively. Thus:
	c++;
	c+=1;
    c=c+1;
are all equivalent in its functionality: the three of them increase by one the value of c.
NB prefix/suffix: a characteristic of his operator is that it can be used both as a prefix and as a suffix. That means that it can be written either before the variable identifier (++a) or after (a++).In simple expression they both have exactly meaning BUT if used inside an outer expression
- if the increase operat..is used as a prefix (++a) the value is increare BEFORE the result of the outer expression is evalueted
	B=3;
	A=++B;
	// A contains 4, B contains 4
- if the increase operator is used as a suffix (a++) the value store in a e' utilizzato per il calcolo della outer expression, e solo dopo viene incrementato; ex:
	B=3;
	A=B++;
	// A contains 3, B contains 4


>> include / # include <...>  vs # include "userDefinedHeaderFiles" / >> headers
# include <system-header> 
	angle brackets, <>, enclose system headers. System headers may or may not be implemented as files. 
# include "user-defined-header-file-name" 
	user defined header files are included by enclosing the name in quotes. Typically, user defined headers have a suffix of .h

>> INCLUDE GUARD pag 379 380 deitel 
prevent multiple inclusion of header 
	#ifndef NAMEMIO_H
	#define NAMEMIO_H
	...
	#endfi
NOTE[pag380]: by convention the name of the neader is written in UPPERCASE with the period replaced by an underscore in the #ifndef and "define preproecssing directives of a header, quindi al posto di nomemio.h -> NOMEMIO_H
>> HEADER ifndef [osservazione simile from pag 71 moo book]: Header files should be guarded against multiple inclusion by wrapping the file ina an #ifndef GUARD_header_name directive. Headers should avoid declaring names that they do not use. In particular, they should not include using declaration, but instead should prefix standard library names with std:: explicitly.
example :/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/grade.h	
--------------------------------------------------------------------------------------
	#ifndef GUARD_grade_h
	#define GUARD_grade_h
	
	// `grade.h'
	#include <vector>
	#include "Student_info.h"
	
	double grade(double, double, double);
	double grade(double, double, const std::vector<double>&);
	double grade(const Student_info&);
	
	#endif
	

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> INITIALIZATION VARIABLE
1) Way 1
type identifier = initial_value; ex: 
	int a = 7;
2) Way 2
type identifier (initial_value); ex: 
	int a(7);

>> int :stands for integer
size 4 bytes
signed: -2147483648
unsigned 0 till 4294967295
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> INHERITANCE
[pag 483deitel]
in short 
Quando vedi i due punti  :  indica inheritance, example 
	class derivedClassName : public baseClassName
	{}
the keyword public (or protected or private) indica il tipo di inheritance
in long 
When classes share common attributes and behaviours, it's possible to define those attributes and behviours in a common "base" class and "inherit" those capabilities into new class definitions, enabling you to create the new classes with minimal amount of code.
NOMENCLATURA
>> base class = the class from which you inherit [they tend to be more general]
>> derived class = the class that inherits the members from the existing base class [they tend to be more specific].
A derived class represents a more specialized group of objects.
Other programming languages, such as Java and C# refer to the base class as the >> superclass and the derived class as the subclass.
C++ offers tre tipi di inheritance
	>> public inheritance
	>> protected inheritance [see voce protected per maggiori informazioni]
	>> private inheritance
>> public inheritance means that every object of a derived class is also an object of that derived class's base class. Cioe' ogni oggetto derivato e' un anche un oggetto della classe base ma il viceversa non e' vero. 
esempio :
if we have "Vehicle" as a base class and "Airplanes" as a derived class, then all "Airplanes" are "Vehicles", but not all "Vehicles" are "Airplanes", for examle a "Vehicle" could be a "Truck" or a "Boat".
>> inheritance vs composition / >> composition vs inheritance
we distinguish between the >> is-a relationship and the has-a relationship. The is-a relationship represents inheritance. In a is-a relationship, an object of a derived class also can be treated as an object of its base class: for example an Airplane is a Vehicle so any attributes and behaviors of a Vehicle are also attributes and behavior of Airplane. By constrast, the has-a relationship represents composition. In a has-a relationship, an object contains one or more objects of other classes as members. For example an Airplane has many components, has a stick, has a aileron, has a engine etc.
Vedi fig 11.2 pag 484 deitel UML class with five levels of inheritance. Each arrow in the hierarchy represents a is-a relationship. For example, as we follow the arrows in this class hierarchy, we can state "a Student is a Community Member"
_____________________  
Inheritance Examples |
---------------------
Base Class | Derived Class
- Student  | GraduateStudent, UndergraduateStudent
- Shape    | Circle, Triangle, Rectangle, Sphere, Cube
Inheritance relationships form >> class hierarchies. 
Although classes can exist independently, once they're employed in inheritance relationships, they become affiliated with other classes. 
A class becomes 
	- either a base class -> supplying members to other classes 
	- a derived class -> inheriting members from other classes
	- or both
Altre definitioni 
[pag485 deitel]
	>> single inheritance = a class is derived from one base class
	>> multiple inheritance = a derived class inherits simultaneously from two or more (possibly unrelated) classes. 
Usually is discouraged to use multiple inheritance. 
Inoltre si dice 
>> indirect base class = an indirect base class is inherited from two or more levels up the class hierarchy. see fig 11.2 pag 484 : communityMember is a indirect bas class di "Teacher". Starting from the bottom of the diagram, you can follow the arrow upwards and apply the is-a relationship to the topmost base class. For example, an AdministratorTeacher is an Administrato, is a Faculty member, is an Employee and is a CommunityMember.
Example  [pag485deitel]         
     |---------->   Shape  <------------|
     |                                  |
  2D_shape                           3D_shape
  ^       ^                          ^      ^
  |       |                          |      |
circle   triangle                sphere    tetrahedron

Nell'esempio sopra abbiamo 3 livelli di gerarchia. Le frecce rappresentano delle relazione "is-a" , per esempio:
a "Triangle" is a "2D_shape" and is a "Shape", while a sphere is a "3D_shape" and a is a "Shape"
To specify that class 2D_shape is derived from class "Shape" class 2D_shape could begin as follows:
	class 2D_shape : public Shape 
The above is an example of 
>> public inheritance
Public inheritance is the most commonly used from. 
Altre possibilita' sono la private inheritance and the protected inheritance. With all forms of inheritance, "private" members of a base class are not accessible directly from its derived classes, but there private base-class members are still inherited (i.e. they're still considered parts of the derived classes). 
NOTE1: "friend" functions are not inherited
NOTE2: >> inheritance vs composition / >> composition vs inheritance
Inheritance is not appropriate for every class relationship. Sometime is necessary to choose "has-a" relationship instead of a "is-a" relationship. For example given the classes:
- Spaceship
- Engine
- Stellarator
it's improper to say that a Spaceship "is a" Engine or that a Spaceship "is a" Stellarator. However it is appropriate to say that a Spaceship "has-a" Engine and that a Spaceship "has-a" Stellarator.
IMPORTANT  NOTE : 
	INSTEAD of COPY and PASTE, use INHERITANCE
[pag497deitel]
- Copying and pasting code fron one class to another can spread many physical copies of the same code and can spread errors throught a system, creating a code-maintenance nightmare. To avoid duplicating code (and possibly errors), use inheritance, rather than "the copy and paste" approach, in situation where you want one class to "absorb" the data members and member functions of another class.
- With inheritance, the common data members and member functions of all the classes in the hierarchy are declared in a base class. When changes are required for these common features, you need to make the changes only in the base class; derived classes then inherit the changes. Witout inheritance, changes would need to be made to all the source code files that contain a copy of the code in question.
NOTE2:
Quando vedi i due punti  :  indica inheritance, example 
	class derivedClassName : public baseClassName
	{}
the keyword public (or protected or private) indica il tipo di inheritance
A derived class inherits all the members of the base class, except for the constructor (each class provides its own constructors that are specific to the class. Destructor too are not inherited)
- NOTE from pag508
Note in the following extract the syntax used to invoke a redefined base-class member function from a derived class : you need to place the base-class name and the scope resolution operator (::) before the base-class member-function name. This member-function invocation is a good software engineering practice. 
example from Deitel-Code_Examples/ch11/fig11_14_15/BasePlusCommissionEmployee.cpp
	// calculate earnings
	double BasePlusCommissionSpaceShip::tonnaggio() const
	{
	   return getBaseCargoWeight() + CommissionSpaceShip::tonnaggio();
	} // end function earnings
By having BasePlusCommissionSpaceShip's tonnaggio() function invoke CommissionSpaceShip's tonnaggio function to calculate part of a BasePlusCommissionSpaceship object's cargo, we avoid duplicating the code and reduce code maintenance problems.
NOTE: when a base-class member function is redefined in a derived class, the derived-class version often calls the base class verion to do additional work. Failure to use the :: operator prefixed with the name of the base class when referencing the base class's member funtion causes infinite recursion, because the derived-class member function would then call itself.
>> C+11 inheriting base class constructors / >> inheritance base class in C+11
C++11 has the ability to inherit a base class's constructors. You can new do this by explicitly including a "using" declaration of the form
	using BaseClass::BaseClass;  //[>> using declaration tag / >> USING DECLARATION see  also moo book pag27
consiglio importante pag 69 moo book: non usare "using" declaration in *.h files, usale solo negli source files .c. Unlike a header file, a source file has no effect on the programs that use these functions. Hence reliance on using declaration in a source file is purely a local decision.]
anywhere in the derived-class definition.
[see pag 510 deitel for more info]
>> TABLE PUBLIC PROTECTED PRIVATE INHERITANCE / >> TABLE MEMBER ACCESSIBILITY
[see pag 511 deitel]
NOTE: [from pag 512] at the design stage in an object oriented system, the designer often determines that certain classes are closely related. The designer should "factor out" common attributes and behaviours and place these in a base class, then use inheritance to form derived classes.
>> INTERFACE INHERITANCE [pag536deitel]
A derived class can inherit interface and /or implementation from a base class. Each new derived class inherits one or more member functions that were defined in a base class, and the derived class uses the base class definitions.Hierarchies designed for interface inheritance tend to have their functionality lower in the hierarchy cioe': a base class specifies one or more functions that should be defined for each class in the hierarchy (i.e. they have the same prototype), but the individual derived classes provdie their own implementation of the function(s).
INSOMMA e' un po' come una presa elettrica. Le classi derivate utilizzano lo stesso prototipo (la stessa tipologia di presa elettrica). Ma poi come ciascuno sia implementato dentro cambia da classe derivata a classe derivata [come degli elettrodomestici, implementati diversamente all'interno ma hanno poi tutti la stessa presa elettrica (same prototype)].
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TAB data output. Ecco qui un esempio using \t\t in modo da tabulare bene i dati in output. 
[pag 44 jesse book]
#include <iostream>
  
int main()
{
   using std::cout;
  
   cout << "The size of an int is:\t\t"    
      << sizeof(int)    << " bytes.\n";
   cout << "The size of a short int is:\t" 
      << sizeof(short)  << " bytes.\n";
   cout << "The size of a long int is:\t"  
      << sizeof(long)   << " bytes.\n";
   cout << "The size of a char is:\t\t"    
      << sizeof(char)   << " bytes.\n";
   cout << "The size of a float is:\t\t"   
       << sizeof(float)  << " bytes.\n";
   cout << "The size of a double is:\t"    
      << sizeof(double) << " bytes.\n";
   cout << "The size of a bool is:\t"      
      << sizeof(bool)   << " bytes.\n";
  
   return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> protected vs private [pag229 moo book]
Quando a partire da una base class, derivi (via inheritance) una nuova classe, questa nuova classe non puo' accedere ai private members functions della base class. If you want to access them you need to modify the base class, e al posto di "private" devi usare "protected". The protected label gives derived classes access to the protected members of their constituent base-class objects, but keeps these elements inaccessible to users of the classes. 

>> INLINE FUNCTIONS pag122 jesse book
IN SHORT
	non usarle, il piccolo improvement in performance e' trascurabile e talvolta il loro uso puo' in effetti rendere il programma meno efficiente
IN LONG
When you call a function, execution of the program jumps to those instructions and when the function returns, execution jumps back to the next line in the calling function. 
A small performance overhead occurs in jumping in and out of functions. It turns out that some functions are very small, just a line or two of code, and an efficiency might be gained if the program can avoid making these jumps just to execute one or two instructions. 
If a function is declared with the keyword inline, the compiler does not create a real function, it copies the code from the inline function directly into the calling function. No jump is made; it is just as if you had written the statements of the function right into the calling function. 
Note that inline functions can bring a heavy cost. If the function is called 10 times, the inline code is copied into the calling function each of those 10 times. The tiny improvement in speed you might achieve might be more than swamped the increase in size of the executable program, whichmight in fact actually slow the program!
The reality is that today's optimizing compilers can almost certainly do a better job of making this decisiion than you can; and so it is genreally a good iea not to delcare a function inline unless it is only one or at most two statements in length. When in doubt tough, leave inline out.
------------------------------------------------------ INLINE FUNCTION EXAMPLE:
// Listing 5.9 - demonstrates inline functions
#include <iostream>
 
inline int Double(int); // declaration of inline function
  
int main()
{
   int target;
   using std::cout;
   using std::cin;
   using std::endl;
  
   cout << "Enter a number to work with: ";
   cin >> target;
   cout << "\n";
  
   target = Double(target);
   cout << "Target: " << target << endl;
  
   target = Double(target);
   cout << "Target: " << target << endl;
  
   target = Double(target);
   cout << "Target: " << target << endl;
   return 0;
}
  
int Double(int target)
{
   return 2*target;
}
///////////////////////////////////////////////////////////////////////////////////////////////

>> INLINE FUNCTIONS 
pag236deitel
Functions calls involve execution time overhead. 
Placing the  qualifier 
	inline
before a function's return type  in the function definition advises the compiler to generate a copy of the function's body every code in every plave where the function is called to avoid function called. This often makes the program larger. 
The compiler can ignore the "inline" qualifier and generally does so for all but the smallest functions. 
Today's optimizing compilers are so sophisticated that it's best to leave  inlining decisions to the compiler.	
pag383deitel
if a member function is declared in a class's body, the member funtion is implicitly declared inline. Remember that the compiler reserves the right not to inline any function.
Define a member function inside the class definition inlines the member function (if the compiler chooses to do so). This can improve performance.


>> INLINE FUNCTION / >> INLINING FUNCTIONS [pag168 mike programming game]
There's a small performance cost associated with calling a function. Normally this isn't a big deal because the cost is relatively minor. However, for tiny functions (such as one or two lines), it's sometimes possible to speed up program performance by inlining them. By inlining a function, you ask the compiler to make a copy of the function everywhere it's called. As a result, program control doesn't have to jump to a different location each time the function is called.
To mark a function for inlining, simply put "inline" before the function declaration (but not put "inline" before the function declaration; see example below)
By flagging the function with "inline" you ask the compiler to copy the function directly into the calling code. This saves the overhead of making the function call. That is, program control doesn't have to jump to another part of your code. For small functions, this can result in a performance boost. However, inlining is not a silver bullet for performance. In fact, indiscriminate inlining can lead to worse performance because inilining a function creates extra copies of it, which can dramatically increase memory consumption. 
HINT: when you inline a function, you realy make a request to the compiler, which has the ultimate decision on whether to inline the function. If your compiler thinks that inlining won't boost performance, it won't inline the function. 
CALLING INLINE FUNCTION: calling an inlined function is no different than calling a non inlined function.
----------------------------------------------------
FULL EXAMPLE (from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/taking_damage.cpp)
		// Taking Damage
		// Demonstrates function inlining
		
		#include <iostream>
		
		int radiation(int health);   // FUNCTION DECLARATION: in the function declaration you DO NOT use "inline" e' solo nella function definition [vedi sotto il blocco dopo main] che userai l'"inline" keyword 
		
		using namespace std;
		
		int main()
		{
		    int health = 80;
		    cout << "Your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		
		    return 0;
		}
		
		inline int radiation(int health)  // FUNCTION DEFINITION : put inline before the function definition.
		{
		    return (health / 2);
		}
--------------------------------------- END FULL EXAMPLE
NOTE: >> PROFILER / >> PERFORMANCE IMPROVEMENT : in the real world although obsessing about performance is a game programmer's favorite hobby, there's a danger in focusing too much on speed. In fact, the approach many developers take is to first get their game programs working well before they tweak for small performance gains. At that point, programmers will "profile" their code by running a utility (>> profiler) that analyzes where the game program spends time. If a programmer sees blottlenecks, he or she might consider hand optimization such as function inlining. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FULL EXAMPLE MAD LIB GAME 
// Mad-Lib
// Creates a story based on user input

#include <iostream>
#include <string>

using namespace std;

string askText(string prompt);
int askNumber(string prompt);
void tellStory(string name, string noun, int number, string bodyPart, string verb);

int main()
{
    cout << "Welcome to Mad Lib.\n\n";
    cout << "Answer the following questions to help create a new story.\n";
    
    string name = askText("Please enter a name: ");
    string noun = askText("Please enter a plural noun: ");
    int number = askNumber("Please enter a number: ");
    string bodyPart = askText("Please enter a body part: ");
    string verb = askText("Please enter a verb: ");
    
    tellStory(name, noun, number, bodyPart, verb);

    return 0;
}

string askText(string prompt)
{
    string text;
    cout << prompt;
    cin >> text;  // TRAP this simple use of "cin" works only with strings that have no white space in them (such as taps or spaces). So when a user is prompted for a name, he can enter "eri" ma "chuck norris" will cause a problem for the program, visto che c'e' uno spazio tra chuch e norris. There are ways to compensate for this, but that really requires a discussion of something called streams, which is beyond the scope of this book. So use "cin" in this way, but just be aware of its limitations.
    return text;
}

int askNumber(string prompt) // >> integer from the user // get integer from the user
{
    int num;
    cout << prompt;
    cin >> num;
    return num;
}

void tellStory(string name, string noun, int number, string bodyPart, string verb)
{
    cout << "\nHere's your story:\n";
    cout << "The famous explorer ";
    cout << name;
    cout << " had nearly given up a life-long quest to find\n";
    cout << "The Lost City of ";
    cout << noun;
    cout << " when one day, the ";
    cout << noun;
    cout << " found the explorer.\n";
    cout << "Surrounded by ";
    cout << number;
    cout << " " << noun;
    cout << ", a tear came to ";
    cout << name << "'s ";
    cout << bodyPart << ".\n";
    cout << "After all this time, the quest was finally over. ";
    cout << "And then, the ";
    cout << noun << "\n";
    cout << "promptly devoured ";
    cout << name << ". ";
    cout << "The moral of the story? Be careful what you ";
    cout << verb;
    cout << " for.";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> INPUT OUTPUT /  binary stream insertion and stream extraction operators 
[pag440deitel]
You can input and output fundamental-type data using the stream extraction operator >> and the stream insertion operator <<. 
The C++ class libraries overload these binary operators for each fundamental type, including pointers and char * strings. You can also overload these operators to perform input and output for your own types. 
See example : /home/dia/Deitel-Code_Examples/ch10/fig10_03_05

>> INPUT from keyboard/ >> get input from the user / >> input from the user
[pag32 and programma di esempio /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/lost_fortune.cpp]
	cout << "Welcome to Lost Fortune\n\n";
	cout << "Please enter the following for your personalized adventure\n";

	cout << "Enter a number: "; 
	cin >> adventurers;

	cout << "Enter a number, smaller than the first: ";
	cin >> killed;

	survivors = adventurers - killed;

	cout << "Enter your last name: ";
	cin >> leader;
IMPORTANT / ATTENTION: this simple use of cin to get a string from the user only works with strings that have NO WHITESPACE (such as tabs or spaces) in them. There are way to compensate for this, but that really requires a discussion of something called streams, which is beyond the scope of the present discussion. So, use cin in this way, but be aware of its limitations.  
>> OUTPUT TO SCREEN example from mike pag 32  /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/lost_fortune.cpp
	cout << "\nA brave group of " << adventurers << " set out on a quest ";
	cout << "-- in search of the lost treasure of the Ancient Dwarves. ";
	cout << "The group was led by that legendary rogue, " << leader << ".\n";

	cout << "\nAlong the way, a band of marauding ogres ambushed the party. ";
	cout << "All fought bravely under the command of " << leader;
	cout << ", and the ogres were defeated, but at a cost. ";
	cout << "Of the adventurers, " << killed << " were vanquished, ";
	cout << "leaving just " << survivors << " in the group.\n";

	cout << "\nThe party was about to give up all hope. "; 
	cout << "But while laying the deceased to rest, ";
	cout << "they stumbled upon the buried fortune. ";
	cout << "So the adventurers split " << GOLD_PIECES << " gold pieces.";
	cout << leader << " held on to the extra " << (GOLD_PIECES % survivors);
	cout << " pieces to keep things fair of course.\n";
Nota come si usa il modulus operator % in the expression GOLD_PIECES % survivors. The expression evaluates to the remainder of GOLD_PIECES / survivors , which is the number of gold pieces that would be left after evenly dividing the stash among all of the surviving adventurers.  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> interface of an object = the collection of operations that are possible of an object  
[pag10 moo book]

>> INTERFACE OF A CLASS 
[pag87deitel]
Interfaces define and standardize the ways in which things such as people and systems interact with one another. The interface (come per esempio i bottoni di un iPod) specifies what operations a system permits users to perform but does not specify how the operations are implemented inside the system.
Similarly, the interface of a class describes what services a class's clients can use and how to request those services, but not how the class carries out the services. 
We can specify a class's interface by writing a class definition that lists only the member-function names, return types and parameter types. 
- SEPARATING INTERFACE FROM IMPLEMENTATION / SEPARATION 
Each class definition can contain [like in example pag84 fig3.9] the complete definition of the class's public member functions and the declarations of its private data members. However, IT'S BETTER software engineering to define member functions OUTSIDE the class definition, so that their implementation details can be hidden from the client code. This practice ensures that you do not write client code that depends on the class's implementation details. 
Trovi un esempio nelle pagine 88-90deitel. 3 per lo meno i files necessary per rispettare questo interface/implementation separation approach:
1) un file myClassName.h contenente l'interface della classe; 
2) un file myClassName.cpp contenente l'implementazione della classe;
3) il file mainFunction.cpp dove si istanzia e si utilizza la classe con un #include myClassName.h
Observations 
	->>>>> IL FILE 1) myClassName.h dona la "class definition" containing the functions prototypes that specify the interface of the class. Although parameter names in function prototypes are optional (they're ignored by the compiler) many programmers use these names for documentation purposes. [See voce >> FUNCTION PROTOTYPES or pag87 per rappeler sa definition] . Also the *.h header still specifies the class's private data member as well. 
NB a function prototype is a declation function that tells the compiler the function's name, its return type and the types of its parameters. Solo nel caso del constructor you won't have any return type (constructors cannot return type not even void see pag 81 star tag)
esempi [da pag88deitel]
	explicit GradeBook ( std::string ); 
questo e' un constructor, so no return type e ; obbligatorio
	void setCourseName ( std::string ); 
this function prototype indicates that setCourseName requires a string parameter and does not return a value (its return type is void)
	std::string getCourseName() const;
this function prototype indicates that the function does not requires parameters and return a string.
Insomma these function prototypes are the same as the first lines of the corresponding function definitions in fig 3.9, except that the parameter names (which are optional in prototypes) are not included and each function prototype must end with a semicolon.
->>>>> IL FILE 2) myClassName.cpp contiene le "member-function definitions" representing the implementation of the class. 
- by convention member-function definitions are placed in a source-code file of the same base name (e.g. myClassName) as the class's header but with a .cpp filename extension. 
- Note that the const keyweord msut appear on boch the function prototypes  (fig.3.11 ,lines 13-14) and the function definitions for functions getCourseName and displayMessage (lines 22 and 28)
- each member function name is preceded by the class name and :: which is known as the scope resolution operator. This "ties" each member function to the (now separate) GradeBook class definition, which declares the class's member functions and data members.
- to indicate that the member functions in GradeBook.cpp are part of class GradeBook, we must first include the GradeBook.h header. This allows us to access the class name GradeBook in the GradeBook.ccp file.
When compiling GradeBook.cpp, the compiler uses the information in GradeBook.h to ensure that
	A) the first line of each member function matches its prototype in the GradeBook.h file
	B) each member function knows about the class's data members and other member functions
->>>>> IL FILE 3) main.cpp (client code) : istanziazione e utilizzo della classe by main 
Once compiled, the source files have to linked together, cioe' le chiamate delle member functions all'interno del client code [FILE 3] need to be tied to the implementation of the class's member functions 
- [pag92 deitel] separare un programma in questo modo permette di poter separare il lavoro di development tra piu' persone 
A) da un lato il client code programmer sviluppera' main.cpp 
B) dall'altra il class-implementation programmer sviluppera myClass.cpp
e hanno solo bisogno di definire insieme l'interface della classe. 
The client code programmer is not give myClass.cpp , so the client remains unaware of now myClass.cpp's member functions are implemented. The client code programmer needs to know only myClass's interface to use the class and must be able to link its object code.
Compilers and IDEs typically invoke the linker for you after compiling your code. 


[asdf]

>> JJJJJJJ

>> japanese. [pag14 moo book] 
To hold characters for Japanese we need to use not char bensi' wchar_t: it's a built-in type intended to hold "wide characters", big enough to hold kanji, hira and kana.

>> KKKKKKK

>> KEYWORDS common keywords in C++ 
see fig4.3 pag109deitel

>> LLLLLLLL / >> LLL

>> LONGEST NAME make >> SPACE >> WHITE SPACE making [no no black space and this is not racist please, we are programming here!]
Make white space according to the longest name in a list in modo che la seconda colonna venga bella diritta. 
Ne trovi un bell'esempio in pag65 moo book 
/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> lambda expressions
[pag729 deitel]
C++11 lambda expressions (r >> lambda functions) enable you to define anonymous function objects where they're passed to a function. They're defined locally inside functions and can "capture" (by value or by reference) the local variables of the envlosing function then manipulate these variables in the mabda's body. 
Example : /home/dia/Deitel-Code_Examples/ch16/fig16_16/fig16_16.cpp
OUTPUT 
	2
	4
	6
	8
	sum is 10
COMMENTS
     10    const size_t SIZE = 4; // size of array values
	 11    array< int, SIZE > values = { 1, 2, 3, 4 }; // initialize values
Lines 10 and 11 declare and initialize a small array fo ints named values. 
	 13    // output each element multiplied by two
	 14    for_each( values.cbegin(), values.cend(),
	 15       []( int i ) { cout << i * 2 << endl; } );
Lines 14-15 call the for_each algorithm on the elements of values. The third argument (line 15) to for_each is a lambda expression. Lambdas begin with lambda introducer [], followed by a parameter list and function body. Return types can be inferred automatically if the body is a single statement of the form return expression; otherwise the return type is void by default or you can explicitly use a trailing return type.
	 19    // add each element to sum
	 20    for_each( values.cbegin(), values.cend(),
	 21       [ &sum ]( int i ) { sum += i; } );
Lines 20-21 calculates the sum of the array elements. The lambda introducer [&sum] indicates that this lambda expression captures the local variable sum by reference (note the use of the ampersand), so that the lambda can modify sum's value. Without the ampersand, sum would be captured by value and the local variable outside the lambda expression would not be updated. The for_each algorihm passes each element of values 
to the lambda, which adds the value to the sum. 
	 23    cout << "sum is " << sum << endl; // output sum
Line23 then displays the value to sum. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LARGE PROGRAM the rigth way
[pag202]
the way to develop and maintain a large program is to construct it from small, simple pieces, or components. This technique is called DIVIDE et CONQUER [dividi et impera] 

>> LEFT 
[pag167deitel]
	left
non parameterized stream operator: used to indicate that values should be output left justified.
To restore right justification output with nonparameterized stream manipulator "right"

>> lvalue meaning 
An lvalue is a way of describing the term on the left hand side of an assignment. It is usually an address or variable.
In this declaration and initialization of the int variable a, the lvalue is a.
	int a = 9*7+c;
[source http://cplus.about.com/od/glossar1/g/lvalue.htm]
per una presentazione piu' approfondita see also http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c
[che ti ho salvato in webkaradocs come "understanding-lvalues-and-rvalues-in-c-and-c.html"]
FROM StackOverflow:
ANSWER1
	An lvalue is a value that can be assigned to:
	lvalue = rvalue;
	It's short for "left value" or "lefthand value" and it's basically just the value on the left of the = sign, i.e. the value you assign something to.
	As an example of what is not an lvalue (i.e rvalue only):
	printf("Hello, world!\n") = 100; // WTF?
	That code doesn't work because printf() (a function that returns an int) cannot be an lvalue, only an rvalue.
ANSWER2
	Something that appears on the left hand side of an assignment i.e. something that can be assigned to.
	Note that in C++ a function call may be an lvalue if:
		int & func() {
		   static int a = 0;
		   return a;
   		}
	then:
		func() = 42;     // is legal (and not uncommon)
ANSWER3
It's traditionally the left side of the "=" operator. However, with time, meaning of "lvalue"/"rvalue" changed. C++ added the term of a "non-modifiable lvalue" which is any lvalue that cannot assigned to: arrays and variables that are qualified with "const" are two examples. In C, you cannot assign to any rvalue (see below). Likewise, in C++, you cannot assign to rvalues that are not of some user defined class type.
You can say an "lvalue" is an expression that names an object which persists over time and occupies some location of storage. Whether or not you can assign to that expression is not important for that classification. A reference, in particular, is also an lvalue, because it has a name that persists over time. All the following are lvalues, because they all refer to named objects. Also note that a const does not have any effect on the lvalue-ness.
	int a; lvalue: a;
		   lvalue: ++a;
	int a[2]; lvalue: a;
	int &ra = a; lvalue: ra;
	int *pa = &a; lvalue: *pa;
The term "rvalue" is used for things like literals and enumerator values and for temporaries that do not enjoy the fun of having a long life and are destroyed right away at the end of a full expression. For rvalues, not the aspect of persistence is important, but the value-aspect. Functions in C++ are lvalues, because they are persistent and they have an address, even though they are not objects. I've left them out in the above overview of lvalues, because it's easier to grasp lvalues when first only taking objects into account. All the following are rvalues:
	enum { FOO, BAR }; rvalue: BAR;
	int a[2]; rvalue: (a+1);
	rvalue: 42;
	int a; rvalue: a++; // refering to a temporary
	struct mystruct { }; mystruct f() { return mystruct(); } rvalue: f();
Incidentally, often you have an lvalue, but an operator needs an rvalue. For example the binary builtin "+" operator adds two values. An lvalue expression first and for all specifies a location where a value first has to be read out. So when you add two variables, an "lvalue to rvalue" conversion takes place. The Standard says that the value contained in an lvalue expression is its rvalue result:
		int a = 0, b = 1;
		int c = a + b; // read values out of the lvalues of a and b.
Other operators do not take rvalue, but lvalues. They don't read a value. An example is the address-of operator, &. You cannot take the address of an rvalue expressions. Some rvalues are not even objects: They do not occupy any storage. Examples are again, literals (10, 3.3, ...) and enumerator values.
How is that scary stuff useful?
Well it has several advantages to have the distinction of lvalue and rvalue
    Allowing the compiler to omit taking storage for rvalues and using registers/readonly memory for scalar values
    Flagging expressions as elusive: rvalues will not live long
        Allows efficient copy semantics for the compiler internally and in c++1x also exposed to the programmer (see move semantics and rvalue references): We can steal away resources from rvalues that are going to be destroyed anyway.
    Allows to build rules upon that property
        rvalues are not allowed to be generated from a yet uninitialized objects where an lvalues refers to. But lvalues may refer to uninitialized objects just fine
        rvalues can never be polymorphic. Their static type must also be their dynamic type: Simplifies rules for the typeid operator.
... There is more to it, i feel it ...
[source http://stackoverflow.com/questions/579421/often-used-seldom-defined-terms-lvalue] 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
>> lvalue spieagazione also pag 56 moo book
an lvalue is a value that denotes a nontemporary object. For example
	a variable 
	a reference 
	the result of calling a function that returns a reference 
are lvalue arguments. 
An expression that generates an arithmetic value, such as sum/count is not an lvalue 

>> LIBRARIES BOOST C++ libraries
the boost C++ libraries are free, open-source libraries created by members of the C++  community. Boost provides C++ programmers with useful libraries that work well with the existing C++ standard library. Some of the C++11 Standard Library features were derived from corresponding Boost libraries. 

>> LIBRARY ORDER / >> ORDER LIBRARY during compiling
quando si compile in g++ l'ordine con cui si elencano i files e' importante?
    cd /home/dia/Deitel-Code_Examples/ch10/fig10_09_11
    g++ Array.h Array.cpp fig10_09.cpp -o executable
ci funziona [thanks Ciccio] ma volevamo giusto sapere se l'ordine con cui si scrivono i files e' davvero indifferente.
ANSWER:
from this link [salvato in blackbird]
http://stackoverflow.com/questions/492374/g-in-what-order-should-static-and-dynamic-libraries-be-linked
it seems that as long are they are static libraries the order in which you list them is not important

>> LIFO 
	= Last In First Out
in LIFO data structure the last item pushed (inserted ) on the stack is the first item popped (removed) from the stack. 

>> LINKAGE identifier
[pag226deitel]
An identifier's linkage determines whether it's known only inthe source file where its declared or cress multiple files that are compiled, then linked together. An identifier's storage class specifier helps determine its storage duration and linkage.

>> LINUX WINDOWS same calculation different results / >> Windows Linux same calculation different results 
[stackoverflow.com/questions/16744245/same-calculation-on-linux-and-windows-different-results]
Original code:
	string toFormatFromDecimal(long long t, Format format) {
		int digitCount = ceil(log(t) / log((int) format));
		string hex = "";
		for (int i = 0; i < digitCount; i++) {
			long double cur = (long double)t / (long double)(format);
			long long ganzzahl = (long long) cur;
			long double kommazahl = cur - ganzzahl;
			hex += digits[(long long) (kommazahl * format)];
			t = ganzzahl;
		}
		return string(hex.rbegin(), hex.rend());
	}
SOLUTION 
	string toFormatFromDecimal(long long t, Format format) {
		int digitCount = ceil(log(t) / log((int) format));
		string hex = "";
		for (int i = 0; i < digitCount; i++) {
			hex += digits[(int) (t%format)];
			t = t/format;
		}
		return string(hex.rbegin(), hex.rend());
	}
NOTE1: 	Yes, GCC and Visual Studio C++ have different long double types. On GCC generating code for x86, long double is a 80-bit double-extended IEEE 754 format(*), whereas Visual Studio C++ treats long double like a 64-bit double-precision IEEE 754 format(*).
So (long double)t does not have to be the same number on both platforms, and the division is not the same either. Although you have tagged your question "integer-division", it is a floating-point division between different floating-point types.
(*) almost: it behaves very very much like a 79-bit IEEE 754 type with 15 exponent bits and 63 significand bits would, but it has a slightly wider exponent range since it uses an explicit bit for the leading 1 in the significand.
(**) almost: because the compiler generates instructions that use the historical x87 instructions after having configured the x87 for 53-bit significands, denormal results may be double-rounded
NOTE2: To make the program work the same on both platforms, avoid floating-point completely
/////////////////////////////////////////////////////////////////////////////
See also 
http://stackoverflow.com/questions/1961442/different-math-rounding-behaviour-between-linux-mac-os-x-and-windows
> n addition to the runtime rounding settings that people mentioned, you can control the Visual Studio compiler settings in [rigth click sul nome del progetto li dal solution explorer] Properties > C++ > Code Generation > Floating Point Model. I've seen cases where setting this to "Fast" may cause some bad numerical behavior (e.g. iterative methods fail to converge).
//////////////////////////////////////////////////////////////////////////////

>> LIST INITIALIZER 
[pa139deitel]
The list initializer can be a comma separated list of values that are passed to the object's constructor. Supponi per esempio di creare una classe SpaceShip che rappresenti il nome dell'astronave, anno di creazione e payload in tonnellate. Assuming the class defines a construct that receives a string for the spaceship name, a int for the year of creazione e a double for the tonnellaggio, potremmo inizializzare "SpaceShip" objects as follows:
	SpaceShip spaceship1{ "Falcor", 2592, 37689.5};
	SpaceShip spaceship2{ "Nostromo", 2552, 23689.0};
- for a fundamental type variable invece you place only one value in the list initializer ex
	unsigned int CruisingYearsCounter{ 1 };
usare un initializer ha il vantaggio che se il type e' diverso da quello atteso (esempio inserisci un real number al posto di un integer ottieni un compilation error, e cio' ti puo' aiutare nell'evitare subtle logic errors)
	int x = 12.7 // non ti da nessun errore, giusto un warning e si effettua una narrowing conversion cioe' x diventa = 12
invece usando 
	int x = { 12.7 };
or
	int x{ 12.7 };
ti avverte con un errore di compilazione.
NOTE: ulteriori informazioni from pag392
C+121 now provides a niform initialization syntax called list initializers that can be used to initialize any variable. So instead of the line 11-13 di fig9.6 [riportate qui sotto per migliore convenienza]
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2( 2 ); // hour specified; minute and second defaulted
	   Time t3( 21, 34 ); // hour and minute specified; second defaulted 
	   Time t4( 12, 25, 42 ); // hour, minute and second specified
le possiamo riscrivere usando i list initializers nel modo seguente (cioe' tutto resta uguale a parte le parentesi tonde che diventano graffe) :
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2{ 2 }; // hour specified; minute and second defaulted
	   Time t3{ 21, 34 }; // hour and minute specified; second defaulted 
	   Time t4{ 12, 25, 42 }; // hour, minute and second specified		
o anche 
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2 = { 2 }; // hour specified; minute and second defaulted
	   Time t3 = { 21, 34 }; // hour and minute specified; second defaulted 
	   Time t4 = { 12, 25, 42 }; // hour, minute and second specified
The form without the = is preferred. 
//////////////////////////////////////////////////////////////////////////////////



>> LIST sequence container
[pag658deitel]
the list sequence container (from header <list>) allows insertion and deletion operations at ANY location in the container. If most of the insertions and deletions occur at the ends of the container, the "deque " data structure provides a more efficient implementation. 
Class template list is implemented as a >> doubly linked list (every node in the list contains a pointer to the previous node in the list and to the next node in the list). This enables class template list to support >> bidirectional iterators that allow the container to be traversed both forward and backward. 
>> forward list 
[pag 658 deitel]
a partire da C+11 e' disponibile the forward_list sequence container (header <forward_list>), which is implemented as a >> singly linked list (= every node in the list contains a pointer to the next node in the list). This enables class template list to support forward iterators that allow the container to be traversed in the forward direction. Any algorithm that requires input, output or forward iterators can operate on a forward_list.
Class template list provides also the following member functions:
	>> splice -> pag661 deitel
	>> push_front
	>> pop_front -> pag662 deitel
	>> remove   [see also pag 699 deitel]
	>> remove_copy algorithm [see pag 116 moo book]
the remove_copy algorithm does what remove does, but copies its results to an indicated destination.
	>> remove_if 
	>> remove_copy_if [pag 117 moo book]
remove_copy_if operates like remove_copy, except that it uses a predicate as its test, rather than a value.
	>> unique
	>> merge -> pag662 deitel  [vedi anche poco qui sotto esempio]
	>> reverse 
	>> sort -> pag661 deitel
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line29
/////////////
Several of these member functions are list-optimized implementations of the Standard Library alorithms presented in Chapter 16.
Both push_front and pop_front are also supported by forward_list and deque. 
>> CREATE LIST OBJECTS / >> create objects list / >> list object creation / >> list creation 
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line17-18
   list< int > values; // create list of ints  // line 17
   list< int > otherValues; // create list of ints // line 18
lines 17-18 instantiate two list objects capable of storing ints. 
The following line (line 29) uses list member function sort to arrange the elements in the list in ascending order.
	values.sort(); // sort values  // line 29
NOTE: this is different from the sort in the standard library algorithms.
A second version of function sort allows you to supply a binary predicate function that takes two arguments (values in the list), perform a comparison and returns a bool value indicating whether the first argument should come before the second in the sorted contents. This function determines the order in which the lements of the list are sorted. This version could be particularly useful for a list that stores pointers rather than values.
>> SPLICE list member function / >> splice member function / 
[pag 661 deitel]
Line 39 uses list function splice to remove the elements in otherValues and insert them into values before the iterator position specified as the first argument.
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line39
   // remove otherValues elements and insert at end of values
   values.splice( values.cend(), otherValues );
Ci anche due altre varianti della funzione splice, rispettivamente con 3 e con 4 argomenti see pag 61 deitel
Per esempio Function splice with four arguments uses 
- the last two arguments to specify a range of locations that sould be removed from the container in the second argument 
- and placed at the location specified in the first argument.
>> merge member function list / >> list member function merge 
[pag662 deitel]  
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 54
   // remove otherValues elements and insert into values in sorted order
   values.merge( otherValues );   // line 54
line 54 uses list member function merge to remove all elements of "otherValues" and insert them in sorted order into values. Both lists must be sorted in the same order before this operation is performed.
>> list member function pop_front / >> pop_front list member function 
list function pop_front to remove the first element in the list 
	values.pop_front(); // remove element from front
>> pop_back list member function to remove the last element in the list
	values.pop_back(); // remove element from back 
>> unique / >> duplicate element / >> remove duplicate element in a list 
[pag 662 deitel]
function unique remove duplicate elements in the list. 
IMPORTANTE: The list should be in sorted order (so that all duplicates are side by side) before this operation is performed, to guarantee that all duplicates are eliminated.
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 65
   values.sort();  // prima ordiniamo gli elementi della lista 
   values.unique(); // remove duplicate elements  line 65
   cout << "\nAfter unique, values contains: ";
   printList( values );  
///////
>> swap / >> list member function swap
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 70
   // swap elements of values and otherValues
   values.swap( otherValues );
swap is used to exchange the contents of list "values" with contents of list "otherValues"
NOTE: see anche pag 710 deitel o voce "algorithm swap"
///////
>> assign / >> remove / >> list member functions assign and remove
>> remove element from a list
>> replace element in a list within a certain range -> using assign member function see line 77 below
[pag662 deitel]
the line 77 of the following extract uses list function assign to replace the contents of "values" with the contents of "otherValues" in the range specified by the two iterator arguments. 
the line 86 uses list function remove to delete all copies of the value 4 from the list 
   // replace contents of values with elements of otherValues
   values.assign( otherValues.cbegin(), otherValues.cend() );  ///// line 77
   cout << "\nAfter assign, values contains: ";
   printList( values );
   // remove otherValues elements and insert into values in sorted order
   values.merge( otherValues ); 
   cout << "\nAfter merge, values contains: ";
   printList( values ); 
   values.remove( 4 ); // remove all 4s    ///////////////////////// line 86
   cout << "\nAfter remove( 4 ), values contains: ";
   printList( values );
   cout << endl;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LITERAL CONSTANTS
are used to express particular values within the source code of a program. Literal Constants can be divided in Interger Numerals, Floating Point Numerals, Strings and Boolean Values.
NOTE from mike pag35: "Tron Ignition" is a string literal, while "42" and "72" are numerical literal

>> LOCAL VARIABLE 
variables declared in a function definition's body are known as local variables and can be used ONLY from the line of their declaration in the function to the closing right brace } of the block in which they are declared.
- a local variable must be declared before it can be used in a function. A local variable cannot be accessed outside the function in which it's declared. When a function terminates, the value of its local variables are lost (with the exception of the static local variables).
[pag74deitel]

>> LOGICAL OPERATORS mike pag58
Operator      Description      Sample Expression 
!             Logical NOT      !expression 
&&            Logical AND      expression1 && expression2
||            Logical OR       expression1 || expression2
---------------------------------------------------------
NOTE logical operators precedence 
! > && > ||
! has a higher level of precedence than logical AND, &&, which has a higher precedence than logical OR, ||. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> LOGICAL OPERATORS (!, &&, ||)
- The operator ! is the C++ operator to perform the boolean operation NOT, it has only one operand, located at its right, and the only thing that is does is inverse the value of it. ex:
	!(5 == 5) // evalualte to false since (5==5) 
                 is true
    !(6 <= 4) // evaluate to true because (6 <= 4)
                 would be false      
    !true     // evaluate to false
    !false    // evaluate to true
- The logical operator AND: &&
	a     |   b   | a&&b
	true  | true  | true
	true  | false | false
	false | true  | false
	false | false | false
- The logical operator OR:  ||
	a     |   b   | a||b
	true  | true  | true
	true  | false | true
	false | true  | true
	false | false | false
--------------------------------------------------
[from pag180deitel] 
Logical operators are used to form more complex conditions by combining simple conditions
- AND (&&) operator : used to ensure that  two conditions are both true before we choose a certain path of execution.
example 
if ( spaceshipType == intergalactic && Tons >= 12890 )
	++HeavyDutyVesselUnits;
//
- NB1: the right side of a logical AND expression is evaluated only if the left side is true [this is the so called short-circuit evaluation . Similmente il short circuit avviene con || quando la prima condition is true, inutile to evalute the following condition visto che sia che sia vera o falsa the overall expression is true].
- NB2: in expressions using operator &&, make the condition most likely to be false the leftmost condition. In expression using operator || make the condition most likely to be true the leftmost condition. This use of short-circuit evaluation can reduce a program's execution time.
- NB3: [pag181] una condizione del tipo 3 < x < 7 benche' corretta matematicamente non puo' essere utilizzata tale quale in C++ . 
Use (3 < x && x < 7 ) to get the proper evaluation in C++
- NB4: to make the combined condition more readable you can add redundant parenthesis:
	if ( ( spaceshipType == intergalactic )  && ( Tons >= 12890 ) )	
		++HeavyDutyVesselUnits;
- NB4: the && operator has a higher precedence than the || operator. Both operators associate from left to right.
----------------------------------------------------
LOGICAL OPERATOR EXAMPLE 
[pag183deitel]
Code_Examples/ch05/fig05_18/fig05_18.cpp
  3 #include <iostream>
  4 using namespace std;
  5
  6 int main()
  7 {
  8    // create truth table for && (logical AND) operator
  9    cout << boolalpha << "Logical AND (&&)"
 10       << "\nfalse && false: " << ( false && false )
 11       << "\nfalse && true: " << ( false && true )
 12       << "\ntrue && false: " << ( true && false )
 13       << "\ntrue && true: " << ( true && true ) << "\n\n";
 14
 15    // create truth table for || (logical OR) operator
 16    cout << "Logical OR (||)"
 17       << "\nfalse || false: " << ( false || false )
 18       << "\nfalse || true: " << ( false || true )
 19       << "\ntrue || false: " << ( true || false )
 20       << "\ntrue || true: " << ( true || true ) << "\n\n";
 21
 22    // create truth table for ! (logical negation) operator
 23    cout << "Logical NOT (!)"
 24       << "\n!false: " << ( !false )
 25       << "\n!true: " << ( !true ) << endl;
 26 } // end main
//==================================================//

>> LOGICAL OPERATOR example mike pag58
// Designers Network
// Demonstrates logical operators
#include <iostream>
#include <string>
using namespace std;
int main() 
{
	string username;
	string password;
	bool success;

	cout << "\tGame Designer's Network\n";

	do
	{
		cout << "\nUsername: ";
		cin >> username; 

		cout << "Password: ";
		cin >> password; 

		if (username == "S.Meier" && password == "civilization")
		{
			cout << "\nHey, Sid.";
			success = true;
		}

		else if (username == "S.Miyamoto" && password == "mariobros")
		{
			cout << "\nWhat's up, Shigeru?";
			success = true;
		}

		else if (username == "W.Wright" && password == "thesims")
		{
			cout << "\nHow goes it, Will?";
			success = true;
		}

		else if (username == "guest" || password == "guest")
		{
			cout << "\nWelcome, guest.";
			success = true;
		}

		else
		{
			cout << "\nYour login failed.";
			success = false;
		}
	} while (!success);   // while (true) cioe while true == !success cioe' finche not successul is true continua a loopare.

    return 0;
}
//
------------------------------
NOTE: al posto di (username == "guest" || password == "guest") si possono anche introdurre per maggior leggibilita' delle >> redundant parentheses:
	( (username == "guest") || (password == "guest") )
while the extra parentheses don't change the meaning of the expression, they really help the two smaller expressions, joined by the || operator, stand out.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> long double : long double precision floating point number 
size: 8byte 
range: +/-1.7e+308 =(~15 digits)

>> long int (long) = long integer
size 4 bytes (= 32bits visto che 1byte = 8bit)
signed: -2147483648
unsigned long int : 0 till 4294967295
In C++11 is also available 
	unsigned long long int 
(which can be abbreviated as unsigned long long). On some systems enables you to store values in 8 bytes (64bits) which can hold numbers as large as 18,446,744,073,709,551,615 (~ 18 miliardi di miliardi)
[pag251deitel]

>> MMMMMMM

>> main ()
The main function is the point by where ALL C++ programs start their execution, independently of its location within the source code. In un classico programma potrai ad esempio veder scritto 
int main () 
The word main is followed by a pair of parenthesis (). That is because is a function declaration. In C++ what differentiate a function declaration from other types of expressions are these parentheses that follow its name. Optionally, these parenthesis may enclose a list of parameters within them. Right after these parenthesis we can find the body of the main function enclosed in braces {}. What is contained within these braces is what the function does when it is executed. 

>> median search inside a vector [example pag 43-45 moo book]
FULL PROGRAM ------------------------------------------------
	#include <algorithm>
	#include <iomanip>
	#ifndef __GNUC__
	#include <ios>
	#endif
	#include <iostream>
	#include <string>
	#include <vector>
	
	using std::cin;             using std::sort;
	using std::cout;            using std::streamsize;
	using std::endl;            using std::string;
	using std::setprecision;    using std::vector;
	
	int main()
	{
		// ask for and read the student's name
		cout << "Please enter your first name: ";
		string name;
		cin >> name;
		cout << "Hello, " << name << "!" << endl;
	
		// ask for and read the midterm and final grades
		cout << "Please enter your midterm and final exam grades: ";
		double midterm, final;
		cin >> midterm >> final;
	
		// ask for and read the homework grades
		cout << "Enter all your homework grades, "
		        "followed by end-of-file: ";
	
		vector<double> homework;
		double x;
		// invariant: `homework' contains all the homework grades read so far
		while (cin >> x)
			homework.push_back(x);
	
		// check that the student entered some homework grades
	#ifdef _MSC_VER
		typedef std::vector<double>::size_type vec_sz;
	#else
		typedef vector<double>::size_type vec_sz;
	#endif
		vec_sz size = homework.size();
		if (size == 0) {
			cout << endl << "You must enter your grades.  "
			                "Please try again." << endl;	
			return 1;
		}
	
		// sort the grades
		sort(homework.begin(), homework.end());
	
		// compute the median homework grade
		vec_sz mid = size/2;
		double median;
		median = size % 2 == 0 ? (homework[mid] + homework[mid-1]) / 2
		                       : homework[mid];
	
		// compute and write the final grade
		streamsize prec = cout.precision();
		cout << "Your final grade is " << setprecision(3)
		     << 0.2 * midterm + 0.4 * final + 0.4 * median
		     << setprecision(prec) << endl;
	
		return 0;
	}
	

FULL PROGRAM END --------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> median  function to computer
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/median.cc]
[pag53 moo book]
	// source file for the `median' function
	#include <algorithm>    // to get the declaration of `sort'
	#include <stdexcept>    // to get the declaration of `domain_error'
	#include <vector>       // to get the declaration of `vector'
	
	using std::domain_error;   using std::sort;   using std::vector;
	
	#include "median.h"
	
	// compute the median of a `vector<double>'
	// note that calling this function copies the entire argument `vector'
	double median(vector<double> vec)
	{
	#ifdef _MSC_VER
		typedef std::vector<double>::size_type vec_sz;
	#else
		typedef vector<double>::size_type vec_sz;
	#endif
	
		vec_sz size = vec.size();
		if (size == 0)
			throw domain_error("median of an empty vector");  // throw exception
	
		sort(vec.begin(), vec.end());
	
		vec_sz mid = size/2;
	
		return size % 2 == 0 ? (vec[mid] + vec[mid-1]) / 2 : vec[mid];
	}
///////////////////////////////////////////////////////////////////////////////////////////

>> manipulator see pag 4 moo book
example 
	std::endl is a manipulator
The key property of manipulators is that writing a manipulator on a stream manipulates the stream. 
In the case of std::endl the action is to end the current line of output.

>> RANDOM NUMBER mike pag64
In short 
	#include <cstdlib>
	int randomNumber = rand(); // generate random number
NOTE: the rand() function generates a random number between 0 and at least 32767. The exact upper limit depends on your implementation of C++. The upper limit is stored in the constant RAND_MAX, which is defined in cstdlib. So if you want to know the maximum random number rand() can generate, just send RAND_MAX to cout.
--------------------------------------------------------------------------
EXAMPLE:
--------
// Die Roller
// Demonstrates generating random numbers

#include <iostream>
#include <cstdlib>  // this file contiene (among other things) functions that deal with generating random numbers. Because we included the file we are then free to call the functions it contains, includeing the function rand(), which is what we do in main()
#include <ctime>

using namespace std;

int main()
{
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time

	int randomNumber = rand(); // generate random number. In questo caso tra le parentesi tonde non vi e' alcun argument visto che rand non ha bisogno di alcun input per generare un numero random
	cout << " il massimo valore che puo' assumere random number nella tua implementazione C++ e' " << RAND_MAX << endl;
	int die = (randomNumber % 6) + 1; // get a number between 1 and 6
	cout << "You rolled a " << die << endl;

    return 0;
}
----------------------
OUTPUT:
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
 il massimo valore che puo' assumere random number nella tua implementazione C++ e' 32767
You rolled a 2
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> SEED RANDOM NUMBER GENERATOR / >> seeding random number / >> srand [mike pag66]
IN SHORT
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
IN LONG 
Computers generate pseudorandom numbers (not truly random numbers) based on a formula. One way to think about this is to imagine that the computer reads from a huge book of predetermined numbers. By reading from this book, the computer can appear to produce a sequence of random numbers. 
But there's a problem: the computer always starts reading the book from the beginning. Because of this the computer will always produce the same series of random numbers in a program. In games, this ins't something we would want.
A solution to this problem is to tell the computer to start reding from some arbitrary place in the book when a game program begins. This process is called seeding the random number generator. Game programmers give the random number generator a number , called a seed, to determine the starting place in this sequence of pesudorandom numbers.
(sembra che sia proprio cio' che bisognerebbe introdurre nel codice di shuffle/random play dell'ipod) 
example:
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
the previous line seeds the random number generator. It seeds the random number generator based on the current date and time, which is perfect since the current date and time will be different for each run of the program.
In term of the actual code, the srand() function seed the random number generator (you just have to pass it an unsigned int as a seed). What gets passed to the function here is the return value of time(0), a number based on the current system date and time. 
[ah bene >> cast : nota come nella frase seguente mike usi cast in maniera chiara cast = convertire, "casting a value from one type to another" significa "convertire una variabile da un tipo ad un altro, per esempio convertire un signed integer into an unsigned integer.]
The code static_cast<unsigned int> just converts (or casts) this value to an unsigned int.
If you want to generate a series of random numbers that are different each time the program is run, your program should execute this line once before making calls to rand().
Example 
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
	int randomNumber = rand(); // generate random number
>> SHUFFLE [pag127 and 128 mike]
standard library algorithms can work also with containers defined outside of the STL. These containers only have to meet certain requirements. For example, even though string objects are not part of the STL, you can use appropriate STL algorithms on them.
example of >> shuffle the characters in a word:
	string word="High Scores";
	random_shuffle(word.begin(), word.end());
the preceding code randomly shuffles the characters in "word".  As you can see, string objects have both begin() and end() member functions, which return iterators to the first character and one past the last character, respectively. That's part of the reason why STL algorithms work with strings (because they are designed to)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> RANDOM NUMBER WITHIN RANGE [mike pag 67 ]
puoi usare il modulus operator 
	(numeroRandom % maxRangeDesiderato) + 1; // donera' un numero tra 1 e maxRangeDesiderato
del resto ogni numero diviso by maxRangeDesiderato, donera' un remainder between 0 and maxRangeDesiderato.
example:
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
	int randomNumber = rand(); // generate random number
	int die = (randomNumber % 6) + 1; // get a number between 1 and 6
	cout << "You rolled a " << die << endl;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> math algorithms / >> mathematical algorithms / >> algorithm mathematical
[pag702 deitel]
please refer to /home/dia/Deitel-Code_Examples/ch16/fig16_05/fig16_05.cpp 
Nel sopra citato programma trovi utili funzioni:
>> random_shuffle algorithm 
	random_shuffle( a1.begin(), a1.end() );
la precedente linea uses the random_shuffle algorithm to reorder randomly the elements in the range a1.begin() up to but not including a1.end().
Note: thie version of random_shuffle uses rand for randominzation and produces the same results each time you run the program unless you seed the random-number generator with srand.
>> count 
puoi usare questo algorithm per individuare quante volte un certo elemento e' presente all'interno di un vettore. 
esempio:
	int result = count( a2.cbegin(), a2.cend(), 8 );
la precedente linea uses the count algorithm to count the elements with the value 8 in the range a2.cbegin() up to, but not including a2.cend(). This algoirthm requires its two iterator arguments to be at least input iterators.
>> count_if : per individuare quanti elementi all'interno di un vettore sono piu' grandi di un certo valore. Example: trovare tutti gli elementi che sono piu' grandi di 9
	 result = count_if( a2.cbegin(), a2.cend(), greater9 );
>> min_element : per individuare l'elemento piu' piccolo all'interno di un vettore 
   cout << "\n\nMinimum element in a2 is: "
      << *( min_element( a2.cbegin(), a2.cend() ) );
NOTE: error-prevention: it's a good practice to check that the range specified in a call to min_element is not empty and that the return value is not the "past the end" iterator.
>> max_element [pag 705 dietel]: algorithm utilizzato per individuare l'elemento piu' grande all'interno di un vettore.
   cout << "\nMaximum element in a2 is: "
      << *( max_element( a2.cbegin(), a2.cend() ) );
>> minmax_element  [algorithm disponibile a partire da C++11]
with this algorithm you can locate both the smallest and largest elements in un vettore.
If there are duplicate smallest or largest elements, the iterators are located at the first smallest and last largest values.
   auto minAndMax = minmax_element( a2.cbegin(), a2.cend() );
   cout << "\nThe minimum and maximum elements in a2 are "
      << *minAndMax.first << " and " << *minAndMax.second
      << ", respectively";
>> accumulate  [utile per esempio mi pare per calcolare la >> media / >> average nel senso che se sei il numero di elementi bastera' dividere il risultato ottenuto da accumulate per il numero di elementi]
   // calculate sum of elements in a1
   cout << "\n\nThe total of the elements in a1 is: "
      << accumulate( a1.cbegin(), a1.cend(), 0 );
La linea precedente uses the accumulate algorithm (the template of which is in header <numeric>) to sum the values in the range from a1.cbegin() up to, but not including a1.cend().
>> for_each algorithm
[pag706 deitel] 
from /home/dia/Deitel-Code_Examples/ch16/fig16_05/fig16_05.cpp
   // output square of every element in a1
   cout << "\n\nThe square of every integer in a1 is:\n";
   for_each( a1.cbegin(), a1.cend(), outputSquare ); 
La precedente linea 59 uses the for_each algorithm to apply a general function to every element in the range from a1.cbegin() up to, but not including a1.cend().
>> transform algorithm
[pag706 deitel]
 63    // calculate cube of each element in a1; place results in cubes
 64    transform( a1.cbegin(), a1.cend(), cubes.begin(), calculateCube );
 65    cout << "\n\nThe cube of every integer in a1 is:\n";
 66    copy( cubes.cbegin(), cubes.cend(), output );
 67    cout << endl;
line 63 uses the transform algorithm to apply a general function to every element in the range from a1.cbegin() up to, but not including a1.cend().  
-----------------------------------------------------------------------
eccoti l'output offerto dal programma [compilato on visual studio 2013]
////////////// OUTPUT
	a1 before random_shuffle: 1 2 3 4 5 6 7 8 9 10
	a1 after random_shuffle: 9 2 10 3 1 6 8 4 5 7
	
	a2 contains: 100 2 8 1 50 3 8 8 9 10
	Number of elements matching 8: 3
	Number of elements greater than 9: 3
	
	Minimum element in a2 is: 1
	Maximum element in a2 is: 100
	The minimum and maximum elements in a2 are 1 and 100, respectively
	
	The total of the elements in a1 is: 55
	
	The square of every integer in a1 is:
	81 4 100 9 1 36 64 16 25 49
	
	The cube of every integer in a1 is:
	729 8 1000 27 1 216 512 64 125 343
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MEMBER FUNCTIONS 
NOTES from pag383deitel: only the simplest and most stable memeber functions (i.e. whose implmentations are unlikely to change) should be defined in the class header. 
Member functions vs Global Functions (also called Free functions)
Usually members function calls are more concise than conventional function calls in procedural programming. Cioe' per esempio una funzione procedurale in matlab ti richiede per esempio di listare tutti i parametri di input che dovra' processore
	nomeFunzioneProcedurale(param1, param2, ... paramN)
rendendo la chiamata lunga, tediosa e con il rischio di dimenticare qualche parametro. 
Invece con un approccio object oriented la chiamata di una funzione si puo' spesso ridurre a member functions that take no arguments, tipo:
	nomeMemberfunction()  [see esempio pratico pag381deitel]
A) Using an object-oriented programming approach often simplifies function calls by reducing the number of parameters. This benefit derives from the fact that encapsulating data members and meber functions within a class, gives the member functions the right to access the data members
-----------------------\
| CLASS                 |
------------------------| 
| data members  <-----\ | 
|                     | | member functions can access data members that are encapsulated in the same class
| member functions ---/ |
\----------------------/
B) Member functions are usually shorter than functions in non-object-oriented programs, because the data stored in data members have ideally been validated by a constructor or by member functions that store new data. Because the data is already in the object, the member-function calls often have no arguments or fewer than function calls in non-object-oriented languages. Thus, the calls, the function definitions and the function prototypes are shorters.This improves many aspects of program development
B) The fact that membe function calls generally take either no arguments or substantially fewer arguments than conventional function calls in non-object-oriented languages reduces the likelihood of passing the wrong arguments, the wrong types of arguments or the wrong number of arguments. 
////////////////////////////////////////////////////////////////////////////////////////////////////////

>> member functions vs non member functions / >> non member function vs member function
pag466 deitel

>> MEMBER FUNCTION const non-const member function combination / >> COMBINATION MEMBER FUNCTION ON CONST OBJECT
[pag403 deitel]
fig9.16 shows various member-function call combination on objects example 
- non-const member function on a non-const object OK 
- const member function on a non-const object OK 
- const member function on a const object  OK 
- non-const member function on a const object DAME!!!! non si puo' modificare un constant object.
NOTE1: calling a non constant member function on a constant object generates a compilation error. 
NOTE2: a constructor must be anon-const member function, but it can still be used to initialize a const object
NOTE3: invoking a non-const member function from the constructor call as part of the initialization of a const object is allowed.
NOTE4 [pag404 comet star tag]: a call of a non constant member function on a constant object non e' ammesso neppure nel caso in cui la member function doesn't modify the object. The function must explicitly be declare constant. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MEMBER INITIALIZERS
[pag404deitel]
An class's constructor can pass arguments to member-object constructors via member initializers. 
NOTE: data members are constructed in the order in which they're declared in the class definition (not in the order they're listed in the constructor's member initializer list) and before their enclosing class objects (sometimes called >> host objects) are constructed.

>> MEMBER ACCESS LEVELS [pag249 mike game programming]
Like functions you should treat objects as encapsulated entities. This means that, in general, you should avoid directly altering or accessing an object's data members. Instead, you should call an object's member functions, allowing the object to maintain its own data members and ensure their integrity. Fortunately, you can enforce data member restrictions when you define a class by setting member access levels.
--------------------------------------------------------------------------------- START FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/private_critter.cpp]
	//Private Critter
	//Demonstrates setting member access levels
	
	#include <iostream>
	
	using namespace std;
// declaring a class for critters that restricts direct access to an object's data member for its hunger level	
	class Critter
	{
	public:            // begin public section
	    Critter(int hunger = 0);
// the member function GetHunger allows access to the data member 
	    int GetHunger() const; 
// the member function SetHunger allows changes to the data member
	    void SetHunger(int hunger);
	    
	private:           // begin private section
	    int m_Hunger;   // the access of the hunger level is restricted
	};
	
	Critter::Critter(int hunger): 
	    m_Hunger(hunger)
	{
	    cout << "A new critter has been born!" << endl;
	}
	
// >> ACCESSOR MEMBER FUNCTION DEFINITION [pag252 mike game programming]. An accessor member function allows indirect accesss to a data member. Because m_Hunger is private, we wrote an accessor member function, GetHunger(), to return the value of the data member. 
	int Critter::GetHunger() const
	{
	    return m_Hunger;
	}
	
	void Critter::SetHunger(int hunger)
	{
	    if (hunger < 0)
		{
	        cout << "You can't set a critter's hunger to a negative number.\n\n";
		}
// when the program attempts to change the critter's hunger level to an illegal value, we catch the illegal value and do not make the change.
	    else
		{
	        m_Hunger = hunger;
		}
	}
	
	int main()
	{
	    Critter crit(5);  
	    //cout << crit.m_Hunger; -- illegal, m_Hunger is private!
	    cout << "Calling GetHunger(): " << crit.GetHunger() << "\n\n";
	   
	    cout << "Calling SetHunger() with -1.\n";
	    crit.SetHunger(-1);
	    
	    cout << "Calling SetHunger() with 9.\n";    
	    crit.SetHunger(9);
// usiamo l'accessor member function "GetHunger" to access the private data member m_Hunger
	    cout << "Calling GetHunger(): " << crit.GetHunger() << "\n\n";
	    
	    return 0;
	}
// >> ACCESSOR MEMBER FUNCTION: what's the point of all this hassle?!
// At this point, you might be wondering why you'd go to the trouble of making a data member private only to grant full access to it through accessor functions. The answer is that you don't generally grant full access. For example in the SetHunger accessor member function, first we check to make sure that the value passed to the member function is greater than zero. If it's not, it's an illegal value, and we display a message leaving the data member unchanged. If the value is greater than zero. then we make the change. This way, SetHunter() protects the integrity of m_Hunger, ensuring that it can't be set to a negative number. Just as we've done here, most game programmers begin their accessor member function names with Get or Set. 
--------------------------------------------------------------------------------- END FULL EXAMPLE
OUTPUT PROGRAM:
	A new critter has been born!
	Calling GetHunger(): 5
	
	Calling SetHunger() with -1.
	You can't set a critter's hunger to a negative number.
	
	Calling SetHunger() with 9.
	Calling GetHunger(): 9
---------------------------------------------------------------------------------
>> PUBLIC AND >> PRIVATE ACCESS LEVELS [pag251 mike game programming]
Every class data member and member function has an access level, which determines where in your program you can access it. In the program right above we start a public session. [>> PUBLIC MEANING] By using "public:" I'm saying that any data member or member function that follows (until another access level specifier) will be public. This means that any part of the program can access them.
		class Critter
		{
		public:            // begin public section
		    Critter(int hunger = 0);
	// the member function GetHunger allows access to the data member 
		    int GetHunger() const; 
// NOTE: because we have declared these member functions within a public section, it means that any part of our code can call any member function through a Critter object.
	// the member function SetHunger allows changes to the data member
		    void SetHunger(int hunger);
// we now specify a private section [>> PRIVATE MEANING] By using "private:" we're saying that any data member or member function that follows (until another access level specifier) will be private. This means that only code in the Critter class (i.e. the current class we are writing in) can directly access it   
		private:           // begin private section
		    int m_Hunger;   // the access of the hunger level is restricted
		};
-------------------------------
NOTE: you can repeat access modifiers. So if you want, you could have a private section, followed by a public section, followed by another private section in a class. 
NOTE2: member access is private by default. Until you specify an access modifier, any class members you declare will be private.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONSTANT MEMBER FUNCTION [pag253 mike game programming]
Constant member function can't modify a data member of its calls or call a non constant member function of its class. It protects you from accidentally altering a data member in the member function. 
You can declare a constant member function by putting the keyword const at the end of the function header. 
	int GetHunger() const;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PRIVATE vs PUBLIC / >> PUBLIC vs PRIVATE / >> PUBLIC versus PRIVATE 
[pag144 jesse]
The private and public keywords are used with member of a class
	where member of a class can be 
		- data members 
		- member methods (chiamate anche "functions")
All members of a class are private, by default. 
To make this a bit clearer, consider this example of class declaration :
	class Cat
	{
		unsigned int itsAge;
		unsigned int itsWeight;
		void Meow();
	};
In this declaration, itsAge, itsWeight, and Meow() are all private because all members of a class are private by default. Unless you specify otherwise, they are private. If you create a program and try to write the following within main (for example):

	int main()
	{
		Cat Boots;
		Boots.itsAge = 5;  // error! can't access private data!

The compiler flags this as an erro. In effect, by leaving theses members as private, you've said to the compiler "I'll access itsAge, itsWeight, and Meow() only from within member functions of the Cat class". Yet, here you've accessed the itsAge member variable of the Boots object from outside a Cat method. Just becuase Boots is an object of class Cat, that doesn't mean that you can access the parts of Boots that are private (even though they are visible in the declaration).
This is source of endless confusion to new C++ programmers. I can almost hear you yelling "Hey! I just said Boots is a Cat. Why can'T Boots access his own age?" The answer is that Boots can, but you can't. Boots, in his won methods, can access all his parts (public and private). Even though you've created a Cat, that doesn't mean that you can see or change the parts of it that are private. 
The way to use Cat so that you can access the data members is to make some of the members public:
	class Cat
	{
	  public:
		unsigned int itsAge;
		unsigned int itsWeight;
		void Meow();
	};
In this declaration itsAge, itsWeight, and Meow() are all public. Boots.itsAge = 5; from the previous example will compile without problems. 
NOTE: the keyword public applies to all members in the declaration until they key-word private is encountered and vice-versa. This lets you easily declare sections of your class as public or private.
Il seguente esempio shows the declaration of a Cat class with public member variables:
-------------------------------------------------------------------------------------
// Demonstrates declaration of a class and
// definition of an object of the class,
  
#include <iostream>   
  
class Cat               // declare the Cat class
{
  public:               // members which follow are public
    int itsAge;         // member variable
    int itsWeight;      // member variable
};         // note the semicolon
  
int main()
{
   Cat Frisky; // Frisky is defined as an instance of a "Cat", that is as a "Cat" object
   Frisky.itsAge = 5;    // assign to the member variable
   std::cout << "Frisky is a cat who is " ;
   std::cout << Frisky.itsAge << " years old.\n";
   return 0;
}

-------------------------------------------------------------------------------------
MAKING MEMBER DATA PRIVATE. WHY? WHAT'S THE POINT? [see pag147 jesse to discover the advantages]
As a general rule of design, you should keep the data members of a class private. Of couse, if you make all of the data members private, you might wonder how you access information about the class. For example, if itsAge is private, how would you be ale to set or get a Cat object's age?
[>> accessor / >> accessors / >> accessor methods] [pag147 jesse]
To access private data in a class, you must create public functions known as accessor methods. Use these methods to set and get the private member variables. These accessor methods are the member function that other parts of your program call to get and set your private member variables. 
A public accessor method is a class member function used either to read (get) the value of a private class member variable or to set its value. 
Why bother with this extra level of indirect access? Why add extra functions when it is simpler and easier to use the data directly? Why work through accessor functions?
The answer to these question os that accessor functions enable you to separate the details of how the dat is sotred from how it is used. By using accessor functions, you can later change how the data is stored without having to rewrite any of the other functions in your programs that use the data. 
If a function that need to know a Cat's age accesses itsAge directly, that function would need to be rewritten if you, as the author of the Cat class, decided to change how that data is stored. By having the function call GetAge(), your Cat class can easily return the right value no matter how you arrive at the age. The calling function doesn't need to know whether you are storing it as an unsigned  integer or a long, or whether you are computing it as needed. 
This technique makes your program eaiser to maintain. It gives your code a longer life because design changes don't make your program obsolete.
In addition, accessor functions can include additional logic, for instance, if a Cat's age is unlikely to be more than 100, or its weight is unlikely to be 1000. These values should probably not be allowed. An accessor function can enforce this types of restrictions as well as do other tasks. 
The following listing shows the Cat class modified to include private member data and public accessor methods. Note, this is not a listing that can be run if it ic compiled.
  1 // Cat class declaration
  2 // Data members are private, public accessor methods
  3 // mediate setting and getting the values of the private data
  4 
  5 class Cat
  6 {
  7   public:      // this is the access control keyword used to declare the following methods as public
  8     // public accessors
  9     unsigned int GetAge();                 // public method 1  - accessor method to get the age
 10     void SetAge(unsigned int Age);         // public method 2  - accessor method to set the age
 11 
 12     unsigned int GetWeight();              // public method 3  - accessor method to get the weight
 13     void SetWeight(unsigned int Weight);   // public method 4  - accessor method to set the weight
 14 
        // the above accessors methods (or you can also called them "accessor functions") set the member variables and return their values. 

 15     // public member functions
 16     void Meow();                           // public method 5  - this is NOT an accessor function, since it does not get or set a member variable. It performs another service for the class, printing the word "Meow"
 17 
 18     // private member data
 19   private:
 20     unsigned int  itsAge;                  // declaration of member variable itsAge
 21     unsigned int  itsWeight;               // declaration of member variable itsWeight
 22 };
-------------------------------------------------------------------------------------------------------------
 Declaring methods or data private enables the compiler to find programming mistakes before they become bugs. Any programmer worth his consulting fees can find a way around privacy if he wants to. Stroustrup said "The C++ access control mechanisms provide protection against accident, not againt fraud."
-------------------------------------------------------------------------------------------------------------
>> SUMMARY terminologia >> class vs >> object vs >> class member data (>> member data) vs >> class method / >> class function. 
The class keyword 
Syntax for the class keyword is as follows

	class class_name 
	{
		// access control keyword here
		// class variables and methods declared here 
	};

You use the class keyword to declare new types. 
A class is a collection of
	1) class member data (= variables of various types, including other classes)
	2) class function (also called class methods). These are functions used to manipulate tha data in the class and to perform other services for the class. 

You define >> objects of the new type in much the same way in which you define any variable. State the type (class) and then the varible name (the object). You access the class members and functions by using the dot (.) operator. 

You use >> access control keyword to declare sections of the class as public or private. The default for access control is private. Each keyword changes the access control from that point on to the end of the class or until the next access control keyword. Class declaration end with a closing brace and a semicolon. 
---------------------------------------------------------------------
Example 1
---------
class Cat
{
	public: // usi la access control keyword "public" in modo da definire i seguenti data and methods/functions as public
		unsigned int Age;      // class member data Age
		unsigned int Weight;   // class member data Weight
		void Meow();           // class function Meow
};  // qui termina la definizione della classe  

Cat Frisky;     // definisci l'oggetto Frisky, il cui type e' la classe Cat
Frisky.Age = 8; // accedi alla class member data Age using the . operator e gli assegni il valore 8
Frisky.Weight = 18;
Frisky.Meow();  // accedi alla class function Meow() using the . operator Non c'e' bisogno di somministrare alcun parametro alla funzione Meow visto che e' giusto una funzione che printa il verso del gatto. 
-----------------------------------------------------------------------

Example 2 
---------
class Flyer
{
	public :     					// the next five are public
		void Start();
		void Accelerate();
		void Brake();
		void SetYear(int year);
		int GetYear();
	
	private:     					// the rest is private
		int Year;
		Char Model [255];
};               					// end of class declaration 

Flyer OldFaithful;    				// make an instance of the flyer
int bought;							// local variable of type int
OldFaithful.SetYear(84);			// assign 84 to the year
bought = OldFaithful.GetYear();		// set bought to 84
OldFaithful.Start();				// call the start method

-------------------------------------------------------------------
in conclusione 
DO
	DO use public accessor methods. 
	DO access private member variables from within class member functions. 
DON'T
	DON'T declare member variables public
	DON'T try to use private member variables from outside the class.
Detto ancora in parole piu' spicciole: le funzioni son PUBBLICHE ma cio' i dati su cui operano sono PRIVATE. Una classe ben costruita e' insomma come un ufficio di amministrazione pubblica che funzioni a dovere. I funzionari son pubblici, qualunque cittadino puo' venire a richiedere i suoi servizi, ma i dati su cui il funzionario opera son privati e il cittadino non puo' pretendere di avere un accesso diretto a tali dati. 

NOTE: >> member function vs method / >> method vs member function: the terms memberfunction and method can be used interchangeably.

--------------------------------------------------------------------
>> CLASS IMPLEMENTATION / >> IMPLEMENTATION OF A CLASS [pag150 jesse]
Each accessor function (= that provides a public interface to the private member data of the class) along with any other class methods that you declare, must have an implementation. The implementation is called the function >> definition.
[>> definition of a function = implementazione della funzione]
a function definition assume la seguente struttura 
// return type that will come from the function | name of the class | two colons | name of the function | function's parameters   
   void                                           Cat                 ::           SetAge                 (int Age)
-------------------------------------------------------------------------------------------------------------------------------
Example listing 6.3 [/home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/List0603.cpp]
  1 // Demonstrates declaration of a class and
  2 // definition of class methods,
  3 #include <iostream>         // for cout
  4 
  5 class Cat                   // begin declaration of the class
  6 {
  7   public:                   // begin public section
  8     int GetAge();           // accessor function
  9     void SetAge (int age);  // accessor function
 10     void Meow();            // general function
 11   private:                  // begin private section
 12     int itsAge;             // member variable
 13 };
 14 // definition of the member function GetAge()
 15 // GetAge, Public accessor function 
 16 // returns value of itsAge member
 17 int Cat::GetAge()       // NOTE: "Cat::" e' la sintassi richiesta per indicare al compiler that the GetAge() function you are defining here is the one that you declared in the Cat class. 
 18 {
 19    return itsAge;
 20 }
 21 
 22 // definition of SetAge, public
 23 // accessor function
 24 // sets itsAge member
 25 void Cat::SetAge(int age)
 26 {
 27    // set member variable itsAge to
 28    // value passed in by parameter age
 29    itsAge = age;
 30 }
 31 
 32 // definition of Meow method
 33 // returns: void
 34 // parameters: None
 35 // action: Prints "meow" to screen
 36 void Cat::Meow()
 37 {
 38    std::cout << "Meow.\n";
 39 }
 40 
 41 // create a cat, set its age, have it
 42 // meow, tell us its age, then meow again.
 43 int main()
 44 {
 45    Cat Frisky;
 46    Frisky.SetAge(5);   // note that the method is called by using the object name "Frisky" followed by the member operator "." and the method name "SetAge"
 47    Frisky.Meow();
 48    std::cout << "Frisky is a cat who is " ;
 49    std::cout << Frisky.GetAge() << " years old.\n";
 50    Frisky.Meow();
 51    return 0;
 52 }
-------------------------------------------------------------------------------------------------------------
>> CONSTRUCTORS / >> DESTRUCTORS [pag153 jesse]
IN SHORT
	CONSTRUCTORS = is a special member function used to initialize the member data of a class
	DESTRUCTORS = clean up after your object and free any resources or memory that might have allocated
IN LONG 
Two ways exist to define an integer variable. You can define the variable and then assign a value to it later in the program. For example 
	int Weight;     // define a variable 
	...				// other code here
	Weight = 7;		// assign it a value
Or you can define the integer and immediately initialize it. For example:
	int Weight = 7;		// define and initialize to 7
Initialization combines the definition of the variable with its initial assignment. Nothing stops you from changing that value later. Initialization ensures that your variable is never without a meaningful value. 
How do you initialize the member data of a class? You can initialize the member data of a class using a special member function called a constructor. The constructor can take parameters as needed, but it cannot have a return value (not even "void"). The constructor is a class method with the same name as the class itself.
Whenever you declare a constructor, you'll also want to declare a destructor. Just as constructors create and initialize objects of your class, destructors clean up after your object and free any resources or memory that you might have allocated (either in the constructor, or throughout the lifespan of the object). A destructor always has the name of the class, preceded by a tilde(~). Destructors take no arguments and have no return value. If you were to declare a destructor for the Cat class, its declaration would look like the following:
	~Cat();
>> ~ = meaning -> quando lo vedi signica che ti trovi davanti a un destructor used to clean up after your object and free any resources or memory that you might have allocated
[Ciccio detto in parole semplici: Constructor is a tool to avoid having data members not inizialized, quindi ti evita che i tuoi data members che ti accingi ad utilizzare portino con se' garbage senza significato. Vedi il team di Constructor e Deconstructor un po come il team di pulizia dello Shinkansen. Prima che salgano i nuovi passeggeri settano tutto a posto, portano via cartacce, rimuovono i morti d'infarto, se ricevono il parametro d'input dal manager mettono nella VIP carrozza una rosa per lady D. Il destructor e' il team che interviene una volta terminato il viaggio, non hanno bisogno di parametri di input, la loro funzione giusto lasciare lo shinkasen tutto bello vuoto e pulito.]
-------------------------------------------------------------------------------------------------------------
>>DEFAULT CONSTRUCTOR and DESTRUCTOR [pag153 jesse]
Many types of constructors are available; some take arguments, others do not. The one that takes no arguments is called the default constructor. There is only one destructor. Like the default constructor, it takes no arguments. 
It turns out that if you don't create a constructor or a destructor, the compiler provides one for you. The constructor that is provided by the compiler is the default constructor. 
The default constructor and destructor created by the compiler don't have arguments. In addition they don't appear to do anything! If you want them to do something, you must create your own default constructor or destructor. 
Using the Default Constructor 
Quando nel programma sopra avevamo scritto 
	Cat Frisky; // che crea un nuovo oggetto chiamato Frisky della classe Cat
this is interpreted as a call to the default constructor. It provides no parameters and it leaves off the parentheses.
As a matter of form, it is always recommended that you define a constructor, and set the member varaibles to appropriate defaults, to ensure that the object will always behave correctly. Also as a matter of form, if you decalre a constructor, be certain to declare a destructor, even if your destructor does nothing. Although it is true that the default destructor would work correctly, it doesn't hurt to declare your own. It makes your code clearer. 
In the following listing we rewrite the Cat class to use a non default constructor to inizialize the Cat object, setting its age to whiatever initial age you provide, and it demonstrates where the destructor is called.
------------------------------------------------------------------------------- [/home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/List0604.cpp]
1 // Demonstrates declaration of  constructors and
  2 // destructor for the Cat class
  3 // Programmer created default constructor
  4 #include <iostream>        // for cout
  5 
  6 class Cat                  // begin declaration of the class
  7 {
  8   public:                  // begin public section
  9     Cat(int initialAge);   // constructor that takes an integer. 
 10     ~Cat();                // destructor (it takes no parameters)
 11     int GetAge();          // accessor function
 12     void SetAge(int age);  // accessor function
 13     void Meow();
 14   private:                 // begin private section
 15     int itsAge;            // member variable
 16 };
 17 
 18 // constructor of Cat, note how the class name precedes the constructor name. Since it is a constructor there is no return value. 
 19 Cat::Cat(int initialAge)     // da linea 19 a 22 trovi l'implementazione del constructor. 
 20 {
 21    itsAge = initialAge;
 22 }
 23 
 24 Cat::~Cat()                 // destructor, takes no action
 25 {                           // note no return time or parameters are included. Do not forget to precede ~Cat by the class name Cat:: 
 26 }
 27 
 28 // GetAge, Public accessor function
 29 // returns value of itsAge member
 30 int Cat::GetAge()
 31 {
 32    return itsAge;
 33 }
 34 
 35 // Definition of SetAge, public
 36 // accessor function
 37 void Cat::SetAge(int age)
 38 {
 39    // set member variable itsAge to
 40    // value passed in by parameter age
41    itsAge = age;
 42 }
 43 
 44 // definition of Meow method
 45 // returns: void
 46 // parameters: None
 47 // action: Prints "meow" to screen
 48 void Cat::Meow()
 49 {
 50    std::cout << "Meow.\n";
 51 }
 52 
 53 // create a cat, set its age, have it
 54 // meow, tell us its age, then meow again.
 55 int main()
 56 {
 57    Cat Frisky(5);
 58    Frisky.Meow();
 59    std::cout << "Frisky is a cat who is " ;
 60    std::cout << Frisky.GetAge() << " years old.\n";
 61    Frisky.Meow();
 62    Frisky.SetAge(7);
 63    std::cout << "Now Frisky is " ;
 64    std::cout << Frisky.GetAge() << " years old.\n";
 65    return 0;
 66 }
 67  
----------------------------------------------------------- 
SUMMARY 
DO
	- do use constructors to initialize your objects
	- do add a destructor if you add a constructor 
DON'T
	- don't give constructor or destructors a return value 
	- don't give destructor parameters. 
-------------------------------------------------------------------------------------------------------------
>> CONST MEMBER FUNCTIONS / >> constant member functions [pag157 jesse]
IN SHORT
una constant member function e' una funzione che non cambia nessuno dei data members within the same class e la si dichiara facendo precedere la keyword const prima del ;
	void SomeFunction() const;
IN LONG
If you declare a class method const, you are promising that the method won't change the value of any of the members of the class. 
To declare a class method constant, put the keyword const after the parentheses enclosing any parameters, but before the semicolon ending the method declaration. For example 
	void SomeFunction() const;
This declares a constant member method called SomeFunction() that takes no arguments and return void. You know this will not change any of the data members within the same class because it has been declared const. 
Accessor functions that only get values are often declared as constant functions by using the constant modifier. For example the accessor function we saw above GetAge() simply return the current value of the member variable itsAge. Therefore, you can declare it in this way: 
	int GetAge() const;
If you declare a function to be const, and the implementation of that function changes the object by changing the value of ANY of its members, the compiler flags it as an error. For example if you wrote GetAge() in such a way that it kept count of the number of times that the Cat was asked its age, it would generate a compiler error. This is because you would be changing the Cat object when the method was called. 
It is a good programming practice to declare as many methods to be const as possible. Each time you do, you enable the compiler to catch your errors instead of letting your errors become bugs that will show up when your program is running. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONSTANT declaration example 
example of declaration of pi greco and initialization of a variable using the declared constant
	const float PI = 3.14159;
	float myPi = PI;
[from pag 825 jesse]

>> MEMORY LOCATION 
- placing a new value into a memory location is said to be a destructive operation 
(perche' when a value is placed in a memory location, the value overwrites the previous value in that location)
- when a value is read out of a memory location, the operation is non destructive (i valori delle variabili contenute nelle memory location in cui si legge, sono ancora presenti anche una volta effettuata la lettura)
[pag49deitel]

>> MICROSOFT VISUAL STUDIO EXPRESS error expired license / >> VISUAL STUDIO LICENSE ERROR
SOLUTION 
Setta la data a ex 2012 e l'errore scompare. Ci capitava con microsoft visual studio 2013. Settando la data ad un anno prima partiva senza problemi su Orion I

>> min / >> max / >> minmax / >> minmax_element
[pag724 tailless] 
example /home/dia/Deitel-Code_Examples/ch16/fig16_13/fig16_13.cpp
OUTPUT de programma:
	The minimum of 12 and 7 is: 7
	The maximum of 12 and 7 is: 12
	The minimum of 'G' and 'Z' is: G
	The maximum of 'G' and 'Z' is: Z
	
	The minimum of 12 and 7 is: 7
	The maximum of 12 and 7 is: 12
	
	Array items contains: 3 100 52 77 22 31 1 98 13 40
	The minimum element in items is: 1
	The maximum element in items is: 100
-----------------------------------------------------
>> min and >> max determine the minimum and the maximum of two elements, respectively.
--------------------
>> initializer_list parameters. // >> minimum of a vector / >> maximum of a vector // >> min algorithm / >> max algorithm
[pag 725 deitel]
C++11 and upp includes overloaded versions of the algorithms min and max each receive an initializer_list parameter and return the smallest or largest item in the list initializer that's passed as an argument. For example the following statement returns 7:
	int minimum = min( {10, 7, 14, 21, 17 } );
---------------------
>> minmax algorithm 
[pag725 deitel]
minmax algorithm receives two items and returns a pair in which the smaller item is stored in first and the larger item is stored in second. A second version of this algorithm takes a third argument a binary predicate function ofr comparing values.
   auto result1 = minmax( 12, 7 );
   cout << "\n\nThe minimum of 12 and 7 is: " << result1.first 
      << "\nThe maximum of 12 and 7 is: " << result1.second;
--------------------
>> minmax_element algorithm
[pag 726 deitel]
minmax_element algorithm receives two input iterators representing a range of elements and returns a pair of iterators in which first points to the smallest element in the range and second points to the largest.
example from  example /home/dia/Deitel-Code_Examples/ch16/fig16_13/fig16_13.cpp
   auto result2 = minmax_element( items.cbegin(), items.cend() );
   cout << "\nThe minimum element in items is: " << *result2.first
      << "\nThe maximum element in items is: " << *result2.second  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> MODULO   %
Modulo is the operation that gives the remainder of a division of two values. For example
, if we write:
	a = 11 % 3; 
the variable a will contain the value 2 since 11/3 = 3 resto 2 (3*3+2 = 11)

>> MULTIDIMENSIONAL ARRAYS / >> ARRAYS MULTIDIMENSIONAL / >> ARRAYS 2D / 2-D arrays / two-dimensional arrays / 2d arrays
[pag304deitel]
We can use arrays with two dimensions to represent tables of values consisting of information arranged in rows and columns. 
To identify a particular table elements, we must specify two subscripts
	- the first identifies the element's row
	- the second identifies the element's column
in general, an array with m rows and n columns is called an m-by-n array
Every element in a 2-D array is identified by an element name of the form
	a[i][j]
where a is the name of the array, and i and j are the subscripts that uniquely identify each element in a. 
Common programming error:
referencing a 2-d array element as a[x,y] is an error. Actually a[x,y] is treated as a[y] because C++ evaluates the expression x,y (containing a comma operator) simply as y (the last of the comma-operated expression) 
EXAMPLE see pag305
	const size_t rows = 2;
	const size_t columns = 3;
	void printArray( const array< array< int, columns >, rows> & );
Spegazione Dialin
Se lo riscriviamo in una maniera piu' matematica e sostituendo i valori di "rows" and "column"
	array [ array(int,3), 2] => crea una matrice 3*2
Quindi quando gli assegneremo le 6 componenti
	array< array< int, columns >, rows > array1 = { 1, 2, 3, 4, 5, 6 };
che nel nostro linguaggio semplificato diventa array [ array(int,3), 2] = {1 2 3 4 5 6}
significa che i primi tre elementi 1 2 3 verranno stored on the first row, and the last 3 on the second row.
//from nostra spiegazione con i colori a pag305
Qualora al posto di 6 elementi nella stringa ci fossero solo 5 initializers, allora il sesto elemento sara' inizializzato a zero. 
Any elements that do not have an explicit initializer are initialized to zero. 
NOTE: la scrittura un poco astrusa 
	array< array< int, columns >, rows >
la puoi anche leggere nel modo seguente, prendi la solita definizione di un array:
	array< typeElement, n >
Ora la particolarita' e' che typeElement e' a sua volta un array di m elements interi cioe' un array< int, m > 
Quindi assemblando il tutto:
	array< array< int, m >, n >
Poniamo ora n = 2 e m = 3. E ripetiamo il ragionamento 
	array< typeElement, 2 >
Abbiamo un array immaginalo a forma di pila con 2 elementi uno sopra l'altro e quando apri la box typeElement scopri che 
	typeElement = array< int, 3 >
Cioe' ciascuno dei due piani della pila ha 3 elementi
Quindi assemblando il tutto  
	array< array< int, 3 >, 2 >
avremmo una matrice 3*2
- FOR STATEMENT for 2-D arrays
[pag306deitel]
We use a nested loop in which the outer loop iterates through the rows and the inner loop iterates through the columns of a given row.
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
	{
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			cout << a[ row ][ column ] << ' ';
		cout << endl;
	} // end outer for 
[see example pratico pag305]
EXAMPLES 2d arrays examples
- EXAMPLE1
[pag306deitel]
Settare a zero tutti gli elementi della seconda riga di una matrice 3x4
	for ( size_t column = 0; column < 4; ++ column )
		a [ 2 ][ column ] = 0;
The preceding for statement is equivalent to the following assignement statements:
	a[ 2 ][ 0 ] = 0;
	a[ 2 ][ 1 ] = 0;
	a[ 2 ][ 2 ] = 0;
	a[ 2 ][ 3 ] = 0;
- EXAMPLE2
[pag306deitel]
Sommare tutti gli elementi di un 2D array (insomma di un tensore 2 o la nostra tradizionale matrice)
	total = 0;
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			total += a[ row ][ column ];
usando il C++11 "auto" keyword il precedente nested loop puo' essere riscritto come 
	total = 0;
	for ( auto row : a ) // for each row
		for ( auto column : row ) // for each column in row 
			total += column;
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MULTIDIMENSIONAL ARRAYS [pag97 mike]
EXAMPLE:
/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter03/tic-tac-toe_board.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////
// Tic-Tac-Toe Board
// Demonstrates multidimensional arrays

#include <iostream>

using namespace std;

int main()
{
    const int ROWS = 3;
    const int COLUMNS = 3;
	// >> 2D ARRAY initialization example / >> multidimensional array example [from pag99 mike] 
    char board[ROWS][COLUMNS] = { {'O', 'X', 'O'},
                                  {' ', 'X', 'X'},
                                  {'X', 'O', 'O'} };  // in questo esempio oltre alla dichiarazione viene anche inizializzato
	/*
	it is possible to simply declare a multidimensional  array without initializing it. For example:
		char chessBoard[8][8];
	The preceding code declares an 8x8, 2dimensional character array, chessBoard. By the way multidimensional arrays aren't required to have the same size of each dimesnion. The following is a perfectly valid declaration for a game map represented by individual characters :
		char map[12][20];

	*/ 

    cout << "Here's the tic-tac-toe board:\n";
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << board[i][j];
		}

        cout << endl;
    }

    cout << "\n'X' moves to the empty location.\n\n";
    board[1][0] = 'X';  // this is an example of how to >> index individual element of a multidimensional array
	// the previous code assigns the character X to the element at board[1][0] (which was ' '). 

    cout << "Now the tic-tac-toe board is:\n";
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << board[i][j];
		}

        cout << endl;
    }

    cout << "\n'X' wins!";

    return 0;
}

//////////////////////////////////////
OUTPUT:
	Here's the tic-tac-toe board:
	OXO
	 XX
	XOO
	
	'X' moves to the empty location.
	
	Now the tic-tac-toe board is:
	OXO
	XXX
	XOO
	
	'X' wins!
////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> JUMBLE PROGRAM
-----------------------------------------------
// Word Jumble
// The classic word jumble game where the player can ask for a hint

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>

using namespace std;

int main()
{
	enum fields { WORD, HINT, NUM_FIELDS };
	const int NUM_WORDS = 5;
	const string WORDS[NUM_WORDS][NUM_FIELDS] =
	{
		{ "wall", "Do you feel you're banging your head against something?" },
		{ "glasses", "These might help you see the answer." },
		{ "labored", "Going slowly, is it?" },
		{ "persistent", "Keep at it." },
		{ "jumble", "It's what the game is all about." }
	};

	srand(static_cast<unsigned int>(time(0)));
	int choice = (rand() % NUM_WORDS);
	string theWord = WORDS[choice][WORD];  // word to guess
	string theHint = WORDS[choice][HINT];  // hint for word

	string jumble = theWord;  // jumbled version of word
	int length = jumble.size();
	for (int i = 0; i<length; ++i)
	{
		int index1 = (rand() % length);
		int index2 = (rand() % length);
		char temp = jumble[index1];
		jumble[index1] = jumble[index2];
		jumble[index2] = temp;
	}

	cout << "\t\t\tWelcome to Word Jumble!\n\n";
	cout << "Unscramble the letters to make a word.\n";
	cout << "Enter 'hint' for a hint.\n";
	cout << "Enter 'quit' to quit the game.\n\n";
	cout << "The jumble is: " << jumble;

	string guess;
	cout << "\n\nYour guess: ";
	cin >> guess;

	while ((guess != theWord) && (guess != "quit"))
	{
		if (guess == "hint")
		{
			cout << theHint;
		}
		else
		{
			cout << "Sorry, that's not it.";
		}

		cout << "\n\nYour guess: ";
		cin >> guess;
	}

	if (guess == theWord)
	{
		cout << "\nThat's it!  You guessed it!\n";
	}

	cout << "\nThanks for playing.\n";

	return 0;
}
////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MULTIPLE INHERITANCE / >> INHERITANCE MULTIPLE [pag950 deitel]
In C++, a class may be derived from more than one base class: this technique is known as multiple inheritance, in which a derived class inherits the members of two or more base classes. This powerful capability encourages interesting forms of software reuse but can cause a variety of ambiguity problems. Multiple inheritance is a difficult conept that sould be used only by experienced programmers. In fact, some of the problems associated with multiple inheritance are so subtle that newer programming languages, such as Java and C# do not enable a class to derive from more than one base class.
Great care is required in the design of a system to use multiple inheritance properly; it should not be used when single inheritance and/or composition will do the job.
A common problem with multiple inheritance is that each of the base classes might contain data members or member functions that have the same name. This can lead to ambiguity problems when you attempt to compile. 
Altri concetti e gergo:
>> diamond inheritance [pag955deitel]
>> virtual base class inheritance [pag957 deitel]
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> multiple value return from function [pag56 moo book]
There is no direct way to return more than one value from a function. One indirect way to do so is to give the function a parameter that is a reference to an object in which it is to palce one of its results. This strategy is common for functions that read input:
EXAMPLE /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main1.cc
// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}
////////////////////////////////////////////////////////////////////////

>> INHERITANCE [mike game programming pag307]
Inheritance is especially useful when you wnat to create a more specialized version of an existing class because you can add data members and members functions to the new class to extend it. 
One of the many advantages of inherintance is that you can reuse classes you've already written. This reusability produces benefits that include:
1) LESS WORK: there's no need to redefine functionality you already have. 
2) FEWER ERROR: once you've got a bug free class, you can reuse it without errors.
3) CLEANER CODE: because the functionality of base classes exists only once in a program, you don't have to wade through the same code repeatedly, which makes programs easier to understand and modify. 
Most related game entities cry out for inheritance. Whether it's the series of enemies that a player faces, squadrons of military vehicles that a player commands, or an inventory of weapons that a player wields, you can use inheritance to define these groups of game entities in terms of each other, which results in faster and easier programming.
Example pag309 Simple Boss Program
>> DERIVE CLASS example extracted from the program below
	class Boss : public Enemy
where
	Boss   = name of the derived class or >> subclass
	:      = put a colon after the name of the derived class
	public = this is the access modifier, in questo esempio e' "public"  [le altre opzioni sono "protected" and "private"]
	Enemy  = name of the base class or >> superclass 
NOTE from pag 315 mike game programming 
		>> public = members are accessible to all code in a program [pag315 mike game programming]
		>> protected = members are accessible only in their own class and certain derived classes, depending upon the access level used in inheritance.
		>> private = members are only accessible in their own class, which means they are not directly accessible in any derived class.
Using public derivation means that 
	- public members in the base class become public members in the derived class, 
	- protected members in the base class become protected  members in the derived class
	- private members in the base class are inaccessible in the derived class.
		note: even if base data members are private, you can still use them indirectly through base class member functions.
Quando usi inheritance e crei una class derivata, e' come se copiassi e pastassi the code from the superclass into the definition of the derived class.
>> DERIVED CLASS INSTANTIATING / >> INSTANTIATING DERIVED CLASS 
	Boss boss1;   // see program below
when a Boss oject is instantiated, the default Enemy constructor is automatically called and the object gets an m_Damage data member with a value of 10 (just like any Enemy object would). Then, the Boss constructor is called and finishes off the object by giving it an m_DamageMultiplier data member with a value of 3. The reverse happens when a Boss object is destroyed at the end of the program. First the Boss class destructor is called for the object, and then the Enemy class destructor is called. 
------------------------------------------------------------
	//Simple Boss
	//Demonstrates inheritance
	
	#include <iostream>
	using namespace std;
	
	class Enemy    // we define this class Enemy for lowly enemies. From this class we will derived the class Boss
	{
	public:
	    int m_Damage;
	
	    Enemy();  
	    void Attack() const;
	};
	
	Enemy::Enemy(): 
	    m_Damage(10)
	{}    
	
	void Enemy::Attack() const
	{ 
	    cout << "Attack inflicts " << m_Damage << " damage points!\n";
	}  
	
	class Boss : public Enemy         // we derive from "Enemy" class this "Boss" class
	{                                 // Bass is based on Enemy. In fact, Enemy is called
	public:                           // base class (or superclass) and Boss the derived class
	    int m_DamageMultiplier;       // or subclass. This means that Boss inherits Enemy's data members
	                                  // and member functions, subject to access control. 
	    Boss();  
	    void SpecialAttack() const;
	
	};
	
	Boss::Boss(): 
	    m_DamageMultiplier(3)
	{}  
	
	void Boss::SpecialAttack() const
	{
	    cout << "Special Attack inflicts " << (m_DamageMultiplier * m_Damage); // note that the member function SpecialAttack uses data member m_Damage declared in Enemy. That's perfectly fine. Boss inherits m_Damage from Enemy and, in this example, the data member works like any other data member in the Boss class
	    cout << " damage points!\n";
	}
	
	int main()
	{ 
	    cout << "Creating an enemy.\n";
	    Enemy enemy1;
	    enemy1.Attack();
	
	    cout << "\nCreating a boss.\n";
	    Boss boss1;
	    boss1.Attack();  // [pag312 mike game programming] qui usiamo the inherited member function "Attack" 
// essendo boss1 un oggetto della classe derivata Boss, esso eredita la member function "Attack" della superclass Enemy
	    boss1.SpecialAttack(); 
	
	    return 0;
	} 
------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DERIVE TYPE OBJECT CREATION [pag231 moo book]
Here's how the implementation creates objects of derived type. 
As with any class type, the implementation begins by allocating space for the object. Next it runs the appropriate constructor to initialize the object.
The fact that the object is of a derived type adds an extra step. Derived objects are constructed by:
- allocating space for the entire object (base class members as well as derived members)
- calling the base-class constructor to initialize the base-class part(s) of the objects
- initializing the members of the derived class as directed by the constructor initializer
- executing the body of the derived class constructor, if any.
>> GET VALUE WITHOUT KNOWING THE OBJECT'S TYPE/ >> VALUE retrieval without knowing the object's type [pag234 moo book]
pag 234 mooo book : virtual function a che serve in parole semplici: we want the system to run the right function based on the actual type of the objects passed to the function, which is known only at run time. To support this kind of run time selection, C++ provides virtual functions.
>> DYNAMIC BINDING vs >> STATIC BINDING [pag235 moo book]
This run time selection fo the virtual function to execute is relevant only when the function is called through a reference or a pointer. If we call a virtual function on behalf of an object (as opposed to through a reference or pointer), then we know the exact type of the object at compile time.
[...] The distinction between dynamic binding and static binding is essential to understand how C++ support OOP (object orienting programming). The phrase dynamic binding captures the notion that functions may be bound at run time, as opposed to static bindings that happen at compile time.
- If we call a virtual function on behalf on an OBJECT, that call is STATICALLY bound, that is, it is bound at compile time, because there is no possibility that the object will have a different type during execution than it does during compilation. 
- In constrast, if we call a virtual function through a POINTER or REFERENCE, then the function is DYNAMICALLY bound, that is, bound at run time. At run time, the version of the virtual function to use will depend on the type of the object to which the reference or pointer is bound.
The fact that we can use a derived type where a pointer or reference to the base is expected is an example of a key concept in OOP called polymorphism. This word, from the greek polymorphos = of many forms, in a programming context, it refers to the ability of one type to stand in for many types. C++ supports polymorphism through the dynamic binding properties of virtual functions. When we call a virtual through a pointer or reference, we make a polymorphic call. The type of the reference (or pointer) is fixed, but the type of the object to which it refers (or points) can be the type of the reference (or pointer) or any type derived from it. Thus, we can potentially call one of many functions through a single type. 
One fine note about virtual functions. These functions must be defined, regardless of whether the program calls them. Nonvirtual functions may be declared but not defined, as long as the program does not call them. Many compilers generate mysterious error messages for calsses that fail to define one or more virtual functions. 
[>> UNDEFINED ERROR message] If your program evokes a message from the compiler that you do not understand, and that message says that something is undefined, you should verify that you have defined all of your virtual functions. You are likely to find that the error goes away when you do so.
>> VIRTUAL DESTRUCTORS [pag242 moo book]
so that the destructor that will be run will depend on the type of object we are pointing to.  
>> HANDLE CLASS [pag243 moo book]
>> STATIC MEMBER FUNCTION [pag244 moo book] Static member functions differ from ordinary member functions in that they do not operate on an object of the class type. Unlike other member functions, they are associated with the class, not with a particular object.
>> INHERITANCE [pag250 moo book]
Inheritance allows us to model classes that are similar to one another with exceptions:
	class base {
	public:
		// common interface 
	protected:
		// implementation members accessible to derived classes
	private:
		// implementation accessible to only the base class
	};
	
	// public interface of base is part of the interface for derived
	class derived: public base { ... };
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> NNNNNNN

>> NAMESPACES / >> NAME SPACES [pag943deitel]
A program may include many identifiers defined in different scopes. Sometimes a variable of one scope will "overlap" (i.e. collide) with a variable of the same name in a different scope, possibly creating a naming conflict. Such overlapping can occur at many levels. Identifier overlapping occurs frequently in third party libraries that happen to use the same names for global identifiers (such as functions). This can cause compilation errors.
	C++ solves this problem with namespaces. Each namespace define a scope in which identifiers and variables are placed. To use an namespace member, either the member's name must be qualified with the namespace name and the scope resolution operator (::), as in 
	MyNameSpace::member
or a "using" directive must appear before the name is used in the program. Typically, such "using" statements are placed at the beginning of the file in which members of the namespace are used. For example, placing the following using directive at the beginning of a source code file
	using namespace MyNameSpace;
specifies that members of namespace MyNameSpace can be used in the file without preceding each member with MyNameSpace and the scope resolution operator (::). [cioe' detto in parole spicciole se scrivi all'inizio del programma using namespace NomeSpace, allora tutte le funzioni/members che appartengono a NomeSpace possono essere utilizzate direttamente all'interno del programma, se invece non scrivessi tale riga, allora dovrai precedere ciascun membro da NomeSpace::nomeDellaFunzioneDiNomeSpaceCheVuoiUtilizzare]
A using directive of the form 
	using std::cout;
brings one name into the scope where the directive appears. A using directive of the form 
	using namespace std;
brings all the names from the specified namespace (std) into the scope where the directive appears.
ERROR prevention: precede a member with its namespace name and the scope resolution operator (::) if the possibility exists of a naming conflict.
NOTE1: not all namespaces are guaranteed to be unique. Two third-party vendors might inadvertently use the same identifiers for their namespace names.
NOTE2: placing main ina namespace is a compilation error.
NOTE3: USING DIRECTIVES SHOULD NOT BE PLACED IN HEADERS namespaces are particularly ueful in large scale applications that use many class libraries. In such cases, there's a higher likelihood of naming conflicts. When working on such projects there should never be a suing directive in an header. Having one brings the corresponding names into any file that includes the header. This could result in name collisions and subtle, hard to find errors. Instead, use only fully qualified names in headers (for example std::cout or std::string)
>> ALIASES for namespace Names
namespaces can be aliased. For example the statement
	namespace CPPHTP = CPlusPlusHowToProgram;
creates the namespace alias CPPHTP for CPlusPlusHowToProgram.
---------------------------------------------------------------------------------------------
OPERATOR KEYWORDS [pag946 deitel]
The C++ standard providesoperator keywords that can be used in place of several C++ operators. You can use operator keywords if you have keyboards that do not support certain characters such as !, &, ^, ~, | etc. 
OPERATOR   OPERATOR KEYWORD    DESCRIPTION 
&&         and                 logical AND
||         or                  logical OR
!          not                 logical NOT
!=         not_eq              inequality
&          bitand              bitwise AND
|          bitor               bitwise inclusive OR
^          xor                 bitwise exclusive OR
~          compl               bitwise complement
&=         and_eq              bitwise AND assignment 
|=         or_eq               bitwise inclusive OR assignment
^=         xor_eq              bitwise exclusive OR assignment  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> NESTING [pag42 mike]
When you write one if statement inside another, it's called nesting.
example
	int score = 1000;
    if (score >= 500)
    {
        cout << "You scored 500 or more. Nice.\n\n";

        if (score >= 1000)
		{
            cout << "You scored 1000 or more. Impressive!\n";
		}
    }
//
NOTE: you can nest as many levels as you want. However, if you nest code tto deeply, it gets hard to read. In general, you should try to limit your nesting to a few levels at most.
/////////////////////////////////////////////////////////////


>> NEWLINE
To have a new line
- Way 1
	cout << "First Line" << endl << "End Line";
- Way 2
o inserisci tra le due linee:
	cout<<"\n";
- NB: to get a blank line in your output, just place two newline characters back to back. 
ex
		std::cout << "Welcome\nto\n\nC++!\n";
donera'
	Welcome
	to
	
	C++!
--------------------------------------------	

>> NEW LINE ogni 5 di output numeri printati vai a capo 
see examnple pag215
      // if counter is divisible by 5, start a new line of output
      if ( counter % 5 == 0 )
         cout << endl;

>> noexcept  -> see pag 751 deitel 

>> nullptr 
[pag 463deitel]
if after deleting dynamically allocated memory, the pointer will continue to exist in memory, set the pointer's value to nullptr to indicate that the pointer no longer points to memory in the free store. By setting the pointer to nullptr, the program loses access to that free-store space, which could be reallocated for a different purpose.If you do not set the pointer to "nullptr", your code could inadvertently access the reallocated memory, causing subtle, nonrepeatable logic errors. 

>> NUMBER PRECISION 
[pag127deitel]
the number of digits to the right of the decimal point

>> NUMBER SYSTEMS [pag973 deitel]
When we write an integer such as 127 in a C++ program, the number is written in the decimal (base 10) number system. Internally computers use the binary (base 2) number systems. The binary number system has only two digits, 0 and 1. Binary numbers tends to be much longer than their decimal equivalent. Programmers who work in assembly languages, and in high level languges like C++ that enable them to reach donw to the machine level, find ti cumbersome to work with binary numbers. So two other number systems [the octal number system (base8) and the hexadecimal number system (base 16)] are popular, primarily because they make it convenient to abbreviate binary numbers.
NOTE: the hexadecimal number system requires 16 digits: visto che abbiamo solo 0 1 2 3 4 5 6 7 8 9 (10 digits provenienti dalla notazione araba), per le restanti 6 si usano the letters from A to F. Thus in hexadecimal we can have numbers like 876 consisting solely of decimal like digits, numbers like 8A55F consisting of digits and letters, and numbers like FFE consisting solely of letters.
Each of these number systems uses >> positional notation: each potition in which a digit is written has a different >> positional value. For example in the decimal number 937 (the 9 the 3 and the 7 are referred to as symbol values), we say that the 7 is written in the ones position, the 3 is written in the tens position and the 9 is written in the hundreds position. Note that each of these position is a power of the base (base 10) and that these powers begin at 0 and increase by 1 as we move left in the number. 
>> HEXADECIMAL / >> OCTAL / >> BINARY NUMBERS CONVERSION -> pag977 deitel
>> negative binary numbers / >> two's complement notation pag980deitel

>> nontype parameters [pag773 deitel]
>> default type argument / >> default argument [pag773 deitel]
 function templates [pag774]
function templates and overloading are intimately related. When overloaded functions perform identical operations on different type of data, they can be expressed more compactly and conveniently using function templates.
You can then write function calls with different types of arguments and let the compiler generate separate function template specializations to handle each function call appropriately.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> OOOOOOO

>> OBJECT mike explains pag82 mike
Most modern programming languages let you work with sorfware objects (often just called objects) that combine data and functions. 
	- A data element of an object is called a >> data member, while 
	- a fnction of an object is called a >> member function. 
As a concret example, think about an alien spacecraft. An alien spacecraft object might be of a new type called Spacecraftk defined by a game programmer, and might have a data member for its energy level and an member function to fire its weapons. In practice, an object energy level might be stored in its data member energy as an int, and its ability to fire its weapons might be defined in a member function called fireWeapons()

                    /------------------\
					|    Spacecraft    |
                    --------------------
                    |   energy: int    |    <-- data member
                    --------------------
                    |   fireWeapons()  |    <-- member function
                    \------------------/

The cool thing about objects is that you don't need to know the implementation details to use them, just as you don't need to know how to build an airplane to drive one. You only have to know the object's data member and member functions (just as you only need to know where a aircraft's cloche, gas, afterburner button, thrust reverse, brake pedal are located)
You can store objects in variables, just like with built-in types. Therefore, you could store an alien spacecraft object in a variable of the Spacecraft type. You can access data member and member functions using the member selection operator (.), by placing the operator after the variable name of the object. So if you want your alien spacecraft, ship, to fire its weapons only if its energy level is greater than 10, you could write:
	// ship is an object of Spacecraft type
	if (ship.energy > 10)  // si accede al data member "energy"
	{	
		ship.fireWeapons() // si accede alla member function "fireWeapons"
	} 
ship.energy accesses the object's "energy" data member, while ship.fireWeapons() calls the object's fireWeapons() member function.
EXAMPLE: un esempio di object che usi spesso e' una stringa. A "string" is actually an object, and it provides its own set of member functions that allow you to do a range of things with the string object (everything from simply getting its length to performing complex character substitutions). In addition, strings are defined so that they work intuitively with a few of the operators you already know.
---------------- Example from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter03/string_tester.cpp
// String Tester
// Demonstrates string objects

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string word1 = "Game";
    string word2("Over");
    string word3(3, '!');   // questo produce la stringa "!!!"   [>> repeat character in string]

    string phrase = word1 + " " + word2 + word3;  // si concatenano le stringhe usando +. This is possible because the + operator has been overloaded. [>> OVERLOADING mike explaines pag 87 and pag 165 game programming ] Operator overloading redefines a familiar operator so it works differently when used in a new, previously undefined context. In this case, I use the + operator not to add numbers but to join string objects. We are able to do this only because the string type specifically overloads the + operator and defines it so the operator means string object concatenation when used with strings. [mmm raffinato l'approccio!, in effetti si puo' usare + in questo modo perche' all'interno della classe string si ridefinisce il "+" in modo che quando si trovi tra stringa agisca in modo da concatenare le stringe]
    cout << "The phrase is: " << phrase << "\n\n";

    cout << "The phrase has " << phrase.size() << " characters in it.\n\n";   // qui utilizziamo la member function "size" of the string object "phrase" through the member selection operator (the . dot). Every character counts, including spaces.
	// NOTE: the string objects also have a member function >> length(), which just like size() returns the number of characters in the string object.  [confermato anche da pag107 mike : both length() and size() return the same value, so you can use either.]

    cout << "The character at position 0 is: " << phrase[0] << "\n\n";  // this is an example of >> indexing a string object. A string object stores a sequence of char values. You can access any individual char value by providing an index number with the subscripting operator ([]). Do not forget that indexing begins at position 0. Remember, a string object with n characters in it can be indexed from position 0 to position n-1.

    cout << "Changing the character at position 0.\n";
    phrase[0] = 'L';  // not only can you access characters in a string object with the subscripting operator, but you can also reassign them [>> reassign character]
    cout << "The phrase is now: " << phrase << "\n\n";
// >> Iteration through string objects / >> iteration through string objects 
	for (unsigned int i = 0; i < phrase.size(); ++i) // loop through string objects ; note that we made the loop variable i an unsigned int because the value returned by size() is an unsigned integral type.
	{
        cout << "Character at position " << i << " is: " << phrase[i] << endl;
	}
// IN THE REAL WORLD dei loop come quello precedente are often used in games. Iterating through a sequence is a powerful and often used technique in games. You might for example, iterate through hundreds of individual units in a strategy game, updating their status and order. Or you might iterate through the list of vertices of a 3D model to apply some geometric transformation. 
    cout << "\nThe sequence 'Over' begins at location ";                                                     012345 
    cout << phrase.find("Over") << endl;    // donera' in output "5" visto che si comincia a contare da zero GAME OVER
// the find() member function searches the calling string object for the string supplied as an argument. The member function returns the position number of the first occurrence where the string object for which you are searching begins in the calling string object.
    if (phrase.find("eggplant") == string::npos)  // visto che eggplant non compare all'interno della stringa, find() returns a special constant defined in the file string, which we access with string::npos. As a result, the screen displays the message "eggplant' is not in the phrase.
	{
        cout << "'eggplant' is not in the phrase.\n\n";
	} // >> string::npos represents the largest possible size of a string object, so it is greater than any possible valid position number in a string object. Informally, it means "a position number that can't exist". It's the perfect return value to indicate that one string couldn't be found in another.
// >> when using find(), you can supply an optional arugment that specifiess a character number for the program to start looking for the substring. The following line will start looking for the string literal "eggplant" beginning at position 5 in the string object phrase. 
    phrase.erase(4, 5); // >> erase() string member function removes a specified substring from a string object. One way to call the member function is to specify the beginning position and the length of the substring. phrase.erase(4, 5) removes the five character substring starting at position 4.
    cout << "The phrase is now: " << phrase << endl; 

    phrase.erase(4); // another way to call erase() is to supply just the beginning position of the substring. This removes all of the characters starting at that position number to the end of the string object.
    cout << "The phrase is now: " << phrase << endl;

    phrase.erase(); // >> this erase every character in "phrase". As a result phrase becomes the empty string, which is equal to "". [>> empty string. Puoi >> delete every character in a string usando nomeString.erase()]
    cout << "The phrase is now: " << phrase << endl;
// >> empty string detection / >> detect empty string
    if (phrase.empty()) // the empty() member function returns a bool value, true if the string object is empty and false otherwise. 
	{ // visto che phrase una volta eseguita l'istruzione phrase.erase() e' diventata an empty string, il seguente messaggio viene printato su screen.
        cout << "\nThe phrase is no more.\n";
	}

	return 0;
}
///----------------------------------------------- OUTPUT

Character at position 0 is: L
Character at position 1 is: a
Character at position 2 is: m
Character at position 3 is: e
Character at position 4 is:
Character at position 5 is: O
Character at position 6 is: v
Character at position 7 is: e
Character at position 8 is: r
Character at position 9 is: !
Character at position 10 is: !
Character at position 11 is: !

The sequence 'Over' begins at location 5
'eggplant' is not in the phrase.

The phrase is now: Lame!!!
The phrase is now: Lame
The phrase is now:

The phrase is no more.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> Object-oriented programming / object oriented programming / >> OOP
Simple instructive example at pag68deitel
Typically the programs you develop will consist of function main and some classes, each containing data members and members functions. 
[pag67deitel]
example
#include <iostream>
using namespace std;
// GradeBook class definition
class GradeBook
{
public:
   // function that displays a welcome message to the GradeBook user
   void displayMessage() const  // questa e' la member function della GradeBook class
   {
      cout << "Welcome to the Grade Book!" << endl;
   } // end function displayMessage
}; // end class GradeBook
// function main begins program execution // la funzione main e' scritta in fondo poiche' affinche' possa creare a GradeBook object, dobbiamo prima dire al compiler what member functions and data members belong to the class.
int main()
{
   GradeBook myGradeBook; // create a GradeBook object named myGradeBook
   myGradeBook.displayMessage(); // call object's displayMessage function
} // end main
//------------------------------------
Observations: 
- by convention the name of a user-defined class begins with a capital letter (class GradeBook)
- for readability each subsequent word in the class name begins with a capital letter (improves readability)[cioe' esattamente nei nomi in openFOAM : pimpleFoam, rhoSimpleFoam, ogni volta che nel nome entra una nuova parola non si mette l'underscore, giusto si usa la capital letter: this capitalization style was widely used in the Pascal programming language; per questo this capitalization style is often referred as Pascal case, or camel case, visto che le lettere maiuscole che di tanto in tanto compaiono assomigliano a gobbe di cammello.]
- the class definition terminates with a semicolon.
- every class's body is enclosed in a pair of left and right braces {}
- the function main is always called automatically when you execute a program. Most functions do not get called automatically. You must call a member function explicitly to tell it to perform its task
- public keyword, is an access specifier. Access specifiers are always followed by a colon (:)
- the member function appears after the public access specifier: to indicate that the function is "available to the public" = can be called by other function in the program (like main) and by member functions of other classes (if there are any). Oltre a public ci sono anche gli "protected" and "private" access specifiers.
- when you define a function, you must specify a return type to indicate the type of the value returned by the function when it completes the task. In the example above, the return type void indicates that the function will not return any data to its calling function.
- by convention our function names use the camel case style with a lowercase first letter. The parenthesis after the member function name indicate that this is a function. An empty set of parenthesis indicates that this member function does not require additional data to perform its task. 
- la forma del tipo 
	void nomeFunction() const 
is commonly referred as a function header. Quando come nell'esempio sopra la funzione e' dichiarata const, si comunica al compiler che la function should not modify the object on which it's called. 
- every function's body is delimited by left and right braces {}
- typically you cannot call a member function of a class until you create an object of that class. nell'esempio sopra we create an object of class GradeBook called myGradeBook
	int main()
	{
		GradeBook myGradeBook;
the variable type is GradeBook, in maniera similare al type int. Solo che int is a fundamental type built in C++, while GradeBook is a user-defined type. So we need to tell the compiler what GradeBook is by including the class definition.
- each class you create becomes a new type that can be used to create objects. You can define new classes as needed; this is one reason why C++ is known as an extensible programming language.
- we call the member function using the dot operator:
    GradeBook myGradeBook; // create a GradeBook object named myGradeBook
	myGradeBook.displayMessage(); // call object's displayMessage function
"myGradeBook." indicates that main should use the GradeBook object created in the previous line.	
[pag69deitel]
- ARGUMENT and parameters [Argument vs parameter]: a member function can require one or more parameters that represent additional data it needs to perform its task. A function call supplies values -called ARGUMENTS- for each of the function's PARAMETERS. --> per comprendere meglio il ruolo di argument e parameter see fig 3.3 pag 71deitel
diciamo in parole semplici: argument e' cio che si passa per esempio in fase di call di una funzione, mentre parameter lo ritrovi tra le parentesi () nella definizione della funzione, per definire gli input di cui la funzione ha bisogno per funzionare.												
[pag71deitel]
- ATTRIBUTES, DATA MEMBERS and MEMBER FUNCTIONS 
a class normally consists of one or more member functions that manipulate the attributes that belong to a particular oject of the class. Attributes are represented as variables in a class definition. Such variables are called data members and are declared inside a class definition but outside the bodies of the class's member-function definition (see example pag75deitel). Each object of a class maintains its own attributes in memory. These attributes exist throughtout the life of the object. If you create more than one object (a partire dalla stessa classe) each will have its own data member, and these can contain different values.
Cioe' detto in parole spicciole: ogni classe ha degli attributi, che vengono rappresentati attraverso dei data members. Ogni volta che istanzi un oggetto a partire da una classe l'oggetto avra' il proprio data members con il suo specifico valore.
[pag74deitel]
////////////////////////////////////////////////////////////////////////////////////

>> OOP / >> Object Oriented Programming [mike programming game pag 241]
In OOP you define different types of objects with relationships to each other that allow the objects to interact. 
One of the key characteristics of OOP is the ability to make your own types from which you can create objects.
C++ lets you represent game entities as software objects, complete with member functions and data members. These objects work just like "string" and "vector" objects. But to use a new kind of object (say, an alien spacecraft) you must first define a type for it.
In the Simple Critter Program (example below) we define a brand new type called "Critter" for creating virtual pet objects. The program uses this new type to create two Critter objects. Then, it gives each cirtter a hunger level. Finally, each critter offers a greeting and announces its hunger level to the world. 
>> CLASS = code that groups data members and member function (p243 mike game programming). From a class, you create individual objects that have their own copies of each data member and access to all of the member functions. A class is like a blueprint. Just as a blueprint deines the structure of a building, a class defines the structure of an object. 
NOTE: to define a class, start with the keyword "class", followed by the class name. By convention, class names begin with an uppercase letter. You surround the class body with curly braces and end it with a semicolon. 
--------------------------------------------------------- START EXAMPLE
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/simple_critter.cpp]
		//Simple Critter
		//Demonstrates creating a new type
		
		#include <iostream>
		
		using namespace std;
[>> CLASS = code that groups data members and member function (p243 mike game programming) here follows a simple example]		
		class Critter            // class definition -- defines a new type, Critter
		{
		public:
		    int m_Hunger;        // data member NOTE convention: notice that we prefix the data "M"ember name with m_, convention to make data "M"ember instantly recognizable.
		    void Greet();        // member function prototype; NOTE: by convention member function names begin with an uppercase letter. 
		};
		
// you can define member functions outside of a class definition
		void Critter::Greet()    // member function definition
		{
		    cout << "Hi. I'm a critter. My hunger level is " << m_Hunger << ".\n";
		}
// >> MEMBER FUNCTION note [nmike pag244 mike programming]: the definition of a member function looks like any other function definition, except for the prefix "Critter::" to the function name. When you define a member function outside of its class, you need to qualify it with the class name and scope resolution operator so the compiler knows that the definition belongs to the class.
		
		int main()
		{
		    Critter crit1;   // INSTANTIATION OBJECTS
		    Critter crit2;
// when you create an object (come nelle due righe precedenti) you instantiate it from a class. In fact specific objects are called >> instances of the class [pag245 mike programming game].
		    // >> data member access [pag245 mike game programming]: you can access an available data member of an object using the member selection operator "." 
		    crit1.m_Hunger = 9;  //assigns "9" to crit1's data member m_Hunger
		    cout << "crit1's hunger level is " << crit1.m_Hunger << ".\n";
		
		    crit2.m_Hunger = 3;
		    cout << "crit2's hunger level is " << crit2.m_Hunger << ".\n\n";
		    
		    crit1.Greet(); 
		    crit2.Greet();
		
		    return 0;
		}
------------------------------------------------------------------ END EXAMPLE
  
////////////////////////////////////////////////////////////////////////////////////

>> OOP SUMMARY OBSERVATION from mike game programming pag 265
- Object oriented programming  is a way of thinking about programming in which you define different types of objects with relationships that interact with each other. 
- You can create a new type by defining a class
- A class is a blueprint for an object
- In a class you can declare data members and member functions. 
- When you define a member function outside of a class definition, you need to quailify it wit the class name and scope resolution operator (::)
	i.e. type nomeClass::nomeMemberFunction(input_parameters)
- You can access data members and member functions of objects through the member selection operator (.)
- Every class has a constructor (a special member function that's automatically called every time a new object is instantied). Constructors are often used to initialize data members 
- You can set member access levels in a class by using the keywords public, private, and protected. 
- A public member can be accessed by any part of your code through an object.
- A private member can be accessed only by a member function of that class.
- A static data member exists for the entire class.
- A static member function exists for the entire class.
- Some game programmers prefix private data member names with m_ and static data members names with s_ so that they're instantly recognizable
PAG267 mike programming: >>struct
What is a structure? A structure is very similar to a class. The only real difference is that the default access level for structures is public (al contrario delle classi in cui il default access level is private). You define a structure by using the keyword "struc". 
Why does C++ have both structures and classes? So that C++ retains backward compatibility with C.
Some game programmers use strutures to group only data together, without functions (because that's how C structures work). But it's probably best to avoid structures whenever possible and use classes instead. 
////////////////////////////////////////////////////////////////////////////////////


>> object size 
[pag385deitel]
People new to object-oriented programming often suppose that objects must be quite large because they contain data member and member functions. Logically this is true (you may think of objects as containing data and functions) but PHYSICALLY however this is not TRUE.
>> PERFORMANCE and object size
Objects contain only data, so objects are much smaller than if they also contained member functions. The compiler creates one copy (only) of the member functions separate from all objects of the class. All objects of the class share this one copy. Each object, of course, needs its own copy of the class's data, because the data can vary among the objects. The function code is nonmodifiable and, hence, can be shared among all objects of one class.

>> object's scope / >> object scope
[pag394deitel]
the block in which that object is defined

>> object serialization 
[pag628 deitel]
When object data members are output to a disk file, we lose the object's type information. We store only the values of the object's attributes, not type information, on the disk. If the program that reads this data knows the object type to which the data corresponds, the program can read the data into an object of that type as we did in your random access files examples (ex Fig14_14.cpp e compagnia pagine 620-628)
An interesting problem occurs when we store objects of different types in the same file. How can we distinguish them (or their collections of data members) as we read them into a program? The problem is that objects typically do not have type fields.
One approach used by several programming languages is called object serialization. A so called >> serialized object is an object represented as a sequence of bytes that includes the object's data as well as information about the object's type and the types of data stored in the object.
 After a serialized object has been written to a file, it can be read form the file and deserialized (taht is the type information and bytes that represent the object and its data can be used to recreate the object in memory).
C++ does not provide a built-in serialization mechanism; however there are third party and open source C++ libraries that support object serialization. The open source Boost C++ libraries (www.boost.org) provide support for serializing objects in text, binary and extensible markup language (XML) formats. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> output  of char * Variables
[pag568]
C++ determines data type automatically (an improvement over C) but this feature sometimes gets in the way. For example, supose we want to print the address stored in a char * pointer. The << operator has been overloaded to output a char * as null-terminated C-style string. To output the address, you can cast the char * to a void * (this can be done to any pointer variable).   

>> overloading pag 118 jesse
C++ enables you to create more than one function with the same name. This is called function overloading. The functions must differ in their parameter list with a different type of parameter, a different number of parameters or both. Here's an example:
	int myFunction (int, int);
	int myFunction (long, long);
	int myFunction (long);
NOTE: two functions with the same name and parameter list, but different return types, generate a compiler error. To chnage the return type, you must also change the signature
Function overloading is also called function polymorphism ( poly = many, morph = form => function of many forms)
Function polymorphis refers to the capability to overload a function with more than one meaning. By changing the number or type of the parameters, you can give two or more functions the same function name, and the right one will be called automatically by matching the parameters used. 
Suppose you write a function that doubles whatever input you give it. You would like to be able to pass in an "int", a long a float or a double. Senza function overloading saresti obbligato a creare 4 funzioni diverse
	int Double(int);
	long DoubleLong(long);
	float DoubleFloat(float);
	double DoubleDouble(double);
with function overloading, it is sufficient to declare:
	int Double(int);
	long Double(long);
	float Double(float);
	double Double(double);
This is easier to read and easier to use.
--------------------------------------------------------------------------------------------------------------
// Listing 5.8 - demonstrates
// function polymorphism
  
#include <iostream>
  
// prototypes of the functions 
int Double(int);
long Double(long);
float Double(float);
double Double(double);
  
using namespace std;

int main()
{
   int      myInt = 6500;
   long     myLong = 65000;
   float    myFloat = 6.5F;
   double   myDouble = 6.5e20;
  
   int      doubledInt;
   long     doubledLong;
   float    doubledFloat;
   double   doubledDouble;
  
   cout << "myInt: " << myInt << "\n";
   cout << "myLong: " << myLong << "\n";
   cout << "myFloat: " << myFloat << "\n";
   cout << "myDouble: " << myDouble << "\n";
  
   doubledInt = Double(myInt);
   doubledLong = Double(myLong);
   doubledFloat = Double(myFloat);
   doubledDouble = Double(myDouble);
  
   cout << "doubledInt: " << doubledInt << "\n";
   cout << "doubledLong: " << doubledLong << "\n";
   cout << "doubledFloat: " << doubledFloat << "\n";
   cout << "doubledDouble: " << doubledDouble << "\n";
  
   return 0;
}
  
// definition of the functions.
int Double(int original)
{
   cout << "In Double(int)\n";
   return 2 * original;
}
  
long Double(long original)
{
   cout << "In Double(long)\n";
   return 2 * original;
}
  
float Double(float original)
{
   cout << "In Double(float)\n";
   return 2 * original;
}
  
double Double(double original)
{
   cout << "In Double(double)\n";
   return 2 * original;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> operator overloading / >> overloading operator
[pag434 deitel]
Examples
- one example of an overloaded operator built into C++ is << 
in effetti << is used both as the stream insertion operator and as the bitwise left-shift operator.
Similarly, >> also is overloaded: it's used both as the stream extraction operator and the bitwise right-shift operator. 
Both of these operators are overloaded in the C++ standard library.
The overloads are built into the base C++ language itself. For example, C++ overloads the addition operator (+) and the subtraction operator (-) to perform differently, depending on their context in integer, floating point and pointer arithmetic with data of fundamental types.
You can overload most operators to be used with class objects (the compiler generates the appropriate code based on the types of the operands). 
NOTES [from pag 438 deitel]
You can use operators with your own user-defined types. Although C++ does not allow new operator to be created, it does allow most exisiting operator to be overloaded so that , when they're used with objects, they have meaning appropriate to those objects. 
Operator overloading is not automatic, you must write operato-voerloadin functions to perform the desired operations. An operator is overloaded by writing a non-static member function definition or non-member function definition as you normally would, except that the function name starts with the keyword "operator" followed by the symbol for the operator being overloaded. 
For example, the function name "operator+" would be used to overload the addition operator (+) for used with objects of a particular class. When operators are overloaded as member functions, they must be non-static, because they must be called on an object of the class and operate on that object. 
To use an operator on an objet of a class, you must define overloaded operator functions for that class, with three exceptions:
1) the assignment operator (=) may be used with most classes to perform memberwise assignment of the data members (each data member is assigned from the assignment's "source" object (on the right) to the "target" object (on the left). Memberwise assignment is dangerous for classes with pointer members, so we'll explicitly overload the assignment operator for such cases)
2) the address (&) operator returns a pointer to the object; thi operator also can be overloaded.
3) the comma operator evaluates  the expression to its left then the expression to its right, and returns the value of the latter  expression. This operation also can be overloaded. 
>> OPERATORS THAT CANNOT BE OBERLOADED
	. 
	.*(pointer to member)
	::
	?:
>> OPERATOR OVERLOADING RULES AND RESTRICTIONS
[pag439deitel]
- The precedence of an operator cannot be changed by overloading. However, parenthesis can e used to force the order of evaluation of overloaded operators in an expression. 
- the associativity of an operator cannot be changed by overloading: if an operator normally associates from left ot right, then so do all of its overloaded versions.
- you cannot change the "arity" [ tag >> arity] of an operator (tha is , the number of operands an operator takes), overloaded unary operators remain unary operators; overloaded binary operators remain binary operators. Operators &, *, + and - all have both unary and binary version; theses unary and binary veresion can be separately overloaded.  
- you cannot create new operators; only existing operators can be overloaded.
- related operators like + and += must be overloaded separately. 
- when overloading (), [], -> or any of the assignment operator, the operator overloading function must be declared as a class member. For all other overloadable operators, the operator overloading functions can be member functions or non-member functions. 
ADVICE : overload operators for class types so they work as closely as possible to the way built-in operators work on fundamental types. 

>> OVERLOADING UNARY OPERATORS
[pag444deitel]
	bool operator!() const;
>> overloaded operators as non-member functions
	bool operator!( const String & );
//////////////////////////////////////////////////////

>> OVERLOADING BINARY OPERATORS.
[pag 439 deitel] 
A binary operator can be overloaded as a 
1) non-static member function with one parameter or as a 
2) non-member fuction with two parameters
ESEMPI
1) Example binary overloaded operators as member functions [pag440deitel]
	class String
	{
	public:
		bool operator<(const String & ) const;
		...
	}; // end class string
2) binary overloaded operators as non-member functions example [pag440 deitel]
	bool operator<( const String &, const String & );
////////////////////////////////////////////////////////////////////////////////////////


>> OVERLOAD ++ / >> OVERLOAD -- / >> OVERLOAD UNARY PREFIX / >> OVERLOAD UNARY POSTFIX
[pag 445 deitel]
NOTE from pag451 
Overloading the postfix increment operator is trickier. For example if int variable x has the value 7, the statement 
	cout << x++ << endl;
outputs the original value of variable x.

>> OVERLOADING FUNCTIONS [pag165 mike game programming]
Suppose you want to write a function that performs a 3D transofmration ona set of vertices that are represented as floats, but you want the function to work with ints as well. Instead of writing 2 separate functions with 2 different names, you could function overloading so that a single function could handle the different parameter lists. This way, you could call one function adn pass vertices as either floats or ints.
In the full example below we use a single function that 's been overloaded to work with an argument of two different types: int and string. 
TO CREATE AN OVERLOADED FUNCTION, YOU SIMPLY NEED TO WRITE MULTIPLE FUNCTION DEFINITIONS WITH THE SAME NAME OF DIFFERENT PARAMETERS LISTS.
extract example from the FULL EXAMPLE below:
		int triple(int number); // this first function prototype takes an int argument and returns an int
		string triple(string text); // this second function prototype takes a string object and returns a string object.
Seguiranno le corrispondenti function definitions come mostrato nel FULL EXAMPLE qui sotto.
FULL EXAMPLE 
[from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/triple.cpp]
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int triple(int number);
		string triple(string text);
		
		int main()
		{
		    cout << "Tripling 5: " << triple(5) << "\n\n";
		    cout << "Tripling 'gamer': " << triple("gamer");
		
		    return 0;
		}
		
		int triple(int number)
		{
		    return (number * 3);
		}
		
		string triple(string text)
		{
		    return (text + text + text);
		}
---------------------------------------------------------
overloading functions TRAP [pag167 mike game programming]: to implement function overloading, you need to write mupltiple definitions for the same function with different parameter lists. That's because if you write two functions definitions in which only the return type is different, you'll generate a compile error. For example you cannot have both of the following proptotypes in a program:
	int Score(int);
	float Score(int); 
>> OVERLOADED FUNCTION CALL / >> CALL OVERLOADED FUNCTION [pag167 mike game programming]
You can call an overloaded function the same way you call any other function, by using its name with a set of valid arguments. But with overloaded functions, the compiler (based on the argument values) determines which definition to invoke.
For exemple in the FULL EXAMPLE above :
    cout << "Tripling 5: " << triple(5) << "\n\n";
since we call triple() giving an "int" as a argument, the compiler knows to invoke the definition that takes an "int". As a result the function returns the int 15. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
>> OVERRIDE keyword 
pag528deitel

>> OVERRIDE member functions [pag319 mike game programming]
Any inherited base class member function that you expect to be overrideen in a derived class should be declared as virtual, using the keyword virtual. When you declare a member function virtual, you provide a way for overridden version of the member function to work as expected with pointers and references to objects. 
Although you can override non-virtual member functions, this can lead to behaviour you might not expect. A good rule of thumb is to declare any base class member function to be overridden as virtual. 
NOTE: the keyword "virtual" is not used in the definition of the member function, only in its declaration. 
TRAP: don't confuse override with overload. When you override a member function, you provide a new definition of it in a derived class. When you overload a function, you create multiple versions of it with different signatures.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> OR OPERATOR   || 
see LOGICAL OPERATORS

>> ORDER of evaluation of operands 
[pag254]
Most programmers simply assume that the operands are evaluated left to right. C++ does not specify the order in which the operands of most operators are to be evaluated. 
C++ specifies the order of evaluation of the operands of only four operators 
	&&
	||
	,
	?:
the first three (&& || , ) are binary operators whose two operands are guaranteed to be evaluated from left to right.
The last operator ?: is the only ternary operator
- its leftmost operand is always evaluated first
- if it evaluates true, the middle operand evaluates next and the last operand is ignored
- if the leftmost operand evaluates to false, the third operand evaluates next and the middle operand is ignored.
MEMENTO: writing programs that depend on the order of evaluation of the operands of operators other than &&, || ?: and the comman (,) operator can lead to logic errors.

>> out of range exception 
[pag458 deitel]
capita quando il subscript all'interno dell'operatore [] si trova al di fuori del range dell'array
tipo avessi un array "carrier" di 7 elementi e effettuassi un 
	carrier[17] = 1000;
ti verrebbe fuori una out of range exception

>> OVERLOADING CONSTRUCTOR 
[pag392deitel]
A class constructor and member functions can also be overloaded. Overloaded constructors typically allow objects to be initialized with different types and/or numbers of arguments. To overload a constructor, provide in the class definition a prototype for each version of the constructor, and provide a separate constructor definition for each overloaded version.
see esempio pag 392deitel 

>> PPPPPPP

>> PASS-BY-VALUE vs PASS-BY-REFERENCE
[pag237deitel]
- Pass by value: when a value is passed  by value a copy the argument value is made and passed to the called function.
Changes to the copy do not affect the original variable's value in the caller. 
One disadvantage is that, if a large data item is being passed, copying that data can take a considerable amount of execution time and memory space.
- Pass by reference: the caller gives the called function the ability to access the caller's data directly and to modify the data
Pass-by-reference is good for performance reasons, because it can eliminate the pass-by-value overhead of copying large amount of data.
BUT : pass by reference can weaken security; the called function can corrupt the caller's data.
 
>> parameter list [pag101 jesse] = is the list of values that you sent into a function. 
For example 
	int myFunction(int someValue, float someFloat);
in questo caso la parameter list is 2 variables :
	int someValue
	float someFloat
>> declaration vs definition of a function [pag101 jesse]
The declaration tells the compiler the name, return type, and parameters of the function. A declaration of a function is called >> prototype
The definition tells the compiler how the function works.
>> prototype [pag102 jesse]
The function prototype is a statement which means it ends  with a semicolon. It consists of the function's return type and signature. A function >> signature is its name and parameter list
example 
 	 unsigned short int   FindArea     (int  length,     int  width)         ; 
 //	 return type          name          type parameter1  type parameter2     do not forget the semicolon!
Note: when you write a function prototype you can also just write the types of the parameters and omit their names, example 
	long Area (int, int);
this would be perfectly legal, but it is not a good idea, since adding parameter names makes your prototype clearer.
If your function does not actually return a value, you declare its return type to be "void", as shown here
	void printNumber(int myNumber);
this declares a function called printNumber that has one integer parameter. Because void is used, nothing is returned.
>> DEFINE FUNCTION [pag103 jesse]
The definition of a function consists of the function header and its body. 
The header is like the function prototype except that the parameters must be named, and no terminating semicolon is used. 
The body of the function is a set of statements enclosed in {}
	int Area (int length, int width)
	{
		//statement 
		return   (length * width);
    //  keyword  return value  
	}
IN SHORT : the only required difference between prototype and definition of a function is that the function prototype  ends with a semicolon and has no body.
---------------------------------------------------------------------------------------------------
// Full example of function delcaration and the definition and use of that function
	// Listing 5.1 - demonstrates the use of function prototypes
	  
	#include <iostream>
	int Area(int length, int width); //function prototype
	  
	int main()
	{
	   using std::cout;
	   using std::cin;
	  
	   int lengthOfYard;
	   int widthOfYard;
	   int areaOfYard;
	  
	   cout << "\nHow wide is your yard? ";
	   cin >> widthOfYard;
	   cout << "\nHow long is your yard? ";
	   cin >> lengthOfYard;
	  
	   areaOfYard= Area(lengthOfYard, widthOfYard);
	  
	   cout << "\nYour yard is ";
	   cout << areaOfYard;
	   cout << " square feet\n\n";
	   return 0;
	}
	  
	int Area(int len, int wid) // definition of the function 
	{    // nota come non sia richiesto usare lo stesso nome dei parametri usati nel prototype qui usiamo "len" e "wid"
         // anche se a pag105 consiglia as a good programming practise to use the same parameters names 
		 //  int Area(int length, int width)   would be clearer when re-reading the program
	   return len * wid;
	}
//////////////////////////////////////////////////////////

>> PREDICATE FUNCTION [pag107 mike]: A predicate function is a function that returns either true or false. The string object member function empty() is an example of a predicate function. 

>> palindromes search example pag 105 moo book 
Palindromes are words that are spelled the same way front to back as back to front. For example "civic", "eye", "level", "rotor" are palindromes.
Ecco a compact solution to determine if a word is a palindrome:
	bool is_palindrome(const string& s)
	{	
		return equal(s.begin(), s.end(), s.rbegin());
	}
dove rbegin return an iterator, but this time it is an iterator that starts with the last element in the container and marches backward through the container. And the ">> equal" function compares two sequences to determine whether they contain equal values. The first two iterators passed to "equal" specify the first sequence. The third argument is the starting point for the second sequence. Because we pass s.rbegin() as the starting point for the second sequence, the effect of this call is to compare values from the back of s to values in the front. The "equal" function will compare the first character with the last. Then it will compare the second with the next to last, and so on. In tal modo checkare se la parola sia un palindrome o no.
--------------------------------------------------------------
>> URL FIND / >> FIND URL example pag105 moo book
A URL is a sequence of character of the form 
	protocol-name://resource-name
Our function will take a string argument and will look for instances of "://" in that string. Each time we find such an instance, we'll look for the protocol-name that precedes it, and the resource-name that follows it.
Because we want our function to find all the URLs in its input, we'll want it to return a vector<string>, with one element for each URL. The function executes by moving the iterator b through the string, looking for the character :// that might be a part of a URL. If we find these characters, it looks backward to find the protocol-name, and it looks forward to find the resource-name. 
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/urls.cc]
	vector<string> find_urls(const string& s)
	{
		vector<string> ret;
		typedef string::const_iterator iter;
		iter b = s.begin(), e = s.end();
	
		// look through the entire input
		while (b != e) {
	
			// look for one or more letters followed by `://'
			b = url_beg(b, e);
	
			// if we found it
			if (b != e) {
				// get the rest of the URL
				iter after = url_end(b, e);
	
				// remember the URL
				ret.push_back(string(b, after));
	
				// advance `b' and check for more URLs on this line
				b = after;
			}
		}
		return ret;
	}
///////////////////////////////////////////////////////////////////////////////////////

>> padding / >> fill / >> setfill
[pag582 deitel]
- fill member function specifies the fill character to be used with justified fields; spaces are used for padding by default. The setfill manipulator also sets the padding character. 
NOTE: padding character = il carattere di riempimento che viene usato per riempire gli spazi che non siano occupati da delle cifre. [di default i padding character sono degli spazi bianchi ma come mostrato a pag583 deitel puoi settare dei caratteri di riempimento diversi.]


>> PAUSE
Is there a decent wait function in C++?
SOLUTION (THE CHOSEN ONE)
you can require the user to hit enter before closing the program... something like this works.
	#include <iostream>
	int main()
	{
	  std::cout << "Hello, World\n";
	  std::cin.ignore();      // OTTIMO QUESTO METODO FUNZIONA A MERAVIGLIA
	  return 0;
	}
The cin reads in user input, and the .ignore() function of cin tells the program to just ignore the input. The program will continue once the user hits enter.
[http://stackoverflow.com/questions/902261/is-there-a-decent-wait-function-in-c]
SOLUTION2
If you want to write portable C++ code, then I'd suggest using cin.get().
system("PAUSE") works on Windows, since it requires the execution of a console command named "PAUSE". 
[http://stackoverflow.com/questions/24776262/pause-console-in-c-program]
SOLUTION3
    sleep(unsigned int)
The value has to be a positive integer in millisecond. That means that if you want your programme wait for 2 second, enter 2000.
Here's an example :
	#include <iostream>     //for using cout
	#include <stdlib.h>     //for using the function sleep
	using namespace std;    //for using cout
	int main(void)         
	{
	   cout << "test" << endl;
	   sleep(5000);         //make the programme waiting for 5 secondes
	   cout << "test" << endl;
	   sleep(2000);         // wait for 2 secondes before closing
	   return 0;
	}
If you wait too long, that probably means the parameter is in second. So change it like that :
	sleep(5);
For those who get error message or problem using sleep try to replace it by _sleep or Sleep especially on Code::Bloks.
And if you still getting probleme, try to add of one this library on the biggining of the code.
	#include <stdio.h>
	#include <time.h>
	#include <unistd.h>
	#include <dos.h>
	#include <windows.h>
[http://stackoverflow.com/questions/902261/is-there-a-decent-wait-function-in-c]
////////////////////////////////////////////////////////////

>> PERFORMANCE 
- a small performance improvement for code that executes many times in a loop result in substantial overall performance improvement. 
[pag118deitel]

>> POINTERS / >> *
[pag335deitel]
Pointers keep track of where data and functions are stored in memory.
[memo trick : il puntatore viene preceduto dal simbolo * perche' come un puntatore laser emette * luce, che usa per puntare/illuminare un determinato indirizzo.]
in short
	int *countPtr, count;
is the declaration of a pointer "countPtr" that points at the int variable "count". [nota come l'"int" si riferisca al type della variable a cui il pointer punta e non al pointer stesso.]
example 2
	double *xPtr, *yPtr;
indicates that both xPtr and yPtr are pointers to double values. When a variable appears in a declaration, it's not an operator; rather it indicates that the variable being declared is a pointer. Pointers can be declared to point objects of any data type.
[pag336deitel]
- Common programming error: each pointer must be declared with the * prefixed to the name (with or without spaces in between). Assuming that the * used to declare a pointer distributes to all names in a declaration's comma-separated list of variables can lead to errors.
- Good programming practice: including the letter Ptr in a pointer variable name makes it clear that the variable is a pointer and that it must be handled accordingly.
- Error prevention: initialize all pointer to prevent pointing to unknown or uninitialized areas of memory. Pointer should be initialized to
	nullptr 
or an address of the corresponding type either when they've declared or in an assignement.
>> NULL POINTER : a pointer with the value nullptr "points to nothing" and is known as a null pointer.   
- Pointers variables contain memory addresses as their values. Normally, a variable directly contains a specific value. A pointer contains the memory address of that variable that, in turn, contains a specific value. 
In this sense, a variable name directly references a value, and a pointer indirectly references a value. Referencing a value through a pointer is called INDIRECTION 
- Diagrams typically represent a pointer as an arrow from the variable that contains an address to the variable located at that address in memory. 
- Pointers like any other variables, must be declared before they can be used. For example, for a pointer "countPtr" that points at the variable "count" (come nella figura 8.1pag336deitel) the declaration :
	int *countPtr, count;
declares the variable countPtr to be of type int * (cioe' e' un pointer che punta a un int value) and is read right to left cioe' "countPtr is a pointer to int."
RESS OPERATOR (&)
[pag 337deitel] the address operator & is a unary operator that obtains the memory address of its operand. For  example:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr
	yPtr = &y;           // assign address of y to yPtr
----------------------------------------------------------------------------------------------------------------------
>> POINTERS TO CLASS MEMBERS ( .* AND ->* )/ >> ->* / >> .* [pag948 deitel]
C++ provides the .* and ->* operators for accessing class members via pointers. This is a rarely used capability, primarily for advanced C++ programmers. 
EXAMPLE:
	// Fig. 23.6: fig23_06.cpp
	// Demonstrating operators .* and ->*.
	#include <iostream>
	using namespace std;
	
	// class Test definition
	class Test
	{
	public:
	   void func()
	   {
	      cout << "In func\n";
	   } // end function func
	
	   int value; // public data member
	}; // end class Test
	
	void arrowStar( Test * ); // prototype
	void dotStar( Test * ); // prototype
	
	int main()
	{
	   Test test;
	   test.value = 8; // assign value 8
	   arrowStar( &test ); // pass address to arrowStar
	   dotStar( &test ); // pass address to dotStar
	} // end main
	
	// access member function of Test object using ->*
	void arrowStar( Test *testPtr )
	{
	   void ( Test::*memberPtr )() = &Test::func; // declare function pointer
	   ( testPtr->*memberPtr )(); // invoke function indirectly
	} // end arrowStar
	
	// access members of Test object data member using .*
	void dotStar( Test *testPtr2 )
	{
	   int Test::*vPtr = &Test::value; // declare pointer
	   cout << ( *testPtr2 ).*vPtr << endl; // access value
	} // end dotStar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTERS [pag211 mike game programming]
The essence of a pointer is quite simple: A POINTER IS A VARIABLE THAT CAN CONTAIN A MEMORY ADDRESS.
Pointers give you the ability to work directly and efficiently with computer memory.
Computer memory is a lot like a neighborhood, but instead of houses in which people store their stuff, you have memory locaions where you can store data. Just like a neighborhood where houses sit side by side, labeled with addresses, chunks of computer memory sit side by side, labeled with addresses. In a computer, you can use a pointer with a memory address in it to get to a particular memory location (and to the stuff stored inside it).
Example /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/pointing.cpp
In questo programma we create a variable for a score and then creates a pointer to store the address of the variable.
il seguente programma dimostra che 
	- you can change the value of a variable directly, and the pointer will reflect the change.
	- you can change the value of a variable through a pointer. 
	- you can change a pointer to point to another variable entirely
	- pointers can work just as easily with objects.
-------------------------------------------------- FULL EXAMPLE pointing.cpp
		// Pointing
		// Demonstrates using pointers
		
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int main()
		{
		    int* pAPointer;    //declare a pointer
            // NOTE: because pointers work in such a unique way, programmers often prefix pointer variable names with the letter "p" to remind them that the variable is indeed a pointer.
			// NOTE2: just like an iterator, a pointer is declared to point to a specific type of value. pAPointer is a pointer to in, which means that it can point to an int value. pAPointer can't point to a float or a char, for example. pAPointer can only store the address of an int. 
		    
		    int* pScore = 0;   //declare and initialize a pointer
		        
		    int score = 1000;
		    pScore = &score;   //assign pointer pScore address of a variable score
		
		    cout << "Assigning &score to pScore\n";
		    cout << "&score is: " << &score << "\n";     //address of score variable ()
		    cout << "pScore is: " << pScore << "\n";     //address stored in pointer  (printi il puntatore quindi l'indirizzo che punta alla variabile)
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n"; //value pointed to by pointer 
		   
		    cout << "Adding 500 to score\n";
		    score += 500;  // ora score = 1500
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";  // *pScore means "the object to which pScore points."
            // anche la linea precedente dona in output 1500
		
		    cout << "Adding 500 to *pScore\n";
		    *pScore += 500;  // aggiungi 500 to the value to which pScore points, quindi score diventa 1500 + 500 = 2000
            // con la linea precedente modifichiamo il valore contenuto nell'indirizzo a cui pScore punta e non pScore stesso. Se per esempio effettuassimo pScore +=500; sarebbe sbagliato perche' cambieremmo l'indirezzo a cui punta pScore, a new address that might contain anything. And this could lead to disastrous results. It would be a disaster. Donald Trump approves this message.
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";
		
		    cout << "Assigning &newScore to pScore\n";    
		    int newScore = 5000;
		    pScore = &newScore;  // reassigning pointers
		    cout << "&newScore is: " << &newScore << "\n";
		    cout << "pScore is: " << pScore << "\n";     
		    cout << "newScore is: " << newScore << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";  
		    
		    cout << "Assigning &str to pStr\n";
		    string str = "score";
		    string* pStr = &str;   //pointer to string object
		    cout << "str is: " << str << "\n";
		    cout << "*pStr is: " << *pStr << "\n";
		    cout << "pStr).size() is: " << pStr).size() << "\n";
		    cout << "pStr->size() is: " << pStr->size() << "\n";  
		  
		    return 0;
		}

--------------------------------------------------- FULL EXAMPLE pointing.cpp end
OUTPUT PROGRAM 
	Assigning &score to pScore
	&score is: 0x7fff6fc5c098
	pScore is: 0x7fff6fc5c098
	score is: 1000
	*pScore is: 1000
	
	Adding 500 to score
	score is: 1500
	*pScore is: 1500
	
	Adding 500 to *pScore
	score is: 2000
	*pScore is: 2000
	
	Assigning &newScore to pScore
	&newScore is: 0x7fff6fc5c09c
	pScore is: 0x7fff6fc5c09c
	newScore is: 5000
	*pScore is: 5000
	
	Assigning &str to pStr
	str is: score
	*pStr is: score
	pStr).size() is: 5
	pStr->size() is: 5
---------------------------------------------------
NOTE: because pointers work in such a unique way, programmers often prefix pointer variable names with the letter "p" to remind them that the variable is indeed a pointer.
NOTE2: >> declare pointer: when you declare a pointer, you can put whitespace on either side of asterisk. So
	int* pAPointer;
or
	int *pAPointer;
or 
	int int * pAPointer; 
all declare a pointer named pAPointer.
TRAP: when you declare a pointer, yhe asterisk only applies to the single variable name that immediately follows it. So the following statement declares pScore as a pointer to int and score as an int. 
	int* pScore, score;
score is not a pointer! It's a variable of type int. One way to make this clearer is to play with the whitespace and rewrite the statement as 
	int *pScore, score;
However, the clearest way to declare a pointer is to declare it in its own statement, as in the following lines.
	int* pScore;
	int score;
NOTE3: >> initialize Pointers / >> pointer initialize  : as with other variables you can initialize a pointer in the same statement you declare it. That's what we do next with the following line, which assigns 0 to pScore:
	int* pScore = 0; // declare and initialize a pointer
Assigning 0 to a pointer has a special meaning. Loosely translated, it means "Point to nothing". Programmers call a pointer with the value of zero a null pointer. You should always initialize a pointer with some value when you declare it, even if that value is zero. 
HINT: many programmer assign NULL to a pointer instead of 0 to make the pointer a null pointer. NULL is a constant defined in multiple library files, including iostream. 
NOTE4: >> assign address to pointer / >> pointer assign [pag215 mike game programming] A way to get address into the pointers is to get the memory address of an existing variable and assign it to a pointer. That's what we do in the following line, which gets the address of the variable score and assigns it to a pScore 
	pScore = &score; // assign pointer address of a variable score.
We get the address of score by preceding the variable name with &, the address of operator. 
NOTE5: & is a symbol used also as "reference operator". However, in this context, the & symbol gets the address of an object.
As a result the preceding line of code, pScore contains the address of score. It's as if pScore knows exactly where score is located in the computer's memory. This means you can use pScore to get to score and manipulate the value stored in score. 

            pScore                               score
      -----------------                    |-----------------|
      |               |                    |                 |
      |            ----------------------->|      1000       |
      |               |                    |                 |
      -----------------                    \-----------------/ 

The pointer pScore points to score, which stores the value 1000
NOTE6 pag 216 
>> DEREFENCING POINTERS [pag216 mike programming] termine sibillino per giusto dire "ottenere il valore puntato dal pointer", ottenere il contenuto dell'indirizzo a cui si punta, REFERENCING -> riferirsi = puntare a DEREFERENCING -> deriferire = ottenere il valore dell'indirizzo a cui si punta
    cout << "*pScore is: " << *pScore << "\n\n"; //value pointed to by pointer
*pScore means "the object to which pScore points."
NOTE7: DON'T@DEREFERENCE A NULL POINTER BECAUSE IT COULD LEAD TO DISASTROUS RESULTS [del resto un nullpointer non si sa bene cosa sia il contenuto a cui punta, metti che sia un goblin, o peggio ancora un gremlins, altro che electric dreams. You end up with electric nightmares!] 
NOTE8: >> pointer reassigning / >> reassign pointer [mike pag 217 game programming]
	pScore = &newScore;  // reassigning pointers
Unlike references, pointers can point to different objects at different times during the life of a program. Reassigning a pointer works like reassigning any other variable. In the following line we reassign pScore with the following line:
	pScore = &newScore; // pScore now points to newScore
TRAP : don't change the value to which a pointer points when you want to change the pointer itself. For  example, if we want to change pScore to point to newScore, then the following line would be a big mistake.
	*pScore = newScore;
This code simply changes the value to which pScore currently points; it doesn't change pScore itself. 
>> POINTERS TO OBJECTS [mike game programming pag217]
    cout << "Assigning &str to pStr\n";
    string str = "score";
    string* pStr = &str;   //pointer to string object, meaning that pStr can store the address of any string object.
    cout << "pStr).size() is: " << pStr).size() << "\n";
where pStr).size() says "Take the result of dereferencing pStr and call that object's size() member function". Because pStr refers to the string object equal to "score", the code returns 5. 
HINT: whenever you dereference a pointer to access a data member or member function, surround the dereferenced pointer with a pair of parentheses. This ensures that the dot operator will be applied to the object to which the pointer points.
NOTE : una maniera piu' readable e del tutto equivalente a pStr).size() e' pStr->size(). It's a more readable way to access object members. [>> -> = easy way to access object members pag 218 mike programming game]
----------------------------------------------------------------------------------------------------------
>> POINTER CONSTANT / >> CONSTANT POINTER [pag219 mike programming game] int* const pScore = &score;
You can use the keyword const to restrict the way a pointer works. These restrictions can act as a safeguards and can make your programming intentions clearer.
Pointers can point to different object at different times in a program. However, by using the const keyword  when you declare and initialize a pointer, you can restrict the pointer so it can only point to the object to which it was initialized to point. A pointer like this is called a constant pointer. Another way to say this is to say that the address stored in a constant pointer can never change: it's constant. You create a constant pointer by putting const right before the name of the pointer when you declare it. Here's an example of creating a constant pointer:
	int score = 100;
	int* const pScore = &score; // a >> constant pointer example
The preceding code creates a constant pointer, pScore, which score to score. Like all constants, you must initialize a constant pointer when you first declare it. For example writing "int* const pScore;" is more ILLEGAL than mexican pleople entering through the Trump wall or Crooked Hillary bribes business.
Also "pScore = &anotherScore;" is illegal since pScore can't point to a different object. 
Although you can't change pScore itself, you can use pScore to cahnge the value to which it points. The following line is completely legal:
	*pScore = 500;
It's perfectly fine to use a constant pointer to change the value to which it points. Remember, the restriction on a constant pointer is that its value, the address that the pointer stores can't change, the address a cui punta non puo' cambiare ma chi ci vive in quell'indirizzo puo' cambiare. Il const pointer mi sembra un po come il padrone di una casa in affitto. Il locatario puo' cambiare, ma il padrone lui resta puntato sempre allo stesso indirizzo da cui riceve l'affitto.
NOTE: the way a constant pointer works should remind you of something: a reference. Like a reference, a constant pointer can refer only to the object to which it was initialized to refer. 
Although you can use a constant pointer instead of a reference in your programs, you should stick with references when possible. References have a cleaner syntax than pointers and can make code easier to read. 
>> POINTER TO CONSTANT [pag220 mike game programming] const int* pNumber; // a pointer to a constant  {{da non confondersi con constant pointer vedi sopra "int* const pScore = &score;"}}
By using a the const keyword when you declare a pointer, you can restrict a pointer so it can't be used to change the value to which it points. A pointer like this is called pointer to a constant. Example 
	const int* pNumber;
The preceding code declares a pointer to a constant, pNumber. You declare a pointer to a constant by putting const right before the type of value to which the pointer will pointer. You assign an address to a pointer to a constant as you did before:
	int lives = 3;
	pNumber = &lives;
However, you can't use the pointer to change the value to which it points. The following line is illegal:
	*pNumber -= 1; // illegal: can't use pointer to constant to change value that pointer points to
Although you can't use a pointer to a constant to change the value to which it points, the pointer itself can change. This means that a pointer to a constant point to different objects in a program. The following code is perfectly legal.
	const int MAX_THRUST = 500;
	pNumber = &MAX_THRUST; // point itself can change.
>> CONSTANT POINTER TO A CONSTANT [pag221 mike programming] (in realta' poco usati perche' sono del tutto equivalenti a delle "constant reference", le quali presentano il vantaggio di offrire a cleaner syntax and a more readable code)
A constant pointer to a constant combines the restrictions of a constant pointer and a pointer to a constant. This means that a constant pointer to a constant can only point to the object to which it was inialized to point. In addition, it can't be used to change the value of the object to which it points. 
	const int* const pBONUS = &BONUS; // >> constant pointer to constant
The preceding code creates a constant pointer to a constant named pBONUS that points to the constant BONUS. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTER PITFALLS [pag254 moo book]
A pointer is a promitive, low level data structure. Programming with pointers is notoriously error prone. Many of the problems with pointers arise because pointers are independent of the objects to which they point, leading to pitfalls:
- copying a pointer does not copy the corresping object, leading to surprises if two pointers inadvertently point to the same object.
- destroying a pointer does not destroy its object, leading to memory leaks
- deleting an object without destroying a pointer to it leads to a dangling pointer, which causes undefined behaviour if the program uses the pointer.
- creating a pointer without initializing it leaves the pointer unbound, which also causes undefined behaviour if the program uses it.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PASSING POINTERS / >> POINTER PASS [pag222 mike programming game]
NOTE [pag224 mike programming] why we pass pointers? perche' si vedono functions' headers like "void goodSwap(int* const pX, int* const pY)" con strani asterischi? E' PERCHE' SI VUOLE DONARE ALLA FUNZIONE ACCESS TO VARIABLES. Vedi l'esempio qui sotto:
	1) in the main() function 
		goodSwap(&myScore, &yourScore); // as input we use the addresses of myScore and your score. WHEN YOU PASS AN OBJECT TO A POINTER YOU NEED TO SEND THE ADDRESS OF THE OBJECT
	2) in the function header
		void goodSwap(int* const pX, int* const pY)    // in the function's header pX and pY are constant pointers and will each accept the memory address we set in the main function. 
----------------------------------------------------------------- 
You can give function access to variables by passing references. But it's also possible to accomplish this using pointers. When you pass a pointer, you pass only the address of an object. This can be quite efficient, especially if you're working with objects that occupy large chunks of memory. Passing a pointer is like e-mailing a friend the URL of a website instead trying to send him the entire website.
-----------------------------------------------------------------
Even though references are the preferred way to pass arguments because of their cleaner syntax, you still might need to pass objects through pointers. For example, suppose you're using a graphics engine that returns a pointer to a 3D object. If you want another function to use this object, you'll probably want to pass the pointer to the object for efficiency. Therefore, it's important to know how to pass pointers as well as references.
NOTE: you can also pass a constant pointer to a constant. This works much like passing a constant reference, which is done to efficiently pass an object that you don't need to change.
[example from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/swap_pointer_ver.cpp]
----------------------------------------------------------------- FULL EXAMPLE
		// Swap Pointer
		// Demonstrates passing constant pointers to alter argument variables
		
		#include <iostream>
		
		using namespace std;
		
		void badSwap(int x, int y);
		void goodSwap(int* const pX, int* const pY);
		
		int main()
		{
		    int myScore = 150;
		    int yourScore = 1000;
		    cout << "Original values\n";
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		    
		    cout << "Calling badSwap()\n";
		    badSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		        
		    cout << "Calling goodSwap()\n";
		    goodSwap(&myScore, &yourScore); // we pass the addresses of myScore and yourScore when we call goodSwap() with the following line. WHEN YOU PASS AN OBJECT TO A POINTER YOU NEED TO SEND THE ADDRESS OF THE OBJECT
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n";
		
		    return 0;
		}
		
		void badSwap(int x, int y)
		{
		    int temp = x;
		    x = y;
		    y = temp;
		}
		
		void goodSwap(int* const pX, int* const pY)    // in this function's header pX and pY are constant pointers and will each accept a memory address. We made the parameters constant pointers because, although we plan to change the values they point to, We don't plan to change the pointers themselves. [i proprietari (pointers) puntano sempre alle stesse case in affitto, cambi giusto i locatari che vi vivono dentro] 
		{
		    //store value pointed to by pX in temp
		    int temp = *pX;
		    //store value pointed to by pY in address pointed to by pX
		    *pX = *pY;
		    //store value originally pointed to by pX in address pointed to by pY       
		    *pY = temp;      
		}
----------------------------------------------------------------- FULL EXAMPLE END
/////////////////////////////////////////////////////////////////////////////////////

>> low level data structures >> pointers and arrays [pag 169 moo book]
We can store data either in varialables or containers, such as vector, that come from the standard library. The reason for this strategy is that the standard library facilities are usually more flexible and easier to use than the facilities that are part of the core language. 
	Once you know how to use the library, the logical next step is to understand how it works. The key to this undersatnding turns out to involve core language programming tools and techniques that come in handy in other contexts as well. We use the term low level to refer to theses ideas because they underlie the standard library and because they correspond closely to the way typical computer hardware works. For these reasons, they tend to be harder to use, and are more dangerous, but they sometimes can be more efficient. Because no library can solve all problems, many C++ programs wind up using low level techniques from time to time. For example we can use arryas and pointers and combine with "new" expressions and "delete" expressions to allow a form of dynamic memory allocation that programmers can control more directly than they can control the automatic memory management offered by library classes such as vector and list.
An >> array is a kind of container, similar to a vector but less powerful. A pointer is a kind of random access iterator that is essential for accessing elements of arrays, and has other uses as well.
Pointers and arrays are among the most promitive data strutures in C and C++. They are virtually inseparable from one another, in the sense that it is impossible to do anything useful with an array without using pointers, and pointers become much more useful in the presence of arrays.
>> POINTER [pag170 moo book]
A pointer is a value that represents the address of an object. Every distinct object has a unique address, which denotes the part of the computer memory that contains the object. If you can access an object, you can obtain its address, and viceversa. 
For example if 
	x is an object
then
	&x is the address of that object, 
and if 
	p is the address of an object 
then 
	*p is the object itself.
The & and &x is an address operator, and is distinct from the use of & to define reference types (pag54 moo book). 
The * is a dereference operator, which works analogously to the way * works when applied to any other iterator (pag81 moo book).
If p contains the address of x, we also say that p is a pointer that points to x. It is common to represent such a astate of affairs with a diagram such as :

               p                                    x
      -----------------                    |-----------------|
      |               |                    |                 |
      |            ----------------------->|                 |
      |               |                    |                 |
      -----------------                    \-----------------/ 

As with other built-in types, a local variable that is a pointer has no meaningful value until we give it one. Programmers frequently use the value 0 to initialize pointers, because converting 0 to a pointer yields a value that is guaranteed to be distinct from a pointer to any object. Moreover, the constant 0 is the only interger value that can be converted to a pointer type. The resulting value, often called a null pointer, is often useful in comparisons.
As with all C++ values, pointers have types. Suppose that x is an object of type int, defined as;

	int x;

and we want to define p to have a type that will allow p to contain the address of x. We do so by saying that the type of p is "pointer to int" which we say implicitly by defining *p to have type int:
	
	int *p;    // *p has type int

Here *p is a >> declarator, which is the part of a definition that defines a single variable. 
Even though the * and the p are part of a single declarator, most C++ programmers write this definition as 
	
	int* p;    // p has type int*

to emphasize the notion that p has a particular type (i.e. int*). These two usages are equivalent because spaces around the * are neutral. However , the latter usage conceals a pitfall that is so important that it deserves special attention:

	int* p, q;

defines p as an object of type "pointer to int" and q as an object of type int. This example is easier to understand if we view it this way:

	int *p, q;  // *p and q have type int

or for that matter this way 

	int (*p), q;   (*p) and q have type int

Still better, we can make our intentions crystal clear by writing

	int* p;   // *p has type int
	int q;    // q has type int

We now know enough to write a simple program that uses pointers:

	int main()
	{
		int x = 5;

		// p points to x 
		int* p = &x;    // dove & e' l'address operator. Questa linea significa: assegn al pointer p (di type int*) l'address della variabile x
		cout << "x = " << x << endl;

		// change the value of x through p
		*p = 6;   // *p = cio' a cui p punta, cioe' il contenuto della memoria allocata alla variable x, cioe' "*p = 6" same as "x = 6"
		cout << "x = " << x << endl;
		return 0;
	}

CICCIO TRICK &x ti da l'indirizzo, and & this is the END. la mafia arriva *p con la torcia * e ti scompiglia tutti i valori che hai in casa.

The output of this program will be 

	x = 5
	x = 6

Nel programma sopra, immediately after we have defined p, the state of our variable is 5. After the first output to screen, the next statement changes the value of x to 6 by executing *p = 6. Remember, once p contains the address of x, *p and x are two different ways of referring to the same object. Thus the x is 6 when the second output expression is executed.
------------------------------------------------------------------------------------- ti ricopio l'esempio sopra in maniera piu' compatta senza commenti
#include <iostream>
using std::cout;
using std::endl;
int main()
{
	int x = 5;

	// `p' points to `x'
	int* p = &x;
	cout << "x = " << x << endl;

	// change the value of `x' through `p'
	*p = 6;
	cout << "x = " << x << endl;
	return 0;
}
------------------------------------------------------------------------------------------
>> POINTERS TO FUNCTIONS [pag172 moo book]
Functions are not objects, and there is no way to copy or assign them. In particular there is no way for a program to create or modify a function (only the compiler can do that). All that a program can ever do with a function is call it or take its address. 
	Nevertheless, we can call a function with another function as an argument [like pag 112-113 moo book]. What happens is that the compiler quietly translates such calls so as to use pointers to functions instead of using functions directly.
Pointers to functions behave similarly to any other pointers. Once you have dereferenced such pointer, however, all you can do with the resulting function is call it (or take the function's address yet again).
[CICCIO SPIEGA in parole semplici: 

	>> DEREFERENCE = ottenere il valore a cui il pointer punta 

Quindi se il puntatore punta a una funzione, deferenziando ottieni la funzione stessa: e con essa potrai effettuare solo due operazioni: chiamarla o ottenerne l'indirizzo.
]
We might write 
	int (*fp)(int);
to say that if we dereference "fp", and call it with an int argument, the result has type int. By implication, "fp" is a pointer to a function that takes an int argument and returns an int result. 
Because all that you can do with a function is to take its address or call it, any use of a function that is not a call is assumed to be taking its address, even without an explicit &. Similarly, you can call a pointer to a function without dereferencing the pointer explicitly. 
So for example if we have a function whose type matches "fp" (nel senso che prende per input un intero e dona in output un intero) as 
	int next(int n)	
	{
		return n+1;
	}
then we can make fp point to "next" by writing either of the following two statements:
	// these two statements are equivalent
	fp = &next;
	fp = next;
Similarly if we have an int variable named i, we can use fp to call "next", and thereby increment i, by writing either:
	// these two statements are equivalent
	i = (*fp)(i);
	i = fp(i);
Finally, if we write a function that looks like it takes another function as a parameter, the compiler quietly translates the parameter to be a pointer to a function instead. So for example, in the write_analysis pag 113 moo book the paraemeter that we wrote as 
	double analysis(const vector<Student_info>&)
could be equivalently have been written as 
	double (*analysis)(const vector<Student_info>&) 
-----------------------------------------------------------------------------------------------------
>> ARRAYS [pag174 moo book]
An array is a kind of container that is part of the core language rather than part of the standard library. Every array contains a sequence of one or more objects of the same type. The number of elements in the array MUST BE KNOWN at compile time, which requirement implies that arrays cannot grow or shrink dynamically the way library containers do. 
Osservazioni: 
- al posto di "size_type" si usa "size_t" to deal with the size of an array. ["size_type" e' una member functions che non e' disponibile per gli arrays, i quali non essendo class types, have no members, fanno parte del core language, non della standard library]
- se dovessi definire un punto usando i container della library potresti convenientemente scrivere:
	double coords[3];
oppure in maniera piu' hard core language potresti scrivere
	const size_t NDim = 3;
	double coords[NDim];
Using NDim instead of 3 distinguishes the 3 that represents the number of dimensions from a 3 that represents, say, the number of sides of a triangle.
No matter ow we define an array, there is always a fundamental relationship between arrays and pointers: whenever we use the name of an array as a value, that name represents a pointer to the initial element of the array. 
[detto in altre parole : >> POINTER TO THE INITIAL ELEMENT OF AN ARRAY = name of the array]
We have defined coords as an array, so using coords as a value gives us the address of the array's initial element. As with any other pointer, we can dereference it with the * operator to get the object to which it points, so that executing
	*coords = 1.5;
sets the initial element of coords to 1.5
------------------------------------------------------------------------------------------------------
>> POINTER ARITHMETIC [pag175 moo book]
Riprendiamo l'esempio sopra:
	const size_t NDim = 3;
	double coords[NDim];
coords ha quindi 3 elementi. The initial element of coords has number 0, we see that coords + 1 is the address of element number 1 of the coords array (i.e. the element after the initial one), and coords + 2 is the address of the element number 2, which is also the last one because we defined coords to have three elements. 
Del resto a pointer is a kind of iterator, more specifically a random access iterator. If p points to the mth element of an array, then p + n points to the (m + n)th element of the array and (p - n) points to the (m-n)th element assuming of course these elements exist.
E anche qualora l'element non esistesse il pointer resta valido anche se non si sa bene a cosa punti. 
Riprendendo l'esempio coords con i sui tre elementi, coords+3 represents the address of where element number 3 would be in the coords array if the element existed, but the element doesn't exist. Nevertheless coords+3 is a valid pointer, even though it doesn't point to an element. 
[pag175moo book]
If p and q are pointers to elements of the same array, then p-q is an integer that represents the distance in elements between p and q. More precisely, p-q is defined so that (p-q)+q is equal to p. Because p-q might be negative, it has a signed integer type. Whether that type is int or long depends of the implementation, so the library provides a synonym, named ptrdiff_t, to represent the appropriate type. Like size_t, the ptrdiff_t type is defined in the <cdtddef> header
-----------------------------------------------------------------------------------------------------
>> INDEXING [pag175 moo book]
Pointers are random-access iterators for arrays. Therefore, like all random-access iterators, they support indexing. Specifically, if p points to the mth element of an array, p[n] is the m+n th element of the array, not the address of the element, but the ELEMENT ITSELF.
Remember that the name of array is the address of the initial element of the array. This fact, together with the definition of p[n], implies that if a is an array, a[n] is the nth element of an array. More formally, if p is a pointer and n is an integer, then p[n] is equivalent to *(p+n).
-----------------------------------------------------------------------------------------------------
>> ARRAY INITIALIZATION [pag176 moo book]
There is a convenient syntax for giving an initial value to each element of an array. 
Moreover, using this syntax often lets us avoid having to state the size of the array explicitly.
For example, if we were writing a program that deals with deals with dates, we might like to know how many days are in each month. One way to do so would be the following:
	const int month_lengths[] = {
		31, 28, 31, 30, 31, 30,
		31, 31, 30, 31, 30, 31
	};
Here, we have given an initial value to each element that corresponds to the length of a month, with January being month 0 and December being month 11. Now, we can use month_length[i] to refer to the length of month i. 
Note that we did not say explicitly how many elements the month_lengths array has. Because we initialized it explicitly, the compiler will count elements for us, a task to which it is much better suited than we.
>> STRING LITERAL REVISITED [pag176 moo book]
We have finally learned enough to understand the true meaning of string literals. A string literal is really an array of const char with one more element than the number of characters in the literal. The extra character is a null character (i.e.,  '\0') that the compiler automatically appends to the rest of the characters. In other workds if we define 
	const char hello[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
then the variable "hello" has exactly the same meaning as the string liberal "Hello", except, of course, that the variable and the literal are two distinct objectds and therefore, have different addresses. 
The reason that the compiler inserts the null character is to allow the programmer to locate the end of the literal given only the address of its initial character. The null character acts as an end marker, so that the programmer can know where the string ends.
There is a library function in <cstring> called strlen, which tells us how many characters are in a string literal or the other null-terminated array of characters, not counting the null at the end. 
IN CONCLUSION : a string literal is just a conveninent way of writing the address of the initial character of a null-terminated sequence of characters. 
>> INITIALIZING ARRAYS OF CHARACTERS POINTERS [pag177 moo book]
As we have seen in the example 
	const int month_lengths[] = {
		31, 28, 31, 30, 31, 30,
		31, 31, 30, 31, 30, 31
	};
we can initialize the elements of an array by giving a seqeunce of appropriate values, enclosed in curly braces, as an initializer. And we know that a string literal is just a conveninent way of writing the address of the initial character of a null-terminated sequence of characters. 
By combining these two facts, we can initialize an array of characters pointers by giving a sequence of string literals. 
>> NUMERIC LETTER CONVERSION / >> LETTER NUMERIC CONVERSION /  NUMBER LETTER / >> NUMBER LETTER CONVERSION [pag177 moo]
Supponi di voler effettuare una conversione del tipo:
If the grade is at least 97  94  90  ect ... 70 60 0 
then the letter grade is A+  A   A-  ect ... C- D  F
Here is a program that does the conversion:
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/letter_grade.cc]
	#include <cstddef>
	#include <string>
	
	using std::string;
	
	string letter_grade(double grade)
	{
		// range posts for numeric grades
		static const double numbers[] = {
			97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
		};
	
		// names for the letter grades
		static const char* const letters[] = {
			"A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
		};
	
		// compute the number of grades given the size of the array
		// and the size of a single element
		static const size_t ngrades = sizeof(numbers)/sizeof(*numbers);
	
		// given a numeric grade, find and return the associated letter grade
		for (size_t i = 0; i < ngrades; ++i) {
			if (grade >= numbers[i])
				return letters[i];
		}
	
		return \?\?";
	}
-----------------------------------------------------------------------------------------------------
>> ARGUMENTS to "main" / >> pass argument to main / >> main arguments pass [pag179 moo book]
example /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/write_args.cc
----------------------------------------------------------------
#include <iostream>

using std::cout;
using std::endl;

int main(int argc, char** argv)
{
	// if there are command-line arguments, write them
	if (argc > 1) {
		cout << argv[1];               // write the first argument

		// write each remaining argument with a space before it
		for (int i = 2; i != argc; ++i)
			cout << " " << argv[i];    // `argv[i]' is a `char*'
	}
	cout << endl;
	return 0;
}
------------------------------------------------------------------
If we compile this program and put the resulting executable in a file called "say", then by asking the system to execute
	say Hello, world
we will cause our program to write
	Hello, world
In this case argc will be 3, and the three elements of argv will be pointers to the initial characters of arrays initialized with "say", "Hello," and "world" respectively. We can visualize the value of argv this way


       argv      
         ------>|______|--> s | a | y | \0  
                |______|--> H | e | l | l | o | , | \0
                |______|--> w | o | r | l | d | \0
 
vedi figura completa pag 180 non ho tempo di farti tutto l'art ascii
///////////////////////////////////////////////////////////////////////////////////////////////////// 


>> return 0 meaning [pag3 moo book]
example 
	// a small C++ program
	#include <iostream>
	
	int main()
	{
		std::cout << "Hello, world!" << std::endl;
		return 0;   // lo zero viene assegnato all' "int" di main a segno che il programma e' stato eseguito con successo.
	}
NOTE: a program may have more than one return statement. If the definition of a function promises that the function returns a value of a particular type, then every return statement in the function must return a value of an appropriate type.
------------------------------------------------------------------------------------
>> FILE READ / >> FILE WRITE [pag180 moo book]
>> ERROR STREAM / >> STANDARD ERROR STREAM [pag180 moo book]
To notify the user abbout error conditions and to make such comments easy to distinguish from ordinary output, the C++ library defines a standard error stream, in addition to the standard input and output streams. This stream is often merged with the standard output, but most systems provide a way to separate them.
A pag180 trovi spiegazione di parole chiave tipo 
	->> clog	[pag180 moo book]: is intended for logging purposes. It has the same buffering properties as "cout". It saves characters and writes them when the system decides that it is appropriate to do so
	->> cerr	[pag180 moo book]: cerr stream, on the other hand always writes its output immediately.
This strategy guarantees that the output will become visible as sson as possible, but it imposes what might be a substantial overhead. Therefore, to write an urgent complaint, you should use cerr; to produce a running commentary about what the program is doing, you should use clog.
Altre parole chiave descritte
	->> ifstream vs >> istream [pag181 moo book]
	->> ofstream vs >> otream [pag181 moo book]
>> input files and >> output files / >> read file / >> write file [pag181 moo book]
Example of program that copies a file named "in" into a file named "out" :
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/copyfile.cc]
	#include <fstream>
	#include <string>
	
	using std::endl;
	using std::getline;
	using std::ifstream;
	using std::ofstream;
	using std::string;
	
	int main()
	{
		ifstream infile("in");
		ofstream outfile("out");
	
		string s;
	
		while (getline(infile, s))
			outfile << s << endl;
		return 0;
	}
-------------------------------------------------------------------------------------
Example 2 pag182 moo book (>> concatenate files): program that produces, on its standard output, a copy of the contents of all the files whose names are given as arguments to main
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/concat_files.cc]
-------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>

using std::cerr;
using std::cout;
using std::endl;
using std::getline;
using std::ifstream;
using std::string;

int main(int argc, char **argv)
{
	int fail_count = 0;
	// for each file in the input list
	for (int i = 1; i < argc; ++i) {
		ifstream in(argv[i]);

		// if it exists, write its contents, otherwise generate an error message
		if (in) {
			string s;
			while (getline(in, s))
				cout << s << endl;
		} else {
			cerr << "cannot open file " << argv[i] << endl;
			++fail_count;
		}
	}
	return fail_count;
}
-------------------------------------------------------------------------------------
For each arugment given to main, the program creates an ifstream object to read the file by that name. If the object appears false when used as a condition, that means that the file does not exist, or that it cannot be read for some reason. Accordingly, the program complains on cerr, and keeps a count of how many failures it had. If the program created the ifstream object successfully, it reads the file, one line at a time, into "s", and writes the contents of each line on the standard output. 
When the program returns control to the system, it passes back the number of files that it was able unable to read. As usual, a return value of zero indicates success, which in this case will indicate that we were able to read all the files.
-------------------------------------------------------------------------------------
>> MEMORY MANAGEMENT [pag182 moo book] / >> MEMORY MANAGEMENT TYPES / >> ALLOCATION / >> DEALLOCATION of an Object
There are two distinct kinds of memory management
The first kind is called >> automatic memory management and is associated with local variables. A local variable occupies memory that the system allocates when it encounters the variable's definition during execution. [ecco perche' non dichiarare una variabile preliminarmente crea errore. bisogna fare bene i preparativi, mettere in posizione le pentole prima di metterci dentro gli ingredienti, se no finisci con un immangiabile frittomisto. Matlab probabilmente riesce ad effettuare operazione senza inizializzazione di variabili, perche' ha un controllo if interno: se l'utente ordina di versare farina e sotto non c'e' ancora una pentola, metti la pentola automaticamente] The system automatically deallocates that memory at the end of the block that contains the definition. 
Once a variable has been deallocated, any pointers to it becomes invalid. It is the programmer's reponsability to avoid using such invalid pointers. For example:

	// this function deliberately yields an invalid pointer
	// it is intended as a negative example don't do this
	int* invalid_pointer()
	{
		int x;
		return &x;   // instant disaaaaaster!!! sad!  MakeAmGreAg!!!
	} 
This program returns the address of the local variable x. Unfortunately, when the function returns, doing so ends execution of the block that contains the definition of x, which deallocates x. The pointer that &x created is now invalid, but the function tries to return it anyway. What happens at this point is anybody's guess. 
If we want to return the address of a variable such as x, one way to do so is to use the other kind of memory management, by asking for x to be statically allocated. [>> static allocation example pag183 moo book]
	// this function is completely legitimate
	int* pointer_to_static()
	{
		static int x;
		return &x;   
	}  
By saying that x is static, we are saying that we want to allocate it once, and only once, at some point before the first time that pointer_to_static is ever called, and that we do not want to deallocate it as long as our program runs. 
However, static allocation has the potential disadvantage that every call to pointer_to_static will return a pointer to the same object! Suppose we want to define a fucntion such that each time we call it, we get a pointer to a brand new object, which stays around until we decide that we no longer want it. To do so, we use >> dynamic allocation [pag183 moo book], which we request by using the new and delete keywords. 
>> ALLOCATE OBJECT If T is a type of an object, "new T" is an expression that allocates an object of type T, which is default initialized, and yields a pointer to this (unnamed) newly allocated object. It is possible to give a specific value to use when initializing the object by executing new T(args)  [cioe' new T(parametroDiInput1, parametroDiInput2, ...parametroDiInputN)]. The object stays around until the program either ends or executes "delete p" (whichever happens first), where "p" is (a copy of) the pointer returned by "new". In order to delete a pointer, the pointer must poin to an object that was allocated by "new", or be equal to zero. Deleting a zero pointer has no effect. 
As an example 
[>> pointer spiegato da dio! conciso e chiaro leggi linee seguenti (from pag183 moo book)]
	int* p = new int(42);
will 
	1) allocate an unnamed new object of type "int", 
	2) initialize the object to 42,  
	3) and cause  "p" to point to that object
We can affect the value of the object by executing statements such as 
	++*p;   // *p is now 43
after which the object has the value 43. When we're done with the object, we can execute 
	delete p;
after which the space occupied by *p is freed and p becomes an invalid pointer, with a value that we can no longer use until we have assigned a new value to it.
As another example, we might write a function that allocates an int object, initializes it, and returns a pointer to it:
[pag184 moo book]
	int* pointer_to_dynamic()
	{
		return new int(0);
	}
which imposes on its caller the responsibility of freeing the object at an appropriate time. [ah ecco perche' in OF abbiamo bisogno di deallocare la memoria, se non si fa nulla, l'oggetto resta li' fino alla fine del programma, occupando inutilmente memoria anche quando non se ne ha piu' bisogno.] 
-------------------------------
>> deallocate entire array / >> deallocate array [pag184 moo book]
	delete[] p;
the [] are necessary to tell the system to deallocate an entire array , rather than a single element.
/////////////////////////////////////////////////////////////////////////////////////


>> RETURN [pag114 jesse]
When inside a function the "return" keyword is encountered, the expression folowing return is returned as the value of the function. Program execution returns immediately to the calling function, and any statements following the return are not executed. 
To return a value from a function write the keyword "return" followed by the value you want to return 
example 
	return 5; // returns 5
	return (x > 5); // returns "true" if x > 5 e "false" is x < 5 (does not return the value of x itself)
	return (MyFunction()); // qui farai ritornare al programma chiamante il valore donato da MyFunction()
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> int main() vs >> void main()  [pag116 jesse]
Both works, but it is adviced to use
	int main()
because 
1) only int main() is ANSI compliant, so only int main() is guaranteed to continue working in future
2) int main() returns a value to the operating system. When your program completes, that value can be captures by, for example, batch programs.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTER RETURN / >> RETURN POINTERS [pag226 mike game programming]
Prima dell'arrivo delle references, l'unica maniera che i programmatori avevano per returning objects efficiently from functions era di utilizzare dei puntatori. E sebbene usare references provides a cleaner syntax than using pointers, you might still need to return objects through pointers.
The following program demonstrates returning pointers. Through returned pointers, the program displays and even alters the values of a vector that holds a here's inventory.
COMMENTI SUI PASSI SALIENTI DEL PROGRAMMA SOTTOSTANTE
	- NOTE: 	string* ptrToElement(vector<string>* const pVec, int i)  // about the header of the function ptrToElement. 
	This function will return a pointer to a string object (and not a string object itself). To specify that a function returns a pointer to an object of a particular type, put an asterisk after the type name of the return type. 
	- NOTE: 
FULL EXAMPLE from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/inventory_pointer.cpp
--------------------------------------------------------------------- FULL EXAMPLE 
	// Inventory Pointer
	// Demonstrates returning a pointer
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	//returns a pointer to a string element
	string* ptrToElement(vector<string>* const pVec, int i);
	
	int main()
	{
	    vector<string> inventory;
	    inventory.push_back("sword");  // sword's position is 0
	    inventory.push_back("armor");
	    inventory.push_back("shield");
	    //displays string object that the returned pointer points to
	    cout << "Sending the object pointed to by returned pointer to cout:\n";       
	    cout << *(ptrToElement(&inventory, 0)) << "\n\n";  // >> RETURNED POINTER TO DISPLAY A VALUE / >> POINTER RETURN EXAMPLE
        	// NOTE: the preceding line calls prtToElement(), which returns a pointer to inventory[0]. 
			// ptrToElement() doesn't return a copy of one of the elements of inventory; it returns a pointer to one of them. 
			// the line then sends the string object pointed to by the pointer to cout. 

	    //assigns one pointer to another -- inexpensive assignment
	    cout << "Assigning the returned pointer to another pointer.\n";  // >> POINTER ASSIGN / >> assigning returned pointer to pointer 
	    string* pStr = ptrToElement(&inventory, 1);
			// the call to prtToElement() returns a pointer to inventory[1]. The statements assigns that pointer to pStr. 
            // quindi il puntatore pStr punta all'object 1 ("armor")
                  
                   inventory
                   ------------------------------------------------
                   |    "sword"   |   "armor"    |    "shield"    | 
                   ----------------------^-------------------------
                                         |
                                         |
                                 pStr    |
                                --------------------
                                |                  |
                                --------------------

			// This is an efficient assignment because assigning a pointer to a pointer does not involve copying the string object. 

	    cout << "Sending the object pointed to by new pointer to cout:\n";
	    cout << *pStr << "\n\n";
	    
	    //copies a string object -- expensive assignment
	    cout << "Assigning object pointed to by pointer to a string object.\n";   // >> ASSIGNING TO A VARIABLE THE VALUE POINTED TO BY A RETURNED POINTER
	    string str = *(ptrToElement(&inventory, 2));
			// the call to ptrToElement() returns a pointer to inventory[2]. 
			// However, the preceding statement doesn't assign this pointer to str (it can't because str is a string object).
			// Instead the computer quietly makes a copy of the string object to which the pointer points and assigns that object to str.
            // quindi str is a new string object, totally independent from inventory.  
	    
        cout << "Sending the new string object to cout:\n";
	    cout << str << "\n\n";
	    
	    //altering the string object through a returned pointer
	    cout << "Altering an object through a returned pointer.\n"; // >> POINTER ALTERS OBJECT
	    *pStr = "Healing Potion";
  			// >> spiegazione linea precedente: because pStr points to the element in position 1 of "inventory", 
			// this code changes inventory[1] so that it's "Healing Potion"
 			// NOTE: if you want to protect an object pointed to by a returned pointer,
			// make sure to restrict the pointer. Return either a pointer to a constant or a constant pointer to a constant.

	    cout << "Sending the altered object to cout:\n";
	    cout << inventory[1] << endl;
	
		int x; cin >> x;
	    
	    return 0;
	}
	
	string* ptrToElement(vector<string>* const pVec, int i) // we specify in the function header that we are returning a pointer.
	{
	    //returns address of the string in position i of vector that pVec points to
	    return &((*pVec)[i]);  >> ESEGESI POINTERS: quando ti trovi davanti a una complex expression a little cryptic, EVALUATE IT LIKE THE COMPUTER DOES, that is BY STARTING WITH THE INNERMOST PART
	// nella parte piu' interna trovi scritto *pVec : questo come spiegato a pagina 216 mike programming significa deferenziare un puntatore. *nomePuntatore = the object to which the object points 
	// [ apro parentesi: da non confondersi con il type* nomePuntatore che trovi tra i parametri di input della funzione. Li si tratta di dichiarare il puntatore e si segue la struttura spiegata a pag 214 mike game programming: vector<string>* == puntatore che punta a dei vettori stringa, quindi segui il nome
	// chiudo parentesi]
	// (*pVec)[i] in questo caso il puntatore punta all'elemento di un vettore, ecco perche' rispetto a pag.216 si aggiunge la complicazione dell'[i], ma alla fine della storia si comprende che (*pVec)[i] significa elemento in position i del vettore a cui il puntatore sta puntanto. E' UN ELEMENTO, non l'indirizzo.
	// aggiungi il guscio intorno &((*pVec)[i]) applicando the address of operator (&) ot the (*pVec)[i] it becomes the address of the element in position i of the vector pointed to by pVec. OK compreso!!!!
	// NOTE perche' *pVec sia circondato dalle parentesi () mi sembra sia legato al motivo spiegato a pag218 mike programming 
	// >> (*nomePuntatore).memberFunction : whenever you dereference a pointer to access a data member function, surround the dereferenced pointer with a pair of parentheses. This ensures that the dot operator will be applied to the object to which the pointer points. 
	} 
--------------------------------------------------------------------- END FULL EXAMPLE 
OUTPUT PROGRAM
	Sending the object pointed to by returned pointer to cout:
	sword
	
	Assigning the returned pointer to another pointer.
	Sending the object pointed to by new pointer to cout:
	armor
	
	Assigning object pointed to by pointer to a string object.
	Sending the new string object to cout:
	shield
	
	Altering an object through a returned pointer.
	Sending the altered object to cout:
	Healing Potion
FINE OUTPUT PROGRAM
-------------------------------------------------
NOTE :TRAP [from pag228 mike programming game] Although returning a pointer can be an efficient way to send information back to a calling function, you have to be careful not to return a pointer that points to an out-of-scope object [>> out of scope object example error]. For example the following function returns a pointer that, if used, could crash the program
	string* badPointer()
	{
		string local = "This string will cease to exist once the function ends.";
		string* pLocal = &local; // assegni al puntatore pLocal l'address della string local, la quale sparira' una volta che funzione ripassa il controllo a main(), quindi la variabile a cui il puntatore pLocal resta indefinita, visto che local non esiste piu', potrebbe esserci dentro di tutto, possibili risultati catastrofici!
		return pLocal;
	} 
NOTE: >> POINTERS vs >> ARRAYS relationship [pag231 mike programming game]
Pointers have an intimate relationship with arrays. In fact, an array name is really a constant pointer to the first element of the array. Because the elements of an array are stored in a contiguous block of memory, you can use the array name as a pointer for random access to elements. Cioe' :
	arrayName[i] e' del tutto equivalente a *(arrayName + 1)
Here's follow a practical example of the concept: [search >> UBIK per saltare al cuore dell'esemplificazione]
>> ARRAY NAME used as a CONSTANT POINTER [pag233 mike game programming]
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/array_passer.cpp]
---------------------------------------------------
	//Array Passer
	//Demonstrates relationship between pointers and arrays
	
	#include <iostream>
	
	using namespace std;
	
	void increase(int* const array, const int NUM_ELEMENTS);
	void display(const int* const array, const int NUM_ELEMENTS);
	
	int main()
	{
	    cout << "Creating an array of high scores.\n\n";
	    const int NUM_SCORES = 3;
	    int highScores[NUM_SCORES] = {5000, 3500, 2700};
	    
	    cout << "Displaying scores using array name as a constant pointer.\n";
	    cout << *highScores << endl; // >> UBIK because an array name is a costant pointer to the first element of the array, you can deference the name to get at the first element.
		// >> RANDOM ACCESS ARRAY ELEMENTS [pag233 mike programming]. Come illustrato nel comando seguente
		// You can randomly access array elements using an array name as a pointer through simple addition. All you have to do is add the position number of the element you want to access to the pointer before you deference it. 
	    cout << *(highScores + 1) << endl;  // this line allows to access the score at position 1
		// NOTE: *(highScores + 1) e' del tutto equivalente a highScore[1]. Both return the element in position 1 of highScores (cioe' 3500).
	    cout << *(highScores + 2) << "\n\n"; // in this line we access the score at position 2 in highScores with the following line, which displays 2700. In general you can write arrayName[i] as *(arrayName + 1) where arrayName is the name of an array.
	    
		// >> ARRAY PASS / >> ARRAY RETURN [pag234 mike game programming]
		// Because an array name is a constant pointer, you can use it to efficiently pass an array to a function.  
	    cout << "Increasing scores by passing array as a constant pointer.\n\n";
	    increase(highScores, NUM_SCORES); // this line passes to increase() a constant pointer to the first element of the array and the number of elements in the array [NOTE: when you pass an array to a function, it's usually a good idea to pass also the number of elements in the array so the function can use this to avoid attempting to access an element that doesn't exist.]. As you can see below from the function header of increase(), the array name is accepted as a constant pointer.
	    
	    cout << "Displaying scores by passing array as a constant pointer to a constant.\n";
	    display(highScores, NUM_SCORES);
	   
	    return 0;
	}
	
	void increase(int* const array, const int NUM_ELEMENTS) // the array name is accepted as a constant pointer.
	{
	    for (int i = 0; i < NUM_ELEMENTS; ++i)
		{
	        array[i] += 500; // the function body adds 500 to each score.
		}
	}
	
	void display(const int* const array, const int NUM_ELEMENTS) // also the function display() accepts highScore as a pointer.
	// note that this function accepts the array as a constant pointer to a constant, in this way, we keep it safe from changes. Since all we want to do is to display each element, it's the perfect way to go.
	{
	    for (int i = 0; i < NUM_ELEMENTS; ++i)
		{
	        cout << array[i] << endl;
		}
	}
	

---------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////


>> PREPROCESSOR / >> PREPROCESSING pag986 deitel
Preprocessing occurs before a program is compiled. Some possible actions are inclusion of other files in the file begin compiled, definition of symbolic constants and macros, conditional compilation of program code and conditional execution of preprocessing directives. All prprocessing directives begin with #, and only whitespace characters may appear before a preprocessing directive on a line. Proprocessing directives are not C++ statements, so they do not end in a semicolon (;). Preprocessin directives are processed fully before compilation begins. 
The two forms of the #include directive are 
	#include <filename>  // used for standard library header files 
	#include "filename"  // used to include programmer defined header files 
The difference between these is the location the proprocessor searches for the file to be included. If the filename is enclosed in angle brackets (< >) - used for standard library header files - the preprocessor searches for the specified file in an implementation dependent manner,normally thorugh predesignated directories. If the file name is enclosed in quotes, the preprocessor searches first in the same directory as the file being compiled, then in the same implementation dependent manner as for a file name encolsed in angle brackets. This method is normally used to include programmer defined header files. 
The #include directive is used to include standard header files such as <iostream> and <iomanip>. The #include directive is also used with programs consisting of several source files that are to be compiled together. A header file containing declarations and definitions common to the separate program files is often created and included in the file. Example of such declarations and definitions are classes, structures, unions, enumerations, function prototypes, constants and stream objects.  
------------------------------------------------------------------------
>> # define Preprocessing directive / >> symbolic constants [pag987 deitel]
The #define preprocessing directive creates symbolic constants -constants represented as symbols -and macros- operations defined as symbols. The #define  preprocessing directive format is 
	#define identifier replacement-text
When this line appears in a file, all subsequent occurrences (except those inside a string) or identifier in that file will be replaced by replacement text before the program is compiled. For example :
	#define PI 3.14
replaces all sbusequent occurrences of the symbolic constant PI with the numeric constant 3.14159. Symbolic constant enable you to create a name for a constant and use the name throughout the program. Later, if the constant needs to be modified throughout the program, it can be modified once in the #define  proprocessing directive and when the program is recompiled, all cocurrences of the constant in the program will be modified. 
NOTE1, IMPORTANT!: non mettere l'uguale tra il nome della symbolic constant e il valore numerico.
	#define PI 3.14     OK
	#define PI = 3.14   DAME   <= questo introdurrebbe many subtle logic and syntax errors
in effetti everything to the right of the symbolic constant name replaces the symbolic constant. For example #define PI = 3.14159 cuases the preprocessor to replace every occurrence of PI with = 3.14159 (come vedi anche l'uguale viene incluso).
NOTE2: note that const variables in C++ are preferred over symbolic constants. Constant  variables have a specific data type and are visible by name to a debugger. Once a symbolic constant is replaced with its replacement text, only the replacement text is visible to a debugger. A disadvantage of const variables is that they might require a memory location of their data type size (symbolic constant do not require any additional memory)
-------------------------------------------------------------------------------
#define Preprocessing Directive : Macros [pag987 deitel] / >> macro
This section is included for the benefit of C++ programmers who will need to work with C legacy code. In C++ macros can often be replaced by templates and inline functions. A macro is an operation defined in a #define prprocessing directive. As with symbolic constants the macro identifier is replaced with the replacement text before the program is compiled. Macros may be defined with or withour arguments. A macro without arguments is processed like a symbolic constant. In a macro with arguments the arguments are substituted in the replacement text, then the macro is expanded.
Example 
Consider the following macro definition with one argument for the area of a circle :
	#define CIRCLE_AREA ( x ) ( PI * ( x ) * ( x ) )
(nel discorso che segue si suppone inoltre che si sia precedentemente gia' definito #define PI 3.14 ) Wherever CIRCLE_AREA ( y ) appears in the file, the value of y is substituted for x in the replacement text, the symbolic constant PI is replaced by its value (defined previously) and the macro is expanded in the program. For example the statement:
	area = CIRCLE_AREA ( 4 );
is expanded to 
	area = ( 3.14 * ( 4 ) * ( 4 ) );
because the expression consists only of constants, at compile time the value of the expression can be evaluated, and the result is assigned to area at runtime. The parentheses around each x in te replacement text and around the entire expression force the proper order of evaluation when the macro argument is an expression. For example, the statement 
	area = CIRCLE_AREA ( c + 2 );
is expanded to
	area = ( 3.14 * ( c + 2 ) ( c + 2 ) );
which evaluates correctly, because the parentheses force the proper order of evaluation. 
NOTE1: forgetting to enclose macro arguments in parenthesis in the replacement text is an error
NOTE2: If the replacement text for a macro or symbolic constant is longer than the remainder of the line, a backslash (\) must be placed at the end of each line of the macro (except the last line), indicating that the replacement text continues on the next line.
NOTE3: (>> discard symbolic constant and macro) Symbolic constants and macros can be discarded using the #undef preprocessing directive. Directive #undef "undefines" a symbolic constant or macro name. The scope of a symbolic constant or macro is from its definition until it is either undefined with #undef or the end of the file is reached. Once undefined, a name can be redefined with #define. 
----------------------------------------------------------------------------------------------------------------------
>> CONDITIONAL COMPILATION / >> COMPILE CONDITIONALLY [pag989 deitel]
Conditional compilation enables you to control the execution of preprocessing directives and the compilation of program code. Each of the conditional proprocessing directives evaluates a constant integer expression that will determine whether the code will be compiled.
The conditional prprocessor construct is much like the if selection structure. Consdier the following proprocessor code:
	#ifndef NULL
		#define NULL 0
	#endif
which determines whether the symbolic constant NULL is already defined. The expression #ifndef NULL includes the code up to #endif if NULL is not defined, and skips the code if NULL is defined. Every #if construct ends with #endif.  Directives #ifdef and #ifndef are shorthand for #if  define(name) and #if !defined(name). 
>> Directive definition Ciccio spiega:
nota come la parola ">> directive" indicante il # seguito da una parola chiave in italiano lo possiamo tradurre con diretiva, istruzione, in effetti con # si da una direttiva, tipo quando si scrive #include si dona la direttiva di includere per esempio una library (ex #include <iostream>  = direttiva di includere la standard library iostream), cosi' come #ifnodef NULL dona la direttiva di includere il codice qualora NULL non sia definito.
A multiple part conditional preprocessor construct may be tested using the #elif (the equivalent of else if in an if structure) and the #else (the equivalent of else in an if structure) directives
>> DIRECTIVE ulteriori spiegazioni in Mike pag 7 : For example the line 
	#include <iostream>
is a preprocessor directive visto che comincia con una #. The preprocessor runs before the compiler does its thing and substitutes text based on various directives. In this case, the line involves the #include directive, which tells the proprocessor to include the contents of another file. Weinclude the file iostream which is part of the standard library because it contains code to help us display output. We surround the filename with <> to tell the compiler to find the file where it keeps all the files that came with the compiler. A file that you include in your programs like this is called a header file. 
>> DEBUG TIPS 
>> TIP USEFUL TIP during program development. / >> COMMENT OUT LARGE PORTION OF CODE [pag990deitel]
During program development, programmers often find it helpful to "comment out" large portions of code to prevent it from being compiled. If the code contains C style comments, /* and */ cannot be used to accomplish this task, because the first */ encountered would terminate the comment. Instead, you can use the following preprocessor construct: 
	#if 0
		code prevented from compiling
	#endif
To enable the code to be compiled, simply replace the value 0 in the preceding construct with the value 1.
>> DEBUG TIP 2 / >> show variable value
Conditional compilation is commonly used as a debugging aid. Output statements are often used to print variable values and to confirm the flow control. These output statements can be enclosed in conditional preprocessing directives so that the statements are compiled only until the debugging process is completed. For example:
	#ifdef DEBUG
		cerr << "Variable x = " << x << endl;
	#endif
causes the cerr statement to be compiled in the program if the symbolic constant DEBUG has been defined before directive #ifdef DEBUG. This symbolic constant is normally set by a command line compiler or by settings in the IDE (e.g. visual studio) and not by an explit #define definition. When debugging is completed, the #define directive is removed from the source file, and the output statements inserted for debugging purposes are ignored from compilation. In larger programs, it might be desirable to define several different symbolic constants that control the conditional compilation in separate sections of the source file. 
--------------------------------------------------------------------------------------------------------------------------------------
>> #error and #pragma preprocessing directives [pag990 deitel]
The #error directive 
	#error tokens
prints an implementation dependent message including the tokens specified in the directive. The tokens are sequences of characters separated by spaces. For example
	#error 1 - Out of range error
contains 6 tokens. In one popular C++ compiler, for example, when a #error directive is processed, the tokens in the directive are displayed as an error message, preprocessing stops and the program does not compile. 
The #pragma directive
	#pragma tokens 
causes an implementation defined action. A pragma not recognized by the implementation is ignored. A particular C++ compiler, for example, might recognize pragmas that enable you to take advantage of that compiler's specific capabilities. 
----------------------------------------------------------------------------------------------
>> # and >> ## operators [pag991 deitel]
The # and ## preprocessor operators are avaiblable in C++ and ANSI/ISO C. The # operator causes a replacement text token to be converted to a string surrounded by quotes. Consider the following macro definition:
	#define HELLO( x ) cout << "Hello, " #x << endl;
When HELLO(John) appears in a program file, it is expanded to
	cout << "Hello, " "John" << endl;
The string "John" replaces #x in the replacement text. Strings separated by white space are concatenated during preprocessing, so the above statement is equivalent to
	cout << "Hello, John" << endl;
Note that the # operator must be used in a macro with arguments, because the operand of # refers to an argument of the macro.
The ## operator concatenates two tokens. Consider the following macro definition:
	cout << "Hello, John" << endl;
	#define TOKENCONCAT ( x, y ) x ## y
When TOKENCONCAT appears in the program, its arguments are concatenated and used to replace the macro. For example, TOKENCONCAT(O, K) is replaced by OK in the program. The ## operator must have two operands.
----------------------------------------------------------------------------------------------
>> PREDEFINED SYMBOLIC CONSTANTS [pag991]
There are six predefined symbolic constants. The identifiers for each of these begin and (except for __cpluscplus) end with two underscores. These identifiers and preprocessor operator defined cannot be used in #define or #undef directives. 
	__LINE__      the line number of the current source code line (an integer constant)
	__FILE__      the presumed name of the source file (a string)
	__DATE__      the date the source file is compiled (a strong of the form "Mmm dd yyyy" such as "Aug 19 2120")
	__STDC__      indicates whether the program conforms to the ANSI/ISO C standard. (If not it put it into JAIL). Scherzi a parte: contains value 1 if there is full conformance and is undefined otherwise.
	__TIME__      the time the source file is compiled (a string literal of teh form "hh:mm:ss").
	__cplusplus   contains the value 199711L (the date the ISO C++ standard was approved) if the file is being compiled by a C++ compiler, undefined otherwise. Allows a file to be set up to be compiled as either C or C++
------------------------------------------------------------------------------------------------
>> ASSERTIONS [pag992 deitel] / >> DEGUB TOOLS (iteresting !! )The assert macro (defined in the <cassert> header file) tests the value of an expression. If the value of the expression is 0 (false) then assert prints an error message and calls function abort (of the general utility library <cstdlib>) to terminate program execution. This is a useful debugging tool for testing whether a variable has a correct value. For example suppose variable x should never be larger than 10 in a program. An assertion may be used to test the value of x and print an error message if the value of x is incorrect. The statement would be;	
	assert (x <= 10); 
If x is greater than 10 when the preceding statement is encountered in a program, an error message containing the line number and file name is printed, an the program terminates. You may then concentrate on this area of the code to find the error. If the symbolic contanst NDEBUG is defined, subseqeunt assertions will be ignored. Thus when assertions are no longer needed (i.e. when debugging is complete) we insert the line 
	#define NDEBUG
in the program file rathe rthan deleting each assertion manually. 
Most C++ compilers now include expetion handling. C++ programmers prefer using exceptions rather than assertions. But assertions are still valuable for C++ programmers who work with C legacy code.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTERS BUILT-IN ARRAYS relationship
[pag355deitel]
Built-in arrays and pointers are intimately related in C++ and may be used almost interchangeably. 
Example
	int b [ 5 ]; // create 5-element int array b; b is a const pointer
	int *bPtr;   // create int pointer bPtr, which isn't a const pointer
we can set bPtr to the address of the first element in the built-in array b with statement:
	bPtr = b; // assign address of built-in array b to bPtr
Nota come l'indirizzo b del built-in array coincide con quello del primo elemento dell'array.
Quindi la precedente istruzione is equivalent to assigning the address of the first element as follows:
	bPtr = &b[ 0 ]; // also assigns address of built-in array b to bPtr
Pointer/Offset notation >> OFFSET NOTATION 
[pag356deitel]
Built-in array element b[3] can be alternatively be referenced with the pointer expression
	*( bPtr + 3 )
The 3 in the preceding expression is the offset to the pointer.
When the pointer points to the beginning of a built-in array, the offsett indicates which built-in array element should be referenced, and the offset value is identical to the subscript. Parenthesis are necessary, because the precedence of * is higher than that of +
Just as the built-in array element can be referenced with a pointer expression, the address
	&b[ 3 ]
can be written with the pointer expression
	bPtr + 3 

>> POINTER/SUBSCRIPT NOTATION 
[pag356deitel] 
Pointers can be subscripted exactly as built-in arrays can. For example, the expression
	bPtr[ 1 ]
refers to b[1]; this expression uses pointer/subscript notation
GOOD PROGRAMMING PRACTICE: for clarity, use built-in array notation instead of pointer notation when manipulating built-in arrays.


>> POINTERS EXPRESSIONS and >> POINTERS ARITHMETIC
[pag352deitel]
Pointer arithmetic is appropriate only for pointers that point to built-in array elements.
Let's assume that int v[5] has been declared and that its first element is at memory location 3000
see fig8.15 deitel o lo schemi stilizzato qui sotto
3000  3004 3008 3012 3016
  |     |    |    |    |
  v[0]  v[1] v[2] v[3] v[4]
variable vPtr can be initialized to point to v with either of the following statements:
POINTER VARIABLE INITIALIZATION:
	int *vPtr = &v[ 0 ];
	int *vPtr = v; // istruzione equivalente alla precedente visto che a built-in array's name evaluates to the address of its zeroth element)
> ADDING INTEGERS TO POINTERS
supponiamo che il nostro vPtr punta all'address 3000, indirizzo dell'elemento v[0]. v nel nostro esempio e' un built-in array di 5 int elements, ciascuno dei quali con un size di 4bytes. Allora se
	vPtr += 2;
would produce 3000 + 2 * 4 = 3008 assuming that an int is stored in a four bytes of memory.	
3000  3004 3008 3012 3016
  |     |    |    |    |
  v[0]  v[1] v[2] v[3] v[4]
quindi ora il puntatore punta all'elemento v[2]
if an integer is stored in eight bytes of memory, then the preceding calculation would result in memory location 3016 (3000 + 2 *8)
> SUBSTRUCTING INTEGERS FROM POINTERS
supponi ora che vPtr punti a v[4] (address 3016), the statement:
	vPtr -= 4;
would set vPtr = 3016 - 4 * 4 = 3000 => il puntatore puntera' at the beginning of the built-in array. If a pointer is being incremented or decremented by one, the increment (++) or decrement (--) operators can be used. Each of the statements
	++vPtr;
	vPtr++;
increments the pointer to point to the built-in array's next element. Each of the statements:
	--vPtr;
	vPtr--;
decrements the pointer to point to the built-in array's previous element.
NOTE: there is no bounds checking on pointer arithmetic. You must ensure that every pointer arithmetic operation that adds an integer to or subtracts an integer from a pointer results in a pointer that references an element within the built-in array's bounds [quindi mi vien da pensare molto importante effettuare prima un sizeof per verificare il size degli elementi perche' a seconda che siano 4 o 8 byte un vPtr++ ti porta a puntare indirizzi diversi!!]
> SUBTRACTING POINTERS
[pag354deitel]
Se per esempio riprendiamo il built-in array v di sopra. If vPtr contains the address 3000 and v2Ptr contains the address 3008, the statement
	x = v2Ptr - vPtr;
would assing to x the number of built-in array elements from vPtr to v2Ptr. 
Lo puoi anche vedere cosi' (mio ragionamento): (3008 - 3000) / 4 = 2 
dove 4 sta per il numero di bytes per elemento.
Pointer variables pointing to the same built-in array may be subtracted from one another.
COMMON PROGRAMMING ERROR: subtracting or comparing two pointers that do not refer to elements of the same built-in array is a logic error.

>> POINTER ASSIGNMENT 
[pag355]
A pointer can be assigned to another pointer if both pointers are of the SAME type. Otherwise a cast operator (normally a reinterpret_cast) must be used to convert the value of the pointer on the right of the assignment to the pointer type on the left of the assignment.
The exception to this rule is the pointer to void (i.e. void *) , which is a generic pointer capable fo representing any pointer type. 
Any pointer to a fundamental type or class type can be assigned to a pointer of type void * without casting.
HOWEVER the pointer of type void * must first be cast to the proper pointer type [sembra un po' di essere come in fonderia, come in una pressa lo devi "castare" pressare con il proper pointer type]
CANNOT DEREFERENCE A VOID * 
A void * pointer cannot be dereferenced. For example the compiler knows that a pointer to int refers to four bytes of memory on a machine with four-byte integers, but a pointer to void simply contains a memory address for an unknown data type - the compiler does not know the precise number of bytes to which the pointer refers and the data type. The compiler must know the data type to determine the number of bytes to dereference for a particular pointer - for a pointer to void, this number of bytes cannot be determined.
COMMON PROGRAMMING ERROR: assigning a ointer of one type to a pointer of another (other than void *) without using a cast (normally a reinterpret_cast) is a compilation error.
ALLOWED OPERATION ON VOID * POINTERS ARE:
- comparing void * pointers with other pointers
- casting void * pointers to other pointer types 
- assigning addresses to void * pointers.
All other operations on void * pointers are compilations errors 
COMPARING POINTERS
Pointers can be compared using equality and relational operators.
Comparisons using relational operators are meaningless unless the pointers point to elements of the same built-in array. Pointer comparisons compare the addresses stored in the pointers. 
A common use of pointer comparison is determining whether a pointer has the value of nullptr, 0 or NULL (i.e. the pointer does not point to anything).

>> INDIRECTION = referencing a value through a point.
Extract from the 8.1 introduction
in chapter 6 we say that references can be used to perform pass-by-reference. Pointers also enable pass-by-reference and can be used to create and manipulate dynamic data structures that can grow and shrink, such as linked lists, queues, stacks and trees.
We also show the intimate relationship among built-in arrays and pointers. C++ inherited built-in arrays from the C programming language. Anyway in new software development projects, you should favor array and vector objects to built-in arrays. 
Similarly, C++ actually offers two types of strings :
- string class object (quella che si usa sin dal primo hello program)
- C-style, pointer-based strings
In new software developments projects, you should favor string class objects. 
NOTE: the so called "polymorphic processing" associated with object-oriented programming is performed with pointers and references. 
NOTE2: null pointers prior to C++11
In earlier versions of C++ the value specified for a null pointer was 0 or NULL. NULL is defined in several standard library headers to represent the value 0. Initializing a pointer to NULL is equivalent to inizializing a pointer to 0, but prior to C++11, 0 was used by convention. The value 0 is the only integer value that can be assigned directly to a pointer variable without first casting the integer to a pointer type.

>> POLYMORPHISM
[pag518deitel]
Suppose that we design a video game that manipulates objects of many different types, including objecdts of classes Martian, Venutian, Plutonian, Spaceship, and LaserBeam. Imagine that each f these classes inherits form the common base class SpaceObject [sembra essere un analogo del IOOjbect che incontriamo nel sorgente di OF] which contains the member function draw. Each derived class implments this function in a manner appropriate for this class. A screen-manager program maintains a container  (e.g. a vector) that holds "SpaceObject" pointers to objects of the various classes. To refresh the screen, the screen manager periodically sends each object the same message (in this case "draw"). Each type of object respond in a unique way. For example, a Martian object might draw ifself in red with the appropriate number of antennae, a SpaceShip obejct might draw itself as a silver flying saucer (disco volante), and a "LaserBeam" object might draw itself as a bright red beam across the screen.
The same message (in this case "draw")  sent to a variety of objects has many forms of results, hence the term polymorphism.
A polymorphic screen manager falicilitates adding new clases to a sysmtem with minimal modifications to its code. Suppose that we want to add objects of class Mercurian to our video game. To do so, we must build a class Mercurian that inhertis from SpaceObject, but provides its own definition of member function "draw". Then, when pointers to objects of class Mercurian appear in the container, you do not need to modify the code for the screen manager. The screen manager invokes member function draw on every object in the container, regardless of the object's type, so the new Mercurian objects simply "plug right in". Thus without modifiying the system (other than to build and include the classes themselves) you can use polymorphism to accommodate additional classes , including ones that were not even envisioned when the system was created >> that's why we can say that >> POLYMORPHISM PROMOTES EXTENSIBILTIY
- FROM pag520 
> we can assign the address of a derived class object to a base-class pointer, then show that invoking a function via the base-class pointer invokes the base-class functionality in the derived-class object [explained in section 12.3.1]
> on the contrary, if we assign the address of a base-class object to a derived-class pointer it will result in a compilation error [explained in section 12.3.2].
> in section 12.3.3 we assign the address of derived-class object to a base-class pointer, then examin how the base-class pointer can be used to invoke only the base-class functionality (when we attempt to invoke derived-class member functions through the base-class pointer, compilation error occur.)
> finally in section 12.3.4 we demonstrate how to get polymorphic behaviour from base-class pointers aimed at derived-class object. We introduce  virtual functions and polymorphism by declaring a base-class function as virtual. We then assign the address of a derived-class object to the base-class pointer and use that pointer to invoke derived-class functionality (precisely the capability we need to achieve polymorphic behaviour)
A KEY CONCEPT in these examples is to demonstrate that with puclic inheritance an object of a derived class can be treated as an object of its base class. 
NOTE from pag 535
DRIVERS and POLYMORPHISM / >> POLYMORPHISM and DRIVERS
[pag535deitel]
Polymorphism is particularly effective for implmentin layered software systems. In operating systems, for example, each type of physical device could operate quite differently from the others. Even so, commands to read or write data from and to devices may have  a certain uniformity. The write message sent to a device-driver object needs to be interpreted specifically in the context of that device driver and how that device driver manipulates devices of a specific type. However the write call itself really is no different from the write to any other device in the system (= place some number of bytes from memory onto that device). An object-oriented operating system could use an abstract base class to provide an interface appropriate for all device drivers.Then through inheritance from that abstract base class, derived classes are formed that all operate similarly. The capabilities (i.e. public functions) offered by the device driveres are provided as pure virtual functions in the astract base class. The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of device drivers. This architecture also allows new devices to be added to a system easily. The user can just plug in he device and install its new device driver. The operating system "talks" to this new device through its device driver, which has the same public member functions as all other device drivers (= those defined in the device driver abstract base class).
>> OVERHEAD OF POLYMORPHISM pag550 in terms of additional memory consumption and processor time.
[pag550deitel]
Il polymorphism non e' la migliore soluzione in tutte le situazioni. For example C++ standard library classes  like array or vector are implemented without polymorphism and "virtual" function to avoid the associated execution-time overhead and achieve optimal performance.
In section 12.7 is explain the data structures that the compiler builds at compile time to support polymorphism at execution time. You'll see that polymorphism is accomplished through three levels of pointers, i.e. >> triple indirection. 
When C++ compiles a class that has one or more virtual functions, it builds a virtual function table (>> vtable) for that class. The vtable contains pointers to the class's virtual functions. 
Just as the name of a built-in array contains the address in memory of the array's first element, a pointer to a function contains the stating address in memory of the code that perform the function's task. An executing program uses the vtable  to select the proper function implementation each time a virtual function fo the class is called.
- any class that has one or more null pointers in its vtable is an abstract class. 
- classes without anyu null vtable pointers are concrete class.
>> POLYMORPHISM PERFORMANCE [pag553]
- polymorphism as typically implemented with virtual functions and dynamic binding in C++ is efficient. You can use these capabilities  with nominal impact on performance. 
- virtual functions and dynamic binding enable polymorphic programming as an alternative to switch logic programming. Optimizing compilers normally generate polymorphic code that's nearly as efficient as hand-coded switch-based logic. Polymorphism's oeverhead is acceptable for most applications. In some situations (such as real-time applications) with stringent performance requirements - polymorphism's overhead may be too high.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POLYMORPHISM = means that a member function will produce different results depending on the type of object for which it is being called.
[mike pag322 game programming]
--------------------------------------------------------------------
//Polymorphic Bad Guy
//Demonstrates calling member functions dynamically

#include <iostream>

using namespace std;

class Enemy
{
public:
    Enemy(int damage = 10);
    virtual ~Enemy();
    void virtual Attack() const;
    
protected:
    int* m_pDamage;
};

Enemy::Enemy(int damage)
{
    m_pDamage = new int(damage);
}

Enemy::~Enemy()               
{
    cout << "In Enemy destructor, deleting m_pDamage.\n";
    delete m_pDamage;
    m_pDamage = 0;
}

void Enemy::Attack() const
{
    cout << "An enemy attacks and inflicts " << *m_pDamage << " damage points.";
}  

class Boss : public Enemy
{
public:
    Boss(int multiplier = 3); 
    virtual ~Boss();
    void virtual Attack() const;
    
protected:
    int* m_pMultiplier; 
};

Boss::Boss(int multiplier)
{
    m_pMultiplier = new int(multiplier);
}

Boss::~Boss()                 
{
    cout << "In Boss destructor, deleting m_pMultiplier.\n";
    delete m_pMultiplier;
    m_pMultiplier = 0;
} 

void Boss::Attack() const
{
    cout << "A boss attacks and inflicts " << (*m_pDamage) * (*m_pMultiplier)
         << " damage points.";
} 

int main()
{    // look here ciccio bella spiegazione di -> in pag 325 mike game programming 
     // perche' questi strani -> * ect : it is useful because it allows you to deal with objects without requiring that you know their exact type.
    cout << "Calling Attack() on Boss object through pointer to Enemy:\n";
    Enemy* pBadGuy = new Boss();
    pBadGuy->Attack();    
   
    cout << "\n\nDeleting pointer to Enemy:\n";
    delete pBadGuy;
    pBadGuy = 0;
   
    return 0;
}

--------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> virtual ~nomeClasse;   spiegazione a pag 326 mike game programming
evita potentiali problemi di free memory and pointer deletion 
SUSUME: a good rule of thumb is that if you have any virtual member functions in a class, you should make the destructor virtual too. 

>> POW 
[pag165 deitel]
Visto che C++ does not include an exponentiation operator, we need to use the standard library function pow
	pow(x,y)
calculates the value of x raised to yth power.
Per usarla non dimenticarti di scrivere 
	#include <cmath> 
come nell'esempio di pagina 165deitel 

>> PRECEDENCE Rules of operator precedence
- For the ARITHMETIC OPERATORS:
they are generally the same as those in algebra:
1) operators in expressios contained within pairs of parenthesis are evaluated first. Parenthesis are said to be at the "highest level of precedence"
2) multiplication, division and modulus operations are applied next. 
If an expression contains several moltiplication, division and modulus operations, operators are applied from left to right. Moltiplication, division and modulus are said to be on the same level of precedence. 
3) addition and subtraction operations are applied last. If an expression contains several addition and subtraction operations, operators are applied from left to right. 
	a + b + c
so a + b is calculated first, then c is added to that sum to determine the whole expression's value. 	
Addition and subtraction also have the same level of precedence. 	 
[pag50deitel]
4) the = assignment operator is applied last because its precedence is lower than that of any of the arithmetic operators.
example the polynomial y = ax^2 + bc + c in C++ diventa: 
	y = a * x * x + b * c + c
	  6   1   2   4   3   5   
dove i numeri sotto indicano l'ordine con cui C++ apply the operators.
5) a differenza di scilab (**) non esiste arithmetic operator for exponentiation in C++. quindi x^2 diventa x * x or possiamo usare the standard library function pow ("power") that performs exponentiation.
6) It's acceptable to place unnecessary parentheses in an expression to make the expression clearer. example 
	y = ( a * x * x ) + ( b * x ) + c
[pag52deitel]
- for RELATIONAL OPERATORS (< > <= >=) e EQUALITY OPERATORS (== !=)
The equality operators both have the same level of precedence, which is lower than that of the relational operators, and associate from left to right.
[pag53deitel]
- for the ASSIGNMENT OPERATOR = 
the associativity is RIGHT to LEFT 
[see nice summary pag 56 fig2.14 deitel + see appendix A pag968 + pag 893 deitel]
[see also nice summary pag184 operator precedence and associativity]
>> ASSOCIATIVITY / >> PRECEDENCE OPERATOR TABLE from pag 893 deitel
They're shown top to bottom in decreasing order of precedence:
Operators                               ASSOCIATIVITY   TYPE
::	(unary; right to left)	            left to right	primary
::  (binary; left to right) 
()  (grouping parenthensis) 
() [] . -> ++ -- static_cast<type>()	left to right	postfix
++ -- + - ! delete sizeof 				right to left	prefix
	* ~ & new
*   / %                                 left to right   multiplicative
+   -                                   left to right   additive
<< >>                                   left to right 	shifting
< <= > >=                               left to right   relational
== !=                                   left to right   equality
&                                       left to right   bitwise AND
^                                       left to right   bitwise XOR
|                                       left to right   bitwise OR
&&                                      left to right   logical AND
||                                      left to right   logical OR
?:                                      right to left   conditional
= += -= *= /= %= &= |= ^= <<= >>=       right to left   assignment
,                                       left to right   comma
----------------------------------------------------------------------------
----------------------------------------------------------------------------
>> PRECEDENCE operator [pag32 moo book]
NOTE: te li listo by precedence from highest to lowest 
NOTE2: ---------------------- = serve per separare grouping with the same precedence
------------------------------------------------------------------------------------ START TABLE
x.y         the member y of object x  [cioe' y e' una della funzioni di cui dispone l'oggetto x]
x[y]        the element in objhect x indexed by y
x++         increments x, returning the original value of x
x--         decrements x, returning the original value of x
------------------------------------------------------------------------------------
++x         increments x, returning the incremented value
--x         decrements x, returning the decremented value
!x          logical negation. If x is true then !x is false
------------------------------------------------------------------------------------
x * y       product of x and y
x / y       quotient of x and y. If both operands are integral, so is the result
			the implementation chooses whether to round toward zero or -inf
x % y       remainder, equivalent to x - ((x/y) * y) . x and y must be integral
------------------------------------------------------------------------------------
x + y       sum of x and y
x - y       results of subtracting y from x 
------------------------------------------------------------------------------------
x >> y      for integral x and y, x shifted right by y bits; y must be non negative
            if x is an istream reads from x into y
x << y      for integral x and y, x shifted left by y bits; y must be non negative
			if x is an ostream, writes y onto x
------------------------------------------------------------------------------------
x relop y   where relop = RELation OPerators yield a bool indicating the truth of the relation 
			the operators (<, >, <=, and >=) have their obvious meanings
------------------------------------------------------------------------------------ 
x == y      yields a bool indicating whether x equals y
x != y      yields a bool indicating whther x is not equal to y
------------------------------------------------------------------------------------
x && y      yields a bool indicating whether both x and y are true
			evaluate y only if x is true
------------------------------------------------------------------------------------
x || y      yields a bool indicating whether either x or y is true
			evaluates y only is x is false
------------------------------------------------------------------------------------
x = y       assign the value of y to x, yielding x as its result
x op= y     compound assignment operators;
			equivalent to x = x op y, where op is one of + - * / % & | ^ << >>
x ? y : z   yields y if x is true, z otherwise. Evaluates only one of y and z.
------------------------------------------------------------------------------------- END TABLE



>> bitfields / >> bit field [deitel pag894]
C++ provides the ability to specify the number of bits in which an integral type or enum type member of a class or a structure is stored. Such a memter is refereed to as a bit field.
Bit fields enable better memory utilization by storing data in the minimum number of bits required. Bit field member must be declared as an integral or enum type.
Consider the following structure definition:
	struct BitCard
	{
		unsigned face : 4;
		unsigned suit : 2;
		unsigned color : 1;
	} // end struct BitCard
The definition contains three unsigned bit fields (face, suit and color) used to represen a card from a deck of 52 cards. A bit field is declared by following an integral type or enum type member with a colon (:) and an integer constant representing the width of the bit field (i.e. the number of bits in which the member is stored). The width must be an integer constant. 
The preceding structure definition indicates that 
	member face is stored in four bits
	member suit in 2 bits 
	member color in one bit
The number of bits is based on the desired range of values for each struture member. Member face stores values between 0 (Ace) and 12 (King) (four bits can store a value between 0 and 15). Member suit stores values between 0 and 3 (0 = Diamonds, 1 = Hearts, 2 = Clubs, 3 = Spades), two bits can store a value between 0 and 3. Finally, member color stores either 0 (red) or 1 (black), one bit can store either 0 or 1. 
NOTE: although bit fields save space, using them can cause the compilerto generate slower executing machine language code. This occurs because it takes extra machine language operations to access only portions of an addressable storage unit. This is one of many examples of the space time trade offs that occur in computer science.
NOTE2 it is possible to specify unnamed bit field, in which case the field is used as >> padding in the structure [pag897 deitel] (= padding = riempimento dello spazio inutilizzato).
For example the structure definition uses an unnamed three bit field as padding, nothing can be stored in those three bits. Member b is stored in another storage unit. 
	struct Example
	{
		unsigned a : 13;
		unsigned   : 3; // align to next storage unit boundary
		unsigned b : 4;
	} // end struct Example
An unnamed bit field with a zero width is used to align the next bit field on a new storage unit boundary. For example the structure definition
	struct Example
	{
		unsigned a : 13;
		unsigned   : 0; // align to next storage unit boundary
		unsigned b : 4;
	} // end struct Example
uses an unnamed 0 bit field to skip the remining bits (as many as there are) of the storage unit in which a is stored an align b on the next storage unit boundary.
COMMON PROGRAMMING ERROR: attempting to take the address of a bit field (the & operator may not be sued with bit fields because a pointer can designate only a particular byte in memory and bit fields can start in the middle of a byte) is a compilation error.
COMMON PROGRAMMING ERROR2: attempting to access individual bits of a bit field with subscripting as if they were elements of an array is a compiaton error. Bit fields are not "arrays of bits""
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> precision / >> setprecision / >> floating point precision  
[pag574deitel]  [also example @pag39 moo book]
We can control the precision of floating-point numbers (i.e. the number of digits to the right of the decimal point) by using either the setprecision stream manipulator or the precision member function of ios_base. A call to either of these sets the precision for all subsequent output operations until the next precision setting call.
A call to member function precision with no argument return the current precision setting (this is what you need to use so that you can restore the original precision eventually after a sticky setting is no longer needed) See prgraom fig13.9 pag 572 to see some code that print a table that shows the square root of 2, with precision varying from 0 to 9
Extract from /home/dia/Deitel-Code_Examples/ch13/fig13_09/Fig13_09:
	   // set precision for each digit, then display square root
	   for ( places = 0; places <= 9; ++places )
	      cout << setprecision( places ) << root2 << endl;
	} // end main 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PROTECTED 
[pag501deitel]
Using protected access offers an intermediate level of protection between public and private access.  
Ricorda che 
	- a base class's public members are accessible within its body and anwhere that the program has a handle (i.e. a name, reference or pointer) t an object of that class or one of its derived classes.
	- a base class's private members are accessible only within its body and to the "friends" of that base class. 
	- a base class's protected members can be accessed within the body of that base class, by members and friends of that base class, and by members and friend of ANY CLASSES DERIVED from that base class.
[nota "base class" lo diciamo in relazione alle "derived class" che vengono derivate dalle base classes usando inheritance]
NOTE: 
vantaggi of protected over private 
C'e' si un piccolo vantaggio dal punto di vista della performance. 
- inheriting protected data members slightly improves performae, because we can directly access the members without incurring the overhead of calls to set and get member functions. In most cases, it's better anyway to use "private" data members to encourage proper software engineering, and leave code optimization issues to the compiler. Your code will be easier to maintain, modify nad debug
MA VI SONO DUE GROSSI SVANTAGGI CHE ti inducono a preferire l'utilizzo di "private" al posto di "protected"
- primo svantaggio e' che an invalid value can easily be asigne to the protected data member, thus leaving the object in a incosistent state.
- second problem with using protected data members is that derived class member functions are more likely to be written so that they depend on the base class implementation. Such software is said to be fragile or >> brittle, because a small change in the base class can "break" derived-class implementation. 
It's BETTER to declare base-class data members "private" (as opposed to declaring them protected) enables you to change the base-class implementation without having to change derived class implementation. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////]:)] 

>> OOOOOOO

>> open file / >> file open / >> FILE OPEN
[pag603]
you can create an ofstream object without opening a specific file, in this case a file can be attached to the object later. For example, the statement
	ofstream outClientFile;
creates an ofstream object that's not yet associated with a file. The ofstream member function open opens a file and attaches it to an existing ofstream as follows. 
	outClientFile.open("client.txt", ios::out);
ERROR PREVENTION: some operating systems allow you to open the same file multiple times simultaneouly. Avoid doing this because it can lead to subtle problems.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////]:)] 



>> OPEN FILE TEST / >> TEST IF FILE OPENED SUCCESSFULLY / >> EXIT PROGRAM EXAMPLE / >> TERMINATE PROGRAM EXAMPLE
[pag603 deitel] /home/dia/Deitel-Code_Examples/ch14/fig14_03
////////////////
   // open the file 
   ofstream outClientFile( "clients.txt", ios::out );	
   // exit program if unable to create file
   if ( !outClientFile ) // overloaded ! operator
   {
      cerr << "File could not be opened" << endl;
      exit( EXIT_FAILURE );
   } // end if
/////////
NOTE: passing EXIT_SUCCESS (also define in <cstdlib>) to exit indicates that the program terminated normally; passing any other value  (in this case "EXIT_FAILURE") indicates that the program terminated due to an error.
OMAGE: thanks Ciccio & Deitel helped to solve the problem in creating a message recovery error and exit in FEAMapper Nastran. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> OPEN KEEP windows open / >> batch file / >> console window keep open mike's way pag10 mike
Se ti capita che una volta cliccato sul programma exe si chiuda subito e ti impedisca di vederne il risultato, puoi creare un batch file that runs your console program and pauses, keeping the console window open so you can see the results of your program. For example if your compiled program is name tron.exe you can simply create a batch file comprising the two lines
	tron.exe
	pause
To create a batch file 
- Open a text editor (like editpad o notepad, nor word or wordpad)
- type your text
- save the file in the same folder with your tron.exe file. Give the file a .bat extension, so in this case, tron.bat would be a good name (in pratica in editpad lo salvi normalmente selezioni come formato unspecified file e lo nomini tron.bat). 
Finally run the batch file by double clicking its icon. You should see the results of the program since the batch file keeps the console window open.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> openFOAM C file structure
di solito all'interno di un file C di openFOAM ritroviamo le seguenti sezioni :
	// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * Private Member Functions * * * * * * * * * * //
	// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
	
>> OpenFOAM H file structure
1) /*help iniziale*/ contenente Class, Description and SourceFiles [e da li che Doxygen ne ricostruisce la documentazione]
2) la class declaration contenente :
		una sezione private con 
			// Private data
			// Private member functions
		una sezione public
			// Runtime type information
			// Constructors
			// Destructor
			// Member Functions	
			
///////////////////////////////////////////////////////////////////////////			

>> PREDICATE FUNCTIONS 
[pag378deitel]
Access functions that can read or write an object's data members. A common use of access functions is to test the truth or falsity of conditions : such functions are called a predicate functions.

>> predicate [pag63 moo book] = optional third arugment of the >> sort function.
If this third argument is present, the sort function will use it to compare elements instead of using the < operator. 
----------------------------------------------------------------------
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc]
	bool compare(const Student_info& x, const Student_info& y)
	{
		return x.name < y.name;
	}
	...	
	// alphabetize the records
	sort(students.begin(), students.end(), compare);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PREPROCESSING DIRECTIVE
a preprocessing directive begins with # and is a message to the C++  preprocessor. Preprocessing directives are processed before the program is compiled. 
example 
	#include <iostream>
tells the C++ preprocessor to include the contents of the input/output stream header, which contains information necessary to compile programs that use std::cin and std::out and the stream insertion << and stream extraction >> operators.	
[pag57deitel]  

>> preprocessor varialbe pag 67 moo book
like #ifndef directive, helps you to control how a program is compiled
Example 
	#ifndef GUARD_median_h
	#define GUARD_median_h
	
	// `median.h'--final version
	#include <vector>
	double median(std::vector<double>);
	
	#endif
-----------------------------------------
Explanation : 
the GUARD_media_h is the name of a >> preprocessor variable
the #ifndef directive asks the preprocessor to process everything between it and the next matching #endif if the give name is not defined.
The first time median.h is included in a program GUARD_media_H will be undefined, so the preprocessor will look at the rest of the file. The first thing it does is to define GUARD_media_h, so that subsequent attempts to include median.h will have no effect. The only the subtlety is that it is a good idea for the #ifndef to be the very first line of the file, without even a comment before it. The reason is that some C++ implementations detect files that have this form and, if the variable is defined, do not even bother to read the file the second time around.
[cioe' detto in parole spicciole: #ifndef ti aiuta ad avere una compilazione piu' efficiente]
///////////////////////////////////////////////////////////////////////////////

>> principle of least privilege
[pag346]
Alway give a function enough access to the data in its parameters to accomplish its specified task, but no more. Let the principle of least privilege be your guide. You can combine "const" with pointer declarations to enforce the principle of least privilege.
A) abbiamo visto che quando un argument e' passato by value, a copy of the argument is passed to the function. If the copy is modified in the called function, the original value in the caller does not change. In some instances, even the copy of the argument's value should not be altered in the called function
B) Oppure potremmo in maniera piu' effience passare alla funzione un built-in array by reference. Visto che e' passato by reference the called function ha il potere di modificarlo. Qualora volessimo assicurarci che non venga modificato dalla called function, dobbiamo usare alcune precauzioni.
Example
Consider a function tha takes 
1) a pointer to the initial element of a built-in array and 
2) the array's size 
as arguments and subsequently display the built-in array's elements.
Such a function should loop through the elements and output each individually. The built-in array's size is used in the function's body to determine the highest subscript so the loop can terminate when the displaying completes. The size does not need to change in the function body, so it should be declared "const"  to ensure that it will not change. Because the built-in array is only being displayed, it, too should be declared const. This is especially important because built-in array are always passed by reference and could easily be changed in the called function. An attempt to modify a const value is a compilation error.
There are 4 ways to pass a pointer to a function
A) nonconstant pointer to nonconstant data [highest access privilege]
B) nonconstant pointer to    constant data
C)    constant pointer to nonconstant data
D)    constant pointer to    constant data [minimum access privilege]
Each combination provides a different level of access privilege.
A) the highest access is grantedd by a nonconstant pointer to nonconstant data: example
	int *countPtr;
the data can be modified through the dereferenced pointer, and the pointer can be modified to point to other data. Such a pointer's declaration does not include const.
B) A nonconstant pointer to constant data is a pointer that can be modified to point to any data item of the appropriate type, but the data to which it points cannot be modified through that pointer.
	const int *countPtr;	
The declaration is read from right to left as "countPtr is a pointer to an integer constant" or more precisely, "countPtr is a non-constant pointer to an integer constant"
C) constant pointer to nonconstant data, example:
	int * const ptr = &x; 
ptr is a constant pointer to a non constant integer. The pointer is initialized with the address of integer variable x. 
A constant pointer to nonconstant data  is a pointer that always points to the same memory location, and the data at that location can be modified through the pointer. Pointers that are declared const must be initialized when they're declared, but if the pointer is a function parameter, it's initialized with the pointer that's passed to the function.
D) constant pointer to    constant data
such a pointer always points to the same memory location, and the data at that location cannot be modified via the pointer.
example:
	const int *const ptr = &x;
this declaration is read from right to left as "ptr is constant pointer to an integer constant"
cfr esempi completi see codice:
	ch08/fig08_10/fig08_10.cpp
	ch08/fig08_11/fig08_11.cpp
o vedi fig8.10 e fig8.11 pag 348-351
Performance tip: if they do not need to be modified by the called function, pass large objects using pointers to constant data or references to constant data, to obtain the performance benefits of pass-by reference and avoid the copy overhead of pass-by-value. In effetti quando a pointer to an object is passed, only a copy of the address of the object must be made, the object itself is not copied.
////////////////////////////////////////////////////////////////////

>> PRIVATE DATA MEMBERS OF A CLASS
[pag458 deiteil]
trovi un esempio a pag 459 
	private:
   size_t size; // pointer-based array size
   int *ptr; // pointer to first element of pointer-based array
[extract from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.h]

>> PROGRAM CONTROL 
[pag106 deitel]
Specifying the order in which statements (actions) execute is called program control.

>> predicative functions are Accesss that function can read or display data. Predicative functions are used to test the truth or falsity of conditions. 
Example :
- potremmo creare a "isFull" predicate function that might test a container-class object to determine whether it has no additional room. 
[pag386deitel]

>> PROMPT 
A prompt is a message that directs the user to take a specific action example 
	std::cout << "Enter StarGate Code: ";
we like to read the preceding statement as "std::cout gets the string "Enter StarGate Code: ""	

>> PSEUDOCODE
[pag106deitel]
Pseudocode (or "fake" code) is an artificial and informal language that helps you develop algorithms without having to worry about the details of C++ language syntax.
The pseudocode is helpful for developing algorithms that will be converted to structured C++ programs. Pseudocode does NOT execute on computers. Rather, it helps you "think out" a program before attempting to write it ina a programming language, such as C++. A carefully prepared pesudocode program can easily be converted to a corresponding C++ program. In many cases, this simply requires replacing pseudocode statements with C++ equivalents.
	Pseudocode normally describes only executable statements, which cause specific actions to occur after you to convert a program from pseudocode to C++ . We tipically do not include variable declarations in our pesudocode. Some programmers choose to list variables and mention their purposes at the beginning of pseudocode programs. 

>> PSEUDOCODE [pag132 mike programming game]
Plan your program formally on paper, it will almost always result in time (and frustration) saved.
Programming is a lot like construction. Without a plan you'll likely struggle through the process and waste time. You might even end up with a program that doesn't quite work.
Use pseudocode (a language that falls somewhere between English and a formal programming language). Anyone that understand english, should be able to follow pseudocode
Example 
	If you can design a new and useful spaceship
		then that's your spaceship
	Otherwise
		take an existing spaceship and rename it and paint it with some fancy colours
	Make an infomercial about your spaceship cargo services
	Show the infomercial on the BladeRunner blimps over the city. 
	Charge $50000 per cargo mission
	Sell 100 cargo missions 
>> STEPWISE REFINEMENT [pag133 mike programming game] 
Your programming plan might not be finished after only one draft. Often pesudocode need multiple passes before it can be implemented in programming code. Stepwise refinement means to rewrite pesudocode to make it more detailed and ready for implementation. By taking each step described in pseudocode and breaking it down into a series of simpler steps, the plan becomes closer to programming code.
You keep breaking down each step until you feel that entire plan could be fairly easily translated into a program.  
For example, take a step from the pseudo code above 
	Make an infomercial about your spaceship cargo services
This might seems too vague. How do you create an informercial? Using the stepwise refinement you can break down the single step into several others so it becomes:
	Write a script for an informercial about your cargo services 
	Rent Lucas Film Studios for a week
	Hire production crew 
	Hire actors 
	Film the infomercial
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> PUBLIC SERVICES / class's public services
i public services altri non sono che the class's public member functions. For example at pag84 fig3.9 : class GradeBook interface contains a constructor and member functions setCourseName, getCourseName and displayMessage. GradeBook's clients (e.g., main) use this functions to request  the class's services. 
[refiti a una classe]

>> PUBLIC STATIC DATA MEMBER
[pag300]
Public static data member can also be accessed outside of the class, even when no objects of the class exist, using the class name followed by the scope resolution operator (::) and the name of the data member. 
EXAMPLE 
[from pag 299 deitel]
	public:
   		// constant -- number of students who took the test
   		static const size_t students = 10; // note public data
this data member student specifies the size of an array. 
- "student" is set to public so that it's accessible to the class's clients. 
- Declaring students with the const qualifier indicates that this data member is constant (its value cannot be changed after being initialized)
- keyword static in this variable declaration indicates that the data member is shared by ALL OBJECTS of the class 

>> PURE VIRTUAL FUNCTION
[pag534deitel]
A pure virtual function is specified by placing "=0" in its declaration as for example 
	virtual void nameFunction() const = 0;
The "=0" is a pure specifier. Pure virtual functions typically do not provide implementations, though they can.
Each concrete derived class must override all base-class pure virtual functions with concreate implementations of those functions; otherwise the derived class is also abstract. 
Although we cannot instantiate objects of an abstract base class, we can use the abstract base class to declare pointers and references that can refer to objects of any concrete classes dervied from the abstract class. Programs typically use such pointers and references to manipulate derived-class objects polymorphically.

>> put
[pag 568 deitel]
we can use the put member function to output characters. For example, the statement
	cout.put ( 'A' );
displays a single character A. Calls to put may be cascaded, as in the statement
	cout.put( 'A' ).put( '\n' );
which outputs the letter A followed by a newline character. As with << the preceding statement executes in this manner, because the dot operator (.) associates from left to right, and the put member function returns a reference to the ostream objct (cout) that received the put call. The put function also may be called with a numeric expression that presents an ASCII value, as in the following statement, which also ouputs A:
	cout.put( 65 );
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> QQQQQQQ

>> QUIT PROGRAM / EXIT PROGRAM
[source http://stackoverflow.com/questions/1116493/how-to-quit-a-c-program]
Call the std::exit function. 

>> qualified name [pag5 moo book]


>> QUEUES 
[pag799 deitel]
Queue nodes are removed only from the head of the queue and are inserted only at the tail of the queue. For this reason, a queue is referred to as a first-in, first-out (FIFO) data structure. The insert and remove operations are called
	>> enqueue = insert element/node ad the tail of the queue
	>> dequeue = remove element/node from the head of the queue
- Application of Queues
> Computers that have a single processor can service only one user at a time. Entries for the other users are placed ina queue. 
Each entry gradually advances to the front of the queue as users receive service. The entry at the front of the queue is the next to receive service.
> PRINTERS: queues are also used to support >> print spooling: for example, a single printer might be shared by allusers of a network. Many users can send print jobs to the printer, even when the printer is already busy. These print jobs are placed in a queue until the printer becomes available. A program called a >> spooler manges the queue to ensure that, as each print job completes, the next print job is sent to the printer.
> NETWORK: information packect also wait in queues in computer networks. Each time a packet arrives at a netword node, it must be routed to the next node on the network along the path to the packet's final destination. The routing node routes one packet at a time, so additional packets are enqueued until the router can route them
> SERVERS: a file server in a computer network handles file access requests from many clients throughout the network. Servers have a limited capacity to service requests from clients. When that capacity is exceeded, client requests wait in queues.  
////////////////////////////////////////////////////////////////

>> RRRRRRR

>> RANDOM NUMBER GENERATION rand / >> rand
[pag214]
the c++ standard library function rand produces integers at random 
	i = rand();
the function rand generates an unsigned integer between 0 and RAND_MAX (a symbolic constant defined in the <cstdlib> header)
The range of values produced directly by the function rand often is different than what a specific application requires. For example a program that simulates rolling a six-sided die would require random integers in the range 1 to 6 [except if is an Inception Die]. A program that simulates coin tossing might require only 0 for "heads" and 1 for "tails" [except for the coin of Rosencrantz and the lucky coin of Harvy Dent]
Example supponi di voler produrre number integer random compresi tra 1 e 6
to produce random integers in the range 0 to 5 [come accade nel lancio di un dado] we use the modulus operator % with rand as follows:
	rand() % 6
This is called scaling. The number 6 is called the >> scaling factor. We then >> shift the range of numbers produced by adding 1 to our previous result (in modo che al posto del range 0 5 shift i risultati nel range 1 6)
see example pag 215deitel
	(1 + rand() % 6 );
We can generalize this as : 
	number = shiftingValue + rand() % scalingFactor
where  [pag219deitel] 
- shiftingValue is equal to the first number in the desired range of consecutive integers and 
- scalingFactor is equal to the width of the desired range of consecutive integers.
NB function rand actually generates pseudorandom numbers. Repeatedly calling rand produces a sequence of numbers that appears to be random. However, the sequence repeats itself each time the program executes. Questo e' desiderabile nella fase di debug di un simulation program, this repeatability is essential for proving that corrections to the program work properly. Once a program has been thoroughly debugged, it can be conditioned to produce a different sequence of random numbers for each execution. This is called randomizing and is accomplished with the X++ standard library function srand. 

>> vector<double>& / >> reference to const vector of double example from pag 54 moo book
"a name is a reference to an objects" means "the name is another name for the object"
So for example if we write
	vector<double> homework;
	vector<double>& hw = homework;   // here hw is a synonym for homework, we are just saying that "hw" is another name for "homework"
From that point, anything we do to hw is equivalent to doing the same thing to homework and viceversa.
We can also create a read-only synonym for "homework" in the following way:
	const vector<double>& chw = homework;
this expression still says that chw is another name for homework, but the const promises taht we will not do anything to change chw that might change its value.
NOTE: when we say that a parameterhas type const vector<double>&, we are asking the implementation ot give us direct access to the accosiated argument, without copying it, and also promising that we won't change the parmeter's value (which would otherwise change the argument too) pag55 moo book
------------------------------------------------------------------------------------ EXAMPLE start
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/grade.cc]
#include <stdexcept>
#include <vector>
#include "grade.h"
#include "median.h"
#include "Student_info.h"

using std::domain_error;  using std::vector;


// compute a student's overall grade from midterm and final exam grades and homework grade
double grade(double midterm, double final, double homework)
{
	return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

// compute a student's overall grade from midterm and final exam grades
// and vector of homework grades.
// this function does not copy its argument, because `median' does so for us.
double grade(double midterm, double final, const vector<double>& hw)
{
	if (hw.size() == 0)
		throw domain_error("student has done no homework");
	return grade(midterm, final, median(hw));
}

double grade(const Student_info& s)
{
	return grade(s.midterm, s.final, s.homework);
} 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> vector separate elements of a vector into two vectors. [pag76 moo book]
[per esempio il seguente programma prende un vettore ed toglie e salva in un secondo vettore tutti gli elementi che sono al di sotto di una certa soglia limite. Nel vettore di input restano solo gli elementi che sono al di sopra della soglia]
example from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/fails_vec1.cc
--------------------------------------------------------------------------------------------------------
	#include <vector>
	#include "Student_info.h"
	#include "grade.h"	
	using std::vector;
	// separate passing and failing student records: first try
	vector<Student_info> extract_fails(vector<Student_info>& students)  // nota come il function parameter sia una reference [la & che segue <Student_info>, so changes to the paremeter are reflected in the argument]
	{
		vector<Student_info> pass, fail;
	
	#ifdef _MSC_VER
		for (std::vector<Student_info>::size_type i = 0;
	#else
		for (vector<Student_info>::size_type i = 0;
	#endif
		     i != students.size(); ++i)
			if (fgrade(students[i]))
				fail.push_back(students[i]);
			else
				pass.push_back(students[i]);
	
		students = pass;  // we copy the passing records back into "students", obliterating the previous contents of students 
		return fail; // return the failing records.
	}
[note this version requires enough memory to hold two copies of each student record]
In the following version we become more spartan and instead of having two vector pass and fail, we will just create a single local variable, named fail, to hold the value that we intend to return. For each record in students, we will compute the grade. If it is a passing grade, we'll leave the record alone; if it's failing grade, we'll append a copy of it to fail, and remove it from students.
We need a way to remove an element from a vector. The good news is that such a facility exists; the bad news is that removing elements from vectors is slow enough to argue against using this approach for large amounts of input data. If the data we process get really big, performance degrades to an astonishing extent. For example if all of our students were to fail, the execution time of the function that we are about to see would grow proprotionally to the square of the number of students. That means that for a class of 100 students, the program would take 10,000 times as long to run as it would for one student. The problem is that our input records are stored in a vector, which is optimized for fast random access. One price of that optimization is that is can be expensive to insert or delete elements other than at the end of the vector.
A) SLOW SOLUTION using erase member function
/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/fails_vec2.cc
------------------------------------------------------------------------------------ 
#include <vector>
#include "Student_info.h"
#include "grade.h"

using std::vector;

// second try: correct but potentially slow
vector<Student_info> extract_fails(vector<Student_info>& students)
{
	vector<Student_info> fail;
#ifdef _MSC_VER
	std::vector<Student_info>::size_type i = 0;
#else
	vector<Student_info>::size_type i = 0;
#endif

	// invariant: elements `[0,' `i)' of `students' represent passing grades
	while (i != students.size()) {
		if (fgrade(students[i])) {
			fail.push_back(students[i]);
			students.erase(students.begin() + i);
		} else
			++i;
	}
	return fail;
}
----------------------------------------------------------------
B) USING LIST INSTEAD OF VECTORS for better performance [pag85 moo book]
Because our function requires only sequential access, we do not need to use indices (del tipo students[i] ), which provide the ability to access any element randomly. Instead, we'd like to rewrite the function so as to restrict access to the container elements to operations that support only sequential access. To that end, the C++ library supplies an assortment of types called iterators, which allow access to data structures in ways that the library can control. This control lets the library ensure efficient implementation. 
>> INDEX versus ITERATORS [pag81 moo book]
Per esempio cio' che si puo' scrivere usando un index:
	for (vector<Student_info>::size_type i = 0;
			i != students.size(); ++i)
		cout << students[i].name << endl;
si puo' riscriverlo usando un iterator:
	for (vector<Student_info>::const_iterator iter = students.begin();  // qui "iter" initially refers to the first element in "students" 
		iter != students.end(); ++iter ) {
		cout << (*iter).name << endl;  // this writes the current element's "name" member on the standard output
	}   
// NOTE: *iter : we access the element of the vector by calling the dereference operator *. When applied to an iterator the * operator returns an lvalue that is the element to which the iterator refers.
// NOTE dobbiamo scrivere (*iter).name e non *iter.name perche' . ha priorita' rispetto a * prima dobbiamo recuperare the value that the iterator iter denotes. E poi applicargli la member function name.
// NOTE this combination of operatios is so common that there is an abbreviation for it instead of 
	(*iter).name
we can write
	iter->name
Then we can rewrite l'esempio sopra as 
	for (vector<Student_info>::const_iterator iter = students.begin(); 
		iter != students.end(); ++iter ) {
		cout << iter->name << endl;  
	}   
Quindi ora, in questo momento posso dire che guardando iter->name ne vedo il significato: hai un iteratore "iter" che ti ritorna un valore di uno degli elementi di un container/vettore e a cui applichi -> la member function name

>> ITERATORS TYPES [pag80 moo book]
Every standard container, such as vector, defines two associated iterator types:
	container-type::const_iterator
	container-type::iterator
where container-type is the container type, such as vector<Student_info>, that includes the type of the container elements. When we wnat to use an iterator to change the values stored in the container, we use the iterator type. If we need only read access, then we use the const_iterator type. 
Abstraction is selective ignorance. The details of what particular type an iterator has may be complicated, but we don't need to understand these details. All we need to know is how to refer to the iterator type, and what operations the iterator allows.
We don't need to know the actual type of iter. All that we need to know is that vector<Student_info> has a member named const_iterator that defines a type that we can use to obtain read-only access to elements of the vector.
The other thing we need to know is that there is an automatic conversion from type iterator to type const_iterator. As we're about to learn, students.begin() returns an iterator, but we said that iter is a const_iterator. In order to initialize iter with the value of students.begin(), the implementation converts the iterator value into the corresponding const_iterator. This conversion is one way, meaning that we can convert an iterator to a const_iterator but not vice-versa.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE vs COPY into function / >> copy vs reference 
Ciccio detto in parole semplici: se all'interno di una funzione vedi un "&" significa che si NON si sta copiando il vettore, bensi semplicemente dando alla funzione l'accesso diretto al vettore e la sua eventuale modifica. 
example "COPY parameter to function" from pag 53 moo book
	double media(vector<double> vec)
		...
		sort(vec.begin(), vec.end());
nella precedente funzione visto che il vettore viene sortato, e' bene fare una copia del vettore, in modo che il vettore originale non venga modificato e che si esegui il sort solo sulla copia del vettore passato alla funzione.
example2 "REFERENCE parameter" from pag 57-58 moo book
	double grade(const vector<double>& hw)
	{
		...
	}
in this case the & asks the implementation not to copy the argument, and the "const" promises that the program will not change the parameter. Such parameters are an important technique for making programs more efficient. They are a good idea whenever the function will NOT change the parameter's value, and the parameter is of a type, such as vector or string, with values that might be time-consuming to copy.
On the contrary it is usaully not worth the bother to use const references for parameters of simple built-in types, such as int or double. Such small objects are usually fast enough to copy, that there' s little, if any, overhead in passing them by value.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> reference count [pag260 moo book]
Reference count is an object that keeps track of how many objects refer to another object. 
We increment the reference count each time that we create a new reference to our target object, and we decrement the reference count each time a referring object goes away. When the last referring object goes away, the reference count will become zero. At that point we'll know that it is safe to destroy the target object.
This technique can save a lot of unneeded memory management and copying of data.

>> RANDOM NUMBERS C++11 
[pag224]
C++11 provides many classes that represent various random-number generation "engines" and "distributions".
- an engine implements a random-number generation algorithm that produces pseudorandom numbers. 
- a distribution controls the range of values produced by an engine, the types of those values (e.g. int, double) and the statical properties of the values. 
For esempio we could choose the default random-number generation engine "default_random_engine" and a "uniform_int_distribution", which evenly distributes pseudorandom integers over a specified range of values. The default range is from 0 to the maximum value of an int on your platform.

>> GAME TERMINOLOGY / >> GAMING TERMINOLOGY
>> RPG = Role Playing Game
>> RTS = Real Time Strategy
>> FPS = First Person Shooter


>> RANGE-BASED FOR STATEMENT [=  lo statement FOR range-based, cioe' un ciclo for senza contatori, che si ripete basandosi sul range (range-based) del vettore]
[pag293deitel]
	for (rangeVariableDeclaration : expression)
		statement
where the rangeVarriableDeclaration  has a type and an identifier (ex int item) and expression is the array through which to iterate.  
Example:
   array< int, 5 > items = { 1, 2, 3, 4, 5 };
   // display items before modification
   cout << "items before modification: ";
   for ( int item : items )
      cout << item << " ";
The "for ( int item : items )" line can be read as "for each iteration, assign the next element of items to int variable item, then execute the following statement". Thus, for each iteration, identifier item represents one element in items. The line is equivalent to the following counter-controlled repetition:
	for ( int counter = 0; counter < items.size(); ++counter )
		cout << items[ counter ] << " ";
In range variable Declarations possiamo anche usare delle reference (&). 
Example pag 294 line 17-18: we use the range-based "for" to modify an array's contents
   for ( int &itemRef : items )
      itemRef *= 2;
itemRef is an int reference (&). Recall that a reference is an alias for another variable in memory [in this case, one of the array's elements). We use an int reference because items contains int values and we want to modify each element's value]. Because itemRef is declared as a reference, any change you make to itemRef changes the correspoding element value in the array.
LIMITATION and WHEN TO USE [pag295deitel]
The range-based for statement can be used in place of the counter-controlled "for" statement whenever code looping through an array does not require access to the element's  subscript. For example, totaling the integers in an array requires access only to the element value, the elements subscripts are irrelevant. 
However, if a program must use subscripts for some reason other than simply to loop through an array (ex. to print a subscript number next to each array value) you should use the counter-controlled for statement. 
NOTE1: It's common to process all the elements of an array. The C++11 range-based for statement allows you to do this without using a counter, thus avoiding the possibility of "stepping outside" the array and eliminating the need for you to implement your own bounds checking.
NOTE2: when processing all the elements of an array, if you don't need to access an array element's subscript, use the range-based for statement.


>> READ DATA FROM A SEQUENTIAL FILE 
[pag605 deitel]
see example /home/dia/Deitel-Code_Examples/ch14/fig14_06
	   // ifstream constructor opens the file          
   ifstream inClientFile( "clients.txt", ios::in );
///////////
The previous line creates an ifstream object called inClientFile and associates it with the clients.txt file. The arguments in parentheses are passed to the ifstream contructor, which opens the file and establishes a "line of communication" with the file.
NOTE: good programming practice
If a file's contents should not be modified, use ios::in to open it only for input. This prevents unintentional modificantion of the file's contents and is nother example of the principle of least privilege.
>> OPEN FILE for input 
[pag606deitel]
Objects of class ifstream are opened for input by default, so the statement
	ifstream inClientFile("arthemis.txt");
opens arthemis.txt for input. Just as with an ofstream object, an ifstream object can be created without opening a specific file, because a file can be attached to it later.
>> ENSURING THAT THE FILE WAS OPENED // >> TEST IF FILE OPEN / >> OPEN FILE TEST / >> CHECK FILE OPEN / >> OPEN FILE CHECK
[pag606deitel] from example /home/dia/Deitel-Code_Examples/ch14/fig14_06
   // exit program if ifstream could not open file
   if ( !inClientFile ) 
   {
      cerr << "File could not be opened" << endl;
      exit( EXIT_FAILURE );
   } // end if
///////////////////
>> READ FROM FILE 
from example /home/dia/Deitel-Code_Examples/ch14/fig14_06
   // display each record in file
   while ( inClientFile >> account >> name >> balance )
      outputLine( account, name, balance );
/////
using function outputLine definita nelle righe 36-41 di fig14_06.cpp possiamo display i records
////////////////////
>> file position pointers / >> seekg / >> seekp
[pag607 deitel]
The file position pointer is an integer vlue that specifies the location in the file as a number of bytes from the file's starting location (this is also referred to as the >> offset from the beginning of the file). 
To retrieve data sequentially from a file, programs normally start reading from the beginning of the file and read all the data consecutively until the desired data is found. It might be necessary to process the file sequentially several times (from the beginning of the file) during the execution of a program. Both istream and ostream provide member functions for reprositioning the file position pointer (the byte number of the next byte in teh file to be read or written). These member functions are:
	>> seekg (= seek get) for istream and 
	>> seekp (= seek put) for ostream. 
Each istream object has a get pointer, which indicates the byte number in the file from which the next input is to occur, and each ostream object has a put pointer, which indicates the byte number in the file at which then next output should be placed. 
The statement
	inClientFile.seekg(0);
repositions the file-position pointer to the beginning of the file (location 0) attached to inClientFile. The argument to seekg is a long integer. A second argument can be specified to indicate the seek direction, which can be 
	>> ios::beg (the default) for positioning relative to the beginning of a stream, 
	>> ios::cur for positioning relative to the current position in a stream or 
	>> ios::end for positioning relative to the end of a stream.
EXAMPLES:
	// position to the nth byte of fileObject (assumes ios::beg)
	fileObject.seekg (n);
	// position n bytes forward in fileObject
	fileObject.seekg (n, ios::cur );
	// position n bytes back from en of fileObject
	fileObject.seekg (n, ios::end );
	// position at end of fileObject
	fileObject.seekg (0, ios::end );
The same operations can be performed using ostream member function seekp. Member functions 
	>> tellg
	>> tellp
are provided to return the current locations of the get an put pointer, respectively. The following statement assigns the get file-position pointer value to variable location of type long:
	location = fileObject.tellg();
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> copy algorithm pag 102 moo book 
the copy algorithm takes three iterators, which we'll call begin, end and out
	copy(begin, end, out)
and copies all the elements in the range [begin, end) to a sequence of elements starting at "out" and extending as far as necessary.
In other words:
	copy(begin, end, out)
has the same effect as 
	while (begin != end)
		*out++ = *begin++;
except that the while body changes the values of the iterators, and "copy" doesn't
NOTE: 
	*out++ = *begin++; 
e' la forma compatta di 
	*out = *begin;
	++out;
	++begin;
-----------------------------------------------------------------------------------
>> iterator adaptors [pag102 moo book]
Iterator adaptors are functions that yield iterators with properties that are related to their arguments in useful ways. The iterator adaptors are defined in <iterator>. The most common iterator adaptor is back_inserter, which takes a container as its arugment and yields an iterator that, when used as a destination, appends values to the container. For example, back_inserter(ret) is an iterator that, when used as a destination, appends elements to ret. Therefore,
	copy(bottom.begin(), bottom.end(), back_inserter(ret));
copies all of the elements of "bottom" and appends them to the end of ret. After this function completes, the size of ret will have increased by bottom.size(). 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> reverse algorithm / >> merge algorithm / >> unique algorithm / >> copy_backward
[pag711 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_08/fig16_08.cpp
output of the program:
	array a1 contains: 1 3 5 7 9
	array a2 contains: 2 4 5 7 9	
	After copy_backward, results contains: 1 3 5 7 9
	After merge of a1 and a2 results2 contains: 1 2 3 4 5 5 7 7 9 9
	After unique results2 contains: 1 2 3 4 5 7 9
	array a1 after reverse: 9 7 5 3 1
>> copy_backward
[pag712 deitel]
	 23    // place elements of a1 into results in reverse order
	 24    copy_backward( a1.cbegin(), a1.cend(), results.end() );
Line24 use the copy_backward algorithm to copy elements in the range from a1.cbegin() up to, but not including a1.cend(), placing the elements in results by starting from the element before results.end() and working toward the beginning of the array. The algorithm returns an iterator positioned at the last element copied into the results (i.e. the beginnig of results because of the backward copy). The elements are planed in results in the same order as a1. This algorithm requires three bidirectional iterator arguments (iterators that can be incremented and decremented to iterate forward and backward through a sequence, respectively).
Once difference between copy_backward and copy is that the iterator returned from copy_backward is positioned at the last element copied (i.e. the first element in the sequence). Also copy_backward can manipulate overlapping ranges of elements in a container as long as the first element to copy is not in the destination range of elements.
[cioe' se ho ben capito, alla fine (come si vede dall'esempio di output sopra, "results" contiene gli stessi elementi di a1, solo che l'ORDINE con cui sono stati copiati e' backward un po come se cominciassi a ricopiare un libro a partire dall'ultima pagina risalendo fino alla prima. Cio' non significa poi che la copia del libro abbia le pagine in ordine inverso, aperta la prima pagina avrai pag1, il fatto che pag1 sia stata copiata alla fine del processo di copiatura, non inverte l'ordine delle pagine)]
NB: in addition to the copy and copy_backward algorithms, C++11 now includes the move and move_backward algorithms. These use C++11's new move semantics (discussed in Chapter 24 C++11 additional feature) to move, rather than copy, objects from one container to another.
---------------------------------------------------------
>> merge algorithm 
[pag713 deitel]
	 30    // merge elements of a1 and a2 into results2 in sorted order
	 31    merge( a1.cbegin(), a1.cend(), a2.cbegin(), a2.cend(),
	 32       results2.begin() );
Lines 31-32 use the merge algorithm to combine two sorted ascending sequences of values into a third sorted ascending sequence.
---------------------------------------------------------
>> back_inserter / >> front_inserter / >> inserter iterator adapters
[pag713 deitel]
---------------------------------------------------------
>> unique algorithm / >> duplicate remove >> rimuovi doppioni / >> doppioni removal
[pag713 deitel]
	 37    // eliminate duplicate values from results2
	 38    auto endLocation = unique( results2.begin(), results2.end() );
line38 uses the unique algorithm on on the sorted sequence of elements in the range from results2.begin() up to, but not including results2.end(). After this algorithm is applied to a sorted sequence with duplicate values, only a single copy of each value remains in the sequence. The algorithm takes two arguments that must be at least forward iterators. The algorithm returns an iterator positioned after the last element in the sequence of unique values. The values of all elements in teh container after the last unique value are undefined.
---------------------------------------------------------
>> reverse algorithm 
[pag714 deitel]
	 43    cout << "\n\narray a1 after reverse: ";
	 44    reverse( a1.begin(), a1.end() ); // reverse elements of v1
line44 uses the reverse algorithm to reverse all the elements in the range from a1.begin() up to, but not including a1.end(). The algorithm takes two arguments that must be at least bidirectional iterators.
---------------------------------------------------------
>> copy_if algorithm
[pag714 deitel]
from C++11 you can find the copy algorithms copy_if and copy_n. The copy_if algorithm copies each element from a range if the unary predicate function in its fourth argument returns true for that element.
[cioe' suppongo sia della forma copy_if (a1.begin(), a1.end(), outputIterator, greaterThan)
- dove greaterThan e' una unary predicate function tipo quella di pag 708 deitel line 93 
bool greaterThan ( int value )
	{
		return value > 10;
	}
quindi solo i valori che sono piu' grandi di 10 verranno copiati.
- percio' che riguarda l'outputIterator e' della forma di pag 714 deitel line 14, cioe' fornisce il container in cui verranno copiati gli elementi di a1 soddisfacenti la condizione specificata in greaterThan 
]
>> copy_algorithm 
[pag714 deitel]
The copy_n algorithm copies the number of elements specified by its second argument from the location specified by its first argument (an input iterator). The elements are output to the location specified by its third argument (an output iterator).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> inplace_merge / >> unique_copy / >> reverse_copy
[pag714 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_09/fig16_09.cpp
OUTPUT [nota bene l'array initiale conteneva 1 3 5 7 9 1 3 5 7 9]
array a1 contains: 1 3 5 7 9 1 3 5 7 9
After inplace_merge, a1 contains: 1 1 3 3 5 5 7 7 9 9
After unique_copy results1 contains: 1 3 5 7 9
After reverse_copy, results2 contains: 9 9 7 7 5 5 3 3 1 1
//////////////////////////////////////////////////////////
>> inplace_merge 
[pag715 deitel]
   // merge first half of a1 with second half of a1 such that 
   // a1 contains sorted set of elements after merge
   inplace_merge( a1.begin(), a1.begin() + 5, a1.end() );
the previous line uses the inplace_merge algorithm to merge two sorted sequences of elements in the same container.
In the example the elements from a1.begin() + 5 up to, but not including a1.end(). This algorithm requires its three iterator arguments to be at least bidirectional iterators. A second version of this algorithm takes as a fourth argument a binary predicate function for comparing elements in the two sequences.
--------------------------------------------------
>> unique_copy algorithm [per copiare giusto un ]
[pag715 deitel]
 28    // copy only unique elements of v1 into results1
 29    unique_copy( a1.cbegin(), a1.cend(), back_inserter( results1 ) );
 30    cout << "\nAfter unique_copy results1 contains: ";
 31    copy( results1.cbegin(), results1.cend(), output );
line 29 uses the unique_copy algorithm to make a copy of all the unique elements in the sorted sequence of values from a1.cbegin() up to but not including, a1.cend(). The copied elements are placed into vector results1.
[nota come si usi >> back_insert in modo da inserire gli elementi piuttosto che sostituirli, in tal modo il vettore puo' crescere per storare elementi aggiuntivi]
The first two arguments mut be at least input iterators and the last must be at least an output iterator. In this example, we did not preallocate enough elements in results1 to store all the elements copied from a1. Instead, we use function back_inserter (defined in header <iterator>  [cfr line 7 #include <iterator>]) to add elements to the end of results1. The back_inserter uses vector's >> push_back member function to insert elements at the end of the vector. Because the back_inserter insers an element rather than replacing an existing element's value, the vector is able to grow to accommodate additional elements. A second version of the unique_copy algorithm takes as a fourth argument a binary predicate function for comparing elements for equality. 
------------------------------------------------------
For a >> push_back member function example see also pag 42 moo book
	vector<double> homework;  // the type of elements contained in a vector is specified within <> brackets, in this case "double"
 	double x;
	// invariant: `homework' contains all the homework grades read so far
	while (cin >> x)
		homework.push_back(x);   // it appends a new element to the end of the vector. As a side effect, it increases the size of the vector by one.
------------------------------------------------------
>> reverse_copy algorithm
[pag715 deitel]
 35    // copy elements of a1 into results2 in reverse order
 36    reverse_copy( a1.cbegin(), a1.cend(), back_inserter( results2 ) );
 37    cout << "\nAfter reverse_copy, results2 contains: ";
 38    copy( results2.cbegin(), results2.cend(), output );
line 36 uses the reverse_copy algorithm to make a reversed copy of the elements in the range a1.begin() up to , but not including, a1.cend(). The copied elements are inserted into results2 using a back_inserter object to ensure that the vector can grow to accommodate the appropriate number of elements copied. Algorithm reverse_copy requires first two iteartor arugments to be at least bidirectional iterators and its third to be at least an output iterator.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> RECURSIVE FUNCTION / >> RECURSION 
[pag248deitel]
For some problems, it's useful to have functions call themselves. A recursive function is a function that calls itself, either directly, or indirectly (through another function).
NB: the C++ standard document indicates that main should not be called within a program or recursively. Its sole purpose is to be the starting point for program execution.
- recursive call pag249deitel
- recursion step pag249deitel
- recursive factorial example : pag249
(a) Procession of recursive calls per calcolare il fattoriale di 5
5!                                                            Final value 120
5 * 4!                                              5 * 4! -> 120 is returned 
    4 * 3!                                  4 * 3! ->  24 is returned 
        3 * 2!                       3 * 2! ->  6 is returned            
            2 * 1!           2 * 1!  ->  2 is returned
                1   --> 1    ->  1 is returned
[dalla fig 6.27pag250 del testo si comprende meglio]
The succession of recursive calls proceeeds until 1! is evaluated to be 1, terminating the recursion. 
The the values are returned from each recursive calls to its caller until the final value is calculated and returned 
- pag 252deitel -> example using recursion: Fibonacci Series 
chiosa estetico-architetturale: The Fibonacci series occurs in nature and, in particular, describes a form of spiral. The ration of successive Fibonacci numbers converges on a constant value of 1.618... This number frequently occurs in nature and has been called the golden ratio or the golden mean. Humans tend to find the golden mean aesthetically pleasing. Architects often design windows, rooms, and buidings whose length and width are in the ratio of the golden mean (1.618). Postcards are often desinged with a golden mean length/width ratio.
- ITERATION vs RECURSION / RECURSION vs ITERATION 
[pag255]
> A recursive approach is generally chosen when the recursive approach more naturally mirrors the problem and results in a program that's easier to understand and debug. BUT recursion has negative. It repeatedly invokes the mechanism, and consequently the overhead of function calls. This can be expensive in both processor time and memory space. While ITERATION usually occurs within a function, so the overhead of repeated functions calls and extra memory assignment is omitted.
- SUMMARY of RECURSION EXAMPLES and EXERCISES in deitel book see table pag257
--------------------------------------------------------------------------------

>> RECURSION [pag124 jesse book] / >> direct recursion vs >> indirect recursion 
Direct Recursion = when the function calls itself
Indirect Recursion = when a function calls another function that then calls the first function.

>> REFERENCE PARAMETER 
[pag238 deitel]
a reference parameter is an alias for its corresponding argument in a function call.
Example: the following declaration in a function header
	int &count
when read from right to left is pronounced "count is a reference to an int" 
example : pass-by-value vs pass-by-reference a pag239
Nell'esempio puoi vedere come nella funzione squareByReference si usi nella line 35 un reference parameter &numberRef
	void squareByReference ( int &numberRef)
	{...}
numberRef punta/si riferisce ad un numero intero [per avere un esempio con mano di cio' che intendo dirti vedi l'esempio nella voce successiva >> REFERENCE AS ALIASES within a FUNCTION]. Cio' significa che quando nella funzione main chiamo la funzione inserendo come input la variabile z
	squareByReference( z );
tale variabile z potra' essere modificata direttamente dalla funzione chiamata. Forse guardando l'esempio direttamente potrai comprendere meglio che da queste parole in cui non riesco bene ad esprirti il concetto, tutto sommato semplice: il simbolo & messo prima del parametro tra le parentesi tonde della definizione della funzione fa si' che le operazioni effettuate sul parametro della funzione chiamata vengano applicate al parametro della funzione chiamante, e' una sorta di simbolic link. 
MA A CHE SERVE TUTTA QUESTA COMPLICATIONE? 
Serve ad esempio a migliorare la performance. Supponi di avere una grossa matrice su cui la funzione chiamata debba effettuare delle operazioni. Se effettuassi un passaggio by value, dovresti fare una copia dell'oggetto, la funzione chiamata quindi agisce sulla copia dell'oggetto. Se invece effettui un passaggio by reference la funzione chiamata non agisce su una copia dell'oggetto ma sull'oggetto stesso, e ti eviti la perdita di tempo di dover copiare grossi oggetti. 
[da pag239: for passing large objects, use a constant reference parameter to simulate the appearance and security of pass-by-value and avoid overhead of passing a copy of the large object.] 
 

>> REFERENCE AS ALIASES within a FUNCTION
[pag239-240]
References can also be used as aliases of other variables within a function
	int count = 1; // declare integer variable count
	int &cRef = count; //create cRef as an alias for count
	++cRef; / increment count (using its alias cRef)
All operations supposedly performed on the alis are actually performed on the original variable. The alias is simply another name for the original variable. 

>> REFERENCE pag177 chapter 6 mike game programming // >> REFERENCE OPERATOR / >> & REFERENCE OPERATOR
A reference provides another name for a variable. Whatever you do to a reference is done to the variable to which it refers. You can think of a reference for a variable (= another name that the variable goes by).
The example below declares and initializes a variable to hold a score and then creates a reference that refers to the variable.
To declare and initialize a reference, start with the type of value to which the reference will refer, followed by the reference operator (&), followed by the reference name, followed by =, followed by the variable to which the reference will refer. 
FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/referencing.cpp]
------------------------------------------------------------------------------------------------------------
		// Referencing
		// Demonstrates using references
		#include <iostream>
		using namespace std;
		int main()
		{
		    int myScore = 1000; // create variable to hold our score
		    int& mikesScore = myScore;  // create a reference: mikesScore is an alias for myScore. mikeScore does not hold its own "int" value; it's simply another way to get at the "int" value that myScore holds.
		    
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";
		    
		    cout << "Adding 500 to myScore\n";
		    myScore += 500;
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";  // this line will display the same value it access the same single chunk of memory. Remember there is only one value, and it is stored in the variable myScore. mikesScores simply provides another way to get to that value.
		
		    cout << "Adding 500 to mikesScore\n";
		    mikesScore += 500;
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";
		
		    return 0;
		}
------------------------------------------------------------------------------------------------------------
NOTE: one way to understand references is to think of them as nicknames. For example, suppose you've got a friend named Eugene, and he (understandably) asks to be called by a nickname, Gibby, not much of an improvement, but it's what Eugene wants. So when you're at a party with your friend, you can call him over using either Eugene or Gibby. Your friend is only one person, but you can call him using either his name or a nick-name. In the same way, you can get to a single value stored in a variable by using its variable name or the name of a reference to that variable.
NOTE2: because a reference must always refer to another value, you must initialize the reference when you declare it. If you don't, you'll get a compile error. The following is quite illegal. 
	int& mikesScore;  // don't try this at home! 
NOTE3: A REFERENCE CANNOT BE REASSIGNED! A reference always refers to the variable with which it was initialized. You can't reassign a reference to refer to another variable so, for example, the results of the following code might not be obvious
	int myScore = 1000;
	int& mikesScore = myScore;
	int larrysScore = 2500; // corvette courtesy Duude Lebowsky
	mikesScore = larrysScore;
The line mikesScore = larryScore; does not reassign the reference mikesScore so it refers to larrysScore because a reference can't be reassigned. However, because mikesScore is just another name for myScore, the mikesScore = larrysScore; is equivalent to myScore = larrysScore;, which assigns 2500 to myScore. And after all is said and done, myScore becomes 2500 and mikesScore still refers to myScore.
NOTE4: references come in quite handy when you are passing variables to functions because when you pass a variable to a function, the function gets a copy of the variable. This means that the original variable you passed (called the argument variable) can't be changed. Sometimes this might be exactly what you want because it keeps the argument variable safe and unalterable.
FULL EXAMPLE
----------------------------------------------------------------------------
		// Swap
		// Demonstrates passing references to alter argument variables
		
		#include <iostream>
		
		using namespace std;
		
		void badSwap(int x, int y);  
		void goodSwap(int& x, int& y);  
		
		int main()
		{
		    int myScore = 150;
		    int yourScore = 1000;
		    cout << "Original values\n";
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		    
		    cout << "Calling badSwap()\n";
		    badSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		        
		    cout << "Calling goodSwap()\n";
		    goodSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n";
		
		    return 0;
		}
		
        // with this function only copies of the score values are sent to the function, the argument variables that hold the scores are unchanged
		void badSwap(int x, int y)  // passing argument by value // >> pass by value // >> argument by value / >> by value
		{
		    int temp = x;
		    x = y;
		    y = temp;
		} // when the function ends, both x and y go out of scope and cease to exist. Contro then returns to main(), where myScore and yourScore won't be changed
		
        // this function uses references, with this function the argument variables will be successfully exchanged
		void goodSwap(int& x, int& y)  // >> pass by reference // reference pass [pag184 mike programming game] 
		{
		    int temp = x;
		    x = y;
		    y = temp;
		}
/* NOTE: to pass by reference you must first declare the parameter as a reference. You can tell that a call to goodSwap() passes both arguments by reference by looking at the function header 
	void goodSwap(int& x, int& y);  
This means that when I call goodSwap(), the parameter x will refer to myScore and the parameter y will refer to yourScore. This means that x is just another name for myScore and y is just another name for yourScore. When goodSwap() executes and x and y exchange values, what really happens is that myScore and yourScore exchange values.
*/
----------------------------------------------------------------------------
OUTPUT PROGRAM 
	[2047 chapter06] >> ./swap 
	Original values
	myScore: 150
	yourScore: 1000
	
	Calling badSwap()
	myScore: 150
	yourScore: 1000
	
	Calling goodSwap()
	myScore: 1000
	yourScore: 150
NOTE >> EFFICIENCY PASS REFERENCES / >> PASSING REFERENCES FOR EFFICIENCY / >> PASS REFERENCE EFFICIENCY [pag14 mike programming game]
Passig a variable by value creates some overhead because you must COPY the variable before you assign it to a parameter. When we're talking about variables of simple, built-in types, such as an int or a float, the overhead is negligible. But a large object, such as one that represents an entire 3D world, could be expensive to copy. 
Passing by reference, on the other hand, is efficient because you don't make a copy of an argument variable. Instead, you simply provide access to the existing object through a reference. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> pass by value / >> by value [see also pag 109 jesse]
The arguments passed in to the function are local to the function. Changes made to the arguments do not affect the values in the calling function. This is known as >> passing by value, which means a local copy of each argument is made in the function. 
example :
// Listing 5.4 - demonstrates passing by value
#include <iostream>

using namespace std;   
void swap(int x, int y);
  
int main()
{
   int x = 5, y = 10;
  
   cout << "Main. Before swap, x: " << x << " y: " << y << endl;
   swap(x,y);
   cout << "Main. After swap, x: " << x << " y: " << y << endl;
   return 0;
}
  
void swap (int x, int y)
{
   int temp;
  
   cout << "Swap. Before swap, x: " << x << " y: " << y << endl;
  
   temp = x;
   x = y;
   y = temp;
  
   cout << "Swap. After swap, x: " << x << " y: " << y << endl;
}
////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE CONSTANT PASS / >> PASS CONSTANT REFERENCE / >> CONSTANT REFERENCE  [pag186 and 187 mike programming game]
A constant reference is a restricted reference. It acts like any other reference, except you can't use it to change the value to which it refers. To create a constant reference, simply put the keyword const before the type in the reference declaration. 
FULL PROGRAM [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/inventory_displayer.cpp]
-------------------------------------------------
	// Inventory Displayer
	// Demonstrates constant references
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	//parameter vec is a constant reference to a vector of strings
	void display(const vector<string>& inventory);  // we put the keyword const before the type in the reference declaration to create a constant reference. It's like providing the function read-only access to the argument
	
	int main()
	{
	    vector<string> inventory;
	    inventory.push_back("sword");
	    inventory.push_back("armor");
	    inventory.push_back("shield");  
	    
	    display(inventory);  // this results in an efficient and safe function call. It's efficient because only a reference is passed; the vector is not copied. It's safe because the reference to the vector is a constant reference: inventory can't be changed by display().
	
	    return 0;
	}
	
	//parameter vec is a constant reference to a vector of strings
	void display(const vector<string>& vec)
	{
	    cout << "Your items:\n";
	    for (vector<string>::const_iterator iter = vec.begin(); 
	         iter != vec.end(); ++iter)
		{
	         cout << *iter << endl;
		}
	}
-------------------------------------------------
HINT: a constant reference comes in handy in another way. If you need to assign a constant value to a reference, you have to assign it to a constant reference. (A non constant reference won't do)
RESUME: >> PASS ARGUMENTS WAYS, how to choose [pag187 mike programming game]
there are three different ways to pass argument
	1) pass by value
	2) pass by reference 
	3) pass by constant reference
How do you decide which method to use. Here are some guidelines
1) By value: pass by value when an argument variable is one of the fundamental built-in types, such as bool, int or float. Objects of these types are so small that passing by reference doesn't result in any gain in efficiency. 
You should also pass by value when you want the computer to make a copy of a variable. You might want to use a copy if you plan to alter a parameter in a function, but you don't want the actual argument variable to be affected. 
2) as a constant reference: pass a constant reference when you want to efficiencly pass a value that you don't need to change.
3) as a reference: pass a reference only when you want to alter the value of the argument variable. However, you should try to avoid changing argument variables whenever possible. 
--------------------------------------------- Ulteriori informazioni about "references" from summary pag 207 mike game programming
- a reference is an alias; it's another name for a variable
- you creare a reference using & (= the referencing operator)
- a reference must be initialized when it's declared
- a reference can't be changed to refer to a different variable
- whatever you do to a reference is done to the variable to which the reference refers
- when you assign a reference to a variable, you create a new copy of the referenced valued
- when you pass a variable to a function by value, you pass a copy of the variable to the function
- when you pass a variable to a function by reference, you pass access to the variable.
- passing by reference can be more efficient than passing by value, especially when you are passing large objects
- passing a reference provides direct access to the argument variable passed to a function. As a result, the function can make changes to the argument variable
- a constant reference can't be used to change the value to which it refers. You declare a constant reference by using the keyword const
- you can't assign a constant reference or a constant value to a non constant reference
- passing a constant reference to a function protects the argument variable from being changed by that function 
- changing the value of an argument variable passed to a function can lead to confusion, so game programmers consider passing a constant reference before passing a non constant reference
- returning a reference can be more efficient than returning a copy of a value, especially when you are returning large objects
- you can return a constant reference to an object so the object can't be changed through the returned reference 
- a basic technique of game AI is to have the computer consider all of its legal moves and all of its opponent's legal replies before deciding which move to take next.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE RETURN / >> RETURN from function [pag188 mike programming game]
Jus like when you pass a value, when you return a value from a function, you're really returning a COPY of the value. Again, for values of the asic built-in types, this isn't a big deal. However, it can be expensive operation if you're returning a large object. Returning a reference is an efficient alternative. 
FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/inventory_referencer.cpp]
NOTE: before you can return a reference from a function, you must specify that you're returning one. That's what we do in the refToElement() function header:
	string& refToElement(vector<string>& inventory, int i); 
by using the reference operator string& when I specify the return type, I'm saying that the function will return a reference to a string object (not a string object ifself). You can use the reference operator & as we did to specify that a function returns a reference to an object of particular type.Simply put the reference operator after the type name.
--------------------------------------------------- FULL EXAMPLE start
		// Inventory Referencer
		// Demonstrates returning a reference
		
		#include <iostream>
		#include <string>
		#include <vector>
		
		using namespace std;
		
		//returns a reference to a string
		string& refToElement(vector<string>& inventory, int i); 
		
		int main()
		{
		    vector<string> inventory;
		    inventory.push_back("sword");
		    inventory.push_back("armor");
		    inventory.push_back("shield");
		
		    //displays string that the returned reference refers to 
		    cout << "Sending the returned reference to cout:\n";   
		    cout << refToElement(inventory, 0) << "\n\n";   // display the first item through a returned reference
		
		    //assigns one reference to another -- inexpensive assignment 
            // >> REFERENCE TO REFERENCE ASSIGNMENT [pag191 mike programming] 
		    cout << "Assigning the returned reference to another reference.\n";
		    string& rStr = refToElement(inventory, 1);  // this is an efficient assignment because assigning a reference to a reference does not involve the copying of an object.
		    cout << "Sending the new reference to cout:\n";
		    cout << rStr << "\n\n";
		
		    //copies a string object -- expensive assignment
		    cout << "Assigning the returned reference to a string object.\n";
		    string str = refToElement(inventory, 2);  // note : this line does not assign a reference to str. It can't , because str is a string object. Instead the code copies the element to which the returned reference refers and assign that new copy of the string object to str. Because this kind of assignment involves copying an object, it's more expensive than assigning one reference to another. 
		    cout << "Sending the new string object to cout:\n";
		    cout << str << "\n\n";
		    
		    //altering the string object through a returned reference
		    cout << "Altering an object through a returned reference.\n";
		    rStr = "Healing Potion"; // because rStr refers to the element in position 1 of inventory, this code changes inventory[1] so it's equal to "Healing Potion"
		    cout << "Sending the altered object to cout:\n";
		    cout << inventory[1] << endl;		
		    return 0;
		}
		
		//returns a reference to a string
		string& refToElement(vector<string>& vec, int i)
		{
		    return vec[i];   // this line returns a reference to the element at position i in the vector. Notice that there is nothing in the return statement to indicate that the function returns a reference. The function header and prototype determine whether a function returns an object or a reference to an object.
		}
--------------------------------------------------- FULL EXAMPLE END 
NOTE TRAP: Altough returning a reference can be an efficient way to send information back to a calling function, you have to be careful not to return a reference to an >> out of scope object (= an object that ceases to exist). For example, the following function returns a reference to a string object that no longer exists after the function ends (that's illegal)
----------
	string& badReference()
	{
		string local = "This string will cease to exist once the function ends.";
		return local;
	}
----------
Once way to avoid this type of problem is to NEVER RETURN A REFERENCE TO A LOCAL VARIABLE
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> REFERENCES FULL EXAMPLE  TIC TAC TOE GAME 

			// Tic-Tac-Toe
			// Plays the game of tic-tac-toe against a human opponent
			
			#include <iostream>
			#include <string>
			#include <vector>
			#include <algorithm>
			
			using namespace std;
			
			// global constants
			const char X = 'X';
			const char O = 'O';
			const char EMPTY = ' ';
			const char TIE = 'T';
			const char NO_ONE = 'N';
			
			// function prototypes
			void instructions();
			char askYesNo(string question);
			int askNumber(string question, int high, int low = 0);
			char humanPiece();
			char opponent(char piece);
			void displayBoard(const vector<char>& board);
			char winner(const vector<char>& board);
			bool isLegal(const vector<char>& board, int move);
			int humanMove(const vector<char>& board, char human);
			int computerMove(vector<char> board, char computer);
			void announceWinner(char winner, char computer, char human);
			
			// main function
			int main()
			{
			    int move;
			    const int NUM_SQUARES = 9;
			    vector<char> board(NUM_SQUARES, EMPTY);
			
			    instructions();
			    char human = humanPiece();
			    char computer = opponent(human);
			    char turn = X;
			    displayBoard(board);
			
			    while (winner(board) == NO_ONE)
			    {
			        if (turn == human)
			        {
			            move = humanMove(board, human);
			            board[move] = human;
			        }
			        else
			        {
			            move = computerMove(board, computer);
			            board[move] = computer;
			        }
			        displayBoard(board);
			        turn = opponent(turn);
			    }
			
			    announceWinner(winner(board), computer, human);
			
			    return 0;
			}
			
			// functions
			void instructions()
			{
			    cout << "Welcome to the ultimate man-machine showdown: Tic-Tac-Toe.\n";
			    cout << "--where human brain is pit against silicon processor\n\n";
			
			    cout << "Make your move known by entering a number, 0 - 8.  The number\n";
			    cout << "corresponds to the desired board position, as illustrated:\n\n";
			    
			    cout << "       0 | 1 | 2\n";
			    cout << "       ---------\n";
			    cout << "       3 | 4 | 5\n";
			    cout << "       ---------\n";
			    cout << "       6 | 7 | 8\n\n";
			
			    cout << "Prepare yourself, human.  The battle is about to begin.\n\n";
			}
			
			char askYesNo(string question)
			{
			    char response;
			    do
			    {
			        cout << question << " (y/n): ";
			        cin >> response;
			    } while (response != 'y' && response != 'n');
			
			    return response;
			}
			
			int askNumber(string question, int high, int low)
			{
			    int number;
			    do
			    {
			        cout << question << " (" << low << " - " << high << "): ";
			        cin >> number;
			    } while (number > high || number < low);
			
			    return number;
			}
			
			char humanPiece()
			{
			    char go_first = askYesNo("Do you require the first move?");
			    if (go_first == 'y')
			    {
			        cout << "\nThen take the first move.  You will need it.\n";
			        return X;
			    }
			    else
			    {
			        cout << "\nYour bravery will be your undoing... I will go first.\n";
			        return O;
			    }
			}
			
			char opponent(char piece)
			{
			    if (piece == X)
				{
			        return O;
				}
			    else
				{
			        return X;
				}
			}
			
			void displayBoard(const vector<char>& board)
			{
			    cout << "\n\t" << board[0] << " | " << board[1] << " | " << board[2];
			    cout << "\n\t" << "---------";
			    cout << "\n\t" << board[3] << " | " << board[4] << " | " << board[5];
			    cout << "\n\t" << "---------";
			    cout << "\n\t" << board[6] << " | " << board[7] << " | " << board[8];
			    cout << "\n\n";
			}
			
			char winner(const vector<char>& board)
			{
			    // all possible winning rows
			    const int WINNING_ROWS[8][3] = { {0, 1, 2},
			                                     {3, 4, 5},
			                                     {6, 7, 8},
			                                     {0, 3, 6},
			                                     {1, 4, 7},
			                                     {2, 5, 8},
			                                     {0, 4, 8},
			                                     {2, 4, 6} };
			    const int TOTAL_ROWS = 8;
			
			    // if any winning row has three values that are the same (and not EMPTY),
			    // then we have a winner
			    for(int row = 0; row < TOTAL_ROWS; ++row)
			    {
			        if ( (board[WINNING_ROWS[row][0]] != EMPTY) &&
			             (board[WINNING_ROWS[row][0]] == board[WINNING_ROWS[row][1]]) &&
			             (board[WINNING_ROWS[row][1]] == board[WINNING_ROWS[row][2]]) )
			        {
			            return board[WINNING_ROWS[row][0]];
			        }
			    }
			
			    // since nobody has won, check for a tie (no empty squares left)
			    if (count(board.begin(), board.end(), EMPTY) == 0)
			        return TIE;
			
			    // since nobody has won and it isn't a tie, the game ain't over
			    return NO_ONE;
			}
			
			inline bool isLegal(int move, const vector<char>& board)
			{
			    return (board[move] == EMPTY);
			}
			
			int humanMove(const vector<char>& board, char human)
			{
			    int move = askNumber("Where will you move?", (board.size() - 1));
			    while (!isLegal(move, board))
			    {
			        cout << "\nThat square is already occupied, foolish human.\n";
			        move = askNumber("Where will you move?", (board.size() - 1));
			    }
			    cout << "Fine...\n";
			
			    return move;
			}
			
			int computerMove(vector<char> board, char computer)
			{ 
			    unsigned int move = 0;
			    bool found = false;
			
			    //if computer can win on next move, that's the move to make
			    while (!found && move < board.size())
			    {
			        if (isLegal(move, board))
			        {
						//try move
			            board[move] = computer;
			            //test for winner
			            found = winner(board) == computer;   
						//undo move
			            board[move] = EMPTY;
			        }
			
			        if (!found)
			        {
			            ++move;
			        }
			    }
			  
			    //otherwise, if opponent can win on next move, that's the move to make
			    if (!found)
			    {
			        move = 0;
			        char human = opponent(computer);
			
			        while (!found && move < board.size())
			        {
			            if (isLegal(move, board))
			            {
							//try move
							board[move] = human;  
							//test for winner
			                found = winner(board) == human;     
						    //undo move
							board[move] = EMPTY;        
			            }
			
			            if (!found)
			            {
			                ++move;
			            }
			        }
			    }
			
			    //otherwise, moving to the best open square is the move to make
			    if (!found)
			    {
			        move = 0;
			        unsigned int i = 0;
			
			        const int BEST_MOVES[] = {4, 0, 2, 6, 8, 1, 3, 5, 7};
			        //pick best open square
			        while (!found && i <  board.size())
			        {
			            move = BEST_MOVES[i];
			            if (isLegal(move, board))
			            {
			                found = true;
			            }
			
			            ++i;
			        }
			    }
			
			    cout << "I shall take square number " << move << endl;
				return move;
			}
			
			void announceWinner(char winner, char computer, char human)
			{
				if (winner == computer)
			    {
			        cout << winner << "'s won!\n";
			        cout << "As I predicted, human, I am triumphant once more -- proof\n";
			        cout << "that computers are superior to humans in all regards.\n";
			    }
			
				else if (winner == human)
			    {
			        cout << winner << "'s won!\n";
			        cout << "No, no!  It cannot be!  Somehow you tricked me, human.\n";
			        cout << "But never again!  I, the computer, so swear it!\n";
			    }
			
				else
			    {
			        cout << "It's a tie.\n";
			        cout << "You were most lucky, human, and somehow managed to tie me.\n";
			        cout << "Celebrate... for this is the best you will ever achieve.\n";
				}
			}
---------------------------------------------------------------------------------------------
NOTE: in the real world: Game Designers work countless hours on concept papers, design documents, and prototypes before programmers write any game code. Once the design work is done, the programmers start their work (more planning). It's only after programmers write their own technical designs that they then begin coding in earnest. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REGISTER VARIABLE
[pag226]
Data in the machine-language version of a program is normally loaded into "registers" for calculations and other processing.
The storage-class specifier register can be placed before an automatic variable declaration to suggest that the compiler maintain the variable  in one of the computer's high speed hardware registers rather than in memory. Example:
	register unsigned int counter = 1;
Often register is unnecessary. Today's optimizing compilers can recognize frequently used variables and may place them in registers without needing a "register" declaration.

>> RELATIONAL AND EQUALITY OPERATORS
Useful to evaluate a comparison between two expressions. The result of a relational operation is a Boolean value that can only be true or false, according to its Boolean result: 
Here's the list:
EQUALITY OPERATORS
	== -> equal to 
	!= -> not equal to
RELATIONAL OPERATORS	 
	>  -> greater than
	<  -> less than 
	>= -> greater than or equal to
	<= -> less than or equal to
IMPORTANT nota come l'uguale venga sempre dopo <= OK e non =< [it would give you a sintax error]
!= OK e non =!. Se usassi =! in some cases will not be a sintax error, but almost certainly will be a logic error (if fatal logic error the program will terminate prematurely, if nonfatal logic error the program will continue executing, but usually produces incorrect results)	
examples:
	(7 == 5)  //  evaluates to false
    (5  > 4)  //  evaluates to true
    (3 != 2)  //  evaluates to true
    (6 >= 6)  //  evaluates to true
    (5 <  5)  //  evaluates to false
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REMOVE / >> remove_if / >> remove_copy / >> remove_copy_if
[pag697 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_03/fig16_03.cpp
>> remove exemple d'emploi
	 13    const size_t SIZE = 10;
	 14    array< int, SIZE > init = { 10, 2, 10, 4, 16, 6, 14, 8, 12, 10 };
	 15    ostream_iterator< int > output( cout, " " );
	 16 
	 17    array< int, SIZE > a1( init ); // initialize with copy of init
	 18    cout << "a1 before removing all 10s:\n   ";
	 19    copy( a1.cbegin(), a1.cend(), output );
	 20 
	 21    // remove all 10s from a1
	 22    auto newLastElement = remove( a1.begin(), a1.end(), 10 );
	 23    cout << "\na1 after removing all 10s:\n   ";
	 24    copy( a1.begin(), newLastElement, output );
Line 22 uses the remove algorithm to eliminate from a1 all elements with the value 10 in the range from ai.begin() up to but not including a1.end(). The first two iterator arguments must be forward iterators. This algorithm does not modify the number of eleements in the container or destroy the eliminated elements, but it does move all elements that are not eliminated toward the beginning of the container. The algorithm returns an iterator positioned after the last element that was not removed. Elements from the iterator position to the end of the container have unspecified values.
>> remove_copy algorithm
Line 32 uses the remove_copy algorithm to copy all elements from a2 that do not have the value 10 in the range from a2.cbegin() up to, but not including a2.cend(). The elements are placed in c, starting at position c.begin(). The iterators supplied as the first two arguments must be input iterators. The iterator supplied as the third argument must be an output iterator so that the elemetn being copied  can be inserted into the copy location. This algorithm returns an iterator positioned after the last element copied into vector c.
[pag699 deitel]
>> remove_if algorithm [pag 699 deitel]
>> remove_copy_if algorithm
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> replace / >> replace_if / >> replace_copy / >> replace_copy_if
[pag700 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_04/fig16_04.cpp
Come puoi vedere dall'esempio puoi usare i replace algorithm in maniera simile a quanto fa li comando replace in un text editor, tutte le volte che trova l'elemento cercato lo sostituisce.
Example from line 22
	replace( a1.begin(), a1.end(), 10, 100 );
line 22 uses the replace algorithm to replace all elements with the value 10 in the range a1.begin() up to, but not including a1.end() with the new value 100.
[abbiamo compilato il programma via Visual Studio 2013 @Orion1 eccoti l'output
	a1 before removing all 10s:
	   10 2 10 4 16 6 14 8 12 10
	a1 after removing all 10s:
	   2 4 16 6 14 8 12
	
	a2 before removing all 10s and copying:
	   10 2 10 4 16 6 14 8 12 10
	c after removing all 10s from a2:
	   2 4 16 6 14 8 12 0 0 0
	
	a3 before removing all elements greater than 9:
	   10 2 10 4 16 6 14 8 12 10
	a3 after removing all elements greater than 9:
	   2 4 6 8
	
	a4 before removing all elements
	greater than 9 and copying:
	   10 2 10 4 16 6 14 8 12 10
	c2 after removing all elements
	greater than 9 from a4:
	   2 4 6 8 0 0 0 0 0 0
]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> RTTI = RunTime Type Information [pag554 deitel]

>> RETURN 
the return statement causes the main function to finish. Return may be followed by a return code ex
	return 0;
A return code of 0 for the main function is generally interpreted as the program worked as expected without any errors during its execution. This is the most usual way to end a C++ console program. 

>> RETURN CONTROL from a function to its caller
there are several ways to return control to the point at which a function was invoked. 
1) if the function does not return a result (i.e. it has a void return type), control returns when the program reaches the function ending right brace, or by execution of the statement
	return;
2) if the function does return a result, the statement
	return expression;
evaluates the expression and returns the value of expression to the caller.

>> REUSABILITY tips 
1) [pag83] to make a class reusable ALWAYS seperate your class into another file from the "main" function. Do not place "main" in the same file with a class definition. Function "main" begins the execution of every program, and every program must have exactly one "main" function. if other programmers include your class definition che hai scritto in un file che contiene anche "main", they get extra "baggage", their programs will then have two "main" functions. Attempting to compile a program with two "main" functions produces an error. 
2) it is customary to define reusable source code (such as a class) in a file that by convention has a .h file extension - known as a header. Programs use 
	#include
preprocessing directives to include headers and take advantage of reusable software components (such as for example type "string" provided in the C++ standard library)
Quindi la struttura generale sara' : avrai almeno due files 
A) il file *.cpp , il source code file che contiene the "main" funcntion, preceduta da degli #include per includere dei types provided dalla standard library (ex #include <iostream>) o userdefine types (ex #include "miaClass")
B) il file *.h chiamato anche header: contiene la class definition (ex "miaClass.h") che resta cosi' separata dal file *.cpp contenente "main"
In tal modo l'*.h potra' essere riutilizzato in altri programmi.
[pag84deitel]

>> SSSSSSS

>> SML Simpletron Machine Language [pag779 deitel]

>> self referential class [pag779]

>> stable_partition / >> partition [pag 119 moo book]
stable_partition is an algorithm that takes a sequence and rearranges its elements so that the ones that satisfy a predicate precede the ones that do not satisfy it.
There are two version of this algorithm: partition and stable_partition
- partition might rearrange the elements within each category, 
- stable_partition keeps them in the same order aside from the partitioning.
So, for example, if the sutdnet names were already in anphabetical order, and we wanted to keep them that way within each category, we would need to use stable_partition rather than partition.

>> short circuit evaluation [pag25 moo book]
like with the || operator (the or operator that tests whether either of its operands is true). 
	condition1 || condition2
if condition1 is true, the condition2 won't be evaluated at all. This property is called short circuit evaluation. [migliora la performance, perche' stare a sprecare il tempo se il resto sia vero o meno, quando si ha gia' la verita' in mano?]

>> standard header [pag2 moo book]
for example 
	#include <iostream>
Including a standard header makes the associated library facilities available to the program. 

>> SCOPE of a VARIABLE
the scope of a variable specifies where it can be used in a program (esempio a restricted use all'interno di un for cycle) 
[pag161deitel]
SCOPE [altra definizione a pag225]
An identifier's scope is where the identifier can be referenced in a program. Some identifiers can be referenced throughout a program; others can be referenced from only limited portions of a program.  
[see also pag228deitel]
Also : [pag6 moo book] the statements between a pair of matching braces {} constitute a scope.
> The portion of the program where an identifier can be used is known as its scope. For example, when we declare a local variable in a block, it can be referred only in that block and in blocks nested within that block. 
> Ci sono sei tipologie di scope
- block scope 
- function scope   [vedi voce >> FUNCTION SCOPE]
- global namespace scope
- function-prototype scope
- class scope
- namespace scope
COMMON PROGRAMMING ERROR: accidentally using the same name for an identifier in an inner block that's used for an identifier in an outer block, when in fact you want the identifier in the outer block to be active for the duration of the inner block, is typically a logic error. [=> quindi sugo del discorso: non usare per nomi di variabili contenute in nested blocks dei nomi di variabili che hai gia' utilizzato nel blocco esterno che circonda i nested blocks]
OSSERVAZIONE 2:
[from pag231]
nota come quando si usa 
	static int 
all'interno di una funzione l'inizializzazione viene effettuata the first time the function is called, mentre nelle successive si prende il valore che la variabile ha assunto
OSSERVAZIONE 3 [from pag261deitel]: static-storage-duration variables exist from the point at which the program begins execution until the program terminates.Unlike automatic variables, static local variables retain their values when the function in which they're declared returns to its caller.

>> SCOPE OF A CLASS / >> CLASS SCOPE
[pag384 deitel]
A class's data members and member functions belong to that class's scope. Nonmember functions are defined at "global namespace scope" by default
same page see def: >> handle of an object , >> implicit handle
pag 386 class scope vs >> block scope

>> SCOPES [mike game programming pag153]
A variable's scope determines where the variable can be seen in your program. Scopes allow you to limit the accessibility of variables and are the key to encapsulation, helping keep separate parts of your program, such as functions, apart from each other.
Example 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/scoping.cpp
NOTE: every time you use curly braces to create a block, you create a scope. Functions are on example of this. Variables declared in a scope aren't visible outside of that scope. This means that variables declared in a function aren't visible outside of that function. 
Variables declared inside a function are considered >> local variables, they're local to the function. This is what makes functions encapsulated.
NOTE: come mostrato nell'esempio qui sotto (extracted from Full Example below), you can create a nested scope with a pair of curly braces in an existing scope. example
	    {
        cout << "In main() in a new scope var is: " << var << "\n\n";

        cout << "Creating new var in new scope.\n";
        int var = 10;  // variable in new scope, hides other variable named var    -> una volta usciti da queste parenthesis non si potra' piu' avere il valore di var = 10 
        cout << "In main() in a new scope var is: " << var << "\n\n";
        }
-----------------------------------------------------------------------
Full Example 
	// Scoping
	// Demonstrates scopes
	
	#include <iostream>
	
	using namespace std;
	
	void func();
	
	int main()
	{
	    int var = 5;  // local variable in main()
	    cout << "In main() var is: " << var << "\n\n";
	
	    func();
	
	    cout << "Back in main() var is: " << var << "\n\n";
	
	    {
	        cout << "In main() in a new scope var is: " << var << "\n\n";
	
	        cout << "Creating new var in new scope.\n";
	        int var = 10;  // variable in new scope, hides other variable named var
	        cout << "In main() in a new scope var is: " << var << "\n\n";
	    }
	
	    cout << "At end of main() var created in new scope no longer exists.\n";
	    cout << "At end of main() var is: " << var << "\n";
	
	    return 0;
	}
	
	void func()
	{
	    int var = -5;  // local variable in func()
	    cout << "In func() var is: " << var << "\n\n";
	}
------------------------------------------------------------- end program
NOTE: when you define variables inside "for" loops, "while" loops, "if" statements, and "switch" statements, these variables don't exist outside their structures. They act like variables declared in a nested scope. For example, in the following code, the variable "i" doesn't exist outside the loop. 
	for(int i=0; i < 10; ++i)
	{
		cout << i;
	} // i doesn't exist outside the loop.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> SENTINEL CONTROLLED REPETITION 
[pag125deitel]
in a sentinel controlled repetition the number of repetitions is not known before the loop begins executing. We use a special value called  a sentinel value (also called a signal value, a dummy value or flag value) to indicate "end of data entry".

>> SEQUENTIAL EXECUTION 
[deitel 107]
Normally, statements in a program execute one after the other in the order in which they're written. This is called sequential execution. Various C++ statements enable you to specify that the next statement to execute may be other than the next one in sequence. This is called transfer of control.

>> SET FUNCTION advice
[from 97 deitel]
A public set function should carefully scrutineze any attempt to modify the value of a data member to ensure that the new value is appropriate for that data item.
Making data member private and controlling access, especially write access, to those data members through public member functions helps ensure data integrity. 

>> SET OPERATIONS [nell'ambito dei standard library algorithms]
[pag716 deitel]
>> set_difference / >> set_intersection / >> set_symmetric_difference / >> set_union
they are useful for manipulating sets of sorted values.
EXAMPLE @ /home/dia/Deitel-Code_Examples/ch16/fig16_10/fig16_10.cpp
OUTPUT 
a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	a3 contains: 4 5 6 11 15
	
	a1 includes a2
	a1 does not include a3
	
	set_difference of a1 and a2 is: 1 2 3 9 10
	
	set_intersection of a1 and a2 is: 4 5 6 7 8
	
	set_symmetric_difference of a1 and a3 is: 1 2 3 7 8 9 10 11 15  [>> set_symmetric_difference cioe' per raccogliere tutti gli elementi di a1 e di a3 che non appartengono all'intersezione di a1 e a3]
	
	set_union of a1 and a3 is: 1 2 3 4 5 6 7 8 9 10 11 15
------------------------------------------------------------------
>> includes algorithm
[pag717 deitel]
 25    // determine whether a2 is completely contained in a1
 26    if ( includes( a1.cbegin(), a1.cend(), a2.cbegin(), a2.cend() ) )
 27       cout << "\n\na1 includes a2";
 28    else
 29       cout << "\n\na1 does not include a2";
lines 26 adn 32 call the includes algorithm, which compares two sets of sorted values to determine whether every element of the second set is in the first set. If so, includes returns true; otherwise, it returns false. The first two iterator arguments must be at least input iterators and must describe the first set of values. In line 26 the first set consists of the elements from a1.cbegin() up to, but not including, a1.cend(). The last two iterator arguments must be at least input iterators and must describe the second set of values. In this example, the second set consists of the elements from a2.cbeing() up to, but not including a2.cend().
Esempio di output 
	a2 contains: 4 5 6 7 8
	a3 contains: 4 5 6 11 15
	
	a1 includes a2
	a1 does not include a3
---------------------------------------------------------------------
>> set_difference algorithm \ >> difference find between to containers. 
[pag718 deitel]
 39    // determine elements of a1 not in a2
 40    auto result1 = set_difference( a1.cbegin(), a1.cend(),
 41       a2.cbegin(), a2.cend(), difference.begin() );
ESEMPIO di output 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	set_difference of a1 and a2 is: 1 2 3 9 10
Lines 40-41 use the set_difference algorithm to find the elements from the first set of sorted values that are not in the second set of sorted values (both sets of values must be in ascending order). The elements that are different are copied into the fifth argument (in this case the array difference)
---------------------------------------------------------------------
>> set_intersection algorithm 
[pag718 deitel]
 47    // determine elements in both a1 and a2
 48    auto result2 = set_intersection( a1.cbegin(), a1.cend(),
 49       a2.cbegin(), a2.cend(), intersection.begin() );
lines 48-49 use the set_intersection algorithm to determine the elements from the first set of sorted values that are in the second set of sorted values (both sets of values must be in ascending order). The elements common to both sets are copied into the fifth argument (in this case, array intersection).
ESEMPIO DI OUTPUT:
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	set_intersection of a1 and a2 is: 4 5 6 7 8
-----------------------------------------------------------------------
>> set_symmetric_difference algorithm 
[pag718 deitel]
 55    // determine elements of a1 that are not in a2 and 
 56    // elements of a2 that are not in a1
 57    auto result3 = set_symmetric_difference( a1.cbegin(), a1.cend(),
 58       a3.cbegin(), a3.cend(), symmetric_difference.begin() );
Lines 57-58 use the set_symmetric_difference algorithm to determine the elements in the first set that are not in the second set and the elements in the second set that are not in the first set (both sets must be in ascending order). The elements that are different are copied from both sets into the fifth argument (the ar\ay symmetric_difference).
[detto in parole spicciole: ti riunisce tutti gli elementi appartenenti ai due insiemi/containers ma non all'intersezione dei  due insiemi/ containers]
ESEMPIO DI OUTPUT 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a3 contains: 4 5 6 11 15
	set_symmetric_difference of a1 and a3 is: 1 2 3 7 8 9 10 11 15
--------------------------------------------------------------------
>> set_union algorithm
[pag719 deitel]
 64    // determine elements that are in either or both sets
 65    auto result4 = set_union( a1.cbegin(), a1.cend(),
 66       a3.cbegin(), a3.cend(), unionSet.begin() );
Lines 65-66 use the set_union algorithm to create a set of all the elements that are in either or both of the two sorted sets (both sets of values must be in ascending order). The elements are copied from both sets into the fifth argument (in this case the array unionSet)
ESEMPIO DI OUTPUT 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a3 contains: 4 5 6 11 15
	set_union of a1 and a3 is: 1 2 3 4 5 6 7 8 9 10 11 15
----------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> INCLUDE "" vs INCLUDE <> [pag66 moo book]
supponi di avere 
	#include "median.h"
	#include <vector>
Quando we use a #include directive with double quotes rather than angle brackets, surrounding the header name, we are saying that we want the compiler to copy the entire contents of the header file that correpsonds to that name into your program in place of the # include@@directive.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STRUCTURES VS CLASSES [deitel pag880]  + pag 160 moo book
The only differences between structures and classes in C++ is that 
	structures members default to public access and 
	class members default to private access 
when no access specifiers are used and that 
	structures default to public inheritance whereas
	classes default to private inheritance. 
The presentation you find at pag881 et seguenti are included for the benefit of those who will work with legacy C and C++ code 
note : >> legacy C = il C usato in precendenza. In ambito informatico >> legacy = utilizzato in precedenza. 
Nel capitolo trovi discussi 
>> bitwise operators that allow you to access and manipulate the individual bits in bytes of data.
>> bitfields = special structures that can be used to specify the exact number of bits a variable occupies in memory. 
These bit manipulation techinques are common in programs that interact directly with hardware devices that have limited memory. 
-------------
Structures Definitions 
Consider the following structure definition 
	struct Card
	{
		string face;
		string suit;
	}; // end struct Card
Keyword struct introduces the definition for structure Card. The identifier Card is the structure name and is sued in C++ to declare variables of the structure type. Card's definiton contain two string members "face" and "suit"
The following declarations :
	Card oneCard;
	Card deck [ 52 ];   // ricordo da Mike che il deck = mazzo di 52 carte appunto
	Card *cardPtr;
declare oneCard to be a structure variable of type Card, deck to be an array with 52 elements of type Card and cardPtr to be a pointer to a Card structure. Variables of a given structure type can also be declared by placing a comma separated list of the variable names between the closing brace of the structure definition and the semicolon that ends the structure definition. For example the preceding declarations could have been incorporated into the Card definition as follows:
 	struct Card
	{
		string face;
		string suit;
	}; oneCard, deck[ 52 ], *cardPtr;
As with classes, structures members are not necessarily stored in consecutive bytes of memory. Sometimes there are holes in a structure, because some computers store specific data types only on ceratin memory boundaries for performance reasons, such as half word, word or double word boudaries.
>> WORD = a word is a standard memory unit used to store data in a computer, usually two, four or eight bytes an typically eight bytes on today's (@2015 suppongo che per te che leggi sarai gia' al quantum computer :) popular 64bit
--------------------------------------------------------------------------------------------
>> typedef [deitel pag882]
keyword typedef provides a mechanism for creating synonyms (or >> aliases) for previously defined data types. Names for structure types are often defined with typedef to more readable type names. For example, the statement
	typedef Card *CardPtr;
defines the new type name CardPtr as a synonym for type Card *.
Creating a new name with typedef does not create a new type; typedef simply creates a new type name that can then be used in the program as an alias for an existing type name. 
>> typedef example from pag 53 jesse
// Demonstrates typedef keyword
#include <iostream>
  
typedef unsigned short int USHORT;   //typedef defined
  
int main()
{
  
   using std::cout;
   using std::endl;
  
   USHORT  Width = 5;   // e typare "USHORT" al posto di "unsigned short in" e' molto piu' comodo, veloce e meno error-prone
   USHORT Length;
   Length = 10;
   USHORT Area  = Width * Length;
   cout << "Width:" << Width << "\n";
   cout << "Length: "  << Length << endl;
   cout << "Area: " << Area <<endl;
   return 0;
}
//////////////////////////////////////////////////////////////////////////////////////
--------------------------------------------------------------------------------------------
>> BYTE = 8 bits
from pag 812 jesse: Because early computers could send eight bits at a time, it was natural to start writring code using 8-bit numbers called bytes.
TRICK se sei in dubbio su Byte 4 or 8 bits. 
Sono 8 bit di cui hai bisogno perche' per un buon bite (morso) hai bisogno di almeno 4 denti sopra e 4 denti sotto.
--------------------------------------------------------------------------------------------
>> BITWISE OPERATORS [deitel pag885] C++ provides extensive bit-manipulation capabilities for getting down to the so called bits and bytes level. Operating systems, test equipment software, networking software and many other kinds of software require that you communicate "directly with the hardware". The book introduce each of the bitwise operators, and discuss how to save memory using bit fields.
All data is represented internally by computers as sequences of bits. Each >> bit can assume the value 0 or the value 1. On most systems, a sequence of eight bits, each of which forms a >> byte (= 8 bits) the standard storage unit for a variable of type char. 
NOTE: bitwise data manipulations are machine dependent.
The bitwise operators are
	&
	|
	^
	<<
	>>
	~
where
	& = bitwise AND
	| = bitwise inclusive OR
	^ = bitwise exclusive OR
	<< = left shift
	>> = right shift
	~ = bitwise complement
The bitwise AND, bitwise inclusive OR and bitwise exclusive OR operators compare their two operand bit by bit.
	& bitwise AND operator sets each bit in the result to 1 if the corresponding bit in both operands is 1.
	| bitwise inclusive OR operator sets each bit in the result to 1 if the corresponding bit in either (or both) operand(s) is 1.
	^ bitwise exclusive OR operator sets each bit in the result to 1 if the corresponding bit in either operand (BUT NOT both) is 1.
	<< the left shift operator shifts the bits of its left operand to the left by the number of bits specified in its right operand.
	>> the right shift operator shifts the bits in its left operand to the rigth by the number of bits specified in its right operand
	~ the bitwise complement operator sets all 0 bits in its operand to 1 in the result and set all 1 bits in its operand to 0 in the result.
-------------------------------------------------------------------------------------------------------------- mettiamo  in forma le precedenti frasi in una tabella
OPERATOR    NAME                  DESCRIPTION
&           bitwise AND           the bits in the result are set to 1 if the corresponding bits in the 2 operands are both 1
|           bitwise inclusive OR  the bits in the result are set to 1 if one or both of the corresponding bits in the 2 operands is 1
^           bitwise exclusive OR  the bits in the result are set to 1 if exactly one of the corresponding bits in the 2 operands is 1
<<          left shift            shifts the bits of the first operand left by the number of gits specified by the second operand; fill from right with 0 bits
>>          right shift with sign extension     Shifts the bits of the first operand right by the number of bits specified by the second operand; the method of filling from the left is machine dependent
~           bitwise complement    all 0 bits are set to 1 and all 1 bits are set to 0
---------------------------------------------------------------------------------------------------------------
EXAMPLES 
>> BINARY REPRESENTATION PRINT OF INTEGRAL VALUE [pag886 deitel]
// Fig. 22.6: fig22_06.cpp
// Printing an unsigned integer in bits.
#include <iostream>
#include <iomanip>
using namespace std;

void displayBits( unsigned ); // prototype

int main()
{
   unsigned inputValue = 0; // integral value to print in binary

   cout << "Enter an unsigned integer: ";
   cin >> inputValue;
   displayBits( inputValue );
} // end main

// display bits of an unsigned integer value
void displayBits( unsigned value )
{
   const int SHIFT = 8 * sizeof( unsigned ) - 1;
   const unsigned MASK = 1 << SHIFT;      // >> MASK qui trovi un esempio di utilizzo di MASK [pag887deitel]: often the bitwise AND operator is used with an operand called a mask (= an integer value with specific bits set to 1). Masks are used to hide some its in a value while selecting other bits.

   cout << setw( 10 ) << value << " = ";

   // display bits
   for ( unsigned i = 1; i <= SHIFT + 1; ++i ) 
   {
      cout << ( value & MASK ? '1' : '0' );
      value <<= 1; // shift value left by 1

      if ( i % 8 == 0 ) // output a space after 8 bits
         cout << ' ';
   } // end for

   cout << endl;
} // end function displayBits
--------------------------------------------------------------------------------------------------
>> BITWISE ASSIGNMENT OPERATORS [pag893 deitel]
&= 	bitwise AND assignment operator
|=	bitwise inclusive OR assignment operator
^=	bitwise exclusive OR assignment operator
<<=	left shift assignment operator
>>=	right shift with sign extension assignment operator
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> protection labels [pag160 moo book]
Per protection labels si intendono le labels tipo 
	public:
o anche
	private:
Each protection label defines the accessibility of all the member that follow the label. Label can occur in any order within the class , and can occur in any order within the class, and can occur multiple times.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> struct [pag61-62 moo book]
Nell'esempio qui sotto trovi
	struct Student_info {
		string name;
		double midterm, final;
		vector<double> homework;
	};	// note the semicolon--it's required
This struct definition says that Student_info is a type, which has four data members. Because Student_info is a type, we can define objects of that type, each of which will contain an instance of these four data members.
Each object of Student_info type holds information about one student. Because Student_info is a type, we can use a vector <Student_info> object to hold information about an arbitrary number of students, just as we used a vector<double> object to hold an arbitrary number of nomework grades. [cioe' cosi' come di solito hai dei vettori di double, ora avrai un vettoeri con degli elementi di type custom, degli elementi ciascuno dei quali contiene multipli elementi. Se espandessi il tutto ti ritrovi di fatto con una matrice.]
ADDITIONAL OBSERVATION from pag 72 moo book
A structure is a type that contains zero or more members. Each object of the structure type contains its own instance of each of its members. Every structure msut have a corresponding definition:
	struct type-name {
		type-specifier member-name;
		...
	};   // note the semicolon
Like all definitions, a structure definition nay appear only once per source file, so it should normally appear in a aproperly guarded header file.
------------------------------------------------------------------------------------------------------------[full program from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc]
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

#ifdef _MSC_VER
#include "../minmax.h"
#else
using std::max;
#endif

using std::cin;
using std::cout;
using std::domain_error;
using std::endl;
using std::istream;
using std::ostream;
using std::setprecision;
using std::setw;
using std::sort;
using std::streamsize;
using std::string;
using std::vector;

struct Student_info {
	string name;
	double midterm, final;
	vector<double> homework;
};	// note the semicolon--it's required

// compute the median of a `vector<double>'
// note that calling this function copies the entire argument `vector'
double median(vector<double> vec)
{
#ifdef _MSC_VER
	typedef std::vector<double>::size_type vec_sz;
#else
	typedef vector<double>::size_type vec_sz;
#endif

	vec_sz size = vec.size();
	if (size == 0)
		throw domain_error("median of an empty vector");

	sort(vec.begin(), vec.end());

	vec_sz mid = size/2;

	return size % 2 == 0 ? (vec[mid] + vec[mid-1]) / 2 : vec[mid];
}

// compute a student's overall grade from midterm and final exam grades and homework grade
double grade(double midterm, double final, double homework)
{
	return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

// compute a student's overall grade from midterm and final exam grades
// and vector of homework grades.
// this function does not copy its argument, because `median' does so for us.
double grade(double midterm, double final, const vector<double>& hw)
{
	if (hw.size() == 0)
		throw domain_error("student has done no homework");
	return grade(midterm, final, median(hw));
}

double grade(const Student_info& s)
{
	return grade(s.midterm, s.final, s.homework);
}

// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}

istream& read(istream& is, Student_info& s)
{
	// read and store the student's name and midterm and final exam grades
	is >> s.name >> s.midterm >> s.final;

	read_hw(is, s.homework);  // read and store all the student's homework grades
	return is;
}

bool compare(const Student_info& x, const Student_info& y)
{
	return x.name < y.name;
}

int main()
{
	vector<Student_info> students;
	Student_info record;
	string::size_type maxlen = 0;

	// read and store all the records, and find the length of the longest name
	while (read(cin, record)) {
		maxlen = max(maxlen, record.name.size());
		students.push_back(record);
	}

	// alphabetize the records
	sort(students.begin(), students.end(), compare);

#ifdef _MSC_VER
	for (std::vector<Student_info>::size_type i = 0;
#else
	for (vector<Student_info>::size_type i = 0;
#endif
	     i != students.size(); ++i) {

		// write the name, padded on the right to `maxlen' `+' `1' characters
		cout << students[i].name
		     << string(maxlen + 1 - students[i].name.size(), ' ');

		// compute and write the grade
		try {
			double final_grade = grade(students[i]);
			streamsize prec = cout.precision();
			cout << setprecision(3) << final_grade
			     << setprecision(prec);
		} catch (domain_error e) {
			cout << e.what();
		}

		cout << endl;
	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> insert element in sorted sequence. >> sorted sequence element insertion
>> lower_bound / >> upper_bound / >> equal_range
[pag719 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_11/fig16_11.cpp
>> lower_bound algorithm 
[pag721 deitel]
 19    // determine lower-bound insertion point for 6 in a
 20    auto lower = lower_bound( a.cbegin(), a.cend(), 6 );
 21    cout << "\n\nLower bound of 6 is element "
 22       << ( lower - a.cbegin() ) << " of array a";
line 20 uses the lower_bound algoirthm to find the first location in a sorted sequence of values at which the third argument could be inserted in teh sequence such that the sequence would still be sorted in ascending order. The first two iterator arguments must be at least forward iterators. The third argument is the vlue for which to determine the lower bound. The algorithm returns a forward iterator pointing to the position at which the insert can occur. [pretty koool!!] A second version fo lower_bound takes as fourth argument a binary predicate function indicating the order in which the elements were originally sorted. 
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8	
	Lower bound of 6 is element 5 of array a
Ciccio spiegazione spicciola 
	element position 0 1 2 3 4 5 6 7 8 9
	element value    2 2 4 4 4 6 6 6 6 8
Quindi la prima posizione in cui potrai inserire il valore 6 in modo che una volta inserito la sequenza sia ancora in ordine, e' la posizione 5.
-----------------------------------------------------------------------
>> upper_bound algorithm
 24    // determine upper-bound insertion point for 6 in a
 25    auto upper = upper_bound( a.cbegin(), a.cend(), 6 );
 26    cout << "\nUpper bound of 6 is element "
 27       << ( upper - a.cbegin() ) << " of array a";
Line 25 uses the upper_bound algorithm to find the last location in a sorted sequence of values at which the third argument could be inserted in the sequence such that the sequence would still be sorted in ascending order. The first two iteartor arguments must be at least forward itearators. The third argument is the value for which to determine the upper bound. The algorithm returns a forward iteartor pointing to the position at which the insert can occur. 
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8
	Upper bound of 6 is element 9 of array a
Ciccio spiegazione spicciola 
	element position 0 1 2 3 4 5 6 7 8 9
	element value    2 2 4 4 4 6 6 6 6 8
L'ultima posizione in cui puoi inserire un 6, in modo che la sequenza resti ancora sorted, e' la posizione 9
-----------------------------------------------------------------------
>> equal_range algorithm 
[pag721 deitel]
 29    // use equal_range to determine both the lower- and 
 30    // upper-bound insertion points for 6
 31    auto eq = equal_range( a.cbegin(), a.cend(), 6 );
 32    cout << "\nUsing equal_range:\n   Lower bound of 6 is element "
 33       << ( eq.first - a.cbegin() ) << " of array a";
 34    cout << "\n   Upper bound of 6 is element "
 35       << ( eq.second - a.cbegin() ) << " of array a";
 36    cout << "\n\nUse lower_bound to locate the first point\n"
 37       << "at which 5 can be inserted in order";
Line 31 uses the equal_range algorithm to return a pair of forwar iterators containing the results of performing both a lower_bound and an upper_bound operation. The first two argument must be at least forward iterators. The third is the value for which to locate the equal range. The algorithm returns a pair of forward iterators for the lower bound (eq.first) and upper bound (eq.second) respectively.
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8
	Using equal_range:
	   Lower bound of 6 is element 5 of array a
	   Upper bound of 6 is element 9 of array a
--------------------------------------------------------------
Algorithms lower_bound, upper_bound and equal_range are often used to locate insertion points in sorted sequences. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> setfill 
[pag382 e esempio a pag381 line 35 deitel]
setfill is a stream manipulator useful to specify the fill character that's displayed when an integer is output in a field wider than the number of digits in the value.
Example 
   cout << setfill( '0' ) << setw( 2 ) << hour << ":" 
      << setw( 2 ) << minute << ":" << setw( 2 ) << second;
il setfill ('0') fa si' che un ora espressa in ore:minuti:secondi
- if the number being output fills the specified field, the fill character will not be displayed
	quindi per esempio 17:32:27 resta -> 17:32:27
- if the number being output do not fill the specified field allora verra' aggiunto uno zero visto che il fill character e' stato specificato to '0' . The fill characters appear to the left of the digits in the number, because the number is right alighed by default (for left aligned values the fill characters would appear to the right).
	quindi per esempio l'ora 7:08:9 diventa 07:08:09
NOTE: once the fill character is specified with setfill, it applies for all subsequent values that are displayed in fields wider than the value being displayed. setFill is a >> sticky setting . This in contrast to setw, which applied only to the next value displayed (setw is a non sticky setting)
NOTE2: each sticky setting (such as a fill character or floating point precision) should be restored to its previous setting when it's no longer needed. Failure to do so may result in incorrectly formatted ouput later in a program. 

>> setprecision 
[pag133deitel]
useful for formatting floating point number 
Example 
[from pag129deitel]
	cout << setprecision( 2 ) << fixed;
	cout << "Antigravitational field intensity is" << average << endl;
in tal modo la variabile average verra' printata con due cifre decimali dopo il punto decimale.
[nota come setprecision preceda la riga in cui compare la variabile di cui vuoi effettuare la formattazione]
A- Since setprecision requires a parameter (il due nelle parentesi) this call is referred as parameterized stream manipulator. Programs that use these calls must contain the proprocessing directive:
	#include <iomanip>
cioe l'       Input Output MANIPulator header
Manipulators come endl invece sono dei nonparameterized stream manipulator because it isn't followed by a value or expression in parentheses and does not required the <iomanip> header. 
B- the stream manipulator fixed indicates that floating-point values should be output on so-calledd fixed point format (ex: 127.76), as opposed to scientific notation (0.12776*10^3).
C- Specifying fixed-point formatting also forces the decimal point and trailing zeros to print, even if the value is a whole number amount, such as 76.00. Without the fixed-point formatting option, such a value prints in C++ as 88 without the trailing zeros and without the decimal point. When the stream manipulators fixed and setprecision are used in a program, the printed value is rounded to the number of decimal positions indicated by the value passed to setprecision, although the value in memory remains unaltered.
D- It is also possible to force a decimal point to appear by using stream manipulator showpoint. 
	showpoint
[pag133]
if showpoint is specified without fixed, then trailing zeros will not print.  

>> setw 
[pag167deitel]
example 
	cout << setw(4) << year << endl;
specifies that the next value output should appear in a field width of 4, i.e. cout prints the value with at least 4 character position wide
[ricorda un poco il -fN che si usava in gnuplot residuals per individuare il N-esimo field, solo che qui in sostanza cio' che si conta sono il numero di colonne a partire dal bordo sinistro.]
See also esempio pag 442deitel

>> sign / unsigned
Data types char, short, long and int can be either signed or unsigned. Signed  types can represent both positive and negative values, whereas unsigned types can only represent positive values (zero). 
ex
	unsigned short int NumberofStars;
	signed int MyAccountBalance;
NB if we do not specify either signed or unsigned most compiler settings will assume the type to be signed. 

>> SIGNATURE / FUNCTION SIGNATURE
[pag259deitel]
The portion of a function prototype that includes the name of the function and the type of its arguments is called the function signature (pag211deitel) or simply the signature.

>> .size()
utile per ottenere la lunghezza di una stringa ex 
	nomeParametroStringa.size()
[pag93deitel]
The C++ standard library's string class defines a member function size that returns the number of characters in a string object.  

>> short int = short integer, size 2 byte
signed: -32768 to 32767
unsigned: 0 to 65535

>> sizeof()
[pag350deitel]
This operator accepts one parameter, which can be either a type or a variable itself, and returns the size in bytes of that type or object; ex:
	a = sizeof (char);
this will assign the value 1 to a because char is a one-byte long type.
See also pag350deitel
the compile time unary operator sizeof determines the size in bytes of a built-in array or of any other data type, variable or constant during program compilation.
- when applied to a built-in array the sizeof operator returns the total number of bytes in the built-in array as a value of type size_t
- when applied to a pointer parameter in a function that receives a built-in array as an argument, the sizeof operator returns the size of the pointer in bytes, not the built-in array's size see fig8.13 pag351
ATTENTION: using the sizeof operator in a function to find the size in bytes of a built-in array parameter results in the size in bytes of a pointer, not the size in bytes of the built-in array.
EXAMPLE : determining the number of elements in a built-in array. Supponi di avere un built-in array "numbers", ne puoi determinare il numero di elementi usando il risultato di due sizeof operations:
	sizeof numbers / sizeof( numbers[ 0 ] )
the expression divides the number of bytes in "numbers" by the number of bytes in the built-in array's zeroth element resulting in the number of elements in "numbers". per esempio se "numbers" aveva 20 elementi => 8bytes * 20 = 160 bytes
sizeof "numbers" e' uguale a 160
mentre il size dell'elemento 0 di "numbers" e' pari 8bytes.
Quindi sizeof numbers / sizeof(numbers [ 0 ]) = 160 / 8 = 20
NOTE: PORTABILITY: the number of bytes used to store a particular data type may vary among systems. When writing programs that depends on data type sizes, always use "sizeof" to determine the number of bytes used to store the data types.
NOTE2: quand'e' che bisogna usare le parentesi con sizeof ? 
the parentheses used with sizeof are required only if a type name e.g. int is supplied as its operand. The parentheses used with sizeof are not required when sizeof's operand is an expression.
anche se riprendendo l'esempio sopra
	sizeof numbers / sizeof( numbers[ 0 ] )
non riesco al momento bene a capire, non sta usando le () con un espressione? itiaf

>> smooth function
http://jean-pierre.moreau.pagesperso-orange.fr/Cplus/smooth_cpp.txt
http://jean-pierre.moreau.pagesperso-orange.fr/c_signal.html


>> SOFTWARE ENGINEERING OBSERVATIONS 
- the most difficult part of solving a problem on a computer is developing the algorithm. Producing a working C++ program from the algorithm is typically straightforward. [pag118deitel]

>> SOURCE CODE vs OBJECT CODE
- what you write is the source code or program text 
extension : 
	*.cpp or *.h
- once the compiler translate your cpp into machine readable format you get the object code,  or executable with suffix 
	*.obj (in windows), or *.o (in Unix)

>> SORT 
	sort 
function to arrange the elements in an array into ascending order
[pag302deitel]
EXAMPLE pag 303
   const size_t arraySize = 7; // size of array colors
   array< string, arraySize > colors = { "red", "orange", "yellow",
      "green", "blue", "indigo", "violet" };
   // output original array
   cout << "Unsorted array:\n";
   for ( string color : colors )
      cout << color << " ";   
   sort( colors.begin(), colors.end() ); // sort contents of colors
[from file fig07_18.cpp]


>> split function / >> iterator adaptor example [pag103 moo book]
example in /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/split.cc
	#include <algorithm> // iterator adaptors are defined in <iterator>
	#include <cctype>
	#include <string>
	#include <vector>
	
	#include "split.h"
	
	using std::find_if;
	using std::string;
	using std::vector;
	
	#ifndef _MSC_VER
	using std::isspace;
	#endif
	
	// `true' if the argument is whitespace, `false' otherwise
	bool space(char c)
	{
		return isspace(c);
	}
	
	// `false' if the argument is whitespace, `true' otherwise
	bool not_space(char c)
	{
		return !isspace(c);
	}
	
	vector<string> split(const string& str)
	{
		typedef string::const_iterator iter;  // we sue typedef to abbreviate the iterator type, so that we can use "iter" instead of the longer "string::const_iterator " 
		vector<string> ret;
	
		iter i = str.begin();
		while (i != str.end()) {
	
			// ignore leading blanks
			i = find_if(i, str.end(), not_space);  // using the algorithm find_if
/*
>> find_if : this algorithm requires 3 arguments. Its first two arguments are iterators that denotes a sequence; the third is a predicate, which tests its argument and returns true or false. The find_if function calls the predicate on each element in the sequence, stopping when it finds an element for which the predicate yields true.
*/
	
			// find end of next word
			iter j = find_if(i, str.end(), space);
	
			// copy the characters in `[i,' `j)'
			if (i != str.end())
				ret.push_back(string(i, j));
			i = j;
		}
		return ret;
	}
////////////////////////////////////////////////////////////////////////////////////////////////

>> SPLIT LINE using whitespace as delimiter 
[http://stackoverflow.com/questions/236129/split-a-string-in-c]
	#include <vector>
	#include <string>
	#include <sstream>
	
	using namespace std;
	
	int main()
	{
	    string str("Split me by whitespaces");
	    string buf; // Have a buffer string
	    stringstream ss(str); // Insert the string into a stream
	
	    vector<string> tokens; // Create vector to hold our words
	
	    while (ss >> buf)
	        tokens.push_back(buf);
	}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STANDARD LIBRARY ALGORITHMS
[pag691 deitel]
The Standard Library provides over 90 algorithms [@2015]. [-> pag 731-732 deitel raccoglie una lista dei piu' essenziali]
The complete list can be found in Section 25 and 26.7 deitel of the C++ standard document and there are various online references where you can learn about each algorithm, such as 
	en.cppreference.com/w/cpp/algorithm
	msdn.microsoft.com/en-us/library/yah1y2x8.aspx
Most of them use iterators to access container elements. Various algorithms can receive a function pointer ( apointer to a function's code) as an argument. Such algorithm use the pointer to call the function (typically with one or two container elements as arguments).
--------------------------------
>> Minimum Iterator Requirements
With few exceptions, the Standard Library separates algorithms from containers. This makes it much easier to add new algorithms. An important part of every container is the type of iterator it supports. This determines which algorithms can be applied to the container. For example, bith vectors and arrays support random access iterators.
All Standard Library algorithms can operate on vectors and the ones that do not modify a container's size can also operate on arrays. 
Each Standard Library algorithm that takes iterator arguments requires those iterators to provide a minimum level of functionality. If an algorithm requires a forward iterator, for example, that algorithm can operate on any ocntainer that supports forward iterators, bidirectional iterators or random-access iterators.
OBSERVATION: standard library algorithms do not depend on the implementation details of the containers on which they operate. As long as a container's (or built-in array's) iterators satisfy the requirements of an algorithm, the algorithm can work on the container.
PORTABILITY: bacause standard library algorithms process containers only indirectly through iterators, one algorithm can often be used with many different containers.
OBSERVATION2: the standard library containers are implmented concisely. The algorithms are separted from the containers and operate on elements of the containers only indirectly through iterators. This separation makes it easier to write generic algorithms applicable to a variety of container classes
OBSERVATION3: using the "weakest iterator" that yields acceptable performance helps produce maximally resusable components. For example, if an algorithm requires only forward iterators, it can be used with any container that support forward iterators, bidirectional iterators or random-access iterators. However, an algorithm that requires random-access iterators can be used only with containers that have random-access iterators.
>> ITERATORS INVALIDATION / >> INVALIDATION ITERATORS / >> INVALID ITERATORS
[pag692 deitel]
Iteartors simply point to container elements, so it's possible for iterators to become invalid when certain container modifications occur. 
For example if you invoke clear on a vector, all of its elements are removed. Of a program had any iterators that pointed to that vector's elements before clear was called, those iterators would now be invalid 
Iterators are invalidated during insert and erase operations when:
1) when inserting into a : 
- vector : if the vector is reallocated, all iterators pointing to that vector are invalidated. Otherwise, iterators from the insertion point to the end of the vector are invalidated. 
- deque : all iteartors are invalidated
- list or forward_list : all iterators remain invalid.
- ordered associative container : all iterators remain invalid 
- unordered associative container : all iterators are invalidated if the container need to be reallocated. 
2) when erasing from a container, iterators to the erased elements are invalidated. in addition 
- vector : iteratos from the erased element to the end of the vector are invalidated
- deque : if an element in the middle of he deque is erased, all iterators are invalidated. 
Qui di seguito ti scrivo gli algoritmi presentati nelle pagine 693 deitel e segg. 
--------------------------------------------------------------------------------
>> fill / >> fill_n / >> generate / >> generate_n 
[pag 693 deitel]
Algorithms fill and fill_n set every element in a range of container elements to a specific value. 
Algorithms generate and generate_n use a >> generator function to create values for every element in a range of container elements. 
The generator function takes no arguments and returns a value that can be placed in an element of the container.
example in /home/dia/Deitel-Code_Examples/ch16/fig16_01/fig16_01.cpp
- Nell'esempio si crea un array di 10 elementi char e quindi li si sostituisce (usando fill) ciascun elemento con l'elemento char "5".
	fill( chars.begin(), chars.end(), '5' ); // fill chars with 5s 
- fill_n algorithm usato per specificare il numero di carattere da sostituire
	fill_n( chars.begin(), 5, 'A' );
la precedente line uses the fill_n algorithm to place the character "A" in the first five elements of chars. The iterator supplied as the fist argument must be at least an output iterator (i.e. it can be used to write into a container in the forward direction). The second argument specifies the number of elements to fill. The third argument spedicies the value to place in each element.
---------------------------------------------------------------------------------
A note about reading standard library algorithm documentation / >> DOCUMENTATION ALGORITHM NOTE / >> ALGORITHMS DOCUMENTATION NOTE / >> ALGORITHM DOCUMENTATION NOTE
[pag695 deitel]
When you look at the standard library algorithms documentation for algorithms that can receive function pointers as arguments, you'll notice in the documentation that the corresponding parameters do not show pointer delcarations. Such parameters can actually receive as arguments function pointers, function objects or lambda expressions. For this reason, the Standard Library declares such parameters using more generic names. 
For example the generate algorithm's prototype is listed in teh C++ standard document as 
	template<class ForwardIterator, class Generator>
	void generate(ForwardIterator first, ForwardIterator last,
		Generator gen);
indicating that generate expects as arguments ForwardIterators representing the range of elements to process and a Generator function. The standard explains that the algorithm calls the Generator function to obtain a value for each element in the range specified by the ForwardIterators. The standard also specifies that the Generator must take no arugments and return a value of teh element type. 
Similar documentation is provided for each algorithm that can receive a function pointer, function object or lambda expression. 
----------------------------------------------------------------------------------
>> equal / >> mismatch / >> lexicographical_compare
[pag695 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_02/fig16_02.cpp
>> equal algorithm to compare two sequences of values for equality. The second seqeunce must contain at least as many elements as the first (equal returns false if the sequences are not of the same length). The == operator (whether built-in or overloaded) performs the element comparisons.
Another version of equal takes a binary predicate function as a fourth parameter. The binary predicate function receives the two elements being compared and returns a bool value indicating whether the elements are equal. This can be useful in sequences that store objects or pointers to values rather than actual values, because you can define one or more comparisons. 
>> mismatch Algorithm [pag697 deitel]
Use mismatch algorithm to compare two sequences of values. The algorithm returns a pair of iterators indicating the location in each sequence of the mismatched elements. If all the elements match, the two iterators in the pair are equal to the end iterator for each sequence. The three iterator arguments must be at least input iterators.
   // check for mismatch between a1 and a3    
   // home/dia/Deitel-Code_Examples/ch16/fig16_02/fig16_02.cpp                  
   auto location = mismatch( a1.cbegin(), a1.cend(), a3.cbegin() );
   cout << "\nThere is a mismatch between a1 and a3 at location "
      << ( location.first - a1.begin() ) << "\nwhere a1 contains " 
      << *location.first << " and a3 contains " << *location.second  
      << "\n\n";
>> lexicographical_compare algorithm [pag697 deitel]
Use the lexicographical_compare algorithm to compare the contents of the two char built-in arrays. This algorithm's four iterator arguments must be at least input iterators. 
The first two iterators arguments specify the range of locations in the first sequence. The last two specify the range of locations in the second sequence. We use the C++11 begin and end functions to determine the range of elements for each built-in array. While iterating through the sequences, the lexicographical_compare checks if the element in the first sequence is less than the corresponding element in the second sequence. If so, the algorithm returns true. If the element in the first sequence is greater than or equal to the element in the second sequence, the algorithm returns false. This algorithm can be used to arrange sequences lexicographically. Typically, such sequences contain strings.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STL / >> standard template library or STL 
[639 deitel] also pag109 mike game programming.
THe STL was developed by Alexander Stepanov and Meng Lee [gia' allora funzionava bene il famoso asse sino-sovietico] at Hewlett-Packard and is based on their generic programming research, with significant contribution from David Musser [si Germany pure]
We'll occasionally refer to these features as the STL. In the C++ standard document, these features are simply referred to as part of the C++ Standard Library.
Three key components of the Standard Library are :
1) containers = data structures capable of storage objecdts of almost any data type
		there are 3 types of containers
		- first class containers 
		- container adapter 
		- near containers 
2) iterators
	Iterators have properties similar to those of pointers. They are used to manipulate container elements. Built-in arrays also can be manipulated by Standard Library algorithms, using pointers as iterators. Manipulating containers with iterators is convenient and provides tremendous expressive power when combined with Standard Library algorithms, in some cases reducing many lines of code to a single statement.
3) algorithms
	Standard library algorithms are function templates that performs such commondata manipulations as searching, sorting, and comparing elements or entire containers. Most of these algorithms use iterators to access container elements. Iterators encapsulate the mechanisms used to access container elements. This encapsulation enables many of the algorithms to be applied to various containers independently of the underlying container implementation. This also enables you to create new algorithms that can process the elements of multiple container types.
SUSUME: 
- avoid reinventing the wheel; program with teh components of the C++ Standard library
- the prepackaged, templatized Standard Library containers are sufficient for most applications. Using the Standard Library helps you reduce testing and debugging time
- the standard library was conceived  and designed for performance and flexibility
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STANDARD LIBRARY CONTAINER CLASSES AND CONTAINER ADAPTERS / >> CONTAINERS
[pag 640 deitel]
the standard library container types are divided into four major categories 
A) SEQUENCE CONTAINERS
B) ORDERED ASSOCIATEIVE CONTAINERS
C) UNORDERED ASSOCIATIVE CONTAINERS 
D) CONTAINER ADAPTERS
------------------------------------------
A) SEQUENCE CONTAINERS [= represent linear data structures, all their elements are conceptually lined up in a row]
	array              : fixed size. Direct access to any element. 
    deque              : rapid insertions and deletions at front or back. Direct access to any element
	forward_list       : singly linked list, rapid insertion and deletion anywhere. from C++11 and up
	list               : doubly linked list, rapid insertion and deletion anywhere
	vector             : rapid insertions and deletion at back. Direct access to any element.
B) ORDERED ASSOCIATIVE CONTAINERS 
	set                : rapid lookup, no duplicates allowed
	multiset           : rapid lookup, duplicates allowed
	map                : one to one mapping, no duplicates allowed, rapid key based lookup
	multimap           : one to many mapping, duplicates allowed, rapid key-based lookup
C) UNORDERED ASSOCIATIVE CONTAINERS 
	unordered_set      : rapid lookup, no duplicates allowed
	unordered_multiset : rapid lookup, duplicates allowed
	unordered_map      : one to one mapping no duplicates allowed, rapid keybased lookup
	unordered_multimap : one to many mapping duplicates allowed, rapid key based lookup
D) CONTAINER ADAPTERS
	stack              : last-in, first-out (LIFO)   [>> LIFO tag]
	queue              : first-in, first out (FIFO)  [>> FIFO tag]
	priority_queue     : highest priority element is always the first element out
NOTE: 
- Sequence containers represent linear data structures, all their elements are conceptually lined up in a row
- Associative containers are nonlinear data structures that typically can locate elements stored in the containers quickly. 
per >> key value pairs / >> first class containers / >> container adpaters / >> near containers
see pag 641 deitel
>> TABLE COMMON MEMBER FUNCTIONS FOR MOST STANDARD LIBRARY CONTAINERS / >> STANDARD LIBRARY CONTAINERS COMMON MEMBER FUNCTIONS
ti scrivo qui giusto le parole chiave : per la loro definizione vedi pag 642 deitel
>> default constructor 
>> copy constructor
>> move constructor
>> destructor
>> empty 
>> insert 
>> size 
>> size 
>> copy operator=
>> move operator=
>> operator<
>> operator<=
>> operator>
>> operator>=
>> operator==
>> operator!=
>> swap
>> max_ size        : returns the maximum nuber of elements for a container
>> begin 
>> end 
>> cbegin
>> cend
>> rbegin
>> rend
>> crbegin
>> crend
>> erase            : removes one or more elements from the container
>> clear            : removes all elements from the container
[pag 642 deitel]
>> FIRST CLASS CONTAINER NESTED TYPES / >> NESTED TYPES FIRST CLASS CONTAINER
[pag 643 deitel]
comon first class container nested = types defined insdie each container class definition. For example value_type in each container always repreesnts the type of elements stored in the container.
riferisciti alla pagina 643 deitel per il significato dei seguenti nested types:
>> allocator_type
>> value_type
>> reference 
>> const_reference
>> pointer
>> const_pointer
>> iterator
>> const_iterator
>> reverse_iterator
>> const_reverse_iterator
>> difference_type
>> size_type
//////////////////////////
>> ITERATORS / >> INTRODUCTION TO ITERATORS 
[pag644 deitel]
Iterators have many similarities to pointers and are used to point to first class containers elements and for other purposes.
An object of a container's iterator type referes to a container element that can be modified. An object of a container's const_iterator type refers to a container element that cannot be modified.
Keywords explained @ pages 644 645 deitel
>> begin = function that the returns an iterator pointing to the first element of the container 
>> end = function that returns an iterator pointing to the first element past the end of the container.
>> istream_iterator
>> ostream_iterator  [a si' quello che abbiamo usato nel NEC feaMapper per far l'output in ascii delle coordinate]
>> sequences also called >> ranges
NOTE: istream_iterator and ostream_iterator can be used with the Standard Library algorithms to create powerful statements. For example, you can use an ostream_iterator with the copy algorithm to copy a container's entire contnets to the standard output stream with a single statement.
pag 645 deitel : example of >> dereference an iterator 
NOTE pag 646: notice that we use the dereferenced outputInt iterator as an lvalue in the assignment statement. If you want to output another value using outpuInt, the iterator must be incremented with ++ first. Either the prefix or postfix increment can be used (we use the prefix form for performance reasons becuase it does not create a temporary object.)
>> ITERATOR CATEGORY [pag646 deitel]
        random access
			 |
        bidirectional
		     |
		  forward
        |        |
      input     output
where the random access is the most powerful iterator type, input and output the weakest iterator type. In fact in the above hierarchy scheme, each iterator category supports all the functionality of the categories below. [cioe' random access supportera' tutte le funzionalita' del bidirectional iterator]
Category               Description 
-  random access       combines the capabilities of a bidirectional iterator with the ability to directly access any elment of the container, i.e. to jump forward or backward by an arbitrary number of elements. 
- bidirectional        combines the capabilities of a forward iterator with the ability to move in the backward direction (i.e. from the end of the container toward the beginning)
- forward              combines the capabilities of input and output iterators and retains their position in the container (as state information). Such iterators can be used to pass through a sequence more than once (for so called >> multipass algorithm)
- output               used to write an elmeent to a container. An output iterator can move only in the forward direction one element at a time. output iterators support only one-pass algorithms (the same output iterator cannot be used to pass through a sequence twice) 
- input                used to read an lement from a container. An input iterator can move only in the forward direction (i.e. from the beginning of the container to the end). one element at a time. Input iterators support only one-pass algorithms (the same input iterator cannot be used to pass through a sequence twice) 
>> ITERATOR TYPES SUPPORTED by EACH CONTAINER [table pag 647deitel]
The iterator category that each container supporta determines whether that container can be used with specific algorithms. Containers that support random access iterators can be used with all Standard Library Algorithms.
- Seuqence containers (first class)
vector         random access 
array          random access
deque          random access
list           bidirectional
forward_list   forward
- Ordered associative containers (first class) 
set            bidirectional
multiset       bidirectional
map            bidirectional
multimap       bidirectional
- Unordered associative containers (first class)
unordered_set  bidirectional
unordered_multiset bidirectional
unordered_map  bidirectional
unordered_multimap bidirectional
- Container adapters
stack          none
queue          none 
priority_queue none
-----------------------------------
>> ITERATOR typedef / >> predefined iterator typedef
[pag 647deitel]
Predefined typedefs for iterator types    Direction of ++     Capability
iterator                                  forward             read/write
const_iterator                            forward             read
reverse_iterator                          backward            read/write
const_reverse_iterator                    backward            read
\\\\\\\\\\\\\\\\\\\\\\\\
>> Iterator Operations
[pag 648 deitel]
> All iterators
++p             preincrement an iterator
p++             postincrement an iterator
p = p1          assign one iterator to another
> Input iterators 
*p              dereference an iterator as an rvalue
p->m            use the iterator to read the element m
p == p1         compare iterators for equality
p != p1         compare iterators for inequality
> Output iterators
*p              dereference an iterator as an lvalue
p = p1          assign one iterator to another
> Forward iterators
Forward iterators provide all the functionality of both input iterators and output iterators.
> Bidirectional iterators
--p             predecrement an iterator
p--             postdecrement an iterator
> Random-access iterators
p += i          increment the iterator p by i positions
p -= i          decrement the iterator p by i positions
Per la spiegazione delle seguenti operations ti rimando direttamente a pagina649deitel
	p + i or i + p
	p - i
	p - p1
	p[ i ]
	p < p1
	p <= p1
	p > p1
	p >= p1
--------------------------------------------------------------------------------------
>> CONTAINER [pag 109 mike game programming]
Containers let you store and access collections of values of the same type. Arrays let you do the same thing, but the STL containers offer more flexibility and power than an simple but trusty array. The algorithms defined in the STL work with its containers. 
The >> algorithms are common functions that game programmers find themselves repeatedly applying to groups of values. They include algorithms for sorting, searching, copying, merging, inserting, and removing container elements. The cool thing is that the same algorithm can work its magic on many different container types.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> searching and sorting algorithm / >> sorting algorithm / >> algorithm sorting / >> algorithm search / >> search algorithm / >> sort algorithm
[pag706 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_06/fig16_06.cpp
>> find algorithm
	 20    // locate first occurrence of 16 in a
	 21    auto location = find( a.cbegin(), a.cend(), 16 );
line 21 uses the find algorithm to locate the value 16 in the range from a.cbegin() up to, but not including a.cend(). 
>> find_if
	 36    // locate first occurrence of value greater than 10 in a
	 37    location = find_if( a.cbegin(), a.cend(), greater10 );
line 37 uses the find_if algorithm (a linear search) to locate the first value in the range from a.cbegin() up to, but not including a.cend() for which the unary predicate function greater10 returns true. greater10 altri non e' che una funzione che viene definita nelle righe 93-96
	 92 // determine whether argument is greater than 10
	 93 bool greater10( int value )
	 94 {
	 95    return value > 10;
	 96 } // end function greater10
Nota come le righe 36 37 doneranno in output:
	The first value greater than 10 is 17
	found at location 2   
(cioe' la terza posizione, si conta a partire da zero)
///////////////////////////////////////////////////////////////////////////////
>> sort algorithm 
[pag 709 deitel]
 45    // sort elements of a
 46    sort( a.begin(), a.end() );
 47    cout << "\n\narray a after sort: ";
Line 46 use sort algorithm to arrange the lements in the range from a a.bing() up to, but not including a.end() in ascending order. The algorithm requires its two iterator arguments to be random-acess iterators. 
///////////////////////////////////////////////////////////////////////////////
>> binary_search algorithm
[pag 709 deitel]
	 50    // use binary_search to locate 13 in a
	 51    if ( binary_search( a.cbegin(), a.cend(), 13 ) )
	 52       cout << "\n\n13 was found in a";
	 53    else
	 54       cout << "\n\n13 was not found in a";
Line 51 uses the binary_search algorithm to determine whether the value 13 is in the range from a.cbegin() up to , but not including a.cend(). The values must be sorted in ascending order. 
>> all_of algorithm
[pag 709 deitel]
	 62    // determine whether all of the elements of a are greater than 10
	 63    if ( all_of( a.cbegin(), a.cend(), greater10 ) )
	 64       cout << "\n\nAll the elements in a are greater than 10";
line 63 uses the all_of algorithm to determine whether the unary predicate function greater10 [definita nelle righe 93 96 del programma] returns true for ALL the elements in the range from a.cbegin() up to, but not including a.cend(). Algorithm all_of requires its two iterator arguments to be at least input iterators.
>> any_of
	 68    // determine whether any of the elements of a are greater than 10
	 69    if ( any_of( a.cbegin(), a.cend(), greater10 ) )
	 70       cout << "\n\nSome of the elements in a are greater than 10";
line 69 uses the any_of algorithm to determine whether the unary predicate function greater10 returns true for AT LEAST ONE of the elements in the range from a.cbegin() up to, but not including a.cend(). Algorithm any_of requires its two iterator arguments to be at least input iterators.
>> none_of
	 74    // determine whether none of the elements of a are greater than 10
	 75    if ( none_of( a.cbegin(), a.cend(), greater10 ) )
	 76       cout << "\n\nNone of the elements in a are greater than 10";
Line 75 uses the none_of algorithm to determine whether the unary predicate function greater10 (user function definita nel programma) returns false for ALL of the elements in the range from a.cbegin() up to but not including a.cend(). Algorithm none_of requires its two iterator arugments to be at least input iterators.
>> find_if_not
[pag710 deitel]
	 80    // locate first occurrence of value that's not greater than 10 in a
	 81    location = find_if_not( a.cbegin(), a.cend(), greater10 );
Line 81 uses the find_if_not algorithm to locate the first value in the range from a.cbeing() up to, but not including a.cend() for which the unary predicate function greater10 returns false. Algorithm find_if requires its two iterator arguments to be at least input iterators. The algorithm returns an input iterator that either is positioned at the first element containing a value for which the predicate function returns false or indicates the end of the sequence. 
----------------------------------------------------
PROGRAM output /home/dia/Deitel-Code_Examples/ch16/fig16_06/fig16_06.cpp
	array a contains: 10 2 17 5 16 8 13 11 20 7	
	Found 16 at location 4
	100 not found
	The first value greater than 10 is 17
	found at location 2
	array a after sort: 2 5 7 8 10 11 13 16 17 20
	13 was found in a
	100 was not found in a
	Some elements in a are not greater than 10
	Some of the elements in a are greater than 10
	Some of the elements in a are greater than 10
	The first value not greater than 10 is 2
	found at location 0
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> Searching and >> sorting
[pag823 deitel] 
Searching data involves determining whether a value (referred to as the search key) is present in the data and, if so, finding the value location.
Two popular search algorithm are the 
	>> linear search  deitel pag824
		the program must compare the search key to every array element. Linear search works well for small or unsorted arrays. However for large arrays, linear searching is inefficient. If the array is sorted you can use the high-speed binary search tehcnique.
	>> binary search  deitel pag827 -> much more effcient (rispetto alla linear search) but more complex to implement
Sorting places data in ascending or descending order, based on one or more >> sort keys.
>> SORTING ALGORITHM / >> ALGORITHM SORT deitel pag831 // >> sorting algorithm pag 128 mike programming 
sort() algorithm sorts the elements of a sequence in ascending order.
example from mike programming game
	sort(scores.begin(), scores.end());
in the previous line we passed the iterators returned by scores.begin() and scores.end(). These two iterators indicate that we want to sort all of the elements in "scores"
NOTE: per ascending order significa dal piu' piccolo al piu' grande
example from the program Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter04/high_scores.cpp
	Randomizing scores.
		High Scores:
		3500
		7500
		1500
	After applying the sort() algorithm:
		High Scores:
		1500
		3500
		7500
	>> INSERTION SORT deitel pag832
	>> SELECTION SORT deitel pag834
	>> MERGE SORT  deitel pag837
	>> BIG O NOTATION deitel pag824 e  seguenti
		used to describe and quantify the amount of effort an algorithm requires to complete a search.
		>> O(1)   constant runtime = the algorithm is indipendent of the number of array elements. 
			>> O(1) is usually pronounced "on the order of 1" or more simply "order 1"
			>> O(n) = linear runtime. deitel pag825
			>> quadratic runtime deitel pag826  order n squared
			>> O(n^2) performance -> sentirai la degradazione di performance when n starts to become big.
	>> BINARY SEARCH deitel pag827
		the binary search algorithm is more efficient than the linear search algorithm, but it requires that the array first be sorted. 
		il concetto e' semplice : supponi di avere dei numeri alla rinfusa e devi cercare se tra di essi e' presente il numero 54. 
		1) ordini i numeri in ordine crescente quindi checki se l'elemento che sta nella meta' dell'array ordinato e' uguale a 54. Se lo e' la ricerca e' finita
		2) se non lo e' due le possibilita': o il numero che sta' a meta' e piu' grande di 54, allora continuerai a cercare nella prima meta' dell'array.
		3) oppure il numero in mezzo e' piu' piccolo di 54 ed allora cercherai nella seconda meta' dell'array.
		NOTE: se il numero di elementi e' pari non e' ovvio quale sia l'elemento in mezzo. The middle lies between two elements. Allora we implement the algorithm to choose the element with the higher index number
--------------------------------------------------------------------------
>> SORT INSERTION ALGORITHM / >> INTERTION SORT ALGORITHM 
[pag 832 deitel]
this is a simple but inefficient sorting algorithm
>> SELECTION SORT  pag834 deitel is another easy-to-implement but inefficient algorithm. 
>> MERGE SORT algorithm (a recursive implementation) pag837 deitel
	the merge sort implementation is recursive. THe recursion step splits an array of two or more elements into two equal sized sub-arrays, recursively sorts each sub-array [see pag840 per una visualizzazione dinamica del suo funzionamento o lancia il programma MergeSort.cpp from deitel book], then merges them into one larger, sorted array. 
-------------------------------
>> Sorting Algorithm Efficiencies
[pag842deitel]
Linear Search   O(n) 
Binary Search   O(log n)
Recursive linear Search		O(n)
Recursive binary Search 	O(log n)
Insertion sort		O(n^2)
Selection sort		O(n^2)
Merge sort       O(n log n)       -> this is a far more efficient algorithm than either insertion sort or selection sort
Bubble sort      O(n^2)
Quicksort        worst case -> O(n^2) ;    average case -> O(n log n)
where
preso se n = 2^10          -> O(log n) = 10 
                           -> O(n) = 2^10
						   -> O(n log n) = 2^10*10
						   -> O(n^2) = 2^20
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> search function [pag109 moo book]
This function takes two pairs of iterators:
- the first pair denotes the sequence in which we are looking, and the second pair denotes the sequence that we wish to locate. If search fails, it returns the second iterator. 

>> ADD FUNCTION EXAMPLE from jesse book pag 37
#include <iostream>
int Add (int first, int second)
{
    std::cout << "In Add(), received " << first << " and " << second << "\n";
    return (first + second);
}
  
int main()
{
    using std::cout;
    using std::cin;
  
  
    cout << "I'm in main()!\n";
    int a, b, c;
    cout << "Enter two numbers: ";
    cin >> a;
    cin >> b;
    cout << "\nCalling Add()\n";
    c=Add(a,b);
    cout << "\nBack in main().\n";
    cout << "c was set to " << c;
    cout << "\nExiting...\n\n";
    return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ALGORITHM stl / >> STL ALGORITHMS / >> Standard Template Library Algorithms [pag126 mike programming game]
in order to use the STL algorithms we need to include
	#include <algorithm>
	using namespace std;   // this line to allow to refer to algorithms without having to precede them with std::
>> FIND ALGORITHM 
	iter = find(scores.begin(), scores.end(), score);
find() STL algorithm searches a specified range of a container's elements for a value. It returns an iterator that references the first matching element. 
NOTE: you must pass the starting point as an iterator, the ending point as an iterator, and a value to find. 
NOTE: the algorithm searches from the starting iterator up to but not including the ending iterator. [e visto che come spiegato a pagina 121 mike programming game, .end() porta l'iteratore a puntare all'elemento DOPO l'ultimo elemento del vettore, significa che tutti gli elementi fino all'N ultimo elemento del vettore verranno searchati]
NOTE: if no match is found, it returns an iterator to the end of the range.
>> RANDOM SHUFFLE ALGORITHM [pag127 mike programming game]
	srand(static_cast<unsigned int>(time(0)));   // [questa stessa linea veniva usata in Deitel book dove veniva scritto "this causes the computer to read its clock to obtain the value for the seed. Function time with the argument 0 as written in the preceding statement typically returns the current time as the number of seconds since January 1, 1970, at midnight reenwich Mean Time (GMT)."]
    random_shuffle(scores.begin(), scores.end());
NOTE: we seed the random number generator before calling random_shuffle(), so the order of results might be different each timewe run the program
NOTE: random_shuffle() is a valuable algorithm for games. You can use it for everything from shuffling a deck of cards to mixing up the order of the enemies a player will encounter in a game level.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> STREAM INPUT 
[pag569deitel]
>> get = getmember function with no arumgents input one character from the designated stream (including white-space characters and other nongraphic characters, such as the key sequence that represents end-of-file) and returns it as the value of the function call. This version of "get" returns EOF when end-of-file is encountered on the stream.
(NOTE: recall that EOF is represented as a int)
The get member function with a character reference argument inputs the next character from the input stream (even if this is white-space character)  and stores it in the character argument. 
A third version of get (pag570deitel) takes three arguments 
	1) a built in array of chars
	2) a size limit 
	3) a delimiter (with default value '\n')
This version reads characters from the input stream. It either reads one fewer than the specified maximum number of characters and terminates or terminates as soon as the delimiter is read. A null character is inserted to terminate the input string in teh carachter array used as a buffer by the program. The delimiter is not placed in teh character array but does remain in the input stream (the delimiter will be the next character read). Thus the result of a second consecutive get is an empty line, unless the delimiter character is removed from the input stream (possibly with cin.ignore())
>> getline member function pag571 deitel 
also spiegato a pag 91 moo book in cui trovi l'esempio 
	while (getline(cin, s)) { ... } return 0;
The getline function takes two arguments. The first is the istream from which to read. The second is a reference to the string into which to store what is read.
-----------------------------------
>> eof member function pag569 deitel
+ pag 604 deitel
	NOTE : the keyboard combination for entering end-of-file for various computer systems
		CTRL + d    per linux/mac
		CTRL + z    per windows
The user enters end-of-file to inform the program to process no additional data. The end-of-file indicator is set when the user enters the end-of-file key combination.
>> put member function pag569 deitel
//////////////
Alcune utili istream meber functions sono 
	>> peek [pag572deitel]
the peek member function returns the next character from an input stream but does not remove the character from the stream.
	>> putback [pag572deitel] // >> searching tool
the putback member function places the previous character obtained by a get from an input stream back into that stream. This function is useful for applications that scan an input stream looking for a field beginning with a specific character. When that character is input, the application returns the character to the stream, so the character can be included in the input data.
	>> ignore [pag572deitel]
The ignore member function of istream reads and discards a designated number of characters (the default is one) or terminates upon encountering a designated delimiter (the default is EOF, which causes ignore to skip to the end of the file when reading from a file).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> left associative [pag 4 moo book] = means that when the operator appears twice or more  in the same expression, each operator will use as much of the expression as it can for its left operand, and as little of it as it can for its right operand. 
example "<<" operator is left associative: std::cout << s << t means the same as (std::cout << s) << t
For example the operator >> takes two operands. 
		std::cout << "Hello, world!" << std::endl;
and is left associative -> kuwashiku hanashi see pag 4 moo book


>> STREAM MANIPULATORS / >> STREAM FORMAT STATES 
[pag578 deitel]
alcuni esempi:
	>> skipws = skip white-space characters on an input stream. 
	>> left = left justify ouput in a field. Padding characters appear to the right if necessary
	>> right =  right justify output in a field. Padding characters appear to the left if necessary
	>> boolalpha = specify that bool values should be displayed as the word true or false. The manipulator noboolalpha sets the stream bakc to displaying bool values as 1 (true) or 0 (false) see omonima voce boolalpha per maggiori informazioni.
	>> showpoint = specify that floating point numbers should be ouput with a decimal point. This is used normally with "fixed" to guarantee  a certain number of digits to the right of the decimal point, even if they're zeros. This setting is reset with stream manipulator "noshowpoint". 
	>> showbase = forces the base of an integral value to be output.[see example pag 583 deitel]
	>> scientific = specify output of a floating point value in scientific notation 
see example pag 584 deitel [ >> scientific format]
/////////////
	  cout << "\nDisplayed in scientific format:" << endl
      << scientific << x << '\t' << y << endl;
/////////////
	>> fixed = specify output of a floating point value in fixed point notation with a specific number of digits (as specified by member function precision or stream manipulator setprecision) to the right of the decimal point.
NOTE: showpoint is a sticky setting that forces a floating-point number to be output with its decimal point and trailing zeros. 
/////////////////////////
>> user-defined output stream manipulators
[]pag577 deitel]
>> showpos = pag 581 deitel
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> SRAND vs RAND
[pag217deitel]
function rand actually generates pseudorandom numbers. Repeatedly calling rand produces a sequence of numbers that appears to be random. However, the sequence repeats itself each time the program executes. Questo e' desiderabile nella fase di debug di un simulation program, this repeatability is essential for proving that corrections to the program work properly. 
Once a program has been thoroughly debugged, it can be conditioned to produce a different sequence of random numbers for each execution. This is called randomizing and is accomplished with the X++ standard library function srand. Function srand takes an unsigned integer argument and seeds the rand function to produce a different sequence of random numbers for each execution. C+11 provies addition random number capabilities that can produce nondeterministic random numbers (= a set of number that cannot be predicted). Such random number generators are used in simulations and security scenarios where predictability is undesirable. [FASCINATING!! the generation of the randomness from a deterministic machine]
see example pag218 fig06_10.cpp
NB: the program produces a different sequence of random numbers each time it executes, provided that the user enters a different seed. But if we used the same seed the same series of numbers will be displayed in each of the outputs. 
SEEDING the RANDOM NUMBER GENERATOR with the CURRENT TIME
to randomize without having to enter a seed each time, we may use a statement like 
	srand( static_cast<unsigned int>( time( 0 ) ) );
[pag219deitel]
this causes the computer to read its clock to obtain the value for the seed. Function time with the argument 0 as written in the preceding statement typically returns the current time as the number of seconds since January 1, 1970, at midnight reenwich Mean Time (GMT).

>> STACK 
[pag231 deitel]
Stack is a data structure analogous to a pile of dishes. When a dish is placed on the pile, it's normally placed at the top (= referred to as pushing the dish onto the stack). Similarly, when a dish is removed from the pile, it's normally removed from the top (= referred to as popping the dish off the stack). Stacks are known as LIFO data structures.
LIFO 
	= Last In First Out
in LIFO data structure the last item pushed (inserted ) on the stack is the first item popped (removed) from the stack. 
LIFO behavior is exactly what a function needs in order to return to the function that called it. 
See also >> Function-Call Stack 
-------------------------------
>> STACK 
[pag794 deitel]
Nodes can be added to a stack and removed from a stack only at its top, so a stack is referred  to as a last-in, first-out (>> LIFO) data structure. 
The primary member functions used to manipulate a stack are push and pop.
Function >> push = inserts a new node at the top of the stack. 
Function >> pop = removes a node from the top of the stack, stores the popped value in a reference variable that's passed to the calling function and returns true if the pop operation was successful (false otherwise)
Applications of Stacks
1) Function calls: when a function call is made, the called function must know how to return to its caller, so the return addres is pushed onto a stack. If a series of function calls occurs, the successive return values are pushed onto the stack in last-in, first-out order, so that each function can return to its caller. Stack support recursive function calls in the same manner as conventional nonrecursive call.
2) Stacks provide the memory for, and store the values of , automatic variables on each invocation of a function. 
When the function returns to its caller or throws an exception, the destructor (if any) for each local object is called, the space for that functions' automatic variables is popped off the stack and those variables are no longer known to the program.
3) Stacks are used by compilers in the process of evaluating expressions and generating machine-language code.
NOTE: gli stack si possono implementare via private inheritance from the List class template.
>> DELEGATION = pag795 deitel
>> dependent name = is an identifier that depends on a template parameter.

>> STACK OVERFLOW 
[pag232deitel]
Since the amount of memory of a computer is finite, only a certain amount of memory can be used to store activation records on the function call stack. If (number function calls) > (number of activation records that can be stored on the function call stack), a fatal error known as stack overflow occurs.
In sostanza uno stack overflow error, significa che il numero massimale di stack frames (contenenti l'indirizzo di ritorno per sapere dove rincasare una volta che la funzione chiamata ha svolto il suo compito) e' stato raggiunto, se volessi chiamare un'altra funzione non avresti piu' lo spazio in memoria per ricordare l'indirizzo della funzione chiamante. Lo stack e' stato appunto overflow. 

>> STACK FRAME
[pa232deitel]
e' anche chiamato "activation record". It contains the return address that the called function needs in order to return to the calling function.
pag 233deitel trovi un bell'esempio di function call stack in action

>> STATIC type variable / static is a >> type modifier [pag 121 moo book]
	static type variable;
For local declarations, declares "variable" with static storage class. The value of "variable" persists across executions of this scope and is guaranteed to be initialized before the variable is used for the first time. When the program exits from the scope, the variable keeps its value until the next time the program enters that scope. 

>> STATIC CAST OPERATOR 
[pag132deitel]
used to convert explicitly a variable 
example divisione di due numeri interi 
	int total = 7;
	int players = 4;
	double average = total / players;
it will truncate the value of the division since it is performed between two numbers.
Instead we can do 
	double average = static_cast< double >( total ) / players;
the static_cast operator creates a temporary floating point copy of its operands in parentheses (cioe' total nell'esempio precedente).  Using a casting operator in this manner is called explicit conversion.
Una volta che "total" diventa temporaneamente double, allora per effettuare la divisione, visto che il compiler sa evaluate only expression in which the operands are identical, allora the compiler performs an operation called PROMOTION (also called implicit conversion) on selected operands. 
OBSERVATIONS
- the static_cast operator is a unary operator (= an operator that takes only one operand)
-  cast operators have higher precedence than other unary operators such as + and - (che usi davanti ai numeri per indicare se sono positivi o negativi).
- hanno una precedence that is higher than that of multiplicative operators *, / and % and lower than that of parenthesis.
- osservazioni aggiuntive pag 212: converting values to lower fundamental types can result in incorrect values. Therefore a value can be converted to a lower fundamental type only by explicitly assigning the value to a variable of lower type, or by using a cast operator.

>> STATIC DATA MEMBERS / also knows as >> CLASS VARIABLES
[see bella discussione pag299-300deitel]
see also pag 418deitel
There is an important exception to the rule that each object of a class has its own copy of all the data members of the class. In certain cases, only one copy of a variable should be shared by all the objects of a class. A "static data member" is used for these and other reasons. Such a variable represents "class-wide" information, i.e. data that is shared by all instances and is not specific to any one object of the class. 
ADVICE PERFORMANCE : use static data members to save storage when a single copy of the data for all objects of a class will suffice.
pag 418deitel: un bell'esempio di perche' usare uno static class-wide data conviene quando un certo dato (data member) dev'essere conosciuto da molteplici oggetti. Al posto di fare multiple copie del data member e di dover poi aggiornare ciascuna delle copie per ciascuno degli oggetti (sprecando spazio e risorse) si puo' dichiarare il data member as "static", in tal modo tutti gli oggetti possono accedere al data member e solo una copia dev'essere mantenuta nel programma (per la piu' lunga e sintatticamente dettagliata spiegazione in inglese ti riferisco a pagina 418deitel) 
>> STATIC DATA MEMBER INITIALIZATION / >> INITIALIZE STATIC DATA MEMBER
[pag419 deitel]
A class's static data members have class scope. A static data member must be initialized exactly once.
Fundmental type static  dta members are initialized by default to 0. Prior to C++11 a static const data member of "int" or "enum" type could be initialized in its declaration in the class definition and all other "static" data member had to be defined and initialized at >> global namespace scope (= outside the body of the class definition). Again C++11's in class initializers also allow you to initialize these variables  where they're declared in the class definition. If a "static" data member is an object of a class that provides a default constructor, the "static" data member need not to be initialized because its default constructor will be called. 
>> STATIC DATA MEMBER ACCESS / >> ACCESS STATIC DATA MEMBER
[pag419 deitel]
A class's "privite" and "protected static" members are normally accessed through the calss's public member functions or "friends". A class's "static" members exist even when no objects of that class exist.
To access a "public static" class member when no objects of the class exist, simply prefix the class name oand the scope resolution operator (::) to the name of the data member. For example, if our preceding (pag418deitel) variable "martianCount" is public, it can be acessed with the expression "Martian::martianCount" (martianCount era il data member dichiarato static in modo da poter essere sharato tra tutti gli objects Martian), even when there are no Martian objects. (Of coarse, using "public" data is discouraged).
To access a private or protected static class member  when no objects of the class exist, provide a public static member function and call the function by prefixing its name with the class name and scope resolution operator. A static member function is a service of the class, not of a specific object of the class.
NOTE: [pag 422 deitel] a member function should be declared static if it does not access non-static data members or non-static member functions of the class (cioe' detto in parole spicciole :  una member function va dichiarata static solo se si limita ad accedere static data member or static member functions of the class). Unlike non-static member functions, a static member function does not have a "this" pointer, because static data members and static member functions exist independently of any objects of a class. The "this" pointer must refer to a specific object of the class, and when a static member function is called there might not be any objects of its class in memory.
COMMON ERRORS
- using the "this" pointer in a static member function is a compilation error
- declaring a "static" member function "const" is a compilation error. The "const" qualifier indicates that a function cannot modify the contents of the object on which it operates, but "static" member funtions exist and operate independently of any objects of the class.
CONCLUDENDO: a class's static data members and "static" member functions exist and can be used even if no objects of that class have been instantiated.
EXAMPLES see programs  /home/dia/Deitel-Code_Examples/ch09/fig09_27_29/fig09_29.cpp  et pag 419 deitel 
Trovi un utile esempio di >> count number of objects instantiated / >> NUMBER OBJECTS INSTANTIATED COUNT / >> number of objects of a class tracking with static data member 
////////////////////////////////////////////////

>> STATIC DATA MEMBERS AND MEMBER FUNCTIONS [pag254 mike game programming]
IN SHORT 
STATIC DATA MEMBER used to STORE A SINGLE VALUE FOR AN ENTIRE CLASS.
IN LONG 
What if you want to store some information about an entire class, such as the total number of instances that exist? You might want to do this if you've created a bunch of enemies and you want them to fight the player based on their total number. For example, if their total number is below a certain threshold, you might want the enemies to run away. You need to store a single value for an entire class. You can do this with a static data member.  
FULL EXAMPLE from 
----------------------------------------------------- FULL EXAMPLE START
	//Static Critter
	//Demonstrates static member variables and functions
	
	#include <iostream>	
	using namespace std;
	
 	// start of the class Critter definition
	class Critter
	{
	public:
	    static int s_Total;     //>> static member variable declaration / >> static declaration 
	                            //s_Total is a static member variable that will display the total number of Critter objects in existence
	    // NOTE >> CONVENTION STATIC DATA: prefixed the variable name with s_ so it would be instantly recognizable as a static data member.

	    Critter(int hunger = 0); // in the beginning (detto stile princess Fantasia) ... there are zero Critters.
// >> STATIC MEMBER FUNCTIONS [pag257 mike game programming]
	    static int GetTotal();  //static member function prototype
	    
	private:
	    int m_Hunger;
	}; // fine della class Critter definition 

// outside the class definition we initialize the static data member to 0	
	int Critter::s_Total = 0;   //static member variable initialization
// NOTE: (>> QUALIFY DATA MEMBER) nella linea di codice precedente we >> qualified the data member name with Critter:: 
// Outside of its class definition, you must quality a static data member with its class name.
// HINT: you can declare a static variable in non class functions too. The static variable maintains its value between function calls.	

    
	Critter::Critter(int hunger): 
	    m_Hunger(hunger)
	{
	    cout << "A critter has been born!" << endl;
// incrementing s_Total:
	    ++s_Total; // every time a new object is instantiated, s_Total is incremented
// note: we did not quality s_Total with Critter::. Just as with nonstatic data members, we don't have to qualify a static data member with its class name inside its class. [una maniera semplice di vedere le cose: visto che Critter:: c'e' gia' all'esterno del blocco {} non e' piu' necessario ripeterlo dentro]
// NOTE: here we made the static data member public, but you can also make a static data member private. But then like any other data member, you can only access it in a class member function.
	}

// >> STATIC MEMBER FUNCTION DEFINITION 	
	int Critter::GetTotal()     //static member function definition
	{
	    return s_Total; // this static member function GetTotal() returns the value of the static data member s_Total
	}
// NOTE: a static member function definition is much like the non static member function definition you've seen so far. The major difference is that a static member function cannot access non static data members. This is because a static member function exists for the entire class and is not associated with any particular instance of the class.	


	int main()
	{
	    cout << "The total number of critters is: ";
// >> ACCESS STATIC DATA MEMBERS / >> STATIC DATA MEMBER ACCESS [pag256 mike game programming]
	    cout << Critter::s_Total << "\n\n"; // questa linea mostra un esempio concreto of how to access a public static data member.
// You can accesss a public static data member anywhere in your program. Basta far precedere il nome dello static data member dal nome della classe in cui e' stato creato
// Un alternativa equivalente a "Critter::s_Total" is to access a static data member through any object of the class. 
// Assuming that crit1 is a "Critter" object, we could display the total number of critters using :   
// cout << crit1.s_Total << "\n\n";
	     
	    Critter crit1, crit2, crit3;
	      
	    cout << "\nThe total number of critters is: ";
// >> CALL STATIC MEMBER FUNCTION [pag257 mike game programming]
	    cout << Critter::GetTotal() << "\n";
// NOTE: to properly identify the static member function, we have to qualify it with Critter::
// To call a static member function from outside of its class, you must qualify it with its class name. ]
// HINT: you can also access a static member function through any object of the class. Assuming that crit1 is a Critter object, we could display the total number of critters with 	
// cout << crit1.GetTotal() << "\n\n";    
	    return 0;
	}
// NOTE: because static member functions exist for the entire class, you can call a static member function without any instances of the class in existance. And just as with private static data members, private static member functions can only be accessed by other member functions of the same class.
----------------------------------------------------- FULL EXAMPLE END
OUTPUT of the program 
	The total number of critters is: 0
	A critter has been born!
	A critter has been born!
	A critter has been born!
	The total number of critters is: 3
////////////////////////////////////////////////////////////////////////////////////////

>> STATIC storage class specifier [pag107 moo book]
Local variables that are declared to be static are preserved across invocations of the function.

>> CRITTER CARETAKER GAME [pag258 mike game programming]
uml for the critter class 

	                        -----------------------------
	                        |                           |
	nome della classe       |          Critter          |       
	                        -----------------------------
	                        |                           |
	                        |      -m_Hunger:int        |
	data members            |      -m_Boredom:int       |
	                        |                           |
	                        -----------------------------     
	                        |                           |
	                        |      +Talk()              |
	                        |      +Eat()               |       
	member functions        |      +Play()              |
	                        |      -PassTime()          |
	                        |                           |
	                        -----------------------------      

- means private and + means public
---------------------------------------------------------------- FULL EXAMPLE CRITTER CARETAKER GAME
[from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/critter_caretaker.cpp]
	//Critter Caretaker
	//Simulates caring for a virtual pet
	
	#include <iostream>
	
	using namespace std;
	
	class Critter  // class definition start
	{
	public:          
	    Critter(int hunger = 0, int boredom = 0); 
	    void Talk();
	    void Eat(int food = 4);
	    void Play(int fun = 4);
	
	private:
	    int m_Hunger;
	    int m_Boredom;
	
	    int GetMood() const;
	    void PassTime(int time = 1);
	
	};    // class definition end
	
	Critter::Critter(int hunger, int boredom):   // >> class constructor
	    m_Hunger(hunger),
	    m_Boredom(boredom)
	{}    // class constructor end
	
	inline int Critter::GetMood() const  // getMood() member function definition
	{
	    return (m_Hunger + m_Boredom);
	}
	// note : this member function is private because it should only be invoked by another member function of the class.
	// come scriveva precedentemente mike: "member access is private by default. Until you specify an access modifier, 
    // any class members you declare will be private."

	void Critter::PassTime(int time)
	{
	    m_Hunger += time;
	    m_Boredom += time;
	}
	
	void Critter::Talk()
	{
	    cout << "I'm a critter and I feel ";
	
	    int mood = GetMood();
	    if (mood > 15)
		{
	        cout << "mad.\n";
		}
	    else if (mood > 10)
		{
	        cout << "frustrated.\n";
		}
	    else if (mood > 5)
		{
	        cout << "okay.\n";
		}
	    else
		{
	        cout << "happy.\n";
		}
	
	    PassTime();
	}
	
	void Critter::Eat(int food) 
	{
	    cout << "Brruppp.\n";
	
	    m_Hunger -= food;
	    if (m_Hunger < 0)
		{
	        m_Hunger = 0;
		}
	
	    PassTime();
	}
	
	void Critter::Play(int fun)
	{
	    cout << "Wheee!\n";
	
	    m_Boredom -= fun;
	    if (m_Boredom < 0)
		{
	        m_Boredom = 0;
		}
	
	    PassTime();
	}
	
	int main()
	{
		Critter crit;
		crit.Talk();
	
		int choice;
		do
	    {
	        cout << "\nCritter Caretaker\n\n";
	        cout << "0 - Quit\n";
	        cout << "1 - Listen to your critter\n";
	        cout << "2 - Feed your critter\n";
	        cout << "3 - Play with your critter\n\n";
	
	        cout << "Choice: ";
	        cin >> choice;
	
	        switch (choice)
	        {
				case 0:	
					cout << "Good-bye.\n";
					break;
				case 1:	
					crit.Talk();
					break;
				case 2:	
					crit.Eat();
					break;
				case 3:	
					crit.Play();
					break;
				default:
					cout << "\nSorry, but " << choice << " isn't a valid choice.\n";
	        }
		} while (choice != 0);
	
	    return 0;
	}
	

---------------------------------------------------------------- END FULL EXAMPLE CRITTER CARETAKER GAME 
OUTPUT of the PROGRAM 
	I'm a critter and I feel happy.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 1
	I'm a critter and I feel happy.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 2
	Brruppp.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 3
	Wheee!
////////////////////////////////////////////////////////////////////////////////////////

>> STATIC LOCAL ARRAY
[pag291deitel]
We can apply static to a local array declaration so that it's not created and initialized each time the program calls the function and is not destroyed each time the function terminates. This can improve performance, especially when using large arrays.

>> STATIC STORAGE DURATION 
[pag227deitel]
Variables with static storage duration exist in memory from the point at which the proram begins execution and until the program terminates.
There are two types of identifiers with static storage duration:
1) global variables
2) static local variables 
	1) Global variables are created by placing variable declarations outside ay class or function definition. Global variables retain their values throughout a program's execution. Global variables and global functions can be referenced by any function that follows their declarations or definitions in the source file.
WARNING: declaring a variable as a global rather than local allows unintended side effects to occur when a function that does not need access to the variable accidentally or maliciously modifies it. In general, except for truly global resources such as cin and cout, the use of global variables should be avoided unless there are unique performance requirements.
	2) Local variables declared static are still known only in the function in which they're declared, but, unlike automatic variables, static local variables retain their values when the function return to its caller. The next time the function is called, tha static local variables contain the values they had when the function last completed execution. 
Example :
	static unsigned int count = 1;
the previous statement declares local variables count to be static and to be initialized to 1:
All numeric variables of static storage duration are initialized to zero by default, but it's nevertheless a good practice to explicitly initialize all variables.

>> std::
the notation std::cout specifies that we are using a name, in this case cout, that belongs to namespace std.
Remember to include std:: before each mention of cout, cin, and cerr in a program. 
Se introduci la "using" declaration and "using" directive you can omit "std::" before each use of a name in the std namespace  
example
	#include <iostream>  // allows program to perform input and output
	using std::cout; // program uses cout
	using std::cin;  // program uses cin
	using std::endl; // program uses endl
	int main()
	{
		cout << "enter two integers to compare: ";  
// non devi piu' far precedere cout da std
		cin >> number1 >> number2; 
// nota come possiamo leggere due numeri da tastiera usando due >> nella stessa riga
	}
NB: al posto delle tre righe 
	using std::cout; // program uses cout
	using std::cin;  // program uses cin
	using std::endl; // program uses endl
puoi piu' sinteticamente giusto scrivere
	using namespace std;
which enables a program to use all the names in any standard C++ header (such as <iostream>) that a program may include.	
[pag42deitel example @54deitel]
NOTE from pag 34 mike: std namespace includes elements from the standard library. To access an element from the namespace, you need to prefix the element with the std:: or employ using.
///////////////////////////////////////////////////////////////////

>> STANDARD INPUT (CIN)
The standard input device is usually the keyboard 
In C++ the operator of extraction is used >>
ex
	int age;
	cin >> age;
The fisrt statement declares a variable of int called age, and the second one waits for an input from cin (the keyboard) in order to store it in this integer variable. 
NB
- cin can only process the input from the keyborad once the RETURN key has been pressed.  
	cin >> a >> b;
is equivalent to:
	cin >> a;
	cin >> b;
- you must always consider the type of the variable that you are using as a container with cin extractions. If you request an integer you will get an integer, if you request a character you will get a character and if you request a string of character you will get a string of charaters. 
EX
	// i/o example 
	#include <iostream>
	using namespace std;
	int main ()
	{
	int i;
	cout << "Please enter an integer value: ";
	cin >> i;
	cout << "The value you entered is " << i;
	cout << " and its double is " << i*2 << ".\n";
	return 0;
	}
Donera' su schermo:
Please enter an integer value: 127
The value you entered is 127 and its double is 254.
- cin and strings: we can use cin to get strings with the extraction operator (>>) 
	cin >> mystring;
however, cin extraction stops reading as soon as if finds any blank space character, so we will be able to get just onw word for each extraction. To extract entire lines it is more recommendable to use "getline"	
EX
	// cin with strings
	#include <iostream>
	#include <string>
	using namespace std;
	int main ()
	{
	string mystr;
	cout <<"What's your name? ";
	getline (cin, mystr);
	cout << "Hello " << mystr << ".\n";
	cout << "What is your favorite team? ";
	getline (cin, mystr);
	cout << "I like " << mystr << " too!\n";
	return 0;
	}  
In Fuji pascon abbiamo dovito modificare le version precedente nel seguente modo (aggiungere due righe) altrimenti non ci memorizzava la risposta a what's your name
	// cin with strings
	#include <iostream>
	#include <string>
	using namespace std;
	int main ()
	{
	string mystr;
	// ecco le due seguenti righe che aggiungiamo
	cout <<"";
	getline (cin, mystr);
	cout <<"What's your name? ";
	getline (cin, mystr);
	cout << "Hello " << mystr << ".\n";
	cout << "What is your favorite team? ";
	getline (cin, mystr);
	cout << "I like " << mystr << " too!\n";
	return 0;
	}  
// ==============================================
// ==============================================
// ==============================================

>> STRING INIZIALIZATION 
#include <iostream>
#include <string>
using namespace std;
int main()
{
	string choice;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> string inizialization examples from pag14 moo book
	std::string s;
		Defines s as a variable of type std::string that is initially empty
	std::string t = s;
		Define t as a variable of type std::string that initially contains a copy of the characters in s, where s can be either a string or a string literal
	std::string z(n, c);
		Define z as a varaible of type std::string that initially contains n copies of the character c. Here,c c must be a char, not a string or a string literal.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

>> self assignement string / >> string self assignment
[pag438deitel]
   // test overloaded copy assignment (=) operator with self-assignment
   string s4(" nostromo-cargo ");	
   cout << "assigning s4 to s4" << endl;
   s4 = s4;  
   cout << "s4 = " << s4 << endl;
///////////////////////////////////////////////////

>> STANDARD LIBRARY HEADERS LIST / C++ STANDARD LIBRARY HEADERS LIST
see section 6.6 deitel pag213-214 
- <iostream> contains function prototypes for the C++ standard input and output
- <iomanip>  contains function prototypes for stream manipulators that format streams of data.
- <cmath>    contains function prototypes for math library functions
- <cstdlib>  contains function prototypes for conversions of numbers to text, text to numbers, memory allocation, random numbers and various other utility functions.
- <ctime>    contains function prototypes and types for manipulating the time and date
- <array>---------|
  <vector>        |
  <list>          |
  <forward_list>  |
  <deque>         |
  <queue>         |----> these headers contain classes 
  <stack>         |      that implement the C++ standard library 
  <map>           |      containers [anche qui navi portacontainers]. 
  <unordered_map> |      Containers store data during program execution.
  <unordered_set> |
  <set>           |
  <bitset> -------|          
- <cctype>     contains function prototypes for functions that test characters for certain properties (such whether the character is a digit or a punctuation) and function prototypes for functions that can be used to convert lowercase letters to uppercase letters and vice versa.
- <cstring>    contains function prototypes for C-style string-processing functions.
- <typeinfo>   contains classes for runtime type identification (determining data types at execution time)
- <exception>  |    
  <stdexcept>  |---------> these headers contain classes that are used for exception handling
- <memory>     contains classes and functions used by the C++ standard library to allocate memory to the C++ standard library containers.
- <fstream>    contains function prototypes for functions that perform input from and output to files on disk
- <string>     contains the definition of class string from the C++ standard library
- <sstream>    contains function prototypes for functions that perform input from strings in memory and output to strings in memory
- <functional> contains classes and functions used by C++ standard library algorithms
- <iterator>   contains classes for accessing data in the C++ standard library containers
- <algorithm>  contains functions for manipulating data in C++ standard library containers
- <cassert>    contains macros for adding diagnostics that aid program debugging see Appendix E, prepocessor pag992
- <cfloat>     contains the floating-point size limits of the system
- <climits>    contains the integral size limits of the system
- <cstdio>     contains function prototypes for the C-style standard input/output library functions
- <locale>     contains classes and functions normally used by stream processing to process data in the natural form for different languages (e.g monetary formats, sorting strings, character presentation, etc)
- <limits>     contains classes for defining the numerical data type limits on each computer platform
- <utility>    contains classes and functions that are used by many C++ Standard Library headers.


>> STANDARD LIBRARY HEADERS Observations / C++ STANDARD LIBRARY HEADERS Observations 
- the C++ Standard Library is divided into many portions, each with its own header. 
The HEADERS -----contains -->| the             | for the
                           @ | functions  ---> | related
@@@@@@@@@@@@@@@@ @@@@@@   @| prototypes      | functions that form each portion of the library. 
The headers also contain 
- definitions of various class types and functions, 
- as well as constants needed by those functions. 
A header "instructs" the compiler on how to interface with library <-and-> user-written components.                 


>> STANDARD OUTPUT
By default the standard output of a program is the screen, and the C++ stream object defined to access it is "cout"
cout is used in conjunction with the insertion operator, which is written as <<
ex:
	cout << "Output Sentence"; // prints Output sentence on screen
	cout << "Hello"; // prints "Hello" on screen
	cout << Hello;   // prints the content of the Hello variable
The insertion operator << may be used more than once in a single statement (useful when we want to print out a combination of variables and constants or more than one variable)
	cout << "Hello,I am " << age << " years old and my zipe code is " << zipcode;
Notice that cout does not add a line break after its output unless we explicitly indicate it. 
In order to perform a line break : \n (backlash n)
ex1
	cout << "Ciao!";
	cout << "Salut!";
otterrai : 
	Ciao!Salut!
ex2
	cout << "Ciao!\n ";
	cout << "Salut!\nHello!";
otterrai:
	Ciao!  
	Salut!
	Hello!
- Alternativamente si puo' anche usare l'end manipulator 
ex3
	cout << "First sentence." << endl;
	cout << "Second sentence " << endl;
ed otterrai: 
	First sentence. 
	Second sentence.
[NB: the end1 manipulator produces a newline character , exactly as the insertion of '\n' does but it also have an additional behavior when it is used with buffered streams (see buffered stream def for more info): the buffer is flushed (cioe' e' inviato dal buffer (temporary storage area) into the computer's permanent memory con una perdita di performance). Anyway , cout will be an unbufferred stream in most cases so you can generally use both the \n escape character and the endl manipulator in order to specify a new line withou any difference in its behavior.]
// ==============================================
// ==============================================
// ==============================================



>> string : variables that can store non-numerical values that are longer than one single character ex: 
	string mystring = "This is a string";
[o anche 
	string mystring ("This is a string");]
NB: in order to declare and use these objects it is necessary to add the following line 
	#include <string>
quindi il beginning del source code sara' del tipo:
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
		{ ect
- Strings can also being declared without an initial value and being assigned values during execution
ex:
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
	{
		string mystring;
	mystring = "This is the initial string content";
	cout << mystring << endl; // endl = vai a capo
	mystring = "This is a different string content";
	cout << mystring << endl;
		return 0;
	}
// ==============================================
// ==============================================
// ==============================================

>> STRING ALL'INTERNO DI UNA FUNCTION / >> STRING INSIDE FUNCTION 
bisogna prima far precedere la string dal nome della library in cui e' definita
	std::string TitleCiccio = "Eri and Yui Queens of Prairies";
usare solo string TitleCiccio non funziona.

>> STRING EXAMPLES / >> STRING CLASS TEST PROGRAM
pag 435 deitel /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
// Fig. 10.1: fig10_01.cpp
// Standard Library string class test program.
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
	{
	   string s1( "happy" );
	   string s2( " birthday" );
	   string s3;
	
	   // test overloaded equality and relational operators
	   cout << "s1 is \"" << s1 << "\"; s2 is \"" << s2
	      << "\"; s3 is \"" << s3 << '\"' 
	      << "\n\nThe results of comparing s2 and s1:"
	      << "\ns2 == s1 yields " << ( s2 == s1 ? "true" : "false" )
	      << "\ns2 != s1 yields " << ( s2 != s1 ? "true" : "false" )
	      << "\ns2 >  s1 yields " << ( s2 > s1 ? "true" : "false" ) 
	      << "\ns2 <  s1 yields " << ( s2 < s1 ? "true" : "false" )
	      << "\ns2 >= s1 yields " << ( s2 >= s1 ? "true" : "false" )
	      << "\ns2 <= s1 yields " << ( s2 <= s1 ? "true" : "false" );
	      
	   // test string member function empty 
	   cout << "\n\nTesting s3.empty():" << endl;
	
	   if ( s3.empty() )
	   {
	      cout << "s3 is empty; assigning s1 to s3;" << endl;
	      s3 = s1; // assign s1 to s3
	      cout << "s3 is \"" << s3 << "\"";
	   } // end if
	
	   // test overloaded string concatenation operator
	   cout << "\n\ns1 += s2 yields s1 = ";
	   s1 += s2; // test overloaded concatenation
	   cout << s1;
	
	   // test overloaded string concatenation operator with a C string
	   cout << "\n\ns1 += \" to you\" yields" << endl;
	   s1 += " to you";  
	   cout << "s1 = " << s1 << "\n\n";
	
	   // test string member function substr
	   cout << "The substring of s1 starting at location 0 for\n"
	      << "14 characters, s1.substr(0, 14), is:\n"
	      << s1.substr( 0, 14 ) << "\n\n";
	
	   // test substr "to-end-of-string" option
	   cout << "The substring of s1 starting at\n"
	      << "location 15, s1.substr(15), is:\n"
	      << s1.substr( 15 ) << endl; 
	
	   // test copy constructor
	   string s4( s1 );  
	   cout << "\ns4 = " << s4 << "\n\n";
	
	   // test overloaded copy assignment (=) operator with self-assignment
	   cout << "assigning s4 to s4" << endl;
	   s4 = s4;  
	   cout << "s4 = " << s4 << endl;
	
	   // test using overloaded subscript operator to create lvalue
	   s1[ 0 ] = 'H';      
	   s1[ 6 ] = 'B';
	   cout << "\ns1 after s1[0] = 'H' and s1[6] = 'B' is: "
	      << s1 << "\n\n";
	
	   // test subscript out of range with string member function "at"
	   try                                                               
	   {                                                                 
	      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
	      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
	   } // end try                                                      
	   catch ( out_of_range &ex )                                        
	   {                                                                 
	      cout << "An exception occurred: " << ex.what() << endl;        
	   } // end catch                                                    
	} // end main
	/**************************************************************************
	 * (C) Copyright 1992-2014 by Deitel & Associates, Inc. and               *
	 * Pearson Education, Inc. All Rights Reserved.                           *
	 *                                                                        *
	 * DISCLAIMER: The authors and publisher of this book have used their     *
	 * best efforts in preparing the book. These efforts include the          *
	 * development, research, and testing of the theories and programs        *
	 * to determine their effectiveness. The authors and publisher make       *
	 * no warranty of any kind, expressed or implied, with regard to these    *
	 * programs or to the documentation contained in these books. The authors *
	 * and publisher shall not be liable in any event for incidental or       *
	 * consequential damages in connection with, or arising out of, the       *
	 * furnishing, performance, or use of these programs.                     *
	 **************************************************************************/
////////////////////////////////////////////////////////////
NOTE: il precedente programma una volta compilato via g++ on ubuntu 12 ci donava il seguente errore:
	[2025 fig10_01] >> g++ fig10_01.cpp -o edyProgram10-01
	fig10_01.cpp: In function ?eint main()?f:
	fig10_01.cpp:75:12: error: expected type-specifier before ?eout_of_range?f
	fig10_01.cpp:75:25: error: expected ?e)?f before ?e&?f token
	fig10_01.cpp:75:25: error: expected ?e{?f before ?e&?f token
	fig10_01.cpp:75:26: error: ?eex?f was not declared in this scope
	fig10_01.cpp:75:29: error: expected ?e;?f before ?e)?f token
SOLUTION abbiamo commentato tutta la guilty section :
	/*
   // test subscript out of range with string member function "at"
   try                                                               
   {                                                                 
      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
   } // end try                                                      
   catch ( out_of_range &ex )                                        
   {                                                                 
      cout << "An exception occurred: " << ex.what() << endl;        
   } // end catch                                                    
   */
//////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

>> STRING MANIPULATORS
[pag573 deitel]
C++ provides various stream manipulators that perform formatting tasks. The strea manipulators provide capabilities  such as 
	- setting field widths
	- setting precision
	- setting and unsetting format state
	- setting the fill character in fields, 
	- flushing streams
	- inserting a new line into the output stream
	- inserting a null character into the output stream and skipping white space in the input stream. 
a pagina 574 trovi spiegati 
	>> hex = manipulator to set the base to hexadecimal (base 16)
	>> oct = manipulator to set the base to octal (base 8)
	>> dec = usato per reset the stream base to decimal. 
Integers are interpreted normally as decimal (base 10) values. To change the base in which integers are interpreted on a stream, inset the hex manipulator to set the base to hexahedral. or insert the oct manipulator to set the base to octal.
These are all sticky manipulators.
A stream's base also may be changed by the setbase stream manipulator, which tkes an int argument of 10, 8, or 16  to set the base to decimal, octal or hexadecimal, respectively. Because setbase takes an argument, it's called a >> parameterized stream manipulator. 
Parameterized stream manipulators like setbase, require the header <iomanip>. The stream base value remains the same until changed explicitly; setbase settings are sticky.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> string size [pag22 moo book]
Whenever we need a local variable to contain the size of a string, we should use std::string::size_type as the type of the variable
Example
	const string::size_type nomeVariabile = nomeStringa.size();
[from program /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter02/frame.cc]
NOTE perche' complicarsi la vita ad usare "const string::size_type nomeVariabile" al posto del piu' semplice "const int nomeVariabile
It's for ensuring that nomeVariabile is capable of containing the number of characters in nomeStringa, no matter how large that number might be. We could simply have said that "nomeVariabile" has type int, and indeed, doing so would probably work. However, the value of nomeVariabile depends on the size of the input to our program, and we have no control over how long that input might be. It is conceivable that someone might give our program a string so long that an int is insufficient to contain its length.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STORAGE DURATION 
[pag 225deitel]
in the programs we use identifiers for variable names and functions. The attributes of variables include name, type, size and value. each identifier in a program also has other attributes, like storage duration, scope and linkage
STORAGE DURATION : an identifier storage duration determines the period during which that identifier exists in memory. Some exist briefly, some are repeatedly created and distroyed and others exist for a program's entire execution. 
The storage-class specifiers can be split into four storage durations: automatic, static, dynamic and thread.
You can request additional memory in your program during the program's execution - so called dynamic memory allocation. Variables allocated dynamically have dynamic storage duration.
- Variable with automatic storage duration include:
	local variables declared in functions
	function parameters
	local variables or function parameters declared with register
Such variables are created when program execution enters the block in which they're defined, they exist while the block is active and they're destroyed when the program exist the block. An automatic variable exists only in the nearest enclosing pair of curly braces within the body of the function in which the definition appears, or for the entire function body in the case of a function parameter. Local variables are of automatic storage duration by default. For the remainder of the text, we refer to variables of automatic storage duration simply as automatic variables.
Performance tip: automatic storage is a means of conserving memory, because automatic storage duration variables exist in memory only when the block in which they're defined is executing.  
 

>> STRING LITERAL string literal = is when you have "" surrounding the literal text "Hello Fede!" is a string literal

>> string concatenation using +=
example from /home/dia/Deitel-Code_Examples/ch10/fig10_01
   string s1( "happy birthday" );
   // test overloaded string concatenation operator with a C string
   cout << "\n\ns1 += \" to you\" yields" << endl;
   s1 += " to you";  
   cout << "s1 = " << s1 << "\n\n";

>> string copy constructor 
[pag438deitel]
   // test copy constructor
   string s4( s1 );  
   cout << "\ns4 = " << s4 << "\n\n";
With the line string s4( s1 );  we create a string object s4 and initializes it with a copy of s1. This results in a call to class string's "copy constructor".  

>> STRINGSTREAM
stringstream is useful to perform extraction or insertion operations from/to strings,We convert  strings to numerical values and viceversa. 
EX
	string mystr;	
	int quantity=0;
	cout << "Enter quantity: ";
    getline (cin, mystr);
	stringstream(mystr) >> quantity; 	
	/* in tal modo la variabile quantity contiene 	
	ora il valore numerico che hai inserito in 
	formato stringa attraverso la tastiera.*/  
[NB: Per poter usare stringstream devi inserire nell'header 
	#include <sstream>
]
// ==============================================
// ==============================================
// ==============================================

>> STRING Assignment and concatenation 
[pag850 deitel]
The class template basic_string provides typical string manipulation operations such as copyoing searching, etc. The template definition and all support facilities are defined in namespace std; these include the typedef statement
	typedef basic_string< char > string;
that creates the alias type string for basic_string<char>. 
>> string initialization / >> initializing string / >> initialization string [pag850 deitel]
Example 1
	string text("Hello");  // creates a string from a const char *
Example 2 (with two constructor arguments)
	string name(8, 'x'); // string of 8 'x' characters
which creates a string containing eight 'x' characters.
Example 3 puoi anche initializzarla con
	string month = "Month"; // same as :   string month("March");
>> string length [pag851 deitel]
the length of a string can be retrieved with member function "size" and with member function length. The subscript operator, [] (which does not perform bounds checking) can be used with strings to access and modify individual characters. A string object has a first subscrit of 0 and a last subscript of size() -1
>> string I/O [pag851]
The stream extraction operator (>>) is overloaded to support strings. The statements
	string stringObject;
	cin >> stringObject;
declare a string object and read a string from cin. INput is delimited by whitespace characters. When a delimiter is encountered, the input operation is terminated. Function 
	getline
also is overloaded for strings. Assuming string1 is a string, the statement
	getline( cin, string1 );
reads a string from the keyboard into string1. Input is delimited by a newline ('\n'), so getLine can read a line of text into a string object. You can specify an alternate delimiter as  the optional third argument to getline.
EXAMPLE 
// Fig. 21.1: fig21_01.cpp
// Demonstrating string assignment and concatenation.
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "cat" );
   string string2; // initialized to the empty string
   string string3; // initialized to the empty string

   string2 = string1; // assign string1 to string2
   string3.assign( string1 ); // assign string1 to string3
/*
note: the previous line uses member function assign to copy string1 into string3. A separate copy is made (cioe' string1 and string3 are indepedent objects). Class string also provides an overloaded version of member function assign that copies a specified number of characters, as in 
	targetString.assign( sourceString, start, numberOfCharacters );
where sourceString is the string to be copied, start is the starting subscript and numberOfCharacters is the number of characters to copy.
*/	 
   cout << "string1: " << string1 << "\nstring2: " << string2
      << "\nstring3: " << string3 << "\n\n";

   // modify string2 and string3 
   string2[ 0 ] = string3[ 2 ] = 'r';

   cout << "After modification of string2 and string3:\n" << "string1: " 
      << string1 << "\nstring2: " << string2 << "\nstring3: ";
/*
il precedente dona:
	string1: cat
	string2: cat
	string3: cat
	After modification of string2 and string3:
	string1: cat
	string2: rat
	string3: car
*/
// >> CONCATENATION EXAMPLE 
   // demonstrating member function at
   for ( size_t i = 0; i < string3.size(); ++i ) 
      cout << string3.at( i ); // can throw out_of_range exception

   // declare string4 and string5
   string string4( string1 + "apult" ); // concatenation
   string string5; // initialized to the empty string

   // overloaded +=                               
   string3 += "pet"; // create "carpet"           
   string1.append( "acomb" ); // create "catacomb"

   // append subscript locations 4 through end of string1 to
   // create string "comb" (string5 was initially empty)
   string5.append( string1, 4, string1.size() - 4 );
                                 
   cout << "\n\nAfter concatenation:\nstring1: " << string1 
      << "\nstring2: " << string2 << "\nstring3: " << string3 
      << "\nstring4: " << string4 << "\nstring5: " << string5 << endl;
/*
il codice precedente dona:
	After concatenation:
	string1: catacomb
	string2: rat
	string3: carpet
	string4: catapult
	string5: comb
*/
--------------------------------------------------------------------
>> at member function pag852 deitel
using the member function "at" you can output the contents of a string one character at a time. The member function "at" provides >> checked access ( or >> range checking )
On the contrary the subscript operator [] does not provide checked access. 
Accessing an elment beyond the size of the string using the subscript operator is an unreported logic error.

>> ARGUMENT mike pag66
Function can also take values to use in their work. You provide these values by placing them between the prentheses after the function name, separated by commas. These values are called arguments, and when you provide them, you pass them to the function. 
example 
	string1.insert( 10, string2 );
NOTE: >> ARGUMENT vs PARAMETER [pag175 mike programming game] : an arugment is what you use in a function call to pass a value to a function. A parameter is what you use in a function definition to accept values passed to a function.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> comparing string / >> string comparison 
[pag853 deitel]
if (string1 == string2)
	...
else if (string 1 > string2)
	...
else
---------------------------------------------------------------------
>> lexicographically GREATER than [pag855 deitel]
[pag855deitel]
ex T is considered lexicographically greater than H
----------------------------------------------------------------------
>> substrings [deitel pag856 deitel] / >> substr [deitel pag856 deitel] / >> extract portion of a string
Clas string provides member function substr for retreiving a substring from a string. 
// Fig. 21.3: fig21_03.cpp
// Demonstrating string member function substr.
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "The airplane landed on time." );

   // retrieve substring "plane" which
   // begins at subscript 7 and consists of 5 characters
   cout << string1.substr( 7, 5 ) << endl;
} // end main
-----------------------------------------------------------------------
>> swapping strings / >> string swap [pag 856 deitel]
	// Fig. 21.4: fig21_04.cpp
	// Using the swap function to swap two strings.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   string first( "one" ); 
	   string second( "two" );
	
	   // output strings
	   cout << "Before swap:\n first: " << first << "\nsecond: " << second;
	
	   first.swap( second ); // swap strings
	
	   cout << "\n\nAfter swap:\n first: " << first
	      << "\nsecond: " << second << endl;
	} // end main
///////////////// Result
	Before swap
	 first: one
	second: two
	
	After swap:
	 first: two
	second: one
----------------------------------------------------------------
>> string characteristcs / >> string size / >> string length / >> string capacity / >> string maximum length [pagdeitel 857]
>> substring find in string / >> characters in a string find [deitel pag859]
alcune funzioni utili 
	>> find 
		ex. string1.find( "is" )     -> ricerca la substring "is" all'interno di string1: if "is" is found the subscript location is returned.
[>> find algorithm vedi anche esempio pag 107 moo book]
	>> rfind = to search a string backward
		ex. string2.rfind ("is")     -> = Reverse find ricerca la substring "is" all'interndo di string2  from right to left
	>> find_first_of  to locate the first occurrence in nomeString of any of the characters contained between the "" of the argument
		ex. string1.find_first_of( "abc" );     -> appena trova in string1 la lettera a, o la lettera b o la lettera c ti indica la location all'interno della stringa, cioe' appena trova una delle tre, della prima che trova ti dona la location. 
	>> find_last_of to find the last occurrence in string1 of any character contained in " "
		ex string1.find_last_of( "abc" );
	>> find_first_not_of  : is a member function used to find the first character not contained in " " argument
		ex location = string1.find_first_not_of( "noi spm" );
note: [>> argument] piu' che dire "input passato a una funzione" e meglio dire "argument passed to a function" cioe' i parametri che inserisci tra le parentesi tonde della member function.
------------------------------------------------------------
>> replace characters in string / >> replace character in string / >> erase character from string / >> subtitution in string 
[deitel861]
1)	string1.erase( 62 );   -> erase everything from (and including) the character in position 62 to the end of the string1. Note: each newline character occupies one character in the string.
2) substitution example 
	   size_t position = string1.find( " " ); // find first space
	
	   // replace all spaces with period
	   while ( position != string::npos )    // nota: member function "find" returns string::npos when the search character is not found. Cio' significa che se position == not found allora tutte le sostituzioni sono state effettuate, e si esce dal ciclo while
	   {
	      string1.replace( position, 1, "." );
	      position = string1.find( " ", position + 1 );
	   } // end while
------------------------------------------------------------------ esemplification
	// Fig. 21.7: fig21_07.cpp
	// Demonstrating string member functions erase and replace.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   // compiler concatenates all parts into one string
	   string string1( "The values in any left subtree"
	      "\nare less than the value in the"
	      "\nparent node and the values in"
	      "\nany right subtree are greater"
	      "\nthan the value in the parent node" );
	   
	   cout << "Original string:\n" << string1 << endl << endl;
	
	   // remove all characters from (and including) location 62 
	   // through the end of string1
	   string1.erase( 62 );
	
	   // output new string
	   cout << "Original string after erase:\n" << string1
	      << "\nAfter first replacement:\n";
	             
	   size_t position = string1.find( " " ); // find first space
	
	   // replace all spaces with period
	   while ( position != string::npos ) 
	   {
	      string1.replace( position, 1, "." );
	      position = string1.find( " ", position + 1 );
	   } // end while
	    
	   cout << string1 << "\nAfter second replacement:\n";
	   
	   position = string1.find( "." ); // find first period
	
	   // replace all periods with two semicolons
	   // NOTE: this will overwrite characters
	   while ( position != string::npos )
	   {
	      string1.replace( position, 2, "xxxxx;;yyy", 5, 2 );
	      position = string1.find( ".", position + 1 );
	   } // end while
	
	   cout << string1 << endl;
	} // end main

OUTPUT 
Original string:
The values in any left subtree
are less than the value in the
parent node and the values in
any right subtree are greater
than the value in the parent node

Original string after erase:
The values in any left subtree
are less than the value in the

After first replacement:
The.values.in.any.left.subtree
are.less.than.the.value.in.the

After second replacement:
The;;alues;;n;;ny;;eft;;ubtree
are;;ess;;han;;he;;alue;;n;;he
------------------------------------------------------------
>> INSERT CHARACTERS INTO A STRING [pag863 deitel]

Example : [/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_08/]
The program declares initializes hen outputs strings string1, string2, string3, string4. Then uses function insert to insert string2's content before element 10 of string 1
	string1.insert( 10, string2 );
The line 
	string3.insert( 3, string4, 0, string::npos );
uses insert to insert string2 before string3's element 3. The last two argument specify the starting and last element of string4 that should be inserted. Using string::pos causes the entire string to be inserted. 
Ecco il programma completo:
	// Fig. 21.8: fig21_08.cpp
	// Demonstrating class string insert member functions.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   string string1( "beginning end" );
	   string string2( "middle " );
	   string string3( "12345678" );
	   string string4( "xx" );
	
	   cout << "Initial strings:\nstring1: " << string1
	      << "\nstring2: " << string2 << "\nstring3: " << string3
	      << "\nstring4: " << string4 << "\n\n";
	
	   // insert "middle" at location 10 in string1
	   string1.insert( 10, string2 );
	
	   // insert "xx" at location 3 in string3
	   string3.insert( 3, string4, 0, string::npos );
	
	   cout << "Strings after insert:\nstring1: " << string1
	      << "\nstring2: " << string2 << "\nstring3: " << string3
	      << "\nstring4: " << string4 << endl;
	} // end main
OUTPUT --;------------
	Initial strings:
	string1: beginning end
	string2: middle
	string3: 12345678
	string4: xx
	
	Strings after insert:
	string1: beginning middle end
	string2: middle
	string3: 123xx45678
	string4: xx
------------------------------------------------------------------
>> pointer based string conversion /  from string to pointer based string. [deitel pag864]
------------------------------------------------------------------
>> ITERATORS [pag865 deitel]
Class string provides iterators  for forward and backward traversal of strings. Iterators provide access to individual characters with a syntax that's similar to pointer operations. Iterators are not range checked.
Example /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_10/
-------------------------------------------- start example
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "Testing iterators" );
   string::const_iterator iterator1 = string1.begin();

   cout << "string1 = " << string1
      << "\n(Using iterator iterator1) string1 is: ";

   // iterate through string
   while ( iterator1 != string1.end() ) 
   {
      cout << *iterator1; // dereference iterator to get char [note: each element is printed by dereferencing the iterator much as you'd dereference a pointer, and the iterator is advanced one position using operator ++]
      ++iterator1; // advance iterator to next char
   } // end while

   cout << endl;
} // end main
------------------------------------------- end example
NOTE : from C++ 11 the lines 
   while ( iterator1 != string1.end() ) 
   {
      cout << *iterator1; // dereference iterator to get char
      ++iterator1; // advance iterator to next char
   } // end while
possono essere sostituite con il piu' compatto
	for (char c : string1 )
		cout << c;
Class string provides member functions >> rend and >> rbegin for accessing individual string chracters in reverse from the end of a string toward the beginning. Member functions rend and rbegin return >> reverse_iterators or >> const_reverse_iterators (based on whether the string is non-const or const). 
NOTE2 : when the operations involving the iterator should not modify the data being processed, use a const_iterator. This is another example of emplying the principle of lest privilege. 
----------------------------------------------------------------------
.......................................
>> STRING STREAM PROCESSING [pag867 deitel]
In addition to standard stream I/O and file stream I/O, C++ stream I/O includes capabilities for inputting from, and outputting to, strings in memory. Theses capabiliteis often are referred to as >> in memory I/O or >> string stream processing.
	- Input from a string is supported by class >> istringstream
NOTE: an isctrings stream object inputs data from a string in memory to program variables. Data is sotred in an sitringstream object as characters. Input from the istringsstrem object works identicallyy to input from any file. The end of the string is interpreted by the istringstream object as end-of-file. see example /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_12/ [riportato anche poco qui sotto]
	- Output from a string is supported by class >> ostringstream
see example + nostre note pag 868 deitel
 Class templates basic_istringstream and basic_ostringstream provide the same functionality as classes istream and ostream plus other member functions specific to >> in memory formatting. Programs that use in memory formatting must include the <sstream> and <iostream> headers.
	One application of these techniques is >> data validation. A program can read an entire line at a time from the input stream into a string. Next, a validation routine can scrutinize the contents of the string and correct (or repair) the data, if necessary. Then the program can proceed to input from the string, knowing that the input data is in the proper format.
	To asist wth data validation, C++ 11 prvides powerful regular expression capabilities. For example, if a program requires a user to enter a Japanese format telephone number (e.g. (080) 2689-0127), you can use a regular expression patter to confirm that the user's input matches the expected format. Many website provdie reular expressions for validating email addresses, URLSs, phone numbers, addresses and other popular kinds of data. 
	Outputting to a string is a nice way to take advantage of the powerful output formatting capabilities of C++ streams. Data can be prepared in a string to mimic the edited screen format. That string could be written to a disk file to preserve the screen image.
--------------------------------------
#include <iostream>
#include <string>
#include <sstream> // header for string stream processing
using namespace std;

int main()
{
   ostringstream outputString; // create ostringstream instance

   string string1( "Output of several data types " );
   string string2( "to an ostringstream object:" );
   string string3( "\n        double: " );
   string string4( "\n           int: " );
   string string5( "\naddress of int: " );

   double double1 = 123.4567;
   int integer = 22;

   // output strings, double and int to ostringstream outputString         
   outputString << string1 << string2 << string3 << double1  
      << string4 << integer << string5 << &integer;

   // call str to obtain string contents of the ostringstream
   cout << "outputString contains:\n" << outputString.str();

   // add additional characters and call str to output string
   outputString << "\nmore characters added";
   cout << "\n\nafter additional stream insertions,\n"
      << "outputString contains:\n" << outputString.str() << endl;
} // end main
////////////////////////////////////////////////////////////////////////////////
--------------------------------------------------------- istringstream EXAMPLE
int main()
{
   string input( "Input test 123 4.7 A" );   // the string input contains the data Input test 123 4.7 A which when read as input to the program, consist of two string ("Input" and "test"), and int (123), a double(4.7) and a char ('A'). These characters are extracted to variables string1, string2, integer, double1 and character in line @STARTag@
   istringstream inputString( input );
   string string1;
   string string2;
   int integer;
   double double1;
   char character;

   inputString >> string1 >> string2 >> integer >> double1 >> character;   // @STARTag@

// quindi the data is output in the following 4 lines:
   cout << "The following items were extracted\n"
      << "from the istringstream object:" << "\nstring: " << string1
      << "\nstring: " << string2 << "\n   int: " << integer
      << "\ndouble: " << double1 << "\n  char: " << character;

   // attempt to read from empty stream
   long value;
   inputString >> value;

   // test stream results        // interessante this if condition uses function "good" to test if any data remains. Because no data remains, the function returns false and the part of the if...else statement is executed.
   if ( inputString.good() )
      cout << "\n\nlong value is: " << value << endl;
   else
      cout << "\n\ninputString is empty" << endl;
} // end main
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> STRUCTURED PROGRAMMING SUMMARY / >> STRUCTURED PROGRAMS
pag 186deitel
Rules for forming structured programs
1) begin with the "simplest activity diagram"
2) any action state can be replaced by two action states in sequence [stacking rule cioe' connetti control statement in sequence]
3) any action state can be replaced by any control statement (sequence, if, if...else, switch, while, do...while or for) [nesting rule]
4) rules 2 and 3 can be applied as often as you like and in any order.
----------------------------------------------------------------------
The beauty of the structured programs is that we use only SEVEN simple single-entry/single-exit control statement 
(1 sequence 
2 if        |
3 if...else |  ---> selection
4 switch    |
5 while        |
6 do...while   |   ---> repetition
7 for)         |
and assemble them in only TWO simple ways (stacking or nesting)
Possiamo semplificare ancora di piu'
It is straightforward to proof that the 
	if statement is sufficient to provide any form of selection : qualunque selection done with if else e switch puo' essere implementata (anche se non in maniera ugualmente chiara ed efficiente) combining if statements
	any repetition puo' essere implementata usando una combinazione di cicli while (anche se non sempre cosi' smoothly)
in conclusione (gli spartani lo avrebbero adorato un linguaggio del genere!) any form of control ever needed in C++ program can be expressed in terms of the following:
- sequence
- if statement (selection)
- while statement (repetition)
and that these control statement can be combined in only two ways: stacking and nesting.


>> SU [this is just an UBIK tag per sorvolare la lunga serie di >> ST]

>> SUBTITUTE CHARACTER IN STRING
[pag438 deitel]
?@?@?@s1 = string ("happy birthday to you"); 
   // test using overloaded subscript operator to create lvalue
   s1[ 0 ] = 'H';      
   s1[ 6 ] = 'B';
   cout << "\ns1 after s1[0] = 'H' and s1[6] = 'B' is: "
      << s1 << "\n\n";
Donera in output:
	s1 after s1[0] = 'H' and s1[6] = 'B' is: Happy Birthday to you
in effetti se conti la posizione dei primi sei caratteri della stringa s1 [NOTE: si conta a partire da zero!!!]
	0123456
	happy birthday
quindi si comprende perche' s1[0] = 'H' fara' diventare la h maiuscola e s1[6] = 'B' fara' diventare la B maiuscola.
ATTENTION! ACHTUNG! 
Class string's overloaded [] operator does not perform any bounds checking. Therefore, you must ensure that operations using standard class "string's" overload [] operator do not accidentally manupulate elements outside the bounds of the string.
//////////////////////////////////////////////////////////////////////////////////

>> substr
[pag95 deitel, exampio pratico in pag94deitel + pag 435 deitel] [also pag 90 moo book]
substr (short for substring) is a member function of the standard class string. It returns a new string object created by copying part of an existing string object. 
Example 
	 nomeAbbreviato = name.substr( 0 , 25 );
this call passes to integers (0 and 25) to "name" 's member function substr. The first argument specifies the starting position in the original string from which characters are copied (the first character in every string is considered to be at position 0). The second argument specifes the number of characters to copy. Therefore 
	name.substr( 0 , 25 );
returns a 25-character substring of "name" starting at position 0 (that is, the first 25 characters).
Example pag435
/home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
line 47
   // test string member function substr
   cout << "The substring of s1 starting at location 0 for\n"
      << "14 characters, s1.substr(0, 14), is:\n"
      << s1.substr( 0, 14 ) << "\n\n";
the previous line gives a 14 character substring (specified by the second argument "14") of s1 starting from position 0 (specified by the first argument)
line 54
   // test substr "to-end-of-string" option
   cout << "The substring of s1 starting at\n"
      << "location 15, s1.substr(15), is:\n"
      << s1.substr( 15 ) << endl; 
NOTE: when the second argument is not specified (come nella riga precedente) substr return the remainder of the string on which it's called. Cioe' detto in parole spicciole s1.substr( 15 ) gives a substring starting from position 15 of s1.
///////////////////////////////////////////////////////////////////

>> SUM ELEMENTS ARRAY / OPERATION on ARRAY ELEMENTS / SUM ARRAY ELEMENTS
[pag280deitel]
To print the sum of the values contained in the first three elements of array c, we'd write:
	cout << c[ 0 ] + c[ 1 ] + c[ 2 ] << endl;
To divide the value of c[6] by 2 and assign the result to the variable x, we would write 
	x = c[ 6 ] / 2;

>> SWITCH MULTIPLE SELECTION STATEMENT[mike pag48]
The generic form of the switch statement is :
switch (choice)
{
	case value1:
		statement1;
		break;
	case value2:
		statement2;
		break;
	case value3:
		statement3;
		break;
         .
         .
         .
	case valueN:
		statementN;
		break;
	default:
		statementN+1;
}
////////////////////
The statement tests choice against the possible values (value1, value2, and value3) in order. If choice is equal to a value, then the program executes the corresponding statement. When the program hits a break statement, its exist the switch structure. If choice doesn't match any value, then the statement associated with the optional default is executed.
The use of break and default are optional. If you leave out a break, however, the program will continue through the remaining statements until it hits a break or a default or until the switch statement ends. Usually you want to break statement to end each case.
NOTE1: although a default case isn't required, it's usually a good idea to have one as a cathall.
NOTE2: (idea to test) penso che questo possa essere un buon strumento di >> DEBUG. quando per esempio in FOAM la compilazione viene ma poi il test case arresta l'esecuzione senza nessun messaggio chiaro, possiamo usare i nostri strumenti Info<< and accerchiare la porzione di programma che pare essere l'origine dell'eccezione in modo da catchare l'eccezione e cercare di ottenere qualche ulteriore informazione sul tipo di crash.
Here's an example to cement the ideas. Suppose choice is equal to value2. The program will first test choice against value1. Because they're not equal, the program will continue. Next, the program will test choice against value2. Because they are equal, the program will execute statement2. Then the program will hit the break statement an exit the switch structure.
NOTE3: you can use the switch statement only to test an int (or a value that can be treated as an int, such as a char or an enumerator). A switch statement won't work with any other type.
Example : menu chooser program presents the user with a menu that lists three difficulty levels and asks him to make a choice. If the user enters a number that correponds to a listed choice, then he is shown a message confirming the choice. If the user makes some other choice, he is told the choice is invalid [gia' questa tipologia di programma quante volte che sara' stato utilizzato all'interno di macchinette ATM and company!].
Example :
///
// Menu Chooser
// Demonstrates the switch statement

#include <iostream>
using namespace std;

int main() 
{
	cout << "Difficulty Levels\n\n";
	cout << "1 - Easy\n";
	cout << "2 - Normal\n";
	cout << "3 - Hard\n\n";

	int choice;
	cout << "Choice: ";
	cin >> choice;

	switch (choice)
	{
		case 1:	
			cout << "You picked Easy.\n";
			break;
		case 2:	
			cout << "You picked Normal.\n";
			break;
		case 3:	
			cout << "You picked Hard.\n";
			break;
		default:
			cout << "You made an illegal choice.\n";
	}

    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////
-------------------------------------------------------
[pag169deitel]
esempio pratico pag172deitel
Observations from pag 174deitel
1) ...
switch ( expression )  // this is called the controlling expression.
{
2) the "switch" statement compares the value of the controlling expression with each case label.
3) the "break" statement causes program control to proceed with the first statement after the switch.
4) without break statements, each time a match occurs in the switch, the statements for that case and subsequent cases execute until a break statement or the end of the switch is encountered. 
5) switch UML activity diagram pag177deitel 
///////////////////////////////////////////////////////////////////////////////////


>> SWAP / >> algorithm swap / >> iter_swap / >> swap_ranges 
[pag710 deitel]
swap, iter_swap and swap_ranges are used for swapping elements
EXAMPLE /home/dia/Deitel-Code_Examples/ch16/fig16_07/fig16_07.cpp
output of the program:
	Array a contains:
	   1 2 3 4 5 6 7 8 9 10
	Array a after swapping a[0] and a[1] using swap:
	   2 1 3 4 5 6 7 8 9 10
	Array a after swapping a[0] and a[1] using iter_swap:
	   1 2 3 4 5 6 7 8 9 10
	Array a after swapping the first five elements
	with the last five elements:
	   6 7 8 9 10 1 2 3 4 5
>> swap algorithm 
	 18    swap( a[ 0 ], a[ 1 ] ); // swap elements at locations 0 and 1 of a
line18 uses the swap algorithm to exchange two values. In this example, the first and second elements of array "a" are exchanged. The function takes as arguments references to the two values being exchanged.
>> iter_swap algorithm 
	 23    // use iterators to swap elements at locations 0 and 1 of array a
	 24    iter_swap( a.begin(), a.begin() + 1 ); // swap with iterators 
line24 uses function iter_swap to exchange the two elements. The function takes two forward iterator arguments (in this case, iterators to elements of an array) and exchanges the values in the elements to which the iterators refer.
>> swap_ranges algorithm 
[pag711 deitel]
	 28    // swap elements in first five elements of array a with
	 29    // elements in last five elements of array a 
	 30    swap_ranges( a.begin(), a.begin() + 5, a.begin() + 5 );
line30 uses function swap_ranges to exchange the elements from a.begin() up to, but not including a.begin()+5?@with the elements beginning at position a.begin()+5.
Il risultato (vedi output riportato sopra) e' che nel vettore di 10 elementi dell'esempio sopra, i primi cinque elementi del vettore diventano gli ultimi 5, e gli ultimi cinque diventano i primi cinque.
The first two arguments specify the range of elements in the first sequence that will be exchanged with the elements in the second sequence starting from the iterator in the third argument.
In this example, the two sequences of values are in the same array, but the sequences can be from different arrays or containers. 
The sequences must not overlap. The destination sequence must be large enough to contain all the elements of the ranges being swapped.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TTTTTTT

>> tie 
[pag 590 deitel]
Interactive applications generally involve an istream for input and an ostream for outputs.
The prompt needs to appear before the input operation proceeds. 
C++ provides member function "tie" to synchronize (= tie together) the operation of an istream and an ostream to ensure that outputs appear before their subsequent inputs.

>> try / >> catch example from pag 59-60 moo book
try tries to execute the statements in {} that follow the try keyword. If a domain_error exception occurs anywhere in these statements, then it stops executing them and continues with the other set of {} enclosed statements. These statements are part of a catch clause, which begins with the catch and indicates the type of exception it is catching.
If the statements between try and catch complete without thrwoing an exception, then the program skips the catch caluse entirely and continues with the next statement.
WARMING: whenever we write a try statement, we must think carefully about side effects and when they occur. We must assume that anything between try and catch might throw an exception. If it does, so then any computation that would have been executed after the exception is skipped. What is important to realize is that a computation that might have followed an expcetion in time does not necessarily follow it in the program text. 
[from the program /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main1.cc]

	// compute and generate the final grade, if possible
	try {
		double final_grade = grade(midterm, final, homework);
		streamsize prec = cout.precision();
		cout << "Your final grade is " << setprecision(3)
		     << final_grade << setprecision(prec) << endl;
	} catch (domain_error) {
		cout << endl << "You must enter your grades.  "
			"Please try again." << endl;
		return 1;
	}

	return 0;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TIME CLASS 
[pag379deitel]
prevents multiple definition errors.
The class definition is enclosed in the following include guard
	// prevent multiple inclusions of header
	#ifndef TIME_H
	#define TIME_H
	...
	#endif
[Extract from Deitel-CppWebResources/Code_Examples/ch09/fig09_01_03/Time.h]
When  we build larger programs, other definitions and declarations will also be placed in headers. The preceding include guard prevents the code between #ifndef (which means if not defined) and #endif from being included if the name TIME_H has been defined. If the header has not been included previously in a file, the name TIME_H is defined by the #define directive and the header statements are included. 
Use #ifndef, #define and #endif preprocessing directives to form an include guard that prevents headers from being included more than once in a source-code file.
NOTE: by convention, use the name of the header in uppercase with the period (= il punto) replaced by an undescore in the #ifndef and #define preprocessing directives of a header. (cioe' ex al posto di time.h use TIME_H) 

>> TIME print 
[pag382deitel]
extract from Deitel-Code_Examples/ch09/fig09_01_03/Time.cpp
/*
questa function takes no arguments and outputs the date in stadard time format, consistinng of the hour, minute and second values separated by colons and followed by an AM or PO indicator.
*/
void Time::printStandard() const
{
   cout << ( ( hour == 0 || hour == 12 ) ? 12 : hour % 12 ) << ":" 
      << setfill( '0' ) << setw( 2 ) << minute << ":" << setw( 2 )
      << second << ( hour < 12 ? " AM" : " PM" );
} // end function printStandard
////////////////////////////////////////

>> this Pointer / >> "this" Pointer
[pag412deitel]
We've seen that an object's member functions can manipulate the object's data. There can be namy objects of a class, so how do member functions know which object's data members to manipulate ? Every object has access to its own address trough a pointer called "this" (a C++ keyword). The "this" pointer is not part of the object itself (cioe' the memory occupied by the "this" pointer is not reflected in the result of a "sizeof" operation on the object). Rather, the "this" pointer is passed (by the compiler) as an implicit argument to each of the object's non-static member function. [on the contrary the "this" pointer is not implicitly passed to "static" member functions]
[pag34 mike game programming] The this pointer is a pointer that all non static member functions automatically have; it points to the object that was used to call the function.
>> this pointer explicit use example pag 412 deitel:
A common explicit use of the "this" pointer is to avoid naming conflicts between a class's data members and member function parameters (or other local variables). 
[tag >> conflict name avoid how to: using the "this" Pointer]
Se per esempio al posto dell'originale Time.cpp ch09/fig09_04_09
	// set hour value
	void Time::setHour( int h )
	{
	   if ( h >= 0 && h < 24 )
	      hour = h;
	   else
	      throw invalid_argument( "hour must be 0-23" );
	} // end function setHour
Mettessimo: 
	// set hour value	void Time::setHour( int hour )
	{
	   if ( hour >= 0 && hour < 24 )
	      this->hour = hour;
	   else
	      throw invalid_argument( "hour must be 0-23" );
	} // end function setHour
rispetto all'originale nel precedente spezzone abbiamo settato il nome del parametro di setHour a "hour" al posto di "h". E sorge cosi' il problema che il data member "hour" che prima veniva aggiornato con un "= h;" ora viene aggiornato con un parametro che ha il suo stesso nome. In setHour's scope, the parameter "hour" hides the data member. However you can still access the data member "hour" by qualifying its name with "this->" . So the following statement assigns the hour parameter's value to the data member "hour"
	this->hour = hour; // si usa il pointer this to access the data member hour (quello a sinistra dell'uguale) e gli si assegna il parametro hour (a destra dell'uguale).
ADVICE: to make your code clearer and more maintanable, never hide data with member with local variables names.
NOTE1: the type of the "this" pointer depends on the type of the object and whether the member function in which this is used is declared const. see pag 413deitel
NOTE2: Implicitly and >> explicitly using the "this" pointer to access an Objct's data member.
see pag 413 deitel
Example fig 9.23 demonstrates the implicit and explicit use of the "this" pointer to enable a member function of class "Test" to print the "private" data "x" of a "Test" object.
	// print x using implicit and explicit this pointers;
	// the parentheses around *this are required
	void Test::print() const   
	{
	   // implicitly use the this pointer to access the member x
	   cout << "        x = " << x;
	   // explicitly use the this pointer and the arrow operator
	   // to access the member x
	   cout << "\n  this->x = " << this->x;
	   // explicitly use the dereferenced this pointer and 
	   // the dot operator to access the member x
	   cout << "\n(*this).x = " << ( *this ).x << endl;   // le parentesi attorno a *this sono obbligatorie. Le parentesi sono richieste perche' the dot operator has higher precedence than the * operator. Without the parentheses, the expression *this.x would be evaluated like *(this.x) which is a compilation error, because the dot operator cannot be used with a pointer.
	} // end function print
Ed otterrai printato su schermo:
	x = 12
	this-> = 12
	(*this).x = 12
NOTE: one interesting use of the "this" pointer is to prevent an object from being assigned to itself. Self-assignment can cause serious erros when the object contains pointers to dynamically allocated storage.
//////////////////////////////////////////////////////////////////////
Un altra bella spiegazione di "this->" la trovi qui
				// http://www.learncpp.com/cpp-tutorial/87-the-hidden-this-pointer/
				// te ne ho salvato anche copia della pagina in 
				// blackbird WebKaraDocs  thisPointer-8.7 The hidden-this-pointer-Learn C++
//////////////////////////////////////////////////////////////////////

>> this [pag 198 moo book]
The "this" keyword is valid only inside a member function, where it denotes a pointer to the object on which the member function is operating.
We use "this" to determine whether the right and left hand sides of the assignment refer to the same object. If they do, then they will have the same address.

>> this pointer to enable cascaded functions calls / >> cascaded member function calls 
[pag414 deitel]
Another use of the this pointer is to enable cascaded member-function calls, that is invoking multiple functions in the same statement
Example from fig9.26 /home/dia/Deitel-Code_Examples/ch09/fig09_24_26/fig09_26.cpp
   // cascaded function calls
   t.setHour( 18 ).setMinute( 30 ).setSecond( 22 );

>> TOP DOWN REFINEMENT /STEPWISE REFINEMENT
[pag125deitel]
cioe' si parte dalla overall representation of the program e si raffina a poco a poco. Helpful technique to develop well-structured programs.  

>> TRAILING RETURN TYPES for functions
[pag248deitel]
Example 
	template < typename T >
	auto maximum( T x, T y, T z ) -> T
to specify a trailing return type you place the keyword auto before the function name, then follow the function's parameter list with -> and the return type.  

>> TREE 
[pag803 deitel]
A tree is a nonlinear, two-dimensional data structure. 
At pag 803 e segg are discussed the >> binary tree = trees whose nodes all contain two links (none, one or both of which may have the value of nullptr  see fig19.18 pag803 bel graphico esplicativo.)
Nomenclature / Terminology
>> root node is the first node of a tree (da non confondere con il root node pointer, che semplicemente punta al primo elemento del tree - se il presente linguaggio ti sembra un poco astruso, see fig19.18 pag 803, bella raffigurazione. Anche tutte le definizioni che seguono qui sotto sono riferite a tale figura)
>> child / node child [pag803 deitel]
>> left subtree [pag803 deitel]
>> right subtree [pag803 deitel]
>> siblings nodes  [pag803 deitel]
>> leaf node = node with no children [pag803 deitel]
---------------------------------------------------
>> binary search tree [pag803 deitel]
A binary search tree (with no duplicate node values) has the characteristic that 
1) the values in any left subtree are less than the value in its >> parent node
2) the values in any right subtree are greater than the value in its parent node 
[see esempio pag 804 deitel]
>> TreeNode / >> tree node class [pag806 deitel]
----------------------------------------------------
START REPETITA IUVANT
>> binary trees facilitate searching and sorting data, duplicate elimination and compiling expressions into machine code. [see pag803deitel]
NOTE: from pag 780 deitel: stacks and queues are linear data structures and they can be viewed as constrained versions of linked lists. Trees are nonlinear data structures.
NOTE2: basic terminology dei trees structures [from pag803 deitel]
	>> root node	deitel p803
	>> child node 	deitel p803
	>> siblings 	deitel p803
	>> leaf node 	deitel p803
	>> left child	deitel p803  non nel senso di bambino lasciato solo, ma di "bambino sul lato sinistro
	>> right subtree deitel p803
	>> left subtree	deitel p803
FINE REPETITA IUVANT
----------------------------------------------------
>> inorder traversal	deitel p804  / >> in order 
	NOTE: [pag810deitel] inorder traversal of a binary search tree prints the node values in ascending order. The process of creating a binary serach tree actually sorts the data - thus this process is called the >> binary tree sort.
>> preorder traversal 	deitel p804  / >> pre order 
	>> preorder traversal algorithm [pag810deitel]
>> postorder traversal	deitel p804  / >> post order
>> duplication elimination / >> eliminate duplicate [pag811 deitel]
	searching a binary gree for a value that matches a key value is fast. If the tree is balanced, then each branch contains about half the number of nodes in the tree. Each comparison of a node to the search key eliminates half the nodes. This is called a 0(logn) algorithm.
So a binary serach tree with n elements would require a maximum of log_2 n comparisons either to find a mathc or to determine that no match exists. This means for example, that when searching a balanced 1000 element binary search tree, no more than 10 comparisons need to be made, because 2^10 > 1000.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TRUNCATION vs ROUNDING in integer division 
[pag123deitel]
the integer division TRUNCATES does means 
7:4 = 1 
anche se aritmeticamente 7:4 = 1.75
suppore che dividendo tra interi 7:4 = 2 no ti taglia secco tutto il 0.75 e ti lascia con 1 e tanti saluti.
Da qui mi viene il mente furbo il nostro trick di aggiungere 0.5 prima di effettuare il troncamento.

>> TYPE CASTING OPERATOR
Type casting operators allow you to convert a datum of a given type to another. 
- Way 1: precede the expression to be converted by the new type enclosed between parentheses (); ex:
	int i;
	float f = 3.14;
	i = (int) f;
The previous code converts the float number 3.14 to an integer value (3), the remainder is lost. Here the typecasting operator was int. 
- Way2: using the functional notation: preceding the expression to be converted by the type and enclosing the expression between parenthesis: 
	i = int (f);

>> typeid / >> type_info 
[pag556 deitel]
Operator typeid returns a reference to an object fo class type_info that contains the information about the bype of its operand, including the name of that type. To use typeid the program must include header <typeinfo>
NOTE: portability
The string returned by type_info member function name may vary by compiler.

>> TYPE FIELDS and switch STATEMENTS
[pag533deitel]
One way to determine the type of an object is to use a switch statement to check the value of a field in the object. This allows us to distinguish amon object types, then invoke an appropriate action for a particular object. For example, in a hierarchy of shapes in which each shape object has a shapeType attribute, a switch statement could check the object's shapeType to determine which print function to call.
But using switch logic exposes programs to a variety of potential problems. For example, you might forget to include a type test or might forget to test all possible cases in a switch statement. Tracking these statements down can be time consuming and error prone. 
SOLUTION : use polymorphic programming instead. Polymorphic programming can eliminate the need for switch logic. By using the polymorphism mechanism to perform the equivalent logic, you can avoid the kinds of errors typically associated with switch logic.
An interesting consequence of using polymorphism is that programs take on a simplified appearance. They contain less branching logic and simpler sequential code.

>> UUUUUUUU

>> UML 
Unified Modeling Language
[pag16deitel]
In the UML, each class is modeled in a UML class diagram as a rectangle with three compartements.
1) the top compartement contains the class's name centered horinzontally and in boldface type.
2) the middle compartment contains the class's attributes, which correspond to data members in C++.
3) the bottom compartment contains the class's operations, which correspond to member functions in C++
- the plus sign (+) in front of the operation name indicates that the function is a public operation in the UML (i.e. a public member function in C++)
[pag50deitel]
- ROMBO : il segno romboidale / diamond indica una decision symbol, which indicates that a decision is to be made [pag111deitel]
- il ROMBO puo' anche indicare un MERGE symbol which joins two flows of activity into one flow of activity [see example pag117deitel con il while loop] anche se graficamente sono rappresentati dallo stesso simbolo li puoi differenziare considerando che 
> il decision symbol ha una freccia in entrata e due o piu' frecce in uscita 
> il merge symbol ha due o piu' frecce in entrata e una sola freccia in uscita
- l'italic (caratteri in corsivo) e' utilizzato per indicare le classi astratte [pag535 deitel: the abstract class name is italicized as per the convertion of the UML]

un tipico esempio grafico da pag 260 mike game programming 
	                        -----------------------------
	                        |                           |
	nome della classe       |          Critter          |       
	                        -----------------------------
	                        |                           |
	                        |      -m_Hunger:int        |
	data members            |      -m_Boredom:int       |
	                        |                           |
	                        -----------------------------     
	                        |                           |
	                        |      +Talk()              |
	                        |      +Eat()               |       
	member functions        |      +Play()              |
	                        |      -PassTime()          |
	                        |                           |
	                        -----------------------------      


examples [notazione grafica i tre blocchi li rapresentiamo con 1) 2) 3) se non scriviamo nulla significa che il campo e' vuoto]
1) GradeBook 
2)
3) + displayMessage( courseName : String )
GradeBook class contains public member function displayMessage with 1 parameter di nome courseName e type String. 
NB: the UML is language indipendent, so its terminology does not exactly match that of C++ . For example UML type String corresponds to the C++ type string. 
[pag73]
- Example UML diagram with a data member and set and get Functions
[pag79deitel]
1) GradeBook
2) -courseName : String
3) + setCourseName( name * String )
   + getCourseName( ) : String
   + displayMessage()
The UML represents data members as attributes by listing the attribute name, followed by a colon and the attribute type  [nell'esempio sopra -courseName : String]. The minus sign in front of the attribute's name indicate that data member courseName is private 
----------------------------------------------------
UML nice UML diagrams for / for UML / do...while UML / if..else UML / switch UML 
- sequence
- if
- if...else
- switch 
- while
- do...while
- for
statements li trovi a pag 187deitel
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unformatted I/O using read write and gcount
[pag 573 deitel]
Unformatted input/output is perfromed using the read and write member functions of istream and ostream, respectively. Member function read inputs bytes to a built-in array of chars in memory; member function write outputs bytes from a built-in array of chars. These bytes are not formatted in any way. They're input or output as raw bytes.
>> read member function inputs a designated number of characters into a built-in array of chars. 
>> gcount is a member function that reports the number of characters read by the last input operation.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unget [pag217 moo book]
unget : the unget function undoes the most recent get by backspacing the input stream by one character.

>> uppercase  lowercase conversion / >> lowercase uppercase conversion / >> toupper() [pag135 mike programming game]
use 
	#include<cctype>
it's part of the standard library and it includes functions for converting characters to uppercase.
example 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter04/hangman.cpp
By using #include<cctype> then you can use line like 
	        guess = toupper(guess); 
this function take as input guess (che contiene a character inputtato dallo user) and the function toupper returns the uppercase version of it. 
///////////////////////////////////////////////////////////////////////////////////////

>> update sequential files / >> sequential files update / >> updating sequential files / >> sequential file update
[pag611 deitel]
Se avessi un file in cui vuoi cambiare giusto una parola, per esempio mettere "Enterprise" al posto di "Nostromo", il problema e' che se lo si effettua in maniera sequenziale, il fatto che Enterprise abbia 3 caratteri in piu' rispetto a Nostromo, fa si che i 3 caratteri che seguono la parola nostromo verranno sovrascritti dalla "ise" di Enterprise [detto in maniera tecnica: i caratteri aggiuntivi "ise" will overwrite the beginning of the next sequential record in the file], e il file dopo l'"update sequenziale" risultera' cosi' corrotto. 
La soluzione quindi se si vuole effettuare un update sequenziale e' di fatto di creare un file nuovo
- nel nuovo file prima si copiera' tutto cio' che precede la porzione che si vuole modificare
- quindi (sempre nel nuovo file) si copiera' la porzione modificata
- infine si copiera tutto cio' che segue alla porzione modificata
Quindi si potra' eliminare il vecchio file e rinominare il nuovo con il nome di quello appena cancellato.
This requires processing every reconrd in the file to update one record. Quindi non molto efficiente ma accettabile nei casi in cui many records are being updated in one pass of the file.
NOTE: anche se e' vero che valori come
	7
	14
	-117
	2074
	27383
are all ints which store the same number of "raw data" bytes internally (typically four bytes on 32 bit machines and 8 bytes on 64-bits machines), however these integers become different-sized fields, depending on their actual values, when ouput as formatted text (character sequences). Therefore, the formatted input/output model usually is not used to update records in place.
L'alternativa e' di usare il 
>> RANDOM ACCESS FILE [pag611deitel]
Sequential files are inappropriate for >> instant access application, in which a particular record must be located immediately. Common instant access applications are airline reservation system, >> ATM (automated Teller Machines), and other kinds of transaction processing systems that require rapid access to specific data. A bank might have hundreds of thousands (or even millions) of other customers, yet, when a customer usees an automated teller machine, the program checks that customer's account in a few seconds or less for sufficient funds. This kind of instant access is made possible with random access files. Individual records of a random-access file can be accessed directly (and quickly) witohout having to search other records.
As we've said, C++ does not impose structure on a file. So the application that wnats to use random-access files must create them 
A variaty of techniques can be used. Perhaps the easiest method is to require that all records in a file be of the same fixed length. 
Using same-size fixed-length records makes it easy for a program to quickly calculate (as function of the record size and the record key) the exact location of any record relative to the beginning of the file. 
A random-access file is like a railroad train with many same-size cars, some empty, some with contents.
Data can be inserted into a random access file without destroying other data in the file. Data stored previously also can be updated or deleted without rewriting the entire file.
CICCIO analogia [>> LIBRARY BOXES ANALOGY]: eccoti qui un altra bella analogia per toccare con mano la differenza tra random access file e sequential file. 
Puoi veder ciascun record come un libro di una biblioteca. In una biblioteca sequeziale si hanno i libri tutti ammassati senza ordine in degli scaffali uno accanto all'altro, senza spazio tra di essi. Il risultato e' che quando ti chiedono di trovare un libro devi sequenzialmente scannare tutti i libri finche' non trovi quello voluto. Se puo la richiesta e' di sostituire un libro trovato con un altro che e' magari piu' spesso, e' l'inferno perche' visto che i volumi sono tutti ammassati gli uni accanto agli altri, allora devi spostare tutti la fila degli altri libri limitrofi.
Invece in una biblioteca che permette un random access sarebbe come avere i libri tutti ordinati in una schiera di boxes tutte uguali. Ad ogni libro e' associato un numero, quindi se ti dicono libro 12342 basta che vai alla box 12342 e op lo trovi subito. Se poi devi modificarlo, o sostituirlo con la nuova edizione piu' spessa, nessun problema, basta che nella box 12342 togli il vecchio libro ed inserisci quello nuovo piu' spesso. Le boxes vicine non ne sono per nulla affettate dalla modifica della box 12342. 
NOTE: nota come in entrambi gli approcci esiste il disordine non scompare. Ma in un caso (sequential access) cerchi in maniera ordinata/sequenziale un ammasso disordinato ed anarchico di dati, nell'altro caso (random access) puoi cercare in una maniera non sequenziale/anarchica un ammasso ben ordinato e strutturato di dati 
>> random access file creation 
[pag612 deitel]
- The >> ostream member function write outputs to the specified stream a fixed number of bytes, beginning at a specific location in memory. When the stream is associated with a file, function write writes the data at the location in the file specified by the put file-position pointer. 
- The >> istream meber function read inputs a fixed number of bytes from the specified stream to an area in meory beginning at a specified address. If the stream is associated with a file, function read inputs bytes at the location in the file specified by the "get" file-position pointer.
WRITING BYTES WITH ostream MEMBER FUNCTION write [pag612 deitel]
When writing the integer number to a file, instead of using the statement
	outFile << number;
which for a four-byte ineger could poinrt as few digits as one or as many as 11  (10 digits plus a sign, each requiring byte of storage), we can use the statement
	outFile.write( reinterpret_cast< const char * >( &number ),
		sizeof( number ) );
[>> cast : tra l'altro nel precedente comando mi sembra di poter intuide il significato di castare una variabile, e' come se la variabile fosse un metallo fuso e la si castasse, forgiasse imponendogli una determinata forma/formato]
which always writes the binary version of  the integer numbr's four bytes (on a machine with four-byte integers). Function write treats its first argument as a group ob bytes by viewing the object in memory as a "const char *", which is a pointer to a byte. Starting from that location, function write outputs the number of bytes specified by its second argurment (= an integer of type size_t). As we'll see, istream function read can subsequently be used to read the fout bytes back into integer variable number 
>> REINTERPRET_CAST operator / converting between pointer types with the reinterpret_cast operator.
[pag613 deitel]
Unfortunately, most pointers that we pass to function write as the first argument are not of type const char *. To output objects of other types, we must convert the pointers to those objects to type const char *; otherwise, the compiler will not compile calls to function write. C++ provides the reinterpret_cast operator for cases like this in which a pointer of one type must be cast to an unrelated pointer type. Without a reinterpret_cast, the write statement that outputs the integer number will not compile because the compiler does not allow a pointer of type int * (the type returned by the expression &number) to be passed to a function that expects an argument of type const char * (as far as the compiler is concerned, these types are incosistent).
NOTE1: reinterpret_cast is compiler dependent and can cause programs to behave differently on different platforms. Use this operator only if it's absolutely necessary.
NOTE2: a program that read unformatted data (written by "write") must be compiled and executed on a system compatible with the program that wrote the data, becuse different systems may represent internal data differently.
pag 614 e segg trovi un simpatico CREDIT CARD PROCESSING PROGRAM [see also Deitel-Code_Examples/ch14/fig14_09_11]
NOTE3: from Deitel-Code_Examples/ch14/fig14_09_11/fig14_11.cpp line 11
	ofstream outCredit( "credit.dat", ios::out | ios::binary );
the use of ios::binary indicates that we are opening the file for output in binary mode, which is required if we are to write fixed-length records.
//////////////////////
>> write data randomly to a random-access file / >> RANDOM write to random access file
[pag 617 deitel]
see example /home/dia/Deitel-Code_Examples/ch14/fig14_12/Fig14_12.cpp
fig14_12 writes data to the file credit.dat and uses the combination of fstream functions seekp and write to store data at exact locations in the file. Function seekp sets the put file position pointer to a specific position in the file, then function write outputs the data. 
>> open a file for input and output in binary mode / >> binary mode input output / >> opening  a file for input and output in binary mode / >> open file in binary mode / >> opening file in binary mode.
[pag619 deitel]
	fstream outCredit( "credit.dat", ios::in | ios::out | ios::binary );
from line 16 /home/dia/Deitel-Code_Examples/ch14/fig14_12/Fig14_12.cpp
>> reading from Random Access file sequentially
[pag619]
we develop a program that reads the file sequentially and points only those records that contain data.
In this example, by storing the records in the file using direct-access technique you get the following advantage: the records are listed in sorted order. [pag621deitel] 
The speed is achieved by making the file large enough to hold every possible record that might be created. This, of coarse, means that the file could be occupied sparsely most of the time, resulting in a waste of storage. This is an example of the >> space-time trade-off: by using large amounts of space, we can develop a much faster sorting algorithm. Fortunately, the continuous reduction in price of storage units has made this less of an issue.
>> INSTANT ACCESS PROCESSING CASE STUDY 
[pag 621 deitel]
you will find there a transaction processing program. The program maintains a bank's account information, it updates existing accounts, adds new accounts, deletes accounts and stores a formatted listing of all current accounts ia text file.
see /home/dia/Deitel-Code_Examples/ch14/fig14_14/Fig14_14.cpp
[un popo di 300 linee di codice ben fatto!]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> uppercase 
[pag585 deitel]
stream manipulator uppercase ouptput an uppercase X or E with hexadecimal integer values or with scientific  notation floating-point values, respectively.
Example from pag 585
	   cout << uppercase << 4.345e10 << endl 
donera in print
	4.345E+010
NOTE: by default the letters for hexadecimal values and the exponents in scientific notation floating-point values appear in lowercase. To reset the uppercase setting, output the stream manipulator nouppercase.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> UNARY SCOPE RESOLUTION OPERATOR 
	::
- it's possible to declare local and lobal variables of the same name.
- C++ provides the unary scope resolution operator (::) to access a global variable when a local variable of the same name is in scope (cioe' quando all'interno di un blocco di una funzione, trovi una variable locale che ha lo stesso nome di una variable globale, puoi far riferimento ad essa usando :: ). 
- the unary scope resolution operator cannot be used to access a local variable of the same name in an outer block.	
- a global variable can be accessed directly without the unary scope resolution operator if the name of the global variable is not the same as that of a local variable in scope.
Good programming practice 
Always using the unary scope resolution operator (::) to refer to a global variable makes it clear that you're intending to access a global variable rather than a nonglobal variable.
Example:
	// Unary scope resolution operator.
	#include <iostream>
	using namespace std;

	int number = 7; // global variable named number

	int main()
	{
	   double number = 10.5; // local variable named number
	
	   // display values of local and global variables
	   cout << "Local double value of number = " << number
	      << "\nGlobal int value of number = " << ::number << endl;
	} // end main	
E questo ti donera' 
Local double value of number = 10.5
Global int value of number = 7
OSSERVAZIONI: always using the unary scope resolution operator (::) to refer to a global variable eliminates logic errors that might occur if a nonglobal variable hides the global variable.
[vedi anche voce >> :: ]	
[pag242deitel]	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unique_ptr 
[pag465deitel]

>> UNSIGNED INT
when a variable is declared as unsigned int, it can store only non-negative values (that is 0, or higher)
Utile per esempio per dichiarare variables usate come contatori (per esempio in cicli while) example 
	unsigned int levelCounter = 1;
[pag121deitel]
Variables of unsigned integer types can represent values from 0 to approximately twice the positive range of the corresponding signed integer types. (cioe' se sul nostro computer quando si usano gli integer ammettesse tipo range -25millions, + 25millions allora quando usi unsigned il range diventa 0, 50millions) 
[pag 134deitel]
NOTE: [from pag48 moo book] whenever ordinary integers and unsigned integers combine in an expression, the ordinary integer is converted to unsigned. 

>> using namespace std;
std stands for standard. All the elements of the standard C++ library are declared within what is called a namespace, the namespace with the name std. So in order to access its functionality scriviamo ad inizio programma "using namespace std;"

>> UTILITY FUNCTIONS
[pag386deitel]
they are also called >> helper function
A utility function is a "private" member function that supports the operation of a class's other member functions.
Utility functions are declared "privite" because ther're not intended for use by the class's clients.
A common use of a utility function would be to place in a function some common code that would otherwise be duplicated in several other member functions.



>> VVVVVVV

>> VALIDATION 
in industrial-strength code, always validate all inputs.
[pag110deitel] 

>> VALIDITY CHECKING 
[pag93deitel]
the validity checking is performed to ensure that the parameter format received by a certain member function is correct. see example pag 94deitel di solito involve una condizione if (ad esempio per testare che il nome immesso in input abbia un numero di caratteri inferiore ad un certo limite)

>> VARIABLE = variable is a place to store information. A variable is a locatio in your computer's memory in which you can store a value and from which you can later retrieve that value.
[pag41 jesse book]

>> VARIABLE = a portion of memory to store a determined value. Each variable needs an identifier that distinguishes it from the others, for example 
	a = 1;
We can give a variable any name we want as long as they are valid identifiers.
see IDENTIFIER for further info
NB: each variable has a 
- name
- type 
- size
- value
[pag48deitel]

>> variable / >> object [pag10 moo book]
A variable is an object that has a name. An object is a part of the computer's memory that has a type. 
NOTE: it is possible to have objects that not have names. (quindi possiamo dedurre tutte le variabili sono oggetti, ma non tutti gli oggetti sono variabili.)
>> variable definition example:
---------------------------------------------------- start example
int main()
{                                                                                                  ----------
	// ask for the person's name                                                                  /          \
	std::cout << "Please enter your first name: ";   // << = (ciccio trick)   diffuse expand to <<   SCREEN   |
                                                                                                  \          / 
	// read the name                                                                               ---------- 
	std::string name;     // define `name'                                                                        ----------\
	std::cin >> name;     // read into `name'        // >> = (ciccio trick) from keyboard  focused and save into  ----------->> VARIABLE
                                                                                                                  ----------/
	// write a greeting
	std::cout << "Hello, " << name  << "!" << std::endl;
	return 0;
}
---------------------------------------------------- end example	
////////////////////////////////////////////////////////////////////////////////

>> variable initialization / >> initializing variable / >> declare variable / >> declaration variable [pag15 mike] 
A variable represents a particular piece of your computer's memory that has been set aside for you to use to store, retrieve, and manipulate data.
NOTE1: every variable you create has a type, which represents the kind of information you can store in the variable. It tells your compiler how much memory to set aside for the variable and it defines exactly what you can legally do with the variable.
NOTE2: puoi dichiarare piu' variabili dello stesso tipo in un singolo statement example 
	int numberVessel, numberEngines;
this lines establishes two int variables "numberVessel" and "numberEngines". Visto che e' uno statement deve terminare con una ;
NOTE3: to declare a variable you must provide a name, known as >> identifier. There are only a few rules you have to folow to create a legal identifier:
	- an identifier can contain only number, letters and underscores
	- an identifier can't start with a number
	- an identifier can't be a C++ keyword.
inoltre e' consigliato di:
	- choose descriptive names. Variable names should be clear to another programmer. One exception to this rule involves variables used for a brief period.  In that case, single letter variable names such as x, are fine.
	- be consistent: se scegli di usare lo style con le capital letter (ex highScore => questo stile di mettere in maiscolo la lettera iniziale delle parole che compongono la variabile e' chiamato >> Camel style ) anziche quello con gli underscore (ex high_score) stitch to it!
	- follow the tradition: si solito le variable names start with a lowercase letter. Inoltre si evita di usare l'underscore come first character. Names that begin with an underscore can have special meaning. 
	- keep the length in check. Even though powerLevelOfMainEngineOfNostromoCarrier is descriptive, it can make code hard to read. Plus long names increase the risk of a typo. As a guideline try to limit your variable names to fewer than 15 characters. 
TRICK: >> self documenting code is written in such a way that it's easy to understand what is happening in the program independent of any comments. Choosing good variable names is an excellent step toward this kind of code.
NOTE4: >> fundamental types (those built into the language) include 
bool 	for Boolean values (true or false), 
char 	for single character values, int 	for integers, 
float 	for single precision floating point numbers, and 
double 	for double precision floating point numbers.
NOTE3: >> modifiers : you can use modifiers to alter a type.
	short int       	-32768  to 32767
	unsigned short int	0 to 65535
	int 				-2147483648 to -2147483647
	unsigned int        0 to 4294967295
	long int 			-2147483648 to -2147483647
	unsigned long int	0 to 4294967295
	float				3.4E +/-38 (seven significant digits)
	double    			1.7E +/-308 (15 significant digits)
	long double 		1.7E +/-308 (15 significant digits)
	char 				256 character values
	bool 				true or false
For brevity "short int" can be written as just "short" and "long int" can be written as just "long".
>> type which is the best choice between int unsigned int double ect 
- If you need an integer type, you're probably best off using int. That's because int is generally implemented so that it occupies an amount of memory that is most efficienly handled by the computer. 
- If you need to represent integer value greater than the maximum int or values that will never be negative, feel free (U2) to use an unsigned int.
- If you need a floating point number you're probably best off using float, which again is likely to be implemented so that it occupies an amount of memory that is most efficiently handled by the computer.
Example
---------------------------------------------------------------------------------------- 
// Game Stats
// Demonstrates declaring and initializing variables

#include <iostream>
using namespace std;

int main()
{
	int score;				
	double distance;		
	char playAgain;			
	bool shieldsUp;			

	short lives, aliensKilled;

	score = 0;
	distance = 1200.76;
	playAgain = 'y';
	shieldsUp = true;
	lives = 3;
	aliensKilled = 10;
		
	double engineTemp = 6572.89;

	cout << "\nscore: "		<< score << endl;
	cout << "distance: "	<< distance << endl;
	cout << "playAgain: "	<< playAgain << endl;
	//skipping shieldsUp since you don't generally print Boolean values
	cout << "lives: "		<< lives << endl;
	cout << "aliensKilled: "<< aliensKilled << endl;
	cout << "engineTemp: "	<< engineTemp << endl;

	int fuel;
	cout << "\nHow much fuel? ";
	cin >> fuel;
	cout << "fuel: " << fuel << endl;

	typedef unsigned short int ushort;
	ushort bonus = 10;
	cout << "\nbonus: " << bonus << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> declare multiple variable on the same line 
[pag51 jesse]
a patto di dichiarare variables of the same type, le puoi concatenare una dietro l'altra separandole con una virgola
	long width = 5, length = 7;
Non e' necessario che le inizializzi tutte, potresti anche per esempio giusto limitarti a dichiarne una senza inizializzarla, example:
	long width = 5, length;
---------------------------------- here's a little example of declaration and initialization 
// Demonstration of variables
#include <iostream>
// questo programma computes the >> AREA computation  
int main()
{
   using std::cout;
   using std::endl;
  
   unsigned short int Width = 5, Length;
   Length = 10;
  
   // create  an unsigned short and initialize with result
   // of multiplying Width by Length
   unsigned short int Area  = (Width * Length);
  
   cout << "Width:" << Width << "\n";
   cout << "Length: "  << Length << endl;
   cout << "Area: " << Area << endl;
   return 0;
}
/////////////////////////////////////////////////////////////////////////////////

>> VECTOR operation summary [from pag 48 moo book]
vector<T>::size_type    a type guaranteed to be able to hold the number of elements in the largest possible vector
v.begin()               return a value that denotes the first element in v
v.end()                 return a value that denotes (one past) the last element in v
vector<T> v;            creates an empty vector that can hold elements of type T
v.push_bash(e)          grows the vector by one element initialized to e
v[i]                    returns the value stored in position i
v.size()                returns the number of elements in v
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> Vector vs list [pag84 moo book]
For small input using vectors and indexes to removes some elements from the vector works fine. But for HUGE vectors, using "erase" to remove an element from the vector is not a good idea. The library optimizes the vector data strcutuer for fast access to arbitrary elements. Moreover vectors performs well when growing a vector one element at time, as long as elements are added at the end of the vector. 
Inserting or removing element from the interior of a vecto is another story. Doing so requires that all lements after the one inserted or meoved be moved in order to preserve fast random access. Moving elements means that the run time of the code might be as slow as quadratic in the number of elements in the vector. 
For better performance we need a new type of data container, that does not support random access thought indices but let's as insert and delete elments efficiently anywhere in the container: this container is called LIST [pag 85 moo book]
Just as vectors are optimized for fast random access, list are optimzed for fast insertion and deletion anywhere within the container. 
Because list have to maintain a more complicated structure, they are slower than vectors if the container is accessed only sequentially. That is if the container grows and shrinks only or primarily from the end, a vector will outperform a list. However, if a program deletes many elements from the middelle of the container then listswill be faster for larger inputs, becoming much faster as the inputs grow. 
Lists and vectors share many operations. As a result, we can often translate programs that operate on vectors into programs that operate on lists, and vice versa.
/////////////////////////////////////////////////////////////////////////////////////////////

>> string analysis / >> white space presence check [pag 89 moo book]
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/split.cc]
extract:
		while (i != s.size() && isspace(s[i]))    // i != s.size() to check that we have still not reach the end of the string
			++i;
NOTE: isspace function is a predicate that takes a char and returns a value that indicates whether that char is whitespace.
Quindi la precedente condizione diventa vera se non siamo alla fine della stringa e se s[i] is a whitespace character.


>> VECTOR vs arrays [pag110 mike game programming]
See also below la voce >> VECTOR Deitel (per una presentazione dal libro Deitel C++)
- Vectors can grow as needed while arrays cannot.
- Vectors can be used with the standard library algorithms while arrays cannot. This means that by using vectors you get complex functionality like searching and sorting, built-in. 
BUT
- vectors require a bit of extra memory as overhead.
- there can be a performance cost when a vector grows in size. 
Necessary steps before using vectors
1) include the file that contains its definition:
	#include <vector>
2) >> declare vector
	vector<string> inventory;  // this declares an empty vector named inventory, which can contain string object elements. It will grow in size when you add new elements 
TO declare a vector of your own wrtie vector followed by the type of objects you want to use with the vector (surrounded by <>), followed by the vector name.
Alternatives ways of declaration
	vector<string> inventory(10); // declares a vector to hold string object elements with a starting size of 10.
O anche 
	vector<string> inventory(10, "nothing"); // initialize all of the vector's element to the same value when you declare it. Nell'esempio si ha un vettore with a size of 10 and initilized all 10 elements to "nothing".
O infine 
>> VECTOR MEMBER FUNCTIONS 
>> push_back = add a new element to the end of a vector / >> add element
ex
	inventory.push_back("sword");
adds a new element "sword" to the end of the vector inventory.
>> size vector = returns the size of a vector
ex
	inventory.size()
ci dona il size del vector "inventory"
>> vector loop / >> loop vector
	cout << "\nYour items:\n";
	for (unsigned int i = 0; i < inventory.size(); ++i)
	{
		cout << inventory[i] << endl;
	}
NOTE: the type of the variable "i" is "unsigned int" because the value returned by size() is an unsigned integer type. 
NOTE TRAP: although vectors are dynamic you can't increase a vector's size by applying the subscripting operator. For example, the following  HIGHLY DANGEROUS  code snippet does not increase the size of the vector inventory 
	vector<string> inventory; // creating an empty vector
	inventory[0] = "sword";  // may cause your program crash!
Just as with arrays, you can attempt to access a nonexistent element position but with potentially disastrous results. The preceding code changed some unknown section of your computer' memory and could cause your program to crash. To add a new element at the end of a vector, use the push_back() member function.
>> MEMBER FUNCTION CALL OF AN ELEMENT [pag115 mike game programming]
	cout << "\nThe item name '" << inventory[0] << "' has ";
	cout << inventory[0].size() << " letters in it.\n";
>> pop_back member function [pag115 mike game programming]
the pop_back() member function removes the last element of avector and reduces the vector size by one. 
	inventory.pop_back();
>> CLEAR VECTOR 
	inventory.clear();
the clear() member function removes all of the items of a vector and sets its size to 0. 	
>> EMPTY member function [pag116 mike game programming]
	if (inventory.empty())
	{
		cout << "\nYou have nothing.\n";
	}
	else
	{
		cout << "\nYou have at least one item.\n";
	}
the vector member function empty() returns true if the vector object is empty; otherwise it returns false.   
>> INSERT ELEMENT AT THE BEGINNING OF VECTOR / >> REMOVE ELEMENT FROM MIDDLE OF VECTOR -> pag 118 mike game programming
>> ITERATOR DECLARATION / >> DECLARATION ITERATOR [pag118 mike game programming]
	vector<string>::iterator myIterator;
the preceding line declares an iterator named "myIterator" for a vector that contains "string" objects.
To declare an iterator of your own follow the same pattern:
	vector             <string>                ::         iterator      myIterator
      |                   |                    |                           |
    container type    type of objects        scope                      name for  
                      that the container     resolution                 your new
                      will hold              operator                   iterator
>> ITERATOR = iterators are values that identify a particular element in a container. Given an iterator, you can access the value of the element. Given the right kind of iterator, you can change the value. Iterators are like Post-it notes that you can sitck on a specific element in a container. An iterator is not one of the elements, but a way to refer to one. After you stick your iterator post-it on a specific element of a vector, you can access the element or even change it through the iterator.
[pag119 mike programming game]
>> CONSTANT ITERATOR / >> const_iterator [pag119 mike game programming]
	 vector<string>::const_iterator iter;
A constant iterator is just like a regular iterator except that you can't use it to change the element to which it refers; the element must remain constant. You can think of a constant iterator as providing read-only access. However the iterator itself can change. This means you can move the iterator all around the vector.
TRAP: using push_back() might invalidate all iterators referencing the vector
[pag119 mike programming game]
>> LOOP VECTOR / >> VECTOR LOOP using iterator [pag120 mike programming]
    myIterator = inventory.begin(); // >> begin() member function returns an iterator that refers to a container's first element.
    *myIterator = "battle axe";  // we change the value of the first element. Remember by >> dereferencing myIterator with *, the preceding assignment statement says, "Assign "battle axe" to the element that myIterator references". It does not change myIterator. 
    cout << "\nYour items:\n";
    for (iter = inventory.begin(); iter != inventory.end(); ++iter)  // >> end() [pag121 mike programming game] = the end() member function returns an iterator one past the last element in a container [cioe' un iteratore that refers to the element successivo all'ultimo elemento del vettore]. This means the loop will continue untili iter has moved through all the elements in inventory.   
    {
        cout << *iter << endl;  // here we are using the >> dereference operator (*) in front of iter. In this way we display the value of the element to which the iterator refers (not the iterator itself)
	}
NOTE: [pag122 mike programming] ciccio spiega 
	>> REFERENCE an iterator to the n-element of a vector = attaccare/riferire l'iterator all'elemento n del vettore.
	>> DEREFERENCE an iterator = get the value dell'elemento a cui l'iterator si riferisce. 
NOTE: >> end() vector member function returns an iterator that's one past the last element in the vector (not the last element). Therefore you can't get a value from the iterator returned by end(). 
NOTE: >> accessing member function of a vector element. // >> -> [pag122 mike game programming]
	cout << "\nThe item name '" << *myIterator << "' has ";
    cout << (*myIterator).size() << " letters in it.\n";
(*myIterator).size() says : "take the result of dereferencing myIterator and call that object's size() member function. Because myIterator refers to the string object equal to "battle axe", the code returns 10.
HINT: whenever you dereference an iterator to access a data member  or member function, surround the dereferenced iterator by a pair of parenthesis. This ensures that the dot operator will by applied to the object the iterator references. 
The code (*myIterator).size() is not the the pretties, so C++ offers an alternative, more intuitive way to express the same thing: 
	cout << "\nThe item name '" << *myIterator << "' has ";
    cout << myIterator->size() << " letters in it.\n";
(*myIterator).size() and myIterator->size() mean exactly the same thing to the computer, but this new version is easier for humans to use. In general, you can use the >> indirect member selection operator "->" to access the member function or data members of an object that an iterator references. 
///////////////////////////////////////////////////////////////////////////////////////////////

>> iterator adaptors / >> insert_iterators [pag121 moo book]
The most common are adaptors that generate insert_iterators, which are iterators that frow the associated container dynamically.
Such iterators can be used safely as the destination of a copying algorithm. 
They are defined in the header <iterator>
	>> back_inserter(c)   yields an iterator on the container c that appends elements to c. The container must support push_back, which the list, vector and the string types all do.
	>> front_inserter 	= like back_inserter, but inserts at the front of the container. The container must support push_front, which list does, but string and vector do not. 
	>> inserter(c, it)
		like back_inserter, but inserts elements before the iterator it.

>> INSERT() vector member function [pag123 mike programming game]
    cout << "\nYou recover a crossbow from a slain enemy.";
    inventory.insert(inventory.begin(), "crossbow"); // this >> insert a new element at the beginning of the vector
NOTE: insert() member function INSERTS a new element into a vector just BEFORE the element referred to by a given iterator. 
NOTE: you supply two arguments to this version of insert() the first is an iterator, and the second is the element to be inserted. 
NOTE: in the example above we insert "crossbow" into "inventory" just before the first element. As a result, all of the other elements will move down by one. 
NOTE: questo insert non e' che overwrite il contenuto dell'elemento a cui l'iteratore sta puntando. Inserire il nuovo elemento nella posizione in cui l'iteratore punta, spingendo giu' tutti gli altri elementi del vettore. 
TRAP: calling the insert() member function on a vector invalidates all of the iterators that reference elements after the insertion point because all of the elements after the insertion point are shifted down by one  

>> REMOVE ELEMENT from the middle of a vector // >> erase() member function [pag124 mike programming] / 
	inventory.erase((inventory.begin() + 2));
NOTE: erase() member function ermoves an element from a vector. erase() requires as argument the iterator that references the element you want to remove. Nell'esempio sopra we passed (inventory.begin() + 2), which is equal to the iterator that references the third element in inventory. As a result all of the following elements will move up by one. 
This version of erase() member function returns an iterator that references the element after the element that has been removed. In the example above, we did not assign the returned iterator to a variable.
TRAP : calling the erase() member function on a vector invalidates all of the iterators that reference elements after the removal point because all of the elements after the removal point are shifted up by one.
>> VECTOR PERFORMANCE / >> PERFORMANCE VECTOR [pag129]
Vectors and other STL containers are incredibly efficient. However these containers have their strengths and weaknesses; a game programmer needs to understand the performance characteristics of the various containers types so that he can choose the right one for the job. 
Although vectors grow dynamically as needed, every vector has a specific size. When a new element added to a vector pushes the vector beyond its current size, the computer reallocates memory and might even copy ALL of the vector elements to this newly seized chunk of memory real estate. This can cause a performance hit!
The most important tihng to keep in mind about program performance is  whether you need to care. For example, vector memory reallocation might not occur at a performance critical part of your program. In that case, you can safely ignore the cost of reallocation. Also, with small vectors, the reallocation cost might be insignificant, so again, you can safely ignore it. 
If you need greater control over these memory allocation you can use 
	>> capacity() member function [pag129 mike game programming] 
	>> reserve() member function [pag130 mike game programming]  
The capacity() vector member function returns the capacity of a vector (>> capacity of a vector = the number of elements that a vector can hold before a program must reallocate more memory for it). Note: a vector's capacity is not the same thing as its size. >> capacity vs >> size : 
>> capacity of a vector = the number of elements that a vector can hold before a program must reallocate more memory for it
>> size of a vector = the number of elements a vector currently holds
Example 
	cout <<"Creating a 10 element vector to hold scores. \n";
	vector<int> scores(10,0); // initialize all 10 elements to 0
	cout <<"Vector size is :" << scores.size() << endl;  // size is 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity is 10
	
	cout <<"Adding a score.\n";
	scores.push_back(0); // memory is reallocated to accommodate growth
	cout <<"Vector size is :" << scores.size() << endl; // size is 11
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity is 20
Right after I declare and initialize the vector, this code reports that its size and capacity are both 10. However, after an element is added the code reports that the vector's size is 11 while its capacity is 20. That's because the capacity of a vector doubles every time a program reallocates additional memory for it. In this case, when a new score was added, memory was reallocated, and the capacity of the vector doubled from 10 to 20.
Example 2 using the reserve() member function. 
The reserve() member function increases the capacity of a vector to the number supplied as an argument. Using reserve() gives you control over when a reallocation of additional memory occurs. Here's an example:
	cout <<"Creating a 10 element vector to hold scores. \n";
	vector<int> scores(10,0); // initialize all 10 elements to 0
	cout <<"Vector size is :" << scores.size() << endl;  // size is 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl;  // capacity is 10 
	
	cout <<"Reserving more memory.\n";
	scores.reserve(20); // reserve memory for 10 additional elements
	cout <<"Vector size is :" << scores.size() << endl;  // size is still 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity has become 20
By using reserve() to keep a vector's capacity large enough for your purposes, you can delay memory reallocation ot a time of your choosing. 
HINT: as a beginner game programmer, it's good to be aware of how vector memory allocation works; however, don't obsess over it. The first game programs you'll write probably won't benefit from a more manual process of vector memory allocation. 
NOTE: >> performance hit expression significa "colpo alla performance, perdita non trascurabile di performance
NOTE: >> overhead = sopra testa, che sta al di sopra l'overhead di un operazione mi sembra voglia dire il tempo e risorse che richiede l'operazione in se', che si aggiunge al tempo di esecuzione del resto del programma. 
>> ERASE PERFORMANCE [pag130 mike programming game]
push_bash() and pop_back() member functions are extremely efficient. 
Adding or removing an element from the end of a vector using the push_bash() or pop_back() member functions is extremely efficient. 
However adding or removing an element at any other point in a vector (for example using insert() or erase() ) can require more work becuase you might need have to move multiple elements to accommodate the insertion deletion. With small vectors the overhead is usually insignificant, but with larger vectors (with, say, thousands of elements), inserting or erasing elements from the middle of a vector can cause a performance hit.
Fortunately the STL offers another sequence container type, list, which allows for efficient insertion adn deletion regardless of the sequence size. The important thing to remember is that one container type isn't the solution for every problem. Although vector is versatile and perhaps the most popular STL container type, there are times when another container type might make more sense. 
TRAP: just because you want to insert or delete elements from the middle of a sequence, that doesn't mean you should abandon the vector. It might still be a good choice for your game program. It really depends on how you use the sequence. If your sequence is small or there are only a few insertions and deletions, then a vector might still be your best bet. 
>> SEQUENTIAL CONTAINER pag 131 mike game programming 
	you can retrieve values in sequence. example: vector is a sequential container
>> ASSOCIATIVE CONTAINER pag 131 mike game programming 
	let's you retrive values based on keys. example: "map" is an associative container, is a collection of key/value pairs in which each key is associated with exactly one value
WHEN should I use SEQUENTIAL and when ASSOCIATIVE?
Consider an online, turn-based strategy game. You could use a sequential container to store a group of players that you wnat to cycle through in sequence. On the other hand, you could use an associative container to retrieve player information in a random-access fashion by looking up a unique identifier, such as a player's IP address.

STL CONTAINERS 
CONTAINER        TYPE           DESCRIPTION
deque            sequential     double-ended queue
list             sequential     linear list
map              associative    collection of key/value pairs in which each key is associated with exactly one value
multimap         associative    collection of key/value pairs in which each key may be associated with more then one value
multiset         associative    collection in which each element is not necessarily unique
priority_queue   adaptor        priority queue
queue            adaptor        queue
set              associative    collection in which each element is unique
stack            adaptor        stack
vector           sequential     dynamic array
 
NOTE: type adaptor: >> container adaptors represent standard computer science data structures. Although they are not official containers, they look and feel just like them.
//////////////////////////////////////////////////////////////////////////////////////

---------------------------------------------------------------------------------------------------------------------------
>> VECTOR 
[pag314deitel]
C++ Standard Library class template "vector" is similar to class template "array", but also support dynamic resizing.
One of the key differences between a vector and an array s that a vector can dynamically grow to accommodate more elements. 
Per usare vector nei tuoi programmi scrivi all'inizio 
	#include <vector>
	using namespace std;
EXAMPLE extracted from fig07_25.cpp [pag315deitel]
   vector< int > integers( 10 ); // 10-element vector< int >
Crea un vector object that store 10 values of type int. By default all the elements are set to 0.
Like arrays, vectors can be defined to store most data types, by replacing int in vector<int> with the appropriate type.
EXAMPLE2 from line 88 fig07_25.cpp 
	integers3.push_back( 7 ); // add 7 to the end of the vector
this command add the element "7" to the end of the vector. [intendiamo aggiungere l'elemento 7, non aggiungere 7 elementi]
To add an element at the end of a vector we use the member function 
	push_back
NOTE1: The C++ standard library class template vector allows you to create a new vector object that's initialized with the contents of an existing vector.
eccoti un example from line 44-46 fig07_25.cpp
   // create vector integers3 using integers1 as an
   // initializer; print size and contents
   vector< int > integers3( integers1 ); // copy constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> visual studio compile program tutorial pag 356 et seguenti mike book C++ game programming
Note anche se Mike consigliava visual studio express 2013 for windows desktop for windows
www.visualstudio.com/downloads/download-visual-studio-vs.
Con il nostro Microsoft Visual Studio Community 2013 funziona benissimo in OrionI
Seguendo le istruzioni di pagina 356 e seguenti, una volta compilato, la finestra resta aperta
Ti riscrivo qui i principali passaggi
- from the application menu -> File -> New Project. In the left pane of the new project dialog that appears select Visual C++. 
- In the middle pane select "win32 console application"
- in the name field type the name of the project. 
- in the location field, browse to the location to save your project by clicking the browse button
- make sure that the check box is checked for "create directory for solution"
- click OK and you will see the win 32 application wizard click next button 
- under Additional options check the check box for empty project. 
- in the win32 application wizard application settings dialog, click the Finish button 
- in the solution explorer right click the source files folder -> Add -> New Item 
- in the add new item that appears select C++ file (.cpp).
- in the name field, type nomeDelTuoProgramma.cpp
- scrivi il programma
- from the application menu, select File, save nomeDelTuoProgramma.cpp
- -> questo l'avevamo saltato (from the application menu, select Build, Build Solution 
- press Ctrl + 5 to run the project and enjoy the fruits of your labor!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> VECTOR ELEMENT-MANIPULATION FUNCTIONS
[pag654 deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp]
line 16
	vector< int > integers( values.begin(), values.end() );
the previous line initializes integers with the contents of the array values  from beginning of values up to (but not including) values.cend()
Altertivamente alla linea 16, si sarebbe anche potuto iniziale il vettore usando la forma:
	vector <int> integers{1, 2, 3 ,4, 5, 6 };
o anche 
	vector <int> integers = {1, 2, 3 ,4, 5, 6 };
Ma these are not fully supported across all compilers [@2015] For this reason the chapter 15 deitel uses line 16 style
////////
Altre parole chiave che si trovano all'interno del programma:
>> ostream_iterator [pag 656 deitel]
example line 20 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   cout << "Vector integers contains: ";
   copy( integers.cbegin(), integers.cend(), output );
line 20 uses standard library algorithm copy (from header <algorithm>) to ouptu the entire contenst of integers to the standard output.
The algorithm copies each element in a range from the location specified by the iterator in its first argument and up to, but not including, the  location specified by the iterator in its second argument.
>> front and >> back vector member functions
Functions front and back (available for most sequence containers) are used to determine the vector's first and last elements respectively.
example line 22 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   cout << "\nFirst element of integers: " << integers.front()
      << "\nLast element of integers: " << integers.back();
NOTE: Notive the difference between functions front and begin. 
	- Function front returns a reference to the first element in the vector, while 
	- function begin returns a random access iterator pointing to the first element in the vector.
Similmente sussiste una differenza tra back and end
	- function back returns a reference to the vector's last element
	- function end returns a random access iterator pointing to the location after the last element 
Attention: the vector must not be empty; otherwise, the results of front and back are undefined.
>> VECTOR ELEMENT ACCESS
[pag 657 deitel] 
Qui di seguito mostriamo due modi per accedere agli elementi di un vettore:
example line 25-26 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   integers[ 0 ] = 7; // set first element to 7
   integers.at( 2 ) = 10; // set element at position 2 to 10
Le due precenti righe sono del tutto equivalenti, la seconda performs la stessa operazione but with bounds checking. The function at first checks the value supplied as an argument and determines whether it's in the vector's bounds. If not, function "at" throws an out_of_range exception. Ecco qui si seguito listate alcune delle Standard Library exception types:
[pag 657 deitel - some execption in the header <stdexcept>]
>> out_of_range     : indicates when subscript is out of range (e.g. when an invalid subscript is specified to vector member function at)
>> invalid_arugment : indicates an invalid argument was passed to a function
>> length_error     : indicates an attempt to create  too long a container, string, etc
>> bad_alloc        : indicates that an attempt to allocate memory with new (or with an allocator) failed because not enough memory was available
//////////////////
>> INSERT element / >> vector member function insert 
[pag657 deitel]
example line 29 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
con la seguente riga inseriamo il valore 22 before the element at the location specified by the iterator in the first argument. 
	integers.insert( integers.cbegin() + 1, 22 );  
in this example the iterator is pointing to the vector's second element, so 22 is inserted as the second element and the original second element becomes the third element.
/////////////
>> insert with three argument (>> range insert)
[pag658 deitel]
line 55 demonstratest the version of function insert that uses the second and third aruments to specify the starting location and ending location in a sequence of values (in this case from the array values) that should be inserted into the vector.

example line 55 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
	integers.insert( integers.cbegin(), values.cbegin(), values.cend() );
NOTE: remembe that the ending location specfied the positon in the sequence after the last element to be inserted;
/////////////////////////////////////////
>> ERASE member function / >> vector MEMBER FUNCTION erase
[pag657 deitel]
Lines 45 and 50 use the tow erase functions that are available in all first-class containers. Line 45 erases the element at the location specified by the iterator arugument (in this example the first element). Line 50 specified that all elements in the range specified by the two iterator arguments should be erased.
example line 45-50 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   // erase first element
   integers.erase( integers.cbegin() );     // line 45 
   cout << "\n\nVector integers after erasing first element: ";
   copy( integers.cbegin(), integers.cend(), output );
   // erase remaining elements
   integers.erase( integers.cbegin(), integers.cend() );    // line 50
   cout << "\nAfter erasing all elements, vector integers " 
      << ( integers.empty() ? "is" : "is not" ) << " empty";  // line 52
line 52 uses function empty (available for all containers and adapters) to confirm that the vector is empty.
NOTE: normally erase destroys the objects that are erased from a container. However, erasing an element that contains apointer to a dynamically allocated object does not delete the dynamically allocated memory -> this can lead to a memory leak. If the element is a unique_ptr, the unique_ptr would be destroyed and the dynamically allocated memory would be deleted. If the element is a shared_ptr, the reference count to the dynamically allocated object would be decremented and the memory would be deleted only if the reference count reached 0. 
/////////////////
>> clear member function / >> vector member function clear
[pag 658 deitel]
line 60 uses function clear (found in all first clas containers execpt array) to empty the vector (this does not necessaily return any ofthe vector's memory to the system.)
	integers.clear(); 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> vector concatenation / >> concatenation vector a pag94 moo book, trovi un esempio di concatenazione vettori.
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/pics.cc]
		vector<string> vcat(const vector<string>& top,
		                    const vector<string>& bottom)
		{
			// copy the `top' picture
			vector<string> ret = top;
		
			// copy entire `bottom' picture
			for (vector<string>::const_iterator it = bottom.begin();
			     it != bottom.end(); ++it)
				ret.push_back(*it);
		
			return ret;
		}
When you need to append elements at the end of a vector [>> append elements into a vector]
instead of 
			for (vector<string>::const_iterator it = bottom.begin();
			     it != bottom.end(); ++it)
				ret.push_back(*it);
you can also use the library function "insert", funziona cosi':
			ret.insert(ret.end()), bottom.begin(), bottom.end()); // same meaning, and more compact

>> VECTOR SEQUENCE CONTAINER
[pag650 deitel]
Class template vector, provides a data structure with contiguous memory locations. This enables efficient, direct access to any element of a vector via the subscript operator [], exactly as with a built-in array. 
Like class template array, template vector is most commonly used when the data in the container must be easily accessible via a subscript or will be sorted, and when the number of elements may need to grow.
When a vector's memory is exhausted
	1) the "vector" allocates a larger built-in array, 
	2) copies (or moves) the original elements into the new built-in array 
	3) deallocates the old-built-in array
NOTE1: performance: choose the vector container for the best random-access performance in a container that can grow.
NOTE2: You must include header <vector> to use class template vector.
>> VECTOR CREATION 
[commenti notevoli from /home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]
extract1:
   vector< int > integers; // create vector of ints
the previous line defines an instance called integers of class template vector that stores int values. 
Whe thi sobject is instantiated, an empty vector is created with size 0 (i.e. the number of elements stored in the vector) and capacity 0 (i.e. the number of elements that can be stored without allocating more memory to the vector).
extract2 lines 16-17
   cout << "The initial size of integers is: " << integers.size()
      << "\nThe initial capacity of integers is: " << integers.capacity();
le due righe precedenti dimostrano the size and capacity functions; 
>> size vector function [pag 652 deitel]
- Function size returns the number of elements currently stored in the container.
>> capacity vector function [pag 652 deitel]
- Function capacity returns the number of elements that can be stored in the vector before the vector need to dynamically resize itself to accommodate more elements. [in parole spicciole: un vettore ha inizialmente una certo size. Certo e' possibile se necessario aumentare tale size in maniera' dinamica (un po come in un hangar dove ci si ritrovasse a dover ospitare troppe merci, e si passasse allora a costruire nuovi hangar per alloggiare le merci che non potevano piu' rientrare nell'hangar originale ormai pieno)]
>> push_back vector member function 
[pag652 deitel [commenti notevoli from /home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]]
	   integers.push_back( 2 );  
       integers.push_back( 3 );  
the previous lines use function push_back available in sequence containers other than array and forward_list to add an element to the end of the vector. If an element is added to a full vector, the vector increases the size. Some implementations have the vector double its capacity [see esempio pratico e nostro disegno nel basso di pag652 deitel]. Sequence containers other than array and vector also provide a push_front function.
NOTE: it can be wasteful to double a vector's size when more space is needed. For example, a full vector of 1000000 elements resizes to accommodate 2000000 elements when a new element is added. This leaves 999999 unused elements. You can use "resize" and "reserve" to control space usage better.
>> VECTOR GROWTH / >> space time trade off [pag653 deitel]
[detto in parole spicciole : lo space-time trade off significa 
1) se allochi tanto spazio per un vettore, sarai molto veloce nel momento in cui devi aggiungere dei nuovi elementi visto che lo spazio e' gia' allocato, ma ahime' rischi di sprecare molto spazio che poi magari non sara' riempito da alcun elemento
2) se allochi giusto lo spazio necessario al numero di elementi presenti, sara' economo nello spazio da allocare al vettore, ma qualora dovessi aggiungere dei nuovi elementi, sarai meno veloce (more time required) visto che dovrai prima allocare del nuovo spazio.]
//////////
>> outputting built-in array contents with pointers
[pag653deitel]
   // display values using pointer notation
   for ( const int *ptr = begin( values ); ptr != end( values ); ++ptr )
      cout << *ptr << ' ';
/////////////
Function "begin" returns an iterator pointing to the built-in array's first element and function
Function "end"  returns an iterator representing the position one element after the end of the built-in array.
Note in the previous for loop the use of != 
When iterating using pointers to built-in array elments, it's common for the loop-continuation condition to test whether the pointer has reached the end of the built-inarray. This techinque is commonly used by the standard library algorithms.
//////////////
>> outputting vector contents with iterators [pag653deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]
	// function template for outputting vector elements
	template < typename T > void printVector( const vector< T > &integers2 )
	{
	   // display vector elements using const_iterator
	   for ( auto constIterator = integers2.cbegin(); 
	      constIterator != integers2.cend(); ++constIterator )   // l'espressione ++constIterator positions the iterator to the vector's next element. 
	      cout << *constIterator << ' ';    // in questa linea  we >> dereference constIterator to get the current element's value. Remember that the iterator acts like a pointer to the lement and that operator * is overloaded to return a reference to the element.
	} // end function printVector 
////////
the loop continues as long as constIterator has not reached the end of the vector.
nota il metodo >> cend : cend e' una member function which returns a const_iterator indicating the location past the last element of the vector.
>> reverse display vector / >> display vector's contents in reverse [pag654 deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]   
	// display vector in reverse order using const_reverse_iterator
    for ( auto reverseIterator = integers.crbegin();               
      reverseIterator!= integers.crend(); ++reverseIterator )
      cout << *reverseIterator << ' ';
C++11 includes vector member function >> crbegin and >> crend which return cont_reverse_iterators that represent the starting and ending points when iterating through a container in reverse.
>> shrink_to_fit [pag654 deitel] / >> memory back / >> memory performance / >> memory optimization 
As of C++11, you can ask a vecto or deque to return unneeded memory to the system by calling member function shrink_to_fit. This requests that the container reduce its capacity to the number of elements in the container.  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> VIRTUAL DESTRUCTORS 
[source http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html]
To build an object the constructor must be of the same type as the object and because of this a constructor cannot be a virtual function. But the same thing does not apply to destructors. A destructor can be defined as virtual or even pure virtual. You would use a virtual destructor if you ever expect a derived class to be destroyed through a pointer to the base class. This will ensure that the destructor of the most derived classes will get called.
see http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
for more info

>> VIRTUAL FUNCTIONS 
[pag 526 deitel]
example 
	virtual void nameFunction() const;
the preceding portotype declares that function nameFunction is a virtual function that takes no arguments and return nothing. 
Note: anche se nell'esempio precedente abbiamo dichiarato la funzione const, e' giusto un esempio, virtual functions do not have to be const functions.
NOTE [from pag532]:  if a class has virtual functions, always provide a virtual destructor, even if one is not required for the class. This ensures that a custom derived-class destructor (if there is one) will be invoked when a derived-class object is deleted via a base class pointer. 
Common programming error: constructors cannot be virtual, declaring a constructor virtual is a compilation error.

>> void * operator
[pag604 deitel]
the operator void * is anotheroverloaded ios member function that converts the stream to a pointer, so it can be tested as 0 (i.e. the null pointer) or nonzero (i.e. any other pointer value). 
When a pointer value is used as a condition, C++ interprets:
-  a null pointer in a condition as the bool value "false" 
	and interprets 
- a non-null pointer as the bool value "true".
The operator void * function can be used to test an input object for end-of-file, but you can also call member function "eof" on the input object.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> WWWWWWW

>> warning  this decimal constant is unsigned [pag25 mike] the warning is the result of something called integer wrap around that you'll probably want to avoid in your own programs; however, the wrap around is intentional in the program at pag24 mike to show the result of the event. You'll learn about integer wrap around in the discussion of this program, in the section "Dealing with Integer Wrap Around".

>> wchar_t : wide character 
size 2 or 4 bytes
range: 1 wide character

>> WHILE repetition statement 
[mike pag51]
generic form of the loop
	while (expression)
		statement;
if expression is false, the program moves on to the statement after the loop. If expression is true, the program executes statement and loops back to test expression again. This cycle repeats until expression tests false, at which point the loop ends.
Example 
// Play Again
// Demonstrates while loops

#include <iostream>
using namespace std;

int main() 
{
	char again = 'y';   // the variable again has to be inizialized before the loop expression
	while (again == 'y')
	{
		cout << "\n**Played an exciting game**";
		cout << "\nDo you want to play it again Sam? (y/n): ";
		cin >> again;
	}

	cout << "\nOkay, bye.";

    return 0;
}
-------------------------------------------------------------------------------------------------------------
[pag116 deitel]
Example 
Consider a program designed to find the power of 3 larger than 100. 
	int product = 3;
	while ( product <= 100 )
		product = 3 * product;
When the while statement begins execution, product's value is 3. Each repetitiion multiplies product by 3, so product takes on the values 9, 27, 81, and 243 successively. When product becomes 243, the while statement condition (product <= 100) becomes false. This terminates the repetition, so the final value of product is 243. 
see also voce >> DO...WHILE REPETITION STATEMENT [from pag168deitel] 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> while statement [pag 19 moo book]
while (condition)
	{
		statement1
		statement2
		ect
	}
that loosely speaking means : "as long as the condition is true do whatever is within the {}"
La vita designata dal demiurgo in un certo senso e' un while loop
As long as they are alive throw a lot of shit on them.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> LOOP DO / >> DO LOOP [pag53 mike]
Like while loops, do loops let you repeat a section of code based on an expression. The difference is htat a do loop tests its expression after each loop iteration. This means that the loop body is always executed at least once. Here's a generic form of a do loop
	do
		statement;
	while (expression)
the program executes statement and then, as long as expression tests true, the loop repeats. Once expression tests false, the loop ends.
Example:
	// Play Again 2.0
	// Demonstrates do loops
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		char again;
		do 
		{
			cout << "\n**Played an exciting game**";
			cout << "\nDo you want to play again? (y/n): ";
			cin >> again;
		} while (again == 'y');
	
		cout << "\nOkay, bye.";
	
		return 0;
	}
//
---------------------------------------------
NOTE: even though you can use while and do loops pretty interchangeably, most programmers use the while loop. Alghough a do loop might seem more natural in some cases, the advantage of a while loop is that its expression appears right at the top of the loop; you don't have to go hunting to the bottom of the loop to find it. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> WIDTH / >> setw
[pag576 deitel]
The width member function (of base class ios_base) sets th field width (i.e. the number of character positions in which a value should be output or the maximum number of characters  positions in which a value should be output or the maximum number of characters that should be input) and returns the previous width
- If values output are narrower than the field width, fill characters are inserted as padding.
- the width setting applies only for the next insertion or extraction (i.e. the width setting is not sticky) 


>> WRAP / >> new line avoid / >> avoid new line creation when 80 column is reached:
Edit -> File settings -> Text width
e metti 0 al posto di 80 in tal modo non andra' piu' a capo automaticamente una volta che superi l'80 esima colonna.

>> WRITE TO A TEXT FILE 
// writing on a text file
#include <iostream>
#include <fstream>
using namespace std;

int main () {
  ofstream myfile ("example.txt");
  if (myfile.is_open())
  {
    myfile << "This is a line.\n";
    myfile << "This is another line.\n";
    myfile.close();
  }
  else cout << "Unable to open file";
  return 0;
}
[source http://www.cplusplus.com/doc/tutorial/files/
salvato anche in blackbird as : Input_output with files - C++ Tutorials]

>> WRITE STANDARD STRING TO FILE / >> BINARY ISSUE 
You're currently writing the binary data in the string-object to your file. This binary data will probably only consist of a pointer to the actual data, and an integer representing the length of the string.
If you want to write to a text file, the best way to do this would probably be with an ofstream, an "out-file-stream". It behaves exactly like std::cout, but the output is written to a file.

The following example reads one string from stdin, and then writes this string to the file output.txt.

#include <fstream>
#include <string>
#include <iostream>

int main()
{
    std::string input;
    std::cin >> input;
    std::ofstream out("output.txt");
    out << input;
    out.close();
    return 0;
}

Note that out.close() isn't strictly neccessary here: the deconstructor of ofstream can handle this for us as soon as out goes out of scope.

For more information, see the C++-reference: http://cplusplus.com/reference/fstream/ofstream/ofstream/

Now if you need to write to a file in binary form, you should do this using the actual data in the string. The easiest way to acquire this data would be using string::c_str(). So you could use:
write.write( studentPassword.c_str(), sizeof(char)*studentPassword.size() );
[http://stackoverflow.com/questions/15388041/how-to-write-stdstring-to-file]
//////////////////////////////////////////////////////////////

>> out of scope [pag175 mike programming game]
A variable goes out of scope when the scope in which it was created ends. Variable going out of scope means the variable ceased to exist. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> WRITE TO FILE nostro esempio tratto
	#include <fstream>
	#include <string>
	#include <iostream>

	int main()
	{
		std::string input = "Eri and Yui Queen of Fairies" ;
		std::ofstream out("output.txt");
		out << input;
		out.close();
		return 0;
	}
///////////////////////////////////////
NOTE: [tag]  >> .write( 
non devi usare 
	nomeFile.write(input) 
bensi 
	out << input
///////////////////////////////////////


>> WRITE TO FILE string + variable + string
// obtaining file size
#include <iostream>
#include <fstream>
using namespace std;

int main () {
  streampos begin,end;
  ifstream myfile ("example.bin", ios::binary);
  begin = myfile.tellg();
  myfile.seekg (0, ios::end);
  end = myfile.tellg();
  myfile.close();
  cout << "size is: " << (end-begin) << " bytes.\n";    //    <---- il succo
  return 0;
}
///////////////////////////////////////////////////
il precedente donera' in output 
size is: 40 bytes.
NOTE: quindi cio' che in python si scriveva con dei piu'
	cout "testa della stringa " + nomeVariabile + " codaDellaStringa\n"
in C++ diventa
	cout "testa della stringa " << nomeVariabile << " codaDellaStringa\n";
NOTE2: nel caso tu non voglia outputtare nello screen bensi' scrivere su file puoi 
	ofstream ciccioFile;
	ciccioFile.open ("output127.txt");  
	ciccioFile << "testa della stringa " << nomeVariabile << " codaDellaStringa\n";
e ti scrivera' il tutto in ciccioFile
Nota come "ciccioFile" da un punto di vista ontologico altri non e' che un ofstream object a cui viene associato il file output127.txt
"ciccioFile" e' un object a cui puoi applicare metodi come .open
[source http://www.cplusplus.com/doc/tutorial/files/]


>> XXXXXXX

>> YYYYYYY

>> ZZZZZZZ


------------------------------------------------
SEZIONE ECLIPSE IDE 
vedi il file ECLIpse nella stessa directory di questo Cplusplus file.
------------------------------------------------
SEZIONE Qt IDE
[installation:
il seguente e' fallito in opensuse usiamo allora KDevelop che tra l'altro e' costruito su Qt 
- entra nella cartella che contiene il .run file
- se necessario lo rendiamo eseguibile con 
	chmod +x filename ]
- quindi 
	sh nomefile.run [in alcuni casi e' necessario essere root]
------------------------------------------------
SEZIONE KDevelop4
------------------------------------------------
====
zxcv
====  
