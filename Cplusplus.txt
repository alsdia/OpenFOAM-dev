====
qwer
====

g++ edyProgram.cpp -o edyProgram.exe

In case of multiple files
	g++ -o myprog.exe file1.cpp file2.cpp
Or also step by step: 
	g++ -c file1.cpp
	g++ -c file2.cpp
	g++ -o myprog.exe file1.o file2.o

se c++11 requested 

	g++ -std=c++11 -o fig16_08.exe fig16_08.cpp

NOTE: on orion I se >> visual studio dona problemi di license.
SOLUTION 
1) se ti compare il messaggio di errore lascialo cosi' aperto come'
2) va nell'orologio nella taskbar in basso a destra e setta la data a 2010
3) ritorna a visual studio e clicca su exit program. 
Il programma non si chiude e lo potrai utilizzare. 
Thanks Ciccio

NOTE2: soundtrack per alta concentrazione per coprire rumori usa white noise, tipo "river sound", lavora a meraviglia e ti immerge in un mondo a-spaziotemporale
NOTE3: per copiarti giusto degli estratti di codice includendo accanto il number line, abbiamo usato "vi" e quindi ":set number", e selezioni il blocco di codice che ti interessa draggando il mouse, selezionera' anche i number lines. 

[MIT course. 
Take a look in MITOpenCourseWare directory -> Introduction to C and C++ absoluely lovely, il zip downloadabile ti permette poi di visionare i documenti nel tuo browser offine, lovely!! con un extract sui Lab files li puoi estrarre nella cartella di downloadaggio ed esercitarti, creare hackerare!!! evviva! poco importa che altri "fan piu'" "son piu'" "han gia'", con la piccola 127 possiamo imparare nel nostro piccolo e creare piccole gadget amusant con arduino e trollare in internet!]
[logistic comment in Orion I aprilo con gedit]

NOTE: se trovi delle voci con numero pagina non accompagnato dal nome del libro, significa che si riferisce al Deitel book
NOTE2: study tip Quando studi con questo txt, aprine una seconda istanza con firefox, in tal modo nel text editor aggiungi le tue note, e in firefox qualora dovessi cercare notazioni dimenticate puoi effettuare delle ricerche e poi tornare al text editor senza bisogno di ritornare al punto in cui stavi scrivendo.
NOTE3: i programmini di Mike sono stati lanciati con Visual Studio 2013 on Orion1 
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug
clicca sul batch file per aprire il terminal e vedere il risultato. Per comodita' abbiamo spesso usato lo stesso file sovrascrivendo il contenuto del file lanciando precedente.
NOTE4: book accelerated / or "moo book" or "barbara book" -> means Accelerated C++ by Andrew Koenig and Barbara Moo
NOTE5: "jesse book" means -> SAMS Teach Yourself C++ in 21 days Jesse Liberty 

LA SANTA TRINITA' 

       declaration -> *.h                             definition -> *.ccp
                           instantiation -> main.ccp

Nel nome della dichirazione, della definizione e della santa istanziazione, Amen.
[trick quando fai il segno della croce ricordati dichiarazione tocca la fronte lo dichiari a Dio verso l'alto [del resto anche il suffisso *H dell'header richiama all'alto, l'H su sui ci poggia l'elicottero, la venuta del santo spirito], con definizione tocchi la pancia, definisci il corpo della dichiarazione precedentemente effettuata, con la santa istanziazione (tocco alle spalle - non dimenticare la s davanti a palle -) incarni la definizione. Il Verbo si fa di Questo MONDO. Ai ripari!!!]

ITIAF question 
) from pag 864 deitel:  I puntatori hanno un'allocazione di memoria di tipologi aidentica a quella delle variabili? Cioe' mi devo immaginare memorizzati disegnati al di sopra della grigali di memoria (vedi disegno pag 864) come una qualunque altra variabile, oppure possiedono un'allocazione speciale, al di sotto (o sopra ) della griglia delle comuni variabili mortali?

[jajaja]

>> UBIK
in vim 
	:set number
per visualizzare il numero delle linee
	:set nonumber
per non visualizzare il numero delle linee (comodo per copiare)


se vi e' spazio a disposizione contrassegniamo le righe di codice con un tab iniziale

>> ; 
semicolon character: this character is used to mark the end of a statement and it MUST be incuded at the end lf ALL expression statements in all C++ programs

>> . 
the dot member selection operator is used to access a public member
[pag378deitel]
Objects names and references can be used with the dot . member selection operator to access a public member and pointers can be used with the arrow (->) member selection operator.
pag 386deitel >> . vs -> / >> -> vs .
- The dot member selection operator . is preceded by 
	1) an object's name or 
	2) with a reference to an object to access the object's members.
- The arrow member selection operator (->) is preceded by 
	a pointer to an object to access the object's members
Example of accessing public class Members through Objects, References and Pointers
Consider an "Account" class that has a "public setBalance" member function. Given the following declarations:
[from pag386deitel]
	Account account; // an account object
	// accountRef refers to an Account object
	Account &accountRef = account; 
  	// accountPtr points to an Account object
	Account*accountPtr = &account;
You can invoke member function "setBalance" using the dot . and arrow -> member selection operators as follows:
	// call setBalance via the Account object
	account.setBalance( 127.16 );
	// call setBalance via a reference to the Account object
	accountRef.setBalance ( 127.16 );
	// call setBalance via a pointer to the Account object
	accountPrt->setBalance( 127.16 );
>> -> examples
lo trovi anche a pag 527 deitel
ex a rogram invokes a virtual function through a base-class pointer to a derived-class object (e.g. shapePtr->draw())

>> _ / >> underscore meaning 
In C++, an underscore usually indicates a private member variable
[source http://stackoverflow.com/questions/3136594/naming-convention-underscore-in-c-c-variables]
also :
- Each name that contains a double underscore (_ _) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.
- Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace
[http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier]
>> _ about the underscore ad the end of a variable [as you can find in some openFOAM header files]:
adding an underscore to member variable allows you to name your getter and setter with the 'conceptual' name of the variable.
ex:
	class MyClass
	{
	   int someMember_;

	public:
	   int someMember() const { return someMember_; }
	   void someMember( int newValue ) { someMember_ = newValue; }
	};
not that I use this style though.
[source : http://stackoverflow.com/questions/1630412/is-using-underscore-suffix-for-members-beneficial]
anyway here this use is discouraged:
	I've read The C++ Programming Language and Stroustrup doesn't use any kind of convention for naming members. He never needs to; there is not a single simple accessor/mutator, he has a way of creating very fine object-oriented designs so there's no need to have a method of the same name. He use\s structs with public members whenever he needs simple data structures. His methods always seem to be operations. I've also read somewhere that he disencourages the use of names that differ only by one character.
[http://stackoverflow.com/questions/3650623/trailing-underscores-for-member-variables-in-c?rq=1]
	The names of variables and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.
[http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Variable_Names]
[http://geosoft.no/development/cppstyle.html]
/////////////////////////////////////////////////////////////////////////

NOMENCLATURA
pag** mike = ci riferiamo al libro di Mike Beginning C++ Through Game Programming

>> * the INDIRECTION OPERATOR * / >> *
[pag337deitel]
{in Mike Programming Game, >> * is also called DEREFERENCE OPERATOR (pag121). By placing * in front of an iterator, you're saying "treat this as the thing that the iterator references, not as the iterator itself"
NOTE trick:  *  somiglia ad una stella, come la luce di una torcia che punta verso l'indirizzo di una sezione di memoria.
Supponi di avere le seguenti righe di codice:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr
	yPtr = &y;           // assign address of y to yPtr
Nella seconda riga compare the unary * operator (commonly referred as the indirection operator or dereferencing operator) that returns an lvalue representing the object to which its pointer operand points. Per esempio riprendendo l'esempio sopra 
	cout << *yPtr << endl;
display the value of variable y namely 5, just as the statement
	cout << y << endl;
Using * in this manner is called dereferencing a pointer. A dereferenced pointer may also be used on the left side of an assignment statement, as in 
	*yPtr = 9;
which would assign 9 to y. The deferenced pointere may also be used to receive an input value as in 
	cin >> *yPtr;
which places the input value in y.
NOTE1: dereferencing an uninitialized pointer results in undefined behaviour that could cause a fatal execution-time erro. This could also lead to accidentally modifying important data, allowing the program to run to completion, possibly with incorrect results.
NOTE2: dereferencing a null pointer results in undefined behavior and typically is a fatal execution-time error, so you should ensure that a pointer is not null before dereferencing it.
Per esempio pratico di utilizzo dell'indirection operator in combinazione con l'address operator see exemple fig8.4 pag 339deitel
Te lo riscrivo qui per comodita'.
// ----------------------------------------------
// Fig. 8.4: fig08_04.cpp
// Pointer operators & and *.
#include <iostream>
using namespace std;
int main()
{
   int a = 7; // assigned 7 to a
   int *aPtr = &a; // initialize aPtr with the address of int variable a

   cout << "The address of a is " << &a
      << "\nThe value of aPtr is " << aPtr;
   cout << "\n\nThe value of a is " << a
      << "\nThe value of *aPtr is " << *aPtr << endl;
} // end main
// ---------------------------------------------- fine estratto codice 
Si ottiene as output
	The address of a is 0x7fff6e3a795c
	The value of aPtr is 0x7fff6e3a795c
	The value of a is 7
	The value of *aPtr is 7
// -----------------------------------------------
   

>> & ADDRESS OPERATOR (&)   [diverso dal >> reference operator & che dev'essere sempre preceduto dal data-type name (see pag190 mike game programming) or look alla voce >> & REFERENCE OPERATOR]
[yes they use & (end) like in Cosa nostra, perche' quando sanno l'ADDRESS, they come and kill you This is the &]
[pag 337deitel] the address operator & is a unary operator that obtains the memory address of its operand. For  example:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr  [il puntatore similmente a un puntatore laser * emette raggi per puntare verso un indirizzo]
	yPtr = &y;           // assign address of y to yPtr
NOTE: the use of the & in the preceding statement is not the same as the use of the & in a reference variable declaration, which is ALWAYS  preceded by a data-type name. When declaring a reference, the & is part of the type. In an expression like &y, the & is the  address operator.
NOTE2: the unary * operator (commonly referred as the indirection operator or dereferencing operator) returns an lvalue representing the object to which its pointer operand points. Per esempio riprendendo l'esempio sopra 
	cout << *yPtr << endl;
display the value of variable y namely 5, just as the statement
	cout << y << endl;
Using * in this manner is called dereferencing a pointer. A dereferenced pointer may also be used on the left side of an assignment statement, as in 
	*yPtr = 9;
which would assign 9 to y. The deferenced pointere may also be used to receive an input value as in 
	cin >> *yPtr;
which places the input value in y. 
NOTE3: memory locations are output as hexadecimal integers. The memory addresses output like a program like the following are platform dependent, so you may get different results when you run the program. 
Dal programma otterrai che l'address di a is the same as the value of aPtr, confirming that the address of a is indeed assigned to the pointer variable Ptr.
// ------------------------------------------------
// Fig. 8.4: fig08_04.cpp
// Pointer operators & and *.
#include <iostream>
using namespace std;
int main()
{
   int a = 7; // assigned 7 to a
   int *aPtr = &a; // initialize aPtr with the address of int variable a

   cout << "The address of a is " << &a
      << "\nThe value of aPtr is " << aPtr;
   cout << "\n\nThe value of a is " << a
      << "\nThe value of *aPtr is " << *aPtr << endl;
} // end main

// ------------------------------------------------
Si ottiene as output
	The address of a is 0x7fff6e3a795c
	The value of aPtr is 0x7fff6e3a795c
	The value of a is 7
	The value of *aPtr is 7
// ------------------------------------------------


>> T& / >> type / >> & [pag71 moo book]
	T&        denotes a reference to the type T. MOst commonly used to pass a parameter 
              that a function may change. Arguments to such parameters must be lvalues. 

	const T&  denotes a reference to the type T that may not be used to change the value to which the refence is bound. 
              Usually used to avoid cost of copying a parameter to a function.  
////////////////////////////////////////////////////////////////////////////////

>> #
the # (hash sign) posto ad inizio riga indica che e'  una riga di directives for the prepocessor. Those lines are not regular code lines with expressions but indications for the compiler's preprocessor.
Prepocessor directives must b specified in their own line and do NOT have to end with a semicolon (;)

>> \ 
escape character 
example 
	std::cout << "Welcome to C++!\n";
a string literal's characters normally print exactly as they appear between the double quotes. However the characters \n are not printed on the screen. When a backslash  is encountered in a string of characters, the next character is combined with the backslash to form an escape sequence. The escape sequence \n means newline.	

>> :
[pag497]
The colon (:) indicates inheritance
example
	class nomeDerivedClass : public nomeBaseClass
	{...codice...}
NOTE1 ( common programming error): when a derived class constructor calls a base class constructor, the arguments passed to the base-class constructor must be consistent with the number and types of parameters specified in one of the base-class constructors; otherwiese, a compilation error occurs.
NOTE2 (advice: initialize member objects explicitly in the member initializer): in a derived class constructor, invoking base-class constructors and initializing member objects explicitly in the member initiliazer list prevents duplicate initialization in which a default constructor is called, then data members are modified again in the derived class constructor's body.
NOTE3: if you get the error
>> error 
	... is a private member of ...
this is due to the fact that C++ rigidly enforces restrictions on accessing private data members, so that even a derived class (which is intimately related to its base class) cannot access the base class's private data.    
A DERIVED CLASS'S MEMBER FUNCTIONS CANNOT ACCESS ITS BASE CLASS'S PRIVATE DATA. In order to retrieve the values of the base class's data members 
- una soluzione e' quella di utilizzare appropriate "get" member functions.
- oppure, come a pagina 502 deitel, si puo' usare PROTECTED base class data members, instead of PRIVATE. In effetti a derived class is granted to access protected base-class data members. Objects of a derived class also can access protected members in any of that derived class's indirect base classes. MA attenzione usare "protected" presenta anche degli svantaggi come puoi trovare scritto nella voce "protected" o a pag.504 deitel
NOTE4 [pag500deitel] : it is necessary to include the Base-Class Header in the Derived Class Header with #include
This is necessary for 3 reason 
	1) for the derived class to use the base class's name, we must tell the compiler that the base class exists
	2) to determine the size of an object of that class. A client program that creates an object of a class #includes the class definition to enable the compiler to reserve the proper amount of memory for the object. When using inheritance, a derived-class object's size depends on the data members declared explicitly in its class definition AND the data members inherited from its direct and indirect base classes.
	3) to allow the compiler to determine whether the derived class uses the base class' inherited members properly.  
/////////////////////////////////////

>> ::
[pag89 deitel]
	::  e' il SCOPE RESOLUTION OPERATOR o anche scope operator [pag5 moo book]
example 
	std::cout = means "the name cout that is in the scope std"
[see also voce >> UNARY SCOPE RESOLUTION OPERATOR pag242deitel]	
It "ties" each member function to the class definition (the *.h header file), which declares the class's member functions and data members. (o detto in maniera piu' semplice [soure pag382deitel] a member function declared in a class definition may be defined outside that class definition and "tied" to the class via the "scope resolution operator")
:: esso compare quando si adotta l'approccio di separare l'interfaccia della classe [il Padre](contenente the functions prototypes that specify the interface of the class) dall'implementation della classe [Il Figlio Cristo] che contiene le member function definitions. 
Detto in parole spicciole: l'header myClasse.h contiene solo il "titolo" delle funzioni, mentre l'implementazione e' contenuta in myClasse.cpp che quindi contiene il "contenuto delle funzioni" . In tal modo quando il main.cpp program chiama la myClass.h (usando un #include) la definizione delle funzioni di myClass resta nascosta, interagisce giusto con l'interfaccia myClass che contiene giusto i "titoli" delle funzioni. L'implementazione delle funzioni e' contenuta/nascosta/protetta in myClass.ccp, ma affinche il compiler possa riconoscerle come member functions della classe myClass, each function name dev'essere preceduto da myClass:: 
Se dimenticassi myClass:: the compiler would consider those functions as free or loose functions, like "main". These are called also global functions. And global functions cannot access private data or call the class's member functions. Se per caso provassi ad accedere ad una variabile che e' stata gia' dichiarata come data member in myClass, visto che mancano i :: non la potresti vedere, dovresti redefinirla localmente in ciascuna "loose" function.  
ACHTUNG! When defining a class's member functions outside that class, omitting the class name and scope resolution operator (::) preceding the function names causes errors. 
Per ulteriori info sulla struttura generale in cui e' inserito il :: vedi voce 
>> INTERFACE OF A CLASS
-------------------------------------- 
DONE [itiaf] twaf = there was a future
OLD
che cosa indica?
ex in sintassi openFOAM del tipo 
	initialMassFluid[i] = fvc::domainIntegrate(rhoFluid[i]).value();
mia risposta [to verify]
mi sembra che sia un modo per far ereditare le proprieta' di una certa classe/library ex domainIntegrate eredita' tutte le proprieta' della classe fvc (= finite volume control) 	


>> ~ meaning
"Destructor" functions are the inverse of constructor functions. They are called when objects are destroyed (deallocated). Designate a function as a class's destructor by preceding the class name with a tilde (~). For example, the destructor for class String is declared: ~String()
[source https://msdn.microsoft.com/en-us/library/6t4fe76c.aspx]
Example from openFOAM:
	// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
	Foam::radiation::multiBandSolidTransmissivity::~multiBandSolidTransmissivity()
	{}
[]	

>> stream insertion operator 
	<<
example 
		std::cout << "Welcome to C++!\n";
the value to the operator's right ("Welcome to C++!\n" alla destra di <<) is inserted in the left  cout = output stream. 
NOTICE that the operator points in the direction of where the data goes. 
[pag42deitel]

>> stream extraction operator 
	>>
example 
	std::cin >> number1; // read first integer from user into number1
NOTE: nel caso tu voglia accedere to an Array's private data, dovrai dichiare lo stream extraction operator as "friend" of class Array
[tag >> access Array data]
[pag462deitel]
////////////////////////////////////////////

>> insertion operator cioe' "<<" 

>> >> vs << / >> << vs >> / >> stream extraction operator / >> stream insertion operator / >> extraction operator / >> insertion operator
[pag 440 deitel]
Eccoti un Ciccio trick per non confondere >> con >> 
1) leggi la riga da sinistra versio destra.                    
il flusso di informazione fluisce da sinistra verso destra 
Quando incontri l'operatore << l'informazione dal mondo del computer viene fatta uscire nel nostro mondo
                      ____________                                                          
 TRON >------------ <<____________ OUR WORLD       example  std::cout << "Welcome to C++!\n";

Quando incontri l'operatore >> l'informazione confluisce dal nostro mondo in TRON (computer)
           ______________
 OUR WORLD ______________ >> -----------> TRON     example  std::cin >> number1;

In questo modo ti dovrebbe venire automatico che quando vedi >> = into TRON , << = into our WORLD
Quando incontri l'operatore >> l'informazione dal mondo finisce in TRON (computer's world)
Inoltre la terminologia
A)	>> extraction operator
B)	<< insertion operator 
e' dal punto di vista del computer. 
A) il computer estrae informazione dal nostro mondo e' l'accumula in se >> ----> extract and brought into TRON
B) il computer inserisce l'informazione nel nostro mondo TRON ------ << OUR WORLD 
ESEMPIO PRATICO 
>> variable definition example:
---------------------------------------------------- start example
int main()
{                                                                                                  ----------
	// ask for the person's name                                                                  /          \
	std::cout << "Please enter your first name: ";   // << = (ciccio trick)   diffuse expand to <<   SCREEN   |
                                                                                                  \          / 
	// read the name                                                                               ---------- 
	std::string name;     // define `name'                                                                        ----------\
	std::cin >> name;     // read into `name'        // >> = (ciccio trick) from keyboard  focused and save into  ----------->> VARIABLE
                                                                                                                  ----------/
	// write a greeting
	std::cout << "Hello, " << name  << "!" << std::endl;
	return 0;
}
---------------------------------------------------- end example
///////////////////////////////////////////


>> AAAAAAA

>> abort 
[pag393deitel]
the function "abort" performs similarly to function "exit" but forces the program to terminate immediately without allowing the destructors of any objects to be called.
Abort is usually used to indicate an abnormal termination of the program.

>> abstract classes
[pag533 deitel]
Abstract classes are classes from which you never intend to instatntiate any objects. Such classes are called abstract classes. Because these classes norally are used as base classes in inheritance hierarchies, we refer to them as abstract base classes.
These classes cannot be used to instantiate objects, because abstract classes are incomplete, derived classes must define the "missing pieces" before objects of these classes can be instantiated.
>> CONCRETE CLASSES vs ABSTRACT CLASSES
An abstract class is a base class from which other classes can inherit. Classes that can be used to instanttiate objects are called "concrete classes" Such classes define or inherit implementations for every member function they declare. We could have an abstract base clas TwoDimensionalShape and derive such concrete classes as Square, Circle and Triangle. We could also have an abstract base class ThreeDimensionalShape and derive such concrete classes as Cube, Sphere, and Cylinder. Abstract ase classes are too generic to define real objects. We need to be more specific before we can think of instantiating objects. For example if someone tells you to "draw the 2-dimensional shape" what shape would you draw? Concrete classes provide the specifics that make it possible to instantiate objects.
An inheritance hierarchy does not need to contain any abstract classes, but many object-oriented systems have class hierarchies headed by abstracdt base classes. In some cases, abstract classes constitute the top few levels of the hierarchy.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ABSTRACT CLASSES [pag327 mike game programming]
useful when you want to define a class to act as a base for other classes, but it doesn't make sense to instantiate objects from this class because it's so generic. An abstract class is a base class only, and not meant for instantiating objects.
>> pure virtual function = [mike game programming pag 329] is one to which you don't need to give a definition. [nice spiegazione]
example 
	virtual void Greet() const = 0; // pure virtual member function
When a class contains at least one pure virtual function, it's an abstract class.
>> DERIVE FROM ABSTRACT CLASS [pag329 mike game programming]
When you derive a new class from an abstract class, you can override its pure virtual functions. If you override all of its pure virtual functions, then the new class is not abstract and you can instantiate objects from it.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> abstract base classes [pag274 moo book]
They exist only to capture an abstract interface for an inheritance hierarchy.

>> access function 
[pag386deitel]
Accesss function can read or display data. Another common use for access functios is to test the truth or falsity of conditions. Such fuctions are often called predicative functions. 
Example :
- potremmo creare a "isFull" predicate function that might test a container-class object to determine whether it has no additional room. 

>> accessor functions [pag161, 162 moo book]

>> accumulate function [pag115 moo book]
example in /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/analysis.cc
Extract:
double average(const vector<double>& v)
{
	return accumulate(v.begin(), v.end(), 0.0) / v.size();   // computing >> average
}
NOTE: this function is declared in <numeric> quindi per usarla all'inizio del programma devi mettere 
	#include <numeric>
NOTE2: accumulate function adds the values in the range denoted by its first two arguments, starting the summation with the value given by its third argument. The type of tue sum is the type of the third argument, so it is crucially important for us to use 0.0, instead of 0. Otherwise, the result would be an int, and any fractional part would be lost.
Having accumulate to generate the sum of all the elements in the range, we divide that sum by v.size(), which is the number of elements in the range. The result of that division, of course, is the average.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> ACTIVATION RECORD
[pag232deitel]
l'activation record e' anche chiamato STACK FRAME. It contains the return address that the called function needs in order to return to the calling function. 
	
>> ACTIVITY DIAGRAM 
[pag108deitel]
An activity diagram models the workflow (also called the activity) of a portion of a software system. In them you can find :                              ____
- action states [scritte in rettangoli con i bordi laterali curvati (____)  ] that represent actions to perform, calculations or input/output operations; 
- arrows transition which represent the flow of the activity; 
- the solid circle at the top of the diagram represents the activity's initial state (=the beginning of the workflow before the program performs the modeled activities);
- the solid circle surrounded by a hollow circle that appears at the bottom of the activity diagram represents the final state.
for more info see pag108deitel and visit www.deitel.com/UML/  
- the diamond or decision symbol indicates that a decision is to be made. A decision symbol indicates that the workflow will continue along a path determined by the symbol's associated guard conditions, which can be true or false. The guard condition is the condition specified in square brackets above or next to the transition arrow (see example if single selection activity diagram @ pag 111deitel)
The decisions can be passedd on conditions containing relational or equality operators. Actually in C++, a decision can be passed on ANY expression:
> if the expression evaluates to zero, it's treated as false [come Dio insomma]
> if the expression evaluates to nonzero, it's treated as true.  C++ provides the data type "bool" for variables that can hold only the values "true" and "false", each of these is a C++ keyword.
For compatibility with earlier versions of C, which used integers for Boolean values 
> the bool value "true" also can be represented by any non zero value (compilers typically use 1)
> the bool value "false" also can be represented as the value zero. 

>> ALGORITHMS
[pag105deitel]
A procedure for solving a problem in terms of 
	1. the ACTIONS to execute and 
	2. the ORDER in which the actions execute
is called algorithm.
/////////////
>> ALGORITHMS INTRODUCTION [pag649deitel]
The Standard Library provides scores of algorithms you'll use frequently to manipulate a variety of containers. Inserting, deleting, searching, sorting and others are appropriate for some or all of the sequence and associative containers.The algorithms operate on container elements onlyindirectly through iterators. Many algorithms operate on sequences of elements defined by iterators pointing to the first element of the sequence and to one element past the last element.
In chapter 15.5 the "copy" algorithm is used in many examples to copy a container's contents to the standard output. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> algorithms vs containers vs iterators [pag120 moo book]
NOTE1: Algorithms act on container elements; they do not act on containers. 
Algorithms like sort, remove_if, and partition functions all move the elements to new positions in the underlying container, but they do not change the properties of the container itself.
For example remove_if does not change the size of the container. Rather it copies each element for which the predicate is false to the beginning of the container, and left the rest of the elements alone. When we need to shorten the container to discard those elements, we must do so ourselves. We need to use "erase" to actually change the container by removing the sequence indicated by its arguments. Note that erase must be a member of the container, because it acts directly on the container, not just on its elements.
NOTE2: it is important to be aware of the interaction between iterators and algorithms, and between iterators and container operators. Operations such as erase and insert invalidate the iterator for the element erased. More important, in the case of vectors and strings, operations such as erase or insert also invalidate any iterator denonting elmeents after the one erased or inserted. Because these operations can invalidate iterators, we must be careful about saving iterator values if we are using these operations.
Similarly, functions such as "partition" or "remove_if" which can move elements around withing the container, will change which element is denoted by particular iterators. After running one of these functions, we cannot rely on an iterator continuing to denote a specific element.


>> AMPERSAND 
	&
il simbolo & e' chiamato ampersand.

>> argv vs >> argc
[http://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean]
What does int argc, char *argv[] mean?
In many C++ IDE's and compilers, when it generates the main function for you, it looks like this:
	int main(int argc, char *argv[])
When I code C++ without an IDE, just with a command line compiler, I type:
	int main()
without any parameters. What does this mean, and is it vital to my program?
ANSWER
argv and argc are how command line arguments are passed to main() in C and C++.
argc will be the number of strings pointed to by argv. This will (in practice) be 1 plus the number of arguments, as virtually all implementations will prepend the name of the program to the array.
The variables are named argc (argument count) and argv (argument vector) by convention, but they can be given any valid identifier: int main(int num_args, char** arg_strings) is equally valid.
They can also be omitted entirely, yielding int main(), if you do not intend to process command line arguments.
Try the following program:
	#include <iostream>	
	int main(int argc, char** argv) {
	    std::cout << "Have " << argc << " arguments:" << std::endl;
	    for (int i = 0; i < argc; ++i) {
	        std::cout << argv[i] << std::endl;
	    }
	}
Running it with ./test a1 b2 c3 will output
Have 4 arguments:
	./test
	a1
	b2
	c3
///////////////////////////////////////////////////////////////////////

>> ARGUMENT COERCION 
[from summary pag259deitel]
Argument coercion is an important feature of function prototypes (pag211deitel) 
Argument coercion =  forcing arguments to the appropriate types specified by the parameter declarations. 


>> ARGUMENT VS Parameter 
[pag71 deitel and pag73]
ARGUMENTS are the values that a function call supply for each of the function's parameters
	class ClassName
	{
	public:
		void functionName( string parameter1 ) const  // member function header
		{....}
	};
	int main ()
	{
		ClassName myObjectName; // creation of a ClassName object
		myObjectName.functionName( argument1 );  // function call
	}
OBSERVATIONS
- each parameter specifies a type (string nell'esempio sopra) and an identifier (parameter1) 
- the parameter variable's name (parameter1) can be the same as or different from the argument variable's name (argument1 nel nostro esempio abbiamo scelto dei nomi diversi)
- a function can specify multiple parameters by separating each from the next with a comma. 	
- the number and order of arguments in a function call must match the number and order of parameters in the parameter list of the called member function's header.
- the argument types in the function call must be consistent with the types of the corresponding parameters in the function header.		
	
>> AND logical operator: &&  / >> &&
see LOGICAL OPERATORS

>> ARRAY 
[pag279deitel]
An array is a contiguous group of memory locations that all have the same type. 
To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.
An element of an array is referred to by giving the array name followed by the particular element's position number in square brackets. ex:
	c[ 0 ]
(che si pronuncia "c sub zero")
ti donera' il primo elemento dell'array c. The position number is more formally called subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeroth element. Thus the elements of array c are c[0] (pronounced " c sub zero"), c[1], c[2] and so on.
	A subscript must be an integer or integer expression. If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a = 5 and b = 6, then the statement:
	c[ a + b ] += 2; 
adds 2 to array element c[11]
A subscripted array name is an lvalue: it can be used on the left side of an assignment, just as non-array variable names can.
	Each array knows its own size, which can be determined by calling its size member function. Ex supponendo di avere un array c, per saperne il size 
	c.size() 
NB: [from pag291deitel] When you use the [] operator to access an array element, C++ provides no automatic array bounds checking to prevent you from referring to an element that does not exist. It's important to ensure that every subscript you use to access an array element is within the array's bounds - that is, greater than or equal to 0 and less than the number of array elements.
Allowing programs to read from or write to array elements outside the bounds of arrays are common security flaws. Reading from out-of-bounds arrays elements can cause a program to crash or even appeear to execute correctly while using bad data. Writing to an out-of-bounds element (known as >> buffer overflow) can corrupt a program's data in memory, crash a program and allow attackers to explot the sstem and execute their own code. Concetto ripetuto anche nell'esempio pratico di pagina 318deitel see smiley tag
NOTE2 [pag318deitel] EXCEPTION HANDLING : in case of out-of-range subscript, we can create fault-tolerant programs with expection handling to continue executing as if no problems were encountered.
More severe problems might prevent a program from continuing normal execution, instead requiring the program to notify the user of the problem, then terminate. When a function detects a problem, such as an invalid array subscript or an invalid argument, it throws an exception (that is an expection occurs)   
To handle an expection, place any code that might throw an expection in a try statement
The try block contains the code that might throw an exception, and the catch block contains the code that handles the exception if one occurs.

>> array subscript operator / >> subscript operator
>> [] e' chiamato array subscript operator
see pag 458 deitel
example 
	integer[5] = 1000;
inizializza il sesto elemento dell'array a 1000 (sesto visto che si contano gli elementi dell'array a partire da zero 0 1 2 3 4 5)
////////////////////////////////////////////////

>> ARRAY MIkE explanation pag 91
While string objects provide a great way to work with a sequence of characters, arrays provide a way to work with elements of any type. That means you can use anarray to store a sequence of integers for, say a high score list. But it also means that you can use arrays to store elements of programmer defined types, such as a sequence of items that an Role Playing Game character might carry.
EXAMPLE:
///////////////////////////////////////
// Batman's Inventory
// Demonstrates arrays

#include <iostream>
#include <string>

using namespace std;

int main()
{
    const int MAX_ITEMS = 10;  // it's often a good idea to define a constant for the number of elements in an array. in this case the constant MAX_ITEMS represents the maximum number of items our Batman hero can carry
    string inventory[MAX_ITEMS]; // >> array initialization : type nameOfTheArray[sizeOfTheArray]
// la linea precedente declares an array inventory of MAX_ITEMS string objects. Because MAX_ITEMS is 10, that means 10 string objects.
    int numItems = 0;
    inventory[numItems++] = "sword";  // you can access any individual element of an array by providing an index number with the subscripting operator
    inventory[numItems++] = "armor"; // visto che scriviamo i piu' dopo numItems++, numItems viene incrementato dopo the assignment to the array.
    inventory[numItems++] = "shield";
/*
you can initialize an array with values when you declare it by providing an initializer list (= a sequence of elements separated by commas and surrounded by curly braces). Here's an example
	string inventory[MAX_ITEMS] = {"sword", "armor", "shield"};
The preceding code declares an array of string objects, inventory, that has a size of MAX_ITEMS. The first three elmeents of the array are initialized to "sword", "armor", "shield". 
If you omit the number of elements when using an initializer list, the array will be created with a size equal to the number of elements in the list. Here's an example:
	 string inventory[] = {"sword", "armor", "shield"};
Because there are three elements in the initalizer list, the preceding line creates an array, inventory, that is three elements in size. Its elements are "sword", "armor", and "shield".

*/
    cout << "Your items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}

    cout << "\nYou trade your sword for a battle axe.";
    inventory[0] = "battle axe";  // assegniamo un nuovo elemento al primo elemento dell'array
    cout << "\nYour items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}

    cout << "\nThe item name '" << inventory[0] << "' has ";
    cout << inventory[0].size() << " letters in it.\n";   // L'istruzione inventory[0].size() applica la member function size all'elemento dell'array inventory[0], cioe' l'istruzione ci indica il size del primo elemento dell'array, cioe' ci dona la lunghezza della string del primo elemento dell'array.

    cout << "\nYou find a healing potion.";
    if (numItems < MAX_ITEMS)
	{
        inventory[numItems++] = "healing potion";
	}
    else
	{
        cout << "You have too many items and can't carry another.";
	}
    cout << "\nYour items:\n";
    for (int i = 0; i < numItems; ++i)
	{
        cout << inventory[i] << endl;
	}
	
	return 0;
}
/////////
OUTPUT:

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
Your items:
sword
armor
shield

You trade your sword for a battle axe.
Your items:
battle axe
armor
shield

The item name 'battle axe' has 10 letters in it.

You find a healing potion.
Your items:
battle axe
armor
shield
healing potion
----------------------------------
NOTE : >> last element accessing 
Arry indexing begins with 0, just as you say with string objects. This means that the following code defines a five element array. 
	int highScore[5];  // qui inizializzi un array di 5 elementi interi. il primo elemento avra' indice 0, l'ultimo elemento index 4
    highScore[4] = 3; // assegniamo all'ultimo dell'array il valore 3
se invece pensando di voler assegnare 3 all'ultimo elemento dell'array avessimo scritto : highScore[5] = 3; wrong there is no element highScore[5] an attempt to access highScores[5] could lead to disastrous results, including a program crash.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> array initialization 
[pag465]
	array< int, 5 > n = { 27, 46, 99, 24, 44 };
and from C++11, since it allows any objet to be initialized with a list initializers in braces, we can write:
	array< int, 5 > n{ 27, 46, 99, 24, 44 };
///////////////////////////////////////////////////////

>> array constructor 
[pag462deitel]
GOOD PROGRAMMING PRACTICE: Arrays and objects in general should be properly initialized as they're created
Example from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.cpp
	Array::Array( int arraySize )
	   : size( arraySize > 0 ? arraySize : 
	        throw invalid_argument( "Array size must be greater than 0" ) ),
	     ptr( new int[ size ] )
	{
	   for ( size_t i = 0; i < size; ++i )
	      ptr[ i ] = 0; // set pointer-based array element
	} // end Array default constructor
///////////////////////////////////

>> ARRAY COPY / >> initializing a new array with a copy of an existing array. 
[pag457deitel]

>> ARRAY DECLARATION 
[pag281deitel]
	array< type, arraySize > arrayName;
example:
	array< int, 12 > c; // c is an array  of 12 int values
-------------EXEMPLES
// initializing an array's elements to zeros and printing the array. 
// Initializing an array's elements to zeros and printing the array.
#include <iostream>
#include <iomanip>
#include <array>
using namespace std;
int main()
{
   array< int, 5 > n; // n is an array of 5 int values
   // initialize elements of array n to 0
   for ( size_t i = 0; i < n.size(); ++i )
      n[ i ] = 0; // set element at location i to 0
   cout << "Element" << setw( 13 ) << "Value" << endl;
   // output each array element's value
   for ( size_t j = 0; j < n.size(); ++j )
      cout << setw( 7 ) << j << setw( 13 ) << n[ j ] << endl;
} // end main
//------------------------------------
NOTE about size_t (>> SIZE_T):
size_t represents an unsigned integral type. This type is recommended for any variable that represents an array's size or an array's subscripts. Type size_t is defined in the std namespace and is in header <cstddef>, which is included by various other headers.
if you attempt to compile a program that uses type "size_t"  and receive errors indicating that it's not defined
SOLUTION 
Include <cstddef> in your program. 
	#include <cstddef>
li' dalle righe dove sta di solito scritto 
	#include <iostream>
[pag282deitel]

>> ARRAY DISPLAY GRAPHICALLY / using bar charts to display array data graphically
[pag287deitel]
carino l'esempio riportato ti permette di visualizzare delle bar chart con degli asterischi pari al valore assunto da una determinata variabile dell'array. Tipo 
	  0-9:
	10-19:
    20-29:
	30-39:
	40-49:
	50-59:
	60-69: *
	70-79: **
	80-89: ***
	90-99: **
	  100: *
--------------------------------------qui ti riporto il codice sorgente:
#include <iostream>
#include <iomanip>
#include <array>
using namespace std;
int main()
{
   const size_t arraySize = 11;
   array< unsigned int, arraySize > n =
      { 0, 0, 0, 0, 0, 0, 1, 2, 4, 2, 1 };
   cout << "Grade distribution:" << endl;
   // for each element of array n, output a bar of the chart
   for ( size_t i = 0; i < n.size(); ++i )
   {
      // output bar labels ("0-9:", ..., "90-99:", "100:" )
      if ( 0 == i )
         cout << "  0-9: ";
      else if ( 10 == i )
         cout << "  100: ";
      else
         cout << i * 10 << "-" << ( i * 10 ) + 9 << ": ";
      // print bar of asterisks
      for ( unsigned int stars = 0; stars < n[ i ]; ++stars )
         cout << '*';
      cout << endl; // start a new line of output
   } // end outer for
} // end main
//------------------------------------


>> ARRAY BUILT-IN ARRAYS 
in short 
	type arrayName[ arraySize ];
where arraySize must be an integer constant greater than zero.
[pag344deitel]
Ricorda le altre due vie sono:
- array class template -> represent fixed-size lists and tables of values
- vector class template -> similar to array but can also grow or shrink dynamically to accomodate more or fewer elements.
Build-in arrays are fixed-size data structures 
> INITIALIZING built-in arrays
	int n[ 5 ] = { 50, 20, 30, 10, 40 };
creates an array of 5 ints and initializes them to the value in the inizializer list.
If you provide fewer initializers than the number of elements, the remaining elements are "value initialized", fundamental numeric types are set to 0, bools are set to false, pointers are set to nullptr and class objects are initialized by their default constructors. 
You can also omit the built-in array's size, the compiler sizes the built-in array to the number of elements in the initializer list.
	int n[] = {50, 20, 30, 10, 40 };
Ma e' sconsigliato. Meglio always to specify a built-in array's size, even when providing an initializer list. This enables the compiler to ensure that you do not provide too many initializers.
As with array objects, you use the subscript ([]) operator to access the individual elements of a built-in array. Recall that the subscript [] operator does not provide bounds checking  for array objects, this is also true for built-in arrays.
> DECLARING BUILT-IN ARRAY PARAMETERS
	int sumElements( const int values[], const size_t numberOfElements )
which indicates that the function's first argument should be a one-dimensional built-in array of ints that should not be modified by the function. Unlike array objects, built-in arrays don't know their own size, so a function that process a built-in array should have parameters to receive both the built-in array and its size.
The preceding header can also be written as :
	int sumElements( const int *values, const size_t numberOfElements )
The compiler does not differenciate between a function that receives a pointer and a function that receives a built-in array. These forms of declaring a one-dimensional array are interchangeable. Ad ogni modo for clarity, Deitel consiglia di usare the [] notation when the function expects a built-in array argument.
> SORTING 
	int n[ 5 ] = { 50, 20, 30, 10, 40 };
	sort( begin( n ), end( n ) ); // sort contents of built-in array n 
C++11's new begin and end function (from header <iterator>) each receive a built0in array as an argument and return a pointer that can be used to represent ranges of elements to process in C++ Standard Library functions like sort.
Nota le differenze rispetto a quando applicavamo sort a un array della array class template
	sort (colors.begin(), colors.end() );
NOTE1: Passing built-in arrays to functions
The value of a built-in array's name is implicitly convertible to the address of the vuilt-in array's first element. So arrayName is implicitly convertible to 
	&arrayName[0]
For this reason you don't need to tkae te address (&) of a built-in array to pass it to a function YOU SIMPLY PASS THE BUILT-IN ARRAY'S NAME. And a function that receives a pointer to a variable in the caller can modify that variable in the caller. For built-in arrays, this means that the called function can modify all the elements of a built-in array in the caller- unless the function precedes the corresponding  built-in array parameter with const to indicate that the elements should not be modified.
SUSUME: applying the const type qualifier to  a built-in array parameter in a function definition to prevent the original built-in array form being modified in the function body is another example of the principle of least priviledge. Functions should not be given the capability to modify a built-in array unless it's absolutely necessary. 
// sezioni esempi
EXAMPLE1 
	int c[ 12 ]; // c is a built-in array of 12 integers
EXAMPLE2 array initialization 
	int n[ 5 ] = { 50, 20, 30, 10, 40 };

>> ARRAY BUILT-IN ARRAY LIMITATIONS
[pag346deitel]
Built-in arrays 
- cannot be compared useing the relational and equality operators- you must use a loop to compare two built-in arrays element by element
- they cannot be assigned to one another
- they don't know their own size: a function that process a built-in array typically receives both the built-in array's name and its size as arguments
- they don't provide automatic bounds checking: you must ensure that array-access expressions use subscripts that are within the built-in array's bounds.
Objects of class templates array and vector are safer, more robust and provide more capabilities than built-in arrays. Ci sono pero' dei casi in i built-in arrays must be used, vedi voce seguente.

>> ARRAY BUILT-IN ARRAY MUST BE USED WHEN
[pag346deitel]
There are cases in which built-in arrays MUST BE used, such as processing a program's command-line arguments. [>> command line arguments].
You supply command-line arguments to a program by placing them after the program's name when executing it from the command line. Such arguments typically pass options to a program. 
For example on Linux and OS X, the following command 
	ls -la
uses the "-la" argument to list the contents of the current directory with details about each file and directory
Command-line arguments (like -la) are passed to "main" as a built-in array of pointer-based strings.
[cioe' in sostanza la viene passato come una array contenente gli elementi "l" e "a" mi sembra sia per questo motivo che non ha grande importanza talvolta l'ordine con cui inserisci le opzioni talvolta scrivamo grep -nR altre volte grep -Rn il programma legge ciascuno degli elementi del built-in array e se la lettera corrisponde ad una delle opzioni previste prosegue senza errori indipendentemente dall'ordine con cui compare all'interno del built-in array]
Appendix F (deitel) shows how to process command-line arguments

>> ARRAY ELEMENTS AS COUNTERS [example of how to use the elements of an array as counters]
pag288deitel

>> ARRAY EXAMPLE SUMMARIZE SURVEY RESULTS [example of using arrays to summarize survey results]
pag289deitel

>> ARRAY INITIALIZATION elements to zero / >> ARRAY INITIALIZE ELEMENTS TO ZERO fast way
[pag283deitel]
	array< int, 5 > n = {}; // initialize elements of array n to 0
Rispetto alla tecnica sopra esposta usante il cyclo for (pag282deitel) questa fast way technique puo' essere inizializzata only in the array's declaration, whereas the initialization technique con il ciclo for can be used repeatedly during program execution to "reinitialize" an array's elements.
NOTA BENE: initializer list specified in an array declaration must be less than or equal to the array size. Per esempio se scrivessi 
	array< int, 5 > n = { 32, 27, 42, 127, 3, 7 } 
donerebbe un errore poiche' there are six initilizers and only five array elements.

>> ARRAY INITIALIZATION using list initializer
[pag283deitel]
(oltre che usando un ciclo for come scritto nell'esempio riportato sopra -pag282deitel-) The elements of an array also can be initialized in the array declaration by following the array name with an  equals sign and a brace-delimited comma-separated list of initializers. Example: 
	   array< int, 5 > n = { 32, 27, 64, 18, 95 };
che potrai utilizzare all'interno di un programma nel seguente modo:
	#include <iostream>
	#include <iomanip>
	#include <array>
	using namespace std;
	int main()
	{
	   // use list initializer to initialize array n
 		array< int, 5 > n = { 32, 27, 64, 18, 95 };
		....
	}
//-----------------------------------------------
if there are fewer initializer than array elements, the remaining array elements are initialized to zero. For example, the elements of the array n could have been initialized to zero with the declaration: 
		array< int, 5 > n = {}; // initialize elements of array n to 0
which initializes the elements to zero, because there are fewer initializers (none in this case) than array elements. 

>> ARRAY KEYBOARD INPUT / ARRAY INITIALIZATION FROM KEYBOARD 
[pag286]
example 
	for ( size_t j = 0; j < a.size(); ++j )
		cin >> a[ j ];
reads one value at a time from the keyboard and stores the value in element a[j].

>> ARRAY OPERATION on ELEMENTS / SUM ELEMENTS ARRAY / OPERATION on ARRAY ELEMENTS / SUM ARRAY ELEMENTS
[pag280deitel]
To print the sum of the values contained in the first three elements of array c, we'd write:
	cout << c[ 0 ] + c[ 1 ] + c[ 2 ] << endl;
To divide the value of c[6] by 2 and assign the result to the variable x, we would write 
	x = c[ 6 ] / 2;

>> ARRAY SIZE 
[pag280deitel]
	Each array knows its own size, which can be determined by calling its size member function. Ex supponendo di avere un array c, per saperne il size 
	c.size()

>> ASSAY SIZE specifying with constant variable
[pag283deitel]
A) You can declaring an array as seen in pag281deitel:
	array< int, 5 > s;
B) or specifying an array's size with a constant variable. 
	const size_t arraySize = 5;
	array< int, arraySize > s;
where we use a const qualifier to declare a constant variable arraySize with the value 5. A constant variable that's used to specify array's size must be initialized with a constant expression when it's declared and cannot be modified thereafter. Constant variables are also called named constants or read only variables
GOOD PROGRAMMING PRACTICE: using B) instead of A) [cioe' defining the size of an array as a constant variable instead of a literal constant] makes programs clearer. 
This technique eliminates the so called magic numbers (= numeric values that are not explained).  Using a constant variable allows you to provide a name for a literal constant and can be help explain the purpose of the value in the program.

>> ARRAY SUM ELEMENTS ARRAY 
[pag286deitel]
   // sum contents of array a
   for ( size_t i = 0; i < a.size(); ++i )
      total += a[ i ];
 

>> ARRAY vs VECTOR / ARRAYS vs VECTORS
[pag279deitel]
- Arrays are fixed-size collections consisting of data items of the same type
- Vectors are collections (also of data items of the same type) that can grow and shrink dynamically at execution time.
Both array and vector are C++ standard library class templates. To use them, you must include the <array> and <vector> headers respectively. 

>> ARRAY CLASS EXAMPLE [the most important study case in deitel book]
[pag453]
Built-in arrays have sereral limitations 
- they do not check whether subscritps fall outsdie the range of the array
- ... lunga lista vedi pag 453 deitel
- cannot assign one built-in array to another using the assignment operator
- cannot compare  two built-in arrays using equality or relational operators (because the arrays names are simply pointers to where the arrays begin in memory and two arrays will always be at different memory locations).
But we can add all these missing capabilities by creating a more powerful Array class, usando classes and operator overloading. 

>> ARRAY SIZE ASSIGNMENT 
[pag463deitel]
[from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.cpp]
	const Array &Array::operator=( const Array &right )
	{
	   if ( &right != this ) // avoid self-assignment
	   {
	      // for Arrays of different sizes, deallocate original
	      // left-side Array, then allocate new left-side Array
	      if ( size != right.size )
	      {
	         delete [] ptr; // release space
	         size = right.size; // resize this object
	         ptr = new int[ size ]; // create space for Array copy
	      } // end inner if
	
	      for ( size_t i = 0; i < size; ++i )
	         ptr[ i ] = right.ptr[ i ]; // copy array into object
	   } // end outer if
///////////////////////////////////

>> ARRAYS [pag407 jesse book]
An array is a sequential collection of adata storage locations, each of which holds the same type of data. Each storage location is called an element of the array. 
You declare an array by writing the type, followed by the array name and the subscript. The subscript is the number of elements in the array, surrounded by square brackets. For example 
	long LongArray[25];
declares an array of 25 long integers, named LongArray. When the compiler sees this declaration, it sets aside enough memory to hold all 25 elements. It each long integer requires four bytes, this declaration sets aside 25*4 = 100 continguous bytes of memory. 
------------------------------------------------------------------------------
>> ACCESSING ARRAY ELEMENTS / >> ARRAY ELEMENTS ACCESS [pag408 jesse]
You access an array element by referring to its offset from the beginning of the array. Array element offsets are counted from zero. Therefore, the first array element is referred to as arrayName[0]. In he longArray example above, longArray[0] is the first array element, LongArray[1] the second, and so forth. 
This can be somewhat confusing. Suppose the array SomeArray[3] has three elements. They are SomeArray[0], SomeArray[1] and SomeArray[2]. More generally, SomeArray[n] has n elements that are numbered SomeArray[0] through SomeArray[n-1]. Again, remember that this is because the index is an offset, so the first array element is 0 storage locations from the beginning of the array, the second is 1 storage location, and so on. [cioe' detto in italiano: element con subscript 0 = no offset = no scostamento. The index ci indica di quanto ci si scosta dal primo elemento. Il primo elemento rispetto a se stesso non ha scostamento quindi the subscript  e' 0. Il secondo elemento si scosta di uno, etc]
Il seguente 13.1 listing shows hot to declare an array of five integers and fill each with a value.
From the following listing you can notice that each element is accessed using the name of the array followed by square brackets with the offset in between "nomeArray[i]". Each of these elements can then be treated like a variable of the array's type.
---------------------------------------------------------------------------------------------------------------- LISTING 13.1 START
	//Listing 13.1 - Arrays
	#include <iostream>
	  
	int main()
	{
	   int myArray[5];     // Declaring array of 5 integers
	   int i;
	   for ( i=0; i<5; i++)  // for loop that counts from 0 to 4
	   {
		   std::cout << "Value for myArray[" << i << "]: ";   // output to screen
		   std::cin >> myArray[i];   // prende in input il valore che immetti via keyboard. The value is saved at the correct offset into the array.
	   }
	   for (i = 0; i<5; i++)   // second for loop to print each value of the array to console.
		  std::cout << i << ": " << myArray[i] << std::endl;
	   return 0;
	}
---------------------------------------------------------------------------------------------------------------- LISTING 13.1 END
OUTPUT:
[1007 Day13] >> g++ List1301.cpp -o List1301.exe
[1008 Day13] >> ./List1301.exe 
Value for myArray[0]: 3
Value for myArray[1]: 67
Value for myArray[2]: 76
Value for myArray[3]: 7
Value for myArray[4]: 127
0: 3
1: 67
2: 76
3: 7
4: 127
--------------------------------------------------------------------------------------------------------------------
NOTE: arrays count from zero, not from one. This is the cause of many bugs in programs written by C++ novices. Think of the index as the offset. The first element, such as  ArrayName[0] is at the beginning of the array, so the offset is zero. Thus, whenever you use an array, remember that an array with 10 elements counts from ArrayName[0] to ArrayName[9]. ArrayName[10] is an error. 
--------------------------------------------------------------------------------------------------------------------
>> WRITING PAST THE END OF AN ARRAY [pag410 jesse]
When you write a value to an element in an array, the compiler computes where to store the value based on the size of each element and the subscript. Suppose that you ask to write over the value at LongArray[5], which is the sixth element. The compiler multiplies the offset (5) by the size of each element, in this case 4 bytes. It then moves that many bytes (5*4 = 20) from the beginning of the array and writes the new value at that location. 
If you asks to write at LongArray[50], most compilers ignore the fact that no such element exists. Rather the compiler computes how far past the first element it should look (50*4 = 200 bytes) and then writes over whatever is at that location. This can be virtually any data, and writing your new value there might have unpredictable results. If you're lucky, your program will crash immediately. If you're unlucky, you'll get strange results much later in your program, and you'll have a difficult time figuring out what went wrong. 
The compiler is like a blind man pacing off the distance from a house. He starts out at the first house, MainStreet[0]. When you ask him to go to the sixth house on Main Street, he says to himself "I must go five more houses. Each house is four big paces. I must go an additional 20 steps". If you ask him to go to MainStreet[100] and Main Street is only 25 houses long, he paces off 400 steps. Long before he gets there, he will, no doubt, step in front of a truck. So be careful when you send him.   
FOLLOWING LISTING MAY CRASH YOU SYSTEM just compile it but not launch it 
-------------------------------------------------------------------------------------------------------------------- 13.2 LISTING START
//Listing 13.2 - Demonstrates what happens when you write 
// past the end of an array
#include <iostream>
using namespace std;
     
int main()
{
   // sentinels
   long sentinelOne[3];
   long TargetArray[25]; // array to fill
   long sentinelTwo[3];
/*
nelle 3 righe precedenti abbiamo creato 3 arrays. Prima e dopo la creazione dell'array TargetArray, creiamo degli array che agiscono da sentinella. These sentinel arrays are initialized wth the value 0 (see following for  cycle). Because these are declared before and after TargetArray, there is a good chance that they will be placed in memory just before and after it. If memory is written beyond the end of TargetArray, it is the sentinels that are likely to be changed rather than some unknown area of data. Some compilers count down in memory; others count up. For this reason, the sentinels are placed both before and after TargetArray. 
*/
   int i;
   for (i=0; i<3; i++)
   {
      sentinelOne[i] = 0;
      sentinelTwo[i] = 0;
   }   
   for (i=0; i<25; i++)
      TargetArray[i] = 10;
       
   cout << "Test 1: \n";  // test current values (should be 0)
   cout << "TargetArray[0]: " << TargetArray[0] << endl;
   cout << "TargetArray[24]: " << TargetArray[24] << endl << endl;
        
   for (i = 0; i<3; i++)
   {
      cout << "sentinelOne[" << i << "]: ";
      cout << sentinelOne[i] << endl;
      cout << "sentinelTwo[" << i << "]: ";
      cout << sentinelTwo[i]<< endl;
   }
         
   cout << "\nAssigning...";
   for (i = 0; i<=27; i++)   // going a little too far!
      TargetArray[i] = 20;
          
   cout << "\nTest 2: \n"; 
   cout << "TargetArray[0]: " << TargetArray[0] << endl;
   cout << "TargetArray[24]: " << TargetArray[24] << endl;
   cout << "TargetArray[25]: " << TargetArray[25] << endl << endl;
   for (i = 0; i<3; i++)
   {
      cout << "sentinelOne[" << i << "]: ";    // this time since "for (i = 0; i<=27; i++) " above, sentinelOne or sentinelTwo may be modified, si possono veder assegnate il valore 20. 
      cout << sentinelOne[i]<< endl;           // or you might also overwrite something else or crash your system instead. 
      cout << "sentinelTwo[" << i << "]: ";   // this is a nasty bug that can be very hard to find, because sentinel array was changed in a part of the code that was not writing to sentinel array at all.
      cout << sentinelTwo[i]<< endl;
   }
           
   return 0;
}
-------------------------------------------------------------------------------------------------------------------- 13.2 LISTING END
>> FENCE POST ERRORS [pag413 jesse book]
It is so common to write to one past the end of an array that this bug has its own name. It is called a fence post error. This refers to the problem in counting how many fences posts you need for a 10 foot fence if you need one post for every foot. You need 11 fences 

detto in maniera semplice se hai due pannelli, hai bisogno di 3 fences 

     |__________|__________|
     1                     2                     3

This type of "off by one" counting can be the bane of any C++ programmer's life. Over time, however, you'll get used to the idea that a 25 element array counts only to element 24, and that everything counts from 0. 
NOTE: some programmers refer to ArrayName[0] as the zeroth element. Getting into this habit is a mistake.If ArrayName[0] is the zeroth element, what is ArrayName[1]? The oneth? If so, when you see ArrayName[24], will you realize that it is not the 24th element in the array, but rather the 25th? It is far less confusing to say that ArrayName[0] is at offset zero and is the first element of the array. 
--------------------------------------------------------------------------------------------------------------------------------
>> INITIALIZING ARRAYS / >> ARRAY INITIALIZATION [pag413 jesse book]
You caninitialize a simple array of built-in types, such as integers and characters, when you first declare the array. After the array name, you put an equal sign  and a list of commad separated values enclosed in braces. For example 
	int IntegerArray[5] = { 10, 20, 30, 40, 50 };
declares IntegerArray to be an array of five integers. It assigns IntegerArray[0] the value 10, IntegerArray[1] the value 20 and so forth. 
If you omit the size of the array, an array just big enough to hold the initialization is created. Therefore you write: 
	int IntegerArray[] = { 10, 20, 30, 40, 50 };
you will create the same array as you did in the previous example, an array that holds five elements. 
You cannot initialize more elements than you've declared for the array. Therefore 
	int IntegerArray[5] = { 10, 20, 30, 40, 50, 60 };
generates a compiler error because you've declared a five-member array and initialzed six values. It is legal, however to write 
	int IntegerArray[5] = { 10, 20};
in this case, you have delcared a five element array and only initialized the first two elements IngeterArray[0] and IntegerArray[1].
NOTE: arrays can have any legal variable name, but they cannot have the same name as another variable or array within their scope. Therefore, you cannot have an array named myHoverBoards[5] and a variable named myHoverboards at the same time.   	
NOTE2: so remember to declare an array, write the type of object stored, followed by the name of the array and subscript with the number of objects to be held in the array. Array count from zero. An array of n items is numbered from 0 to n-1. 
example : 
	int MyIntegerArray[90];   // dichiarazione di un array di 90 elementi di type "int"
	// assign ninth member of MyIntegerArray to theNinethInteger
	int  theNinethInteger = MyIntegerArray[8];   // qui assegni il nono elemento dell'array alla variabile intera "theNinethInteger"
----------------------------------------------------------------------------------------------------------------------------------------------------
>> ARRAYS OF OBJECTS / >> OBJECTS ARRAYS [pag416 jesse]
Any object, whether built-in or user defined, can be stored in an array. When you declare the array to hold  objects, you tell the compiler the type of object yo store and the number for which to allocate room. The compiler knows how much room is needed for each object based on the class declaration. The class must have a default constructor that takes no arguments so that the obejcts can be created when the array is defined. 
Accessing member data in an array of objects is a two-step process. You identify the member of the array by using the index operator ([ ]), and then you add the member operator (.) to access the particular member variable. Listing 13.4 (see below) demonstrates how you would create and access an array of five Cats. 
---------------------------------------------------------------------------------------------------------------------------------- LISTING 13.4 START
// Listing 13.4 - An array of objects
  
#include <iostream>
using namespace std;
  
class Cat
{
  public:
     Cat() { itsAge = 1; itsWeight=5; }   // declaration and definition of the default constructor for the Cat class. For each Cat, a default age of 1 is set as well as a default weight of 5. 
     ~Cat() {}
    int GetAge() const { return itsAge; }
    int GetWeight() const { return itsWeight; }
    void SetAge(int age) { itsAge = age; }
  
  private:
    int itsAge;
    int itsWeight;
};
  
int main()
{
   Cat Litter[5];
   int i;
   for (i = 0; i < 5; i++)
      Litter[i].SetAge(2*i +1);  
  
   for (i = 0; i < 5; i++)
   {
      cout << "Cat #" << i+1<< ": ";
      cout << Litter[i].GetAge() << endl;   // You identify the member of the array by using the index operator ([ ]), and then you add the member operator (.) to access the particular member variable.
   }
   return 0;
}
---------------------------------------------------------------------------------------------------------------------------------- LISTING 13.4 END
OUTPUT 
[1010 Day13] >> g++ List1304.cpp -o List1304.exe
[1011 Day13] >> ./List1304.exe 
Cat #1: 1
Cat #2: 3
Cat #3: 5
Cat #4: 7
Cat #5: 9
------------------------------------------------------------------------------------------------------------------------------------
>> MULTIDIMENSIONAL ARRAYS [pag417 jesse]
It is possible to have array of more than one dimension. Each dimension is represented as a subscript in the array. Therefore, a two-dimensional array has two subscripts; a three-dimensional array has three subscripts; and so on. Arrays can have any number of dimensions, although it is likely that most of the arrays you create will be of one or two dimensions. 
A good example of a two dimensional array is a chess board. One dimension represents the eight rows; the other dimension represents the eight columns. Suppose that you have a class named SQUARE. The declaration of an array named Board that represents it would be 
	SQUARE Board[8][8];
You could also represent the same data with a one-dimensional, 64-square array. For example: 
	SQUARE Board[64];
This one-dimensional array however, doesn't correspond as closely to the real-world object as the two-dimensional array. When the game begins, the king is located in the fourth position in the first row; that position corresponds to
	Board[0][3];
assuming that the first subscript corresponds to row and the second to column.   
------------------------------------------------------------------------------------------------------------------------------------
>> MULTIDIMENSIONAL ARRAYS INITIALIZING / >> MULTIDIMENSIONAL ARRAY INITIALIZATION [pag419 jesse book]
You can initialize multidimensional arrays. You assign the list of values to array elements in order, with the last array subscript (the one farthest to the right) changing while each of the former holds steady. Therefore if you have an array
	int theArray[5][3];
the first three elements go into the "theArray[0]"; the next three into theArray[1]; and so forth. 
You initialize this array by writing 
	int theArray[5][3] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
or for the sake of clarity, you could group the initializations with braces. For example 
	int theArray[5][3] = {{1,2,3},
                                       {4,5,6},
                                       {7,8,9},
                                       {10,11,12},
                                       {13,14,15}};
The compiler ignores the inner braces, but they do make it easier to understand how the numbers are distributed. When initializing elements of an array, each value must be separted by a comma, without regard to the braces. The entire initialization set must be within braces, and it must end with a semicolon.
The following listing 13.5 creates a two-dimensional array. The first dimension is the set of numbers from zero to four. The second dimension consists of the double of each value in the first dimension. 
------------------------------------------------------------------------------------------------------------------------------------ LISTING 13.5 START
// Listing 13.5 - Creating a Multidimensional Array
#include <iostream>
using namespace std;
  
int main()
{
   int SomeArray[2][5] = { {0,1,2,3,4}, {0,2,4,6,8}};   // declaring SomeArray to be a 2D array. The first dimension inidcates that there will be two sets; the second dimension consists of five integers. This creates a 2x5 grid
   for (int i = 0; i<2; i++)    // outer loop; the first dimension is incremented only after the second dimension has gone through all of its increments. Then counting for the second dimension starts over
   {
        for (int j=0; j<5; j++)    // inner loop ticks through each member of the second dimension. 
        {
          cout << "SomeArray[" << i << "][" << j << "]: ";
          cout << SomeArray[i][j]<< endl;
        }
   }
   return 0;
}
------------------------------------------------------------------------------------------------------------------------------------ LISTING 13.5 END
OUTPUT 
	[1012 Day13] >> g++ List1305.cpp -o List1305.exe
	[1013 Day13] >> ./List1305.exe 
	SomeArray[0][0]: 0
	SomeArray[0][1]: 1
	SomeArray[0][2]: 2
	SomeArray[0][3]: 3
	SomeArray[0][4]: 4
	SomeArray[1][0]: 0  //  the first dimension is incremented only after the second dimension has gone through all of its increments. Then counting for the second dimension starts over
	SomeArray[1][1]: 2
	SomeArray[1][2]: 4
	SomeArray[1][3]: 6
	SomeArray[1][4]: 8
--------------------------------------------------------------------------------------------------------------------------------------
NOTE: when you declare an array, you tell the compiler exactly how many objects you expect to store in it. The compiler sets aside memory for all the objects, even if you never use it. This isn't a problem with arrays for which you have a good idea of how many objects you'll need. For example, a chessboard has 64 squares. When you have no idea of how many objects you'll need, however, you must see more advanced data structures, like arrays of pointers, arrays built on the free store, and various other collections. 
--------------------------------------------------------------------------------------------------------------------------------------
>> ARRAYS of POINTERS / >> POINTER ARRAYS / >> ARRAY POINTERS [pag421 jesse]
The arrays discussed so far store all their members on the stack. Usually, stack memory is more limited, whereas free store memory is much larger. It is possible to declare each object on the free store and then to store only a pointer to the object in the array. This dramatically reduces the amount of stack memory used. Listing 13.6 rewrites the array from Listing 13.4, but it stores all the objects on the free store. 
-------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.6 START
// Listing 13.6 - An array of pointers to objects
  
#include <iostream>
using namespace std;
  
class Cat    // the Cat object is identical to the Cat object declared in Listing 13.4
{
  public:
    Cat() { itsAge = 1; itsWeight=5; }
    ~Cat() {}                                 // destructor
    int GetAge() const { return itsAge; }
    int GetWeight() const { return itsWeight; }
    void SetAge(int age) { itsAge = age; }
  
  private:
    int itsAge;
    int itsWeight;
};
  
int main()
{
   Cat * Family[500];   // what changes is that this time the array declared is named Family and it is declared to hold 500 elements. More importantly, these 500 elements are pointers to Cat objects.  
   int i;
   Cat * pCat;
   for (i = 0; i < 500; i++)  // with this loop 500 new Cat objects are created on the free store, and each one has its age set to twice the index plus one. 
   {
      pCat = new Cat;
      pCat->SetAge(2*i +1);
      Family[i] = pCat;   // assigning the pointer to the array. Because the array has been declared to hold pointers, the pointer (rather than the dereferenced value in the pointer) is added to the array. 
   }

   for (i = 0; i < 500; i++) // with this second loop we print each value. 
   {
      cout << "Cat #" << i+1 << ": "; // because inex offsets start from zero, we add 1 to display a count starting at 1 instead
      cout << Family[i]->GetAge() << endl; //the pointer is accessed by using the index, Family[1]. That address is then used to access the GetAge() method. 
   }
   return 0;
}
// NOTE how in this example, the array Family and all its pointers are stored on the stack, but the 500 Cat objects that are created are stored on the free store
-------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.6 END
>> POINTER ARITHMETIC / >> POINTER OPERATIONS [pag423 jesse]
There are few things that can be done mathematically with pointers. Pointers can be subtracted, one from another. One powerful technique is to point two pointers at different elements in an array and to take their difference to see how many elements separate the two members. This can be very useful when parsing arrays of characters, as illustrated in Listing 13.7
-------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.7 START
// Illustrates how to parse out words from a character string
// This program allows the user to enter in a sentence. The program then breaks out each word (each set of alphanumeric characters) of the sentence. 
#include <iostream>
#include <ctype.h>
#include <string.h>

bool GetWord(char* theString, 
          char* word, int& wordOffset);

// driver program
int main()
{
   const int bufferSize = 255;
   char buffer[bufferSize+1];   // hold the entire string
   char word[bufferSize+1];     // hold the word
   int wordOffset = 0;          // start at the beginning

   std::cout << "Enter a string: ";   // prompting the user to enter a sentence
   std::cin.getline(buffer,bufferSize);

   while (GetWord(buffer,word,wordOffset))  // the method GetWord() returns each word from the string until the end of the string is reached.
   {
      std::cout << "Got this word: " << word << std::endl;
   }
   return 0;
}

// function to parse words from a string.
bool GetWord(char* theString, char* word, int& wordOffset)
{
   if (!theString[wordOffset])  // end of string?
       return false;

   char *p1, *p2;    // declaration of two character pointers. 
   p1 = p2 = theString+wordOffset;  // point to the next word

   // eat leading spaces
   for (int i = 0; i<(int)strlen(p1) && !isalnum(p1[0]); i++)
      p1++;

   // see if you have a word
   if (!isalnum(p1[0]))  // by using isalnum (= is it alphanumeric?) we ensure that an alphanumeric character is found. If not, false is returned. 
      return false;

   // p1 now points to start of next word
   // point p2 there as well
   p2 = p1;

   // march p2 to end of word
   while (isalnum(p2[0]))
      p2++;  // p2 march through the word, stopping at the first nonalphanumeric character. So that p2 ends up pointing to the end of the word that p1 points to the beginning of. 

   // p2 is now at end of word
   // p1 is at beginning of word
   // length of word is the difference
   int len = int (p2 - p1);   // by substracting the p1 from p2 and casting the result to an integer, you are able to establish  the length of the word. 

   // copy the word into the buffer
   strncpy (word,p1,len);   // That word is then copied using "strncpy" a string copying method from the standard library, passing in as the starting point p1and as the length of the difference that you' ve established.

   // null terminate it
   word[len]='\0';

   // now find the beginning of the next word
   for (int j = int(p2-theString); j<(int)strlen(theString)
      && !isalnum(p2[0]); j++)
   {
      p2++;
   }

   wordOffset = int(p2-theString);

   return true;
}
-------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.7 END
OUTPUT 
[1014 Day13] >> g++ List1307.cpp -o List1307.exe
[1016 Day13] >> ./List1307.exe 
Enter a string: fighting to bring an hoverboard and symphony into Earth Dimension Go C127VA!         
Got this word: fighting
Got this word: to
Got this word: bring
Got this word: an
Got this word: hoverboard
Got this word: and
Got this word: symphony
Got this word: into
Got this word: Earth
Got this word: Dimension
Got this word: Go
Got this word: C127VA
NOTE: this is a classic example of code that is best understood by putting it into a debugger and stepping through its execution.  Using pointer arithmetic is very common when working with pointers and arrays, but it is also a dangerous activity and needs to be apprached with respect. 
---------------------------------------------------------------------------------------------------------------------------------------
>> ARRAY DECLARATION ON THE FREE STORE / >> DECLARATION ARRAYS ON THE FREE STORE / >> FREE STORE ARRAY DECLARATION [pag426 jesse]
It is possible to put the entire array on teh free store, also known as the heap. You do this by creating a pointer to the array. Create the pointer by calling "new" and using the subscript operator. The result is a pointer to an area on the free store that holds the array. For example 
	Cat *Family = new Cat[500];
declares Family to be a pointer to the first element in an array of 500 Cats. In other words, Family points to (or has the address of) Family[0].
The advantage of using Family in this way is that you can use pointer arithmetic to access each member of Family. For example, you can write
	Cat *Family = new Cat[500];
	Cat *pCat = Family;    // pCat points to Family[0]
	pCat->SetAge(10);     // set Family[0] to 10
	pCat++;                       // advance to Family[1]
	pCat->SetAge(20);     // set Family[1] to 20
This declares a new array of 500 Cats and a pointer to point to the start of the array. Using that pointer, the first Cat's SetAge() function is called with a value of 10. The pointer is then incremented. This causes the pointer to be incremented to point to the next Cat object in the array. The second Cat's SetAge() method is then called with a value of 20. 
>> POINTER TO AN ARRAY vs >> ARRAY of POINTERS [pag426 jesse]
Examine the following three declaration: 
	Cat    FamilyOne[500];   // FamilyOne is an array of 500 Cat objects
	Cat * FamilyTwo[500];  // FamilyTwo is an array of 500 pointers to Cat objects
	Cat * FamilyThree = new Cat[500]; // FamilyThree is a pointer to an array of 500 Cat objects
The differences among these three code lines dramatically affect how these arrays operate. FamilyThree is a variant of FamilyOne, but it is very different from FamilyTwo. In the third case, FamilyThree is a pointer to an array. That is, the address in FamilyThree is the address of the first item in that array. This is exactly the case for FamilyOne. 
>> POINTERS and >> ARRAY NAMES [pag427 jesse]
In C++, an array name is a constant pointer to the first element of the array. Therefore, in the declaration 
	Cat Family[500];
Family is a pointer to &Family[0], which is the address of the first element of the array Family. 
It is legal to use array names as constant pointers, and viceversa. Therefore, Family + 4 is a legitimate way of accessing the data at Family[4]
The compiler does all the arithmetic when you add to, increment, and decrement pointers. The address accessed when you write Family + 4 isn't four bytes past the adress of Family, it is four objects. If each object is four bytes long, Family + 4 is 16 bytes past the start of the array. If each object is a Cat that has 
	4 long member variables of 4 bytes each + two short member variables of 2 bytes each => 4*4+ 2*2 = 20 => each Cat is 20 bytes 
then Family + 4 is 80bytes past the start of the array.   
The following listing 13.8 illustrates declaring and using an array on the free store
------------------------------------------------------------------------------------------------------------------------------------ LISTING 13.8 START
 // Listing 13.8 - An array on the free store

#include <iostream>

class Cat
{
  public:
    Cat() { itsAge = 1; itsWeight=5; }
    ~Cat();
    int GetAge() const { return itsAge; }
    int GetWeight() const { return itsWeight; }
    void SetAge(int age) { itsAge = age; }

  private:
    int itsAge;
    int itsWeight;
};

Cat :: ~Cat()
{
   // std::cout << "Destructor called!\n";
}

int main()
{
   Cat * Family = new Cat[500]; // declaration of the pointer "Family" : it is a pointer to an array of 500 Cat objects. 
                                                     // The entire array is created on the free store with the call to new Cat[500]
   int i;

   for (i = 0; i < 500; i++)
   {
      Family[i].SetAge(2*i +1);  // the Family pointer we declared can be used with the index operator [], and thus can be treated just like a regular array. 
   }

   for (i = 0; i < 500; i++)
   {
      std::cout << "Cat #" << i+1 << ": ";
      std::cout << Family[i].GetAge() << std::endl;   // also here just like an array name, we can use the pointer to call the GetAge() method. 
   }                                                  // as you can see for all practical purposes we can treat this pointer to the Family array as an array name. 
   // The only thing you will need to do, however, is to free the memory you allocated in setting up the array.                      
   delete [] Family;   // that's what we do in this line with a call to "delete"

   return 0;
}
------------------------------------------------------------------------------------------------------------------------------------ LISTING 13.8 END
NOTE  [>> ARRAY DELETION ON FREE STORE / >> FREE STORE ARRAY DELETION]:
What happens to the memory allocated for these Cat objects when the array is destroyed? Is there a chance of a memory leak?
Delete Family automatically returns all the memory set aside for the array if you use the delete with the [] operator. By including the square brackets, the compiler is smart enough to destroy each object in the array and to return its memory to the free store.  
When you create an item on the heap by using new, you always delete that item and free its memory with delete. Similarly, when you create an array by using new <class>[size], you delete that array and free all its memory with delete[]. The brackets signal the compiler that this array is being deleted. 
ATTENTION: if you leave the brackets off, only the first object in the array is deleted, in that case yes, you create a memory leak. 
------------------------------------
>> RESIZE ARRAYS at runtime / >> ARRAYS RESIZE / >> RESIZING ARRAY at runtime [pag429 jesse]
The biggest advantage of being able to allocate arrays on the heap is that you determine the size of the array at runtime and then allocate it. For instance, if you asked the user to enter the size of a family into a variable called SizeOfFamily, you could then declare a Cat array as follows:
	Cat *pFamily = new Cat[SizeOfFamily];
with that, you now have a pointer to an array of Cat objects. You can then create a pointer to the first element and loop through this array using a pointer and pointer arithmetic. 

	Cat *pCurrentCat = Family[0];
	for ( int Index = 0; Index < SizeOfFamily; Index++, pCurrentCat++ )
	{
		pCurrentCat->SetAge(Index);
	};
Because C++ views ARRAYS AS NO MORE THAN SPECIAL CASES OF POINTERS, you can skip the second pointer and simply use standard array indexing: 
	for ( int Index = 0; Index < SizeOfFamily; Index++ )
	{
		pFamily[Index].SetAge(Index);   // woooow! very elegante!!!
	};
The use of the subscript brackets automatically dereferences the resulting pointer and the compiler causes the appropraite pointer arithmetic to be performed. 
A further advantage is that you can use a similar technique to resize an array at runtime when you run out of room. The following listing 13.9 illustrates this reallocation : 
-------------------------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.9 START 
	//Listing 13.9 
	// reallocating an array at runtime 
	#include <iostream>
	using namespace std;
	int main()
	{
	   int  AllocationSize = 5;   // setting the initial size of the array
	   int *pArrayOfNumbers = new int[AllocationSize];  // allocating the array and assigning its address to pArrayOfNumbers
	   int  ElementsUsedSoFar = 0;
	   int  MaximumElementsAllowed = AllocationSize;
	   int  InputNumber = -1;
	  
	   cout << endl << "Next number = ";  // get the number from the user 
	   cin >> InputNumber;                          // and place it into the InputNumber variable

	   while ( InputNumber > 0 )   // we start the while loop only if the number inputted is greater than zero.
	   {
		  pArrayOfNumbers[ElementsUsedSoFar++] = InputNumber;
	 
		  if ( ElementsUsedSoFar == MaximumElementsAllowed ) // performing a check to see if this is the last element that the array has room for.
		  {                                        // if there is no room in the array we enter inside this block to increase the size of the array
		      int *pLargerArray =
		          new int[MaximumElementsAllowed+AllocationSize]; // creating a larger array capable to hold AllocationSize=5 more elements
	 
		      for ( int CopyIndex = 0;
		          CopyIndex < MaximumElementsAllowed;
		          CopyIndex++ )
		      {
		          pLargerArray[CopyIndex] = pArrayOfNumbers[CopyIndex];  // copying all the elements from the old array to the new larger array using array notation 
		      };
	 
		      delete [] pArrayOfNumbers;  // deleting the old array
		      pArrayOfNumbers = pLargerArray;  // replacing the old pointer with the pointer to the larger array. 
		      MaximumElementsAllowed+= AllocationSize;
		  };
		  cout << endl << "Next number = ";
		  cin >> InputNumber;
	   }
	 
	   for (int Index = 0; Index < ElementsUsedSoFar; Index++)
	   {
		 cout << pArrayOfNumbers[Index] << endl;
	   }
	   return 0;
	 }
-------------------------------------------------------------------------------------------------------------------------------------------------------- LISTING 13.9 END
 OUTPUT 
[1019 Day13] >> g++ List1309.cpp -o List1309.exe
[1020 Day13] >> ./List1309.exe 
Next number = 234                                             // you can enter the number one after the other and they get stored in an array
Next number = 23                                               
Next number = 242
Next number = 242
Next number = 1231
Next number = 252
Next number = 23523
Next number = 1231
Next number = 234523423
Next number = 123123
Next number = 23452
Next number = 123
Next number = 2435
Next number = 123
Next number = 0                                 // when a number less or equal to 0 is entered, the array of numbers that has been gathered is printed.
234
23
242
242
1231
252
23523
1231
234523423
123123
23452
123
2435
123
------------------------------------------------------------------------------------------------
MEMENTO 
DO use aray indexing with pointers that point to arrays
DO use delete[] to remove an entire array created on the free store. Using just delete without the [] only deletes the first element. 
DON'T write or read past the end of an array 
DON'T confuse an array of pointers with a pointer to an array
DON'T forget to delete any memory you allocate using "new"
--------------------------------------------------------------------------------------------------
>> CHAR ARRAYS and STRINGS [pag432 jesse]
There is  a type of array that gets special attention. This is an array of characters that is terminated by a null. This array is considered a "C-style string". The only C-style strings you've seen until now have been unnamed C-style string constants used in "cout" statements, such as :
	cout << "Hover board";
You can declare and initialize a C-style string the same as you would any other array. For example: 
	char Greeting[] = {'H', 'o', 'v', 'e', 'r', ' ', 'b', 'o', 'a', 'r', 'd', '\0' }:
In this case, Greeting is declared as an array of characters and it is initialized with a number of characters. The last character '\0' is the null character, which many C++ functions recognize as the terminator for a C-style string. Although this character-by-character approach works, it is difficult to type and admits too many opportunities for error. C++ enables you to use a shorthand form of the previous line of code. It is 
	char Greeting[] = "Hover board";
You should note two things about this syntax:
- instead of single quoted characters separated by commas and surrounded by braces, you have a double quoted C-style string, no commas, and no braces.
- you don't need to add the null character because the compiler adds it for you. 
When you declare a string, you need to ensure that you make it as large as you will need. The length of a C-style string includes the number of characters including the null character. For example, the string "Hello World" is 12 bytes. Hello is 5 bytes. The space is 1 byte, World is 5 bytes, and the null character is 1 byte. 
You can also create uninitialized character arrays. As with all arrays, it is important to ensure that you don't put more into it than there is room for. The following 13.10 listing demonstrates the use of an uninitialized buffer:
------------------------------------------------------------------------------ LISTING 13.10 Filling an array START
//Listing 13.10 char array buffers
  
#include <iostream>
  
int main()
{
    char buffer[80]; // character array is created to act as a buffer to hold 80 characters. This is large enough to hold a 79 character C-style string and a terminating null character. 
    std::cout << "Enter the string: ";
    std::cin >> buffer;
    std::cout << "Here is's the buffer:  " << buffer << std::endl;
    return 0;
}
------------------------------------------------------------------------------ LISTING 13.10 Filling an array END
OUTPUT 
[1003 Day13] >> g++ List1310.cpp -o List1310.exe
[1004 Day13] >> ./List1310.exe 
Enter the string: Symphony and Hoverboard Goo!!!!!
Here is's the buffer:  Symphony
-------------------------------------------------------------------------------
Two problems occur with the previous program
1) if the user enters more than 79 characters, cin writes past the end of the buffer. Second, if the user enters a space, cin thinks that it is the end of the string, and it stops writing to the buffer. To solve these problems, you must call a special method on cin, called get().
cin.get() takes 3 parameters:
	A) the buffer to fill.
	B) the maximum number of characters to get.
	C) the delimiter that terminates input.
The delimiter default to a newline character (cioe' quando premi invio considera che hai terminato di inserire la stringa).
------------------------------------------------------------------------------------- LISTING13.11 
// Filling an array with a maximum number of characters. 
//Listing 13.11 using cin.get()
  
#include <iostream>
using namespace std;
  
int main()
{
    char buffer[80]; // 
    cout << "Enter the string: ";
    cin.get(buffer, 79);       // get up to 79 or newline
	// nota come the buffer declared two lines above is passed in as the first argument.  The second argument is the maximum number of characters to get. In this case, it must be no greater than 79 to allow for the terminanting null. No need exists to provide a terminanting character because the default value of newline is sufficient. 
If you enter spaces, tabs, or other whitespace characters, they are assigned to the string. A newline character ends the input. Entering 79 characters also results in the end of the input. You can verify this by rerunning the listing  and trying to enter a string longer than 79 characters
    cout << "Here's the buffer:  " << buffer << endl;
    return 0;
}
------------------------------------------------------------------------------- 
OUTPUT
 [1006 Day13] >> ./List1311.exe 
Enter the string: Symphony and Hoverboard Goo!!!!!
Here's the buffer:  Symphony and Hoverboard Goo!!!!!    // ora si' che viene printata l'intera stringa e non si interrompe piu' dopo lo space.
------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> STRCPY() and >> STRNCPY methods  [pag435 jesse]
A number of existing functions are available in the C++ library for dealing with strings. C++ inherits many of these functions for dealing with C-style string from the C language. Among the many function provided are two for cpyoing one string into another: 
	- strcpy() copies the entire contents of one string into a designated buffer. 
	- strncpy() copies a number of characters fron one string to another. 
The following listing demonstrates the use of strcpy():
------------------------------------------------------------------------------- LISTING 13.12 start 
//Listing 13.12 Using strcpy()
  
#include <iostream>
#include <string.h>  // this header file string.h contains the prototype of the strcpy() function. strcpy() takes two character arrays
using namespace std;
  
int main()
{
   char String1[] = "CHRA California HoverBoard Racing Association";
   char String2[80];
  
   strcpy(String2,String1);  // strcpy takes two character arrays, destination followed by a source. 
               // String2 is the destination, String1 source 
               // cioe' strcpy(String2,String1); = copy String1 into String2
   cout << "String1: " << String1 << endl;
   cout << "String2: " << String2 << endl;
   return 0;
}
------------------------------------------------------------------------------- LISTING 13.12 end
OUTPUT
[1007 Day13] >> g++ List1312.cpp -o List1312.exe
[1008 Day13] >> ./List1312.exe 
String1: CHRA California HoverBoard Racing Association
String2: CHRA California HoverBoard Racing Association
-------------------------------------------------------------------
NOTE: you have to be careful suing the strcpy() function. If the source is larger than the destination, strcpy() overwrites past the end of the buffer. To protect against this, the Standard Library also includes  strncpy(). This variation takes a maximum number of characters to copy. strncpy() copies up to the first null character or the maximum number of characters specified into the destination buffer. The following 13.13 listing illustrates the use of strncpy()
--------------------------------------------------------------------------------- LISTING 13.13 start
//Listing 13.13 Using strncpy()
  
#include <iostream>
#include <string.h>
  
int main()
{
    const int MaxLength = 80;
    char String1[] = "CHRA California HoverBoard Racing Association";
    char String2[MaxLength+1];  // String2 is declared to takes MaxLength+1 characters. (the extra character is for the "\0" which strcopy() and strncopy() automatically add to the end of the string)
  
    strncpy(String2,String1,MaxLength);  // compared to strcpy(), strncpy() takes a third parameter : the maximum number of characters to copy
  
    std::cout << "String1: " << String1 << std::endl;
    std::cout << "String2: " << String2 << std::endl;
    return 0;
}
--------------------------------------------------------------------------------- LISTING 13.13 end
[1010 Day13] >> g++ List1313.cpp -o List1313.exe
[1011 Day13] >> ./List1313.exe
String1: CHRA California HoverBoard Racing Association
String2: CHRA California HoverBoard Racing Association
---------------------------------------------------------------------------------
NOTE : as with the integer aray shown in listing13.9 character arrays can be resized using heap allocation techniques and element-by-element copying. Most flexible string clases provided to C++ programmers use some variation on that technique to allow strings to grow and shrink or to insert or delete elements from the middle of the string. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> STRING CLASSES [pag 436 jesse]
 C++ inherited the null-terminated C-style string and the library of functions that includes strcpy() from C, but these functions aren't integrated into an object-oriented framework. The Standard Library includes a String class that provides an encapsulated set of data and functions for manipulating that data, as well as accessor functions so that the data itself is hidden from the clients of the String class. Before using this class, we will create a custom String class as an exercise in understanding the issues involved. At a minimum, your String class should overcome the basic limitations of character arrays. 
Like all arrays, character arrays are static. You define how large they are. They always take up that much room in memory, even if you don't need it all. Writing past the end of the array is disastrous. 
A good String class allocates only as much as memory as it needs and always enough to hold whater it is given. If it can't allocate enough memory, it should fail gracefully. 
The following 13.14 listing provides a first approximation of a String class.
NOTE: the following custom string is quite limited and is by no means complete, rboust, or ready for commercial use. That is fine, howeve, as the Standard Library does provide a complete and robust String class.
------------------------------------------------------------------------------ LISTING 13.14
	  //Listing 13.14 Using a String class

	#include <iostream>
	#include <string.h>
	using namespace std;

	// Rudimentary string class
	class String
	{
	  public:
		// constructors  NB: usiamo 3 constructors, to add flexibility to the class. 
		String();   // default constructor 
		String(const char *const); // the copy constructor	
		String(const String &); // constructor that takes an existing null-terminated (C-style) string
		~String();

		// overloaded operators
		char & operator[](unsigned short offset);
		char operator[](unsigned short offset) const;
		String operator+(const String&);
		void operator+=(const String&);
		String & operator= (const String &);

		// General accessors
		unsigned short GetLen()const { return itsLen; }
		const char * GetString() const { return itsString; }

	  private:
		String (unsigned short);         // private constructor
		char * itsString;
		unsigned short itsLen;
	};

	// default constructor creates string of 0 bytes
	String::String()
	{
	   itsString = new char[1];
	   itsString[0] = '\0';
	   itsLen=0;
	}

	// private (helper) constructor, used only by
	// class methods for creating a new string of
	// required size. Null filled.
	String::String(unsigned short len)
	{
	   itsString = new char[len+1];
	   for (unsigned short i = 0; i<=len; i++)
		  itsString[i] = '\0';
	   itsLen=len;
	}

	// Converts a character array to a String
	String::String(const char * const cString)
	{
	   itsLen = strlen(cString);
	   itsString = new char[itsLen+1];
	   for (unsigned short i = 0; i<itsLen; i++)
		  itsString[i] = cString[i];
	   itsString[itsLen]='\0';
	}

	// copy constructor
	String::String (const String & rhs)
	{
	   itsLen=rhs.GetLen();
	   itsString = new char[itsLen+1];
	   for (unsigned short i = 0; i<itsLen;i++)
		  itsString[i] = rhs[i];
	   itsString[itsLen] = '\0';
	}

	// destructor, frees allocated memory
	String::~String ()
	{
	   delete [] itsString;
	   itsLen = 0;
	}

	// operator equals, frees existing memory
	// then copies string and size
	String& String::operator=(const String & rhs)
	{
	   if (this == &rhs)
		  return *this;
	   delete [] itsString;
	   itsLen=rhs.GetLen();
	   itsString = new char[itsLen+1];
	   for (unsigned short i = 0; i<itsLen;i++)
		  itsString[i] = rhs[i];
	   itsString[itsLen] = '\0';
	   return *this;
	}

	//nonconstant offset operator, returns
	// reference to character so it can be
	// changed!
	char & String::operator[](unsigned short offset)
	{
	   if (offset > itsLen)
		  return itsString[itsLen-1];
	  else
		  return itsString[offset];
	}

	// constant offset operator for use
	// on const objects (see copy constructor!)
	char String::operator[](unsigned short offset) const
	{
	  if (offset > itsLen)
		  return itsString[itsLen-1];
	  else
		  return itsString[offset];
	}

	// creates a new string by adding current
	// string to rhs
	String String::operator+(const String& rhs)
	{
	  unsigned short  totalLen = itsLen + rhs.GetLen();
	  String temp(totalLen);
	  unsigned short i;
	  for ( i= 0; i<itsLen; i++)
		  temp[i] = itsString[i];
	  for (unsigned short j = 0; j<rhs.GetLen(); j++, i++)
		  temp[i] = rhs[j];
	  temp[totalLen]='\0';
	  return temp;
	}

	// changes current string, returns nothing
	void String::operator+=(const String& rhs)
	{
	  unsigned short rhsLen = rhs.GetLen();
	  unsigned short totalLen = itsLen + rhsLen;
	  String  temp(totalLen);
	  unsigned short i;
	  for (i = 0; i<itsLen; i++)
		  temp[i] = itsString[i];
	  for (unsigned short j = 0; j<rhs.GetLen(); j++, i++)
		  temp[i] = rhs[i-itsLen];
	  temp[totalLen]='\0';
	  *this = temp;
	}

	int main()
	{
	  String s1("initial test");
	  cout << "S1:\t" << s1.GetString() << endl;

	  char * temp = "Hello World";
	  s1 = temp;
	  cout << "S1:\t" << s1.GetString() << endl;

	  char tempTwo[20];
	  strcpy(tempTwo,"; nice to be here!");
	  s1 += tempTwo;
	  cout << "tempTwo:\t" << tempTwo << endl;
	  cout << "S1:\t" << s1.GetString() << endl;

	  cout << "S1[4]:\t" << s1[4] << endl;
	  s1[4]='x';
	  cout << "S1:\t" << s1.GetString() << endl;

	  cout << "S1[999]:\t" << s1[999] << endl;

	  String s2(" Another string");
	  String s3;
	  s3 = s1+s2;
	  cout << "S3:\t" << s3.GetString() << endl;

	  String s4;
	  s4 = "Why does this work?";
	  cout << "S4:\t" << s4.GetString() << endl;
	  return 0;
	}
------------------------------------------------------------------------------------- LISTING 13.14 end 
>> LINKED LISTS and OTHER STRUCTURES [pag444 jesse + pag875 jesse]
Arrays are much like Pyrex containers. They are great containers, but they are of a fixed size. If you pick a container that is too large, you waste space in your storage area. If you pick one that is too small, its contents spill all over and you have a big mess. 
One way to solve this problem is shown in listing 13.9. However, when you start using large arrays or when you want to ove, delete, or insert entries in the array, the number of allocations and deallocations can be expensive. 
One way to solve such a problem is with a linked list. A linked list is a data structure that consists of a small containers that are designed to link together as needed.  The idea is to write a class that holds one object of your data (such as one Cat or one Rectangle) and that can point at the next container. You create one container for each object that you need to store, and you chain them together as needed. 
ADDITIONAL DETAILS on linked list from pag875 jesse [and pag876 nice pictures of the linked lists forms you can create]
A linked list is a data structure that consists of small containers that are designed to link together as needed. The idea is to write a class that holds one objects of your data that can point at the next container of the same type. You create one container for each object that you need to store, and you chain them together as needed. The containers are called >> nodes. The first node in the list is called the head, and the last node in the list is called the tail. 
Lists come in three fundamentals forms. From simplest to most complex, they are : 
	- singly linked
	- doubly linked 
	- trees
In a singly linked list, each node points forward to the next one, but not backward. To find a particular node, start at the top and go from node to node, as in a treasure hunt ("the next node is under the sofa"). 
A doubly linked list enables you to move backward and forward in the chain. 
A tree is a complex structure built from nodes, each of which can point in two or more directions. 
The linked lists you create will consist of nodes. The node class itself will be abstract; we will use three subtypes of nodes to accomplish the work. 
1) There will be a head node whose job is to manage the head of the list, 
2) a tail node that manages the tail of the list, 
3) and zero or more internal nodes. The internal nodes will keep track of the actual data to be held in the list. 
Note that the data and the list are quite different. You can, in theory, save any type of data you like in a list. It isn't the data that is linked together, it is the node that holds the data. The driver program doesn't know about the nodes, it works with the list. The list, however does little work; it simply delegates to the nodes. 
The following ListE.1 shows the code: 
---------------------------------------------------------------------------------------------------------- LISTING E.1 Linked list STARTS
// ***********************************************
//    FILE:        Listing 13E.13
//    PURPOSE:    Demonstrate ilinked list
//    NOTES:
//
//  COPYRIGHT:  Copyright (C) 2000-04 Liberty Associates, Inc.
//                All Rights Reserved
//
// Demonstrates an object-oriented approach to
// linked lists. The list delegates to the node.
// The node is an abstract data type. Three types of
// nodes are used, head nodes, tail nodes and internal
// nodes. Only the internal nodes hold data.
//
// The Data class is created to serve as an object to
// hold in the linked list.
//
// ***********************************************
 
 
#include <iostream>
using namespace std;
 
enum { kIsSmaller, kIsLarger, kIsSame};  // this enumerated constant provides three constant values. These constants will be the result value returned by the Compare() method.  
 
// Data class to put into the linked list
// Any class in this linked list must support two methods:
// Show (displays the value) and 
// Compare (returns relative position)
class Data
{
  public:
    Data(int val):myValue(val){}   // il suo constructor
    ~Data(){}   // il destructor
	// e i suoi due methods Compare and Show
    int Compare(const Data &);
    void Show() { cout << myValue << endl; }
  private:
    int myValue;
};
 
// Compare is used to decide where in the list
// a particular object belongs.
int Data::Compare(const Data & theOtherData)
{
    if (myValue < theOtherData.myValue)
       return kIsSmaller;
    if (myValue > theOtherData.myValue)
       return kIsLarger;
    else
       return kIsSame;
}
 
// forward declarations
class Node;
class HeadNode;
class TailNode;
class InternalNode;
 
// ADT representing the node object in the list
// Every derived class must override Insert and Show
class Node
{
   public:
     Node(){}
     virtual ~Node(){}
     virtual Node * Insert(Data * theData)=0;
     virtual void Show() = 0;
   private:
};
 
// This is the node which holds the actual object
// In this case the object is of type Data
// We'll see how to make this more general when
// we cover templates
class InternalNode: public Node
{
   public:
     InternalNode(Data * theData, Node * next);
     ~InternalNode(){ delete myNext; delete myData; }
     virtual Node * Insert(Data * theData);
     // delegate!
     virtual void Show() { myData->Show(); myNext->Show(); }  
 
   private:
     Data * myData;  // the data itself
     Node * myNext;    // points to next node in the linked list
};
 
// All the constructor does is to initialize
InternalNode::InternalNode(Data * theData, Node * next):
myData(theData),myNext(next)
{
}
 
// the meat of the list
// When you put a new object into the list
// it is passed ot the node which figures out
// where it goes and inserts it into the list
Node * InternalNode::Insert(Data * theData)
{
 
    // is the new guy bigger or smaller than me?
    int result = myData->Compare(*theData);
 
 
    switch(result)
    {
    // by convention if it is the same as me it comes first
    case kIsSame:        // fall through
    case kIsLarger:    // new data comes before me
       {
          InternalNode * dataNode = new InternalNode(theData, this);
          return dataNode;
       }
 
    // it is bigger than I am so pass it on to the next
    // node and let HIM handle it.
    case kIsSmaller:
       myNext = myNext->Insert(theData);
       return this;
    }
    return this;  // appease MSC
}
 
 
// Tail node is just a sentinel
 
class TailNode : public Node
{
   public:
     TailNode(){}
     ~TailNode(){}
     virtual Node * Insert(Data * theData);
     virtual void Show() { }
 
   private:
 
};
 
// If data comes to me, it must be inserted before me
// as I am the tail and NOTHING comes after me
Node * TailNode::Insert(Data * theData)
{
    InternalNode * dataNode = new InternalNode(theData, this);
    return dataNode;
}
 
// Head node has no data, it just points
// to the very beginning of the list
class HeadNode : public Node
{
   public:
     HeadNode();
     ~HeadNode() { delete myNext; }
     virtual Node * Insert(Data * theData);
     virtual void Show() { myNext->Show(); }
   private:
     Node * myNext;
};
 
// As soon as the head is created
// it creates the tail
HeadNode::HeadNode()
{
 	myNext = new TailNode;
}
 
// Nothing comes before the head so just
// pass the data on to the next node
Node * HeadNode::Insert(Data * theData)
{
    myNext = myNext->Insert(theData);
    return this;
}
 
// I get all the credit and do none of the work
class LinkedList
{
   public:
     LinkedList();                                                     // when the linked list is created 
     ~LinkedList() { delete myHead; }            //          the constructor is called
     void Insert(Data * theData);                    //                    |
     void ShowAll() { myHead->Show(); }      //                   |
   private:                                                         //                   |
     HeadNode * myHead;                                //                  |
};                                                                       //                  |
                                                                         //                   |
// At birth, I create the head node                     //                |
// It creates the tail node                                        //           |
// So an empty list points to the head which      //              |
// points to the tail and has nothing between         //          |    here
LinkedList::LinkedList()         //   <--------------------------- /
{
    myHead = new HeadNode;
}
 
// Delegate, delegate, delegate
void LinkedList::Insert(Data * pData)
{
    myHead->Insert(pData);
}
 
// test driver program
int main()     // declaring the driver program
{
    Data * pData;   // a pointer to a Data object is declared
    int val;
    LinkedList ll;    // local linked list is defined 
 
    // ask the user to produce some values
    // put them in the list
    for (;;)
    {
       cout << "What value? (0 to stop): ";
       cin >> val;
       if (val == 0)
          break;
       pData = new Data(val);
       ll.Insert(pData);
    }
 
    // now walk the list and show the data
    ll.ShowAll();
    return 0;  // ll falls out of scope and is destroyed!
}

---------------------------------------------------------------------------------------------------------- LISTING E.1 Linked list ENDS
OUTPUT:
	[1016 AppE] >> g++ AppxE01.cpp -o AppxE01.exe
	[1017 AppE] >> ./AppxE01.exe 
	What value? (0 to stop): 2
	What value? (0 to stop): 5
	What value? (0 to stop): 8
	What value? (0 to stop): 5 
	What value? (0 to stop): 7
	What value? (0 to stop): 4
	What value? (0 to stop): 3
	What value? (0 to stop): 1
	What value? (0 to stop): 2
	What value? (0 to stop): 7
	What value? (0 to stop): 0
	1
	2
	2
	3
	4
	5
	5
	7
	7
	8
-----------------------------------------------------------------------------------------
LESSONS LEARNT
In a well designed object oriented program, no one is in charge. Each object does its own little job, and the net effect is a well-running machine. The linked list has the single job of maintaining the head node. The head node immediately passes new data to whatever it points to, without regard to what that might be. The tail node creates a new node and inserts it whenever it is handed data. It knows only one thing: if this came to me, it gets inserted right before me. 
Internal nodes are marginally more complicated; they ask their existing object to compare itself with tne new object. Depending on the result, they then insert or they just pass it along. Note that the internal node (InternalNode in the preceding listing) has no idea how to do the comparison; that is properly left to the object itself. All the internal node knows is to aks the objects to compare themselves and to expect one of three possible answers. Given one answer, it inserts; otherwise, it just passes it along, not knowing or caring where it will end up. 
NOTE: >> comment: in a real program the comments on functions are usually written into the class declaration
Terminology 
>> WALK a list / >> WALKING a list = walking a list means asking each node in the list for the next node, until you reach a node whose next pointer is NULL.
TRICK quando scrivi le functions methods di una classe, conviene scriverli in alphabetical (alpha beta gamma da li che deriva la parola alfa beto e' l'ordine delle lettere greche, avremmo dovuto aggiornare la parola a ABeto) order, as it makes finding the functions easier, for example : 
  class PartsList
  {
    public:
      PartsList();
      ~PartsList();
      // needs copy constructor and operator equals!
      Part*      Find(int & position, int PartNumber)  const;
      int        GetCount() const { return itsCount; }
      Part*      GetFirst() const;
      void       Insert(Part *);
      void       Iterate() const;
      Part*      operator[](int) const;
    private:
      PartNode * pHead;
      int itsCount;
  };

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
>> ARRAY CLASS CREATION [pag444 jesse]
Writing your own array class has many advantages over using the built-in arrays. For starters you can prevent array overruns. You might also consider making your array class dynamically sized. At creation, it might have only one member, growing as needed during the course of the program. 
You might also want to sort or otherwise order the members of the array. You might have a need for one or more of these powerful array variants:
	- ordered collection : each member is in sorted order
	- set : no member appears more than once
	- dictionary  : this uses matched paris in which one value acts as a key to retrieve the other value 
	-  sparse array: indices are permitted for a large set, but only those values actually added to the array consume memory. Thus, you can ask for SpaseArray[5] or SparseArray[200], but it is possible that memory is allocated only for a small number of entries. 
	- bag: an unordered collection that is added to and retrieved in indeterminate order. 
Q&A
- How do you declare a multidimentional array? / >> 3D array
[pag847 jesse] Write a set of subscripts for each dimension. For example, SomeArray[2] [3] [2] is a >> three dimensional array.  The first dimension has two elements, the second has three, and the third has two.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ARGUMENT COERCION : this is an important feature of function prototypes i.e, forcing  arguments to the appropriate types specified by the parameter declarations.


>> ARGUMENT PROMOTION : sometimes, argument values that do not correspond precisely to the parameter types in the function prototype can be converted by the compiler to the proper type before the function is called. These conversions occur as specified by C++ promotion rules. The promotion rules indicate the implicit conversions that the compiler can perform between fundamental types. For example an "int" can be converted to a "double" o viceversa a double can converted to an "int" (the fractional part will be truncated). 
- Promotion rules apply also in mixed-type expressions (per esempio un espression in cui molplichi un int con un double). The type of each value in a mixed-type expression is promoted to the "highest" type in the expression (esempio l'int verra' promosso a double se moltiplicato con delle variabili double). See figure 6.6 pag212 deitel trovi la lista degli aritmetic data types from "highest type" to "lowest type".

>> ARITHMETIC OPERATORS
+  -> addition
-  -> substraction
*  -> multiplication
/  -> division
%  -> modulo   (see modulo for further info)
NB: arithmetic operators are all binary operators, cioe' operators that take two operands. For example expression number1 + number2 contains the binary operator + and the two operands number1 and number2.
NB2: integer division (i.e. where both the numerator and the denominator are integers) yields an integer quotient; for example, the expression 7 / 4 evaluates 1 , expression 17 /3 evaluates 3. Any fractional part in integer division is truncated. 
NB3: the modulus operator % yields the remainder (= resto) after integer division. The modulus operator can be used only with integer operands. Examples
	 7 % 4 yields 3 (visto che 7/4 = 1 con resto 3)
	17 % 5 yields 2 (visto che 17/5 = 3 con resto 2)
Some interesting application of the modulus operator is determining whether one number is a multiple of another (a special case of this is determining whether a number is odd or even).
[pag49deitel]
------------------------------------------------------------------------------------------------------------------------------------------
>> ARITHMETIC OPERATORS [pag13 mike]
example :
// Expensive Calculator
// Demonstrates built-in arithmetic operators

#include <iostream>
using namespace std;

int main()
{
	cout << "7 + 3 = " << 7 + 3 << endl;  // visto e' proprio come un funnel (= imbuto or channel del bob di running man) cout << parte la stringa 7 + 3 = quindi il risultato dell'operatione 7 + 3 viene << fiuuuuuuu inviato e compare su schermo, quindi endl << fiuuuu anche lui inviato su schermo e ti manda a capo per le righe successive. 
	cout << "7 - 3 = " << 7 - 3 << endl;
	cout << "7 * 3 = " << 7 * 3 << endl;

	cout << "7 / 3 = " << 7 / 3 << endl;
	cout << "7.0 / 3.0 = " << 7.0 / 3.0 << endl;

	cout << "7 % 3 = " << 7 % 3 << endl;

	cout << "7 + 3 * 5 = " << 7 + 3 * 5 << endl;
	cout << "(7 + 3) * 5 = " << (7 + 3) * 5 << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ARITHMETIC OVERFLOW 
pag123 deitel

>> assign declare variable in a single statement / >> variable assignment and initialization 
	double rocketMainEngineTemperature = 6572.89; // in Celsius 
NOTE: although you can declare a varaible without assigning it a value, it's best to initialize a new variable with a starting value whenever you can. This make your code clearer, plus it eliminates the chance of accessing an uninitialized variable, which may contain any value. 

>> ASSIGNMENT  (=)
The  assignment operator assigns a value to a variable. 
ex1 
    sum = number1 + number2;
we like to read this statement as "sum gets the value of number1 and number2"
[deitel pag47]     
ex2
	a = b;
the statement assigns to variable a the variable contained in variable b. The value that was stored until this moment in a is not considered at all in this operation, in fact that value is lost. We only assign the value of b at the moment of the assignment operation. Therefore, a later change of b will not affect the value of a.
NB: rembember always right to left rule: the assignment operation always takes place from right to left, and never the other way.
NB2: hte part at the left of the assignment operator (=) is known as the lvalue (left value) and the right one as the rvalue (right value). 
NB3: the assignment operation can be used as the rvalue ofr another assignment operation. 
ex 
	a = + (b = 5);
is equivalent to:
	b =5;
	a =2 +b;     // perche' 2? non capisco piu' da dove l'avessi copiato
The following expression is also valid in C++:
	a = b = c = 5; 
it assigns 5 to all the three variables a,b and c
NB4: place spaces on either side of a binary operator. This makes the operator stand out and makes the program more readable. so a = b better to a=b.
---------------------------------------------------
>> assign string / >> string assignment [pag21 and pag 86 mike]
	string playItAgainSam = "AiharaAsaka";
qui assegniamo AiharaAsaka alla string variable playItAgainSam
>> assign character
	char playAgain; 
	playAgain = 'y';
you can assign a character to a variable of type char by surrounding the character with SINGLE quotes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> self assignment operator / >> assignment operator
[pag73 jesse]
how to add a value to a variable and then assign the result back into the same variable 
1) first way (long way)
	int myAge = 5;
	int temp;
	temp = myAge + 2;
	myAge = temp;
2) faster way
	int myAge = 5;
	myAge = myAge + 2;
you can read the above line as : add tw to the value in myAge and assign the result to myAge
3) hyper fast way
	int myAge = 5;
	myAge += 2;  // che si legge "myAge plus equals two"
this line uses the >> self assigned addition operator (+=).
	myAge += 2 la puoi leggere : myAge prima somma (+) a myAge, il valore 2, quindi (=) assegna il risultato della somma a myAge. 
Insomma per non farti confondere, basta che leggi l'espressione da sinistra verso destra 
	+=
prima sommi il valore che sta alla destra, quindi assegni il risultato della somma alla variabile che sta a sinistra. 
Detto in parole forbite: the self assigned addition operator adds the r-value to the l-value and then reassigns the result into the l-value. This operator is pronounced plus-equals
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> bool assignment / >> assign bool value [pag21 mike]
nomeBoolVariable = true;  // per settare la variabile a true
nomeBoolVariable = false; // per settare la variabile a false
NOTE from pag 37 mike: you can represent true and false with their corresponding keywords, true and false. Although the keywords true and false are handy, any expression or value can be interpreted as true or false too. 
- ANY NON ZERO VALUE CAN BE INTERPRETED AS TRUE
- while 0 CAN BE INTERPRETED as FALSE


>> ASSIGNMENT OPERATORS for abbreviating assignment expressions / ABBREVIATION ASSIGNMENT OPERATORS
[pag139deitel]
Any statement of the form 
	variable = variable operator expression;
in which the same variable appears on both sides of the assignment operator (e dove operator e' uno dei binary operators +, -, *, /, %) can be written in the form:
	variable operator= expression;
c += 3;    <-equivale a->   c = c + 3; //tag >> +=   = aggiungi 3 a "c" e assegna il risultato della somma a "c"  
c -= 3;    <-equivale a->   c = c - 3; //tag >> -=
c *= 3;    <-equivale a->   c = c * 3; //tag >> *=
c /= 3;    <-equivale a->   c = c / 3; //tag >> /=
c %= 3;    <-equivale a->   c = c % 3; //tag >> %=
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ASSIGNMENT OPERATOR COMBINED / >> COMBINED ASSIGNMENT OPERATOR / >> +=  [pag25 mike]
Ciccio spiega
+= leggilo da sinistra a destra e il significato diventa chiaro
ex a += 10 diventa   aggiungi 10 ad "a" e assegna il risultato della somma ad "a"  
Mike spiega
The += is called a combined assignment operator because it combines an arihmetic operation (addition in this case) with assignment. This operator is shorthand for saying "add whatever's on the right to what's on the left and assign the result back to what's on the left"
EXAMPLE
// Game Stats 2.0
// Demonstrates arithmetic operations with variables

#include <iostream>
using namespace std;

int main()
{
	unsigned int score = 5000;
	cout << "score: " << score << endl;

	//altering the value of a variable
	score = score + 100;
	cout << "score: " << score << endl;

	//combined assignment operator
	score += 100;
	cout << "score: " << score << endl;

	//increment operators
	int lives = 3;
	++lives;
	cout << "lives: "   << lives << endl;

	lives = 3;
	lives++;
	cout << "lives: "   << lives << endl;

	lives = 3;
	int bonus = ++lives * 10;
	cout << "lives, bonus = " << lives << ", " << bonus << endl;

	lives = 3;
	bonus = lives++ * 10;
	cout << "lives, bonus = " << lives << ", " << bonus << endl;

	//integer wrap around
	score = 4294967295;
	cout << "\nscore: " << score << endl;
	++score;
	cout << "score: "   << score << endl;

	return 0;
}

--------------------------------------------------------------------
[OUTPUT]
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
score: 5000
score: 5100
score: 5200
lives: 4
lives: 4
lives, bonus = 4, 40
lives, bonus = 4, 30

score: 4294967295
score: 0
///////////////////////////////////////////////////////////////////////////////////////////////

>> ASSIGNMENT OPERATOR disquisitio filosofico-platonica
[pag196 moo book] 
Assignment differs from the copy constructor in that assignment always involves obliterating an existing value (the left-hand side) and replacing it with a new value (the right hand side). When we make a copy, we are creatin a new object for the first time, so there is no preexisting object to deallocate.

>> assignment vs initialization [pag199 moo book]
The difference between assignment and initialization is one of the trickier aspects of learning C++ well. The fact that the = symbol can be involved in both initialization and assignment can make the distinction harder to grasp.
- Assignment always obliterates a previous value. 
- Initialization never does so. Rather, initialization involves creting a new object and giving it a value at the same time.
Examples
	string url_ch = "void Layer Machine";  // initialization 
	string y; // initialization [invoking the default constructor to create an empty string]
	y = url_ch; // assignment 
Riassumendo 
	Constructors always control initialization 
	The "operator=" member function always controls assignment.
////////////////////////////////////////////////////////////////////////////////////////////////// 


>> ++ / >> INCREMENT OPERATOR / >> DECREMENT OPERATOR [pag26 mike] [also pag74 jesse]
	engines = 3;
	// il seguente e' un esempio di  >> prefix increment operator
	++engines;  // engines assume cosi' il valore 4
Si potrebbe anche 
	engines = 3;
	// il seguente e' un esempio di  >> postfix increment operator
	engines++;  // engines assume cosi' il valore 4
In esempi come sopra dove you only increment a single variable, both operators produce the same final result. But in a more complex expression the results can be different. 
Example 
	engines = 3;
	int fluxCapacitorPower = ++engines * 10;
A) the prefix increment operator increment a variable before the evaluation of a larger expression involving the variable. ++engines * 10 is evaluated by first incrementing engines, and then mutiplying that result by 10. Therefore, the code is equivalent to 4 * 10 =>  fluxCapacitorPower = 40.
B) the  postfix increment operator increments a variable after the evaluation of a larger expression involving the variable. 
	engines = 3;
	int fluxCapacitorPower = engines++ * 10;
questa volta fluxCapacitorPower = 30, poiche' prima si moltiplica engines=3 * 10, e solo una volta che 30 e' assegnato a fluxCapacitorPower, allora la variabile engines viene incrementata da 3 a 4. Insomma mettere ++ dopo il nome della variabile, fa si' che prima si eseguisce l'istruzione usando il valore corrente della variabile, solo una volta che l'istruzione e' eseguita, allora la variabile viene incrementata.
>> decrement operator / >> --
C++ also defines the decrement operator, --. It works just like the increment operator, except it decrements a variable. It comes in the two flavors (prefix and postfix) as well. 
NOTE >> WRAP AROUND 
what happens when you increase an integer variable beyond its maximum value? It turns out you don't generate an error. Instead the value "wrap around" to the type's minimum value. Example 
	unsigned int score = 4294967295;  // gli attribuisci il valore massimo
	cout << "\nscore: " << score << endl;
	++score;  // se lo incrementi di uno op e' come se facessi ripartire da capo il tachigrafo e riparti da zero
	cout << "score: "   << score << endl;
Donera' come risultato "score 0", becomes 0 because the value wrapped around, much like a car odometer does when it goes beyond its maximum value. 
Decrementing an integer variable beyond its minimum value "wraps it around" to its maximum
NOTE [from pag 74 jesse]
lo statement 
	variable++;
e' equivalente a 
	variable += 1;
il quale e' a sua volta equivalente a 
	variable = variable + 1;
NOTE2 as you might have guessed, C++ got its name by applying the increment operator to the name of its predecessor language: C. The idea is that C++ is an incremental improvement over C. 
Insomma 
	C++
significa 
	C = C + 1
that is C++ is simply MORE!
NOTE3 pag75 jesse >> prefix vs >> postfixing 
You can both write 
	++myAge // prefix
or
	myAge++ // postfix
Both are valid but they have a different meaning. 
++myAge // prefix -> means: increment the value in the variable and then fetch or use it. 
myAge++ // postfix -> means: fetch or use the value and then increment the original variable. 
Example1 
	int x = 5;
	int a = ++x;
in questo caso prima x verra incrementato (5+1 = 6) and then il suo valore 6 viene assegnato ad "a". Quindi dopo i due precedenti statements, sia x che a sono uguali a 6. 
Example2
	int x = 5;
	int a = x++;
in questo caso prima si assegna il valore di x (5) ad "a", quindi si incrementa il valore di x (che diventa 6). Quindi dopo i due precedenti statements, x = 6 e a = 5.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ASSOCIATIVE CONTAINERS
[pag664 deitel]
The associative containers provide directo access to store and retrieve elements via keys (often called >> search keys). The four ordered associative containers are 
	multiset 
	set 
	multimap 
	map 
Each of these maintains its keys in sorted order. There are also four corresponding unordered associative containers.
	unordered_multiset
	unordered_set
	unordered_multimap
	unordered_map
that offer the most of the same capabilities as their ordered counterparts. The primary difference between the ordered and unordered associative containers is that the unordered ones do not maintain their keys in sorted order.
PERFORMANCE
The unordered associative containers might offer better performance for cases in which it's not necessary to maintain keys in sorted order.
	1) >> multiset = provide operations for manipulation sets of values where the values are the keys (there is not a separate value associated with each key). It allows duplicate keys [da li' il nome multi].
	2) >> set = provide operations for manipulation sets of values where the values are the keys (there is not a separate value associated with each key). It does not allow duplicate keys. [see voce "set" omonima per maggiori dettagli su libro deitel p668 ]
	3) >> multimap = provide operations for manipulating values associated with keys (these values are sometimes referred to as >> mapped values). A multimap allows duplicate keys with associated values to be stored.
	4) >> map = provide operations for manipulating values associated with keys (these values are sometimes referred to as >> mapped values). map allows only unique keys with associated values.
----------------------------------------------------
>> multiset associative container 
[pag 665 deitel]
the multiset ordered associative container (from header <set>) provides fast storage and retrieval of keys and allows duplicate keys. The element's ordering is determined by a so called >> comparator function object.
For example, in an integer multiset, elements can be sorted in ascending order by ordering the keys with comparator function object less<int>.
A multiset supports bidirectional iterators (but not random-access iterators). In if the order of the keys is not important, you can use unordered_multiset (header <unordered_set>) instead.
see example /home/dia/Deitel-Code_Examples/ch15/fig15_15/Fig15_15.cpp
here some extract [i numeri sulla sinitra indicano giusto il numero di linea]
	5 #include <set> // multiset class-template definition
line 14 creates a multiset of ints ordered in ascending order, using the function object less<int>. Ascending order is the default for a multiset, so less<int> can be omitted.
	14    multiset< int, less< int > > intMultiset; // multiset of ints
NOTE lo spazio tra gli > > dopo int era obbligatorio nei C++98, non e' piu' necessario a partire da C+11, dove anche se scrivessi 
	multiset<int, less< int >> intMultiset;
compila correttamente senza problemi.
- Linea 17 uses function count (abialable to all associative containers) to count the number of occurrences of the value 15 currently in the multiset:  	
	17    cout << "There are currently " << intMultiset.count( 15 )
	18       << " values of 15 in the multiset\n";
- Lines 20 -21 use one of the several overloaded versions of function insert to add the value 15 to the multiset twice. 
	20    intMultiset.insert( 15 ); // insert 15 in intMultiset
	21    intMultiset.insert( 15 ); // insert 15 in intMultiset
A second version of insert takes 
	> an iterator 
	> a value as argument and begins the search for the insertion point from the iterator position specified.
A third versio of insert takes 
	> two iterators as arguments taht specify a range of values to add to the mutiset from another container. 
- Line 26 uses function find (available to all associative containers) to locate the value 15 in the mutiset. Function find returns an iterator or a const_iterator pointing to the location at which the value is found. 
	25    // find 15 in intMultiset; find returns iterator
	26    auto result = intMultiset.find( 15 );
If the value is not found, find returns an iteartor or a const_iterator equal to the value returned by calling end on the container.
	31    // find 20 in intMultiset; find returns iterator
	32    result = intMultiset.find( 20 );
- Line 38 Inserting elements of another container into a multiset 
Line 38 uses function insert to insert the elements of array a into the mutiset. In line 40 the copy algorithm copies the elements of the multiset to the standard output in ascending order.
	37    // insert elements of array a into intMultiset
	38    intMultiset.insert( a.cbegin(), a.cend() );
	39    cout << "\nAfter insert, intMultiset contains:\n";
	40    copy( intMultiset.cbegin(), intMultiset.cend(), output );
- Line 44 and 45 use functions lower_bound and upper_bound (available in all associative containers) to locate the earliest occurrence of the value 22 in the multiset and the element after the last occurrence of the value 22 in the multiset. Both functions return iterators or const_iterators pointing to the appropriate location or the iterator returned by end if the value is not in the multiset.
	42    // determine lower and upper bound of 22 in intMultiset
	43    cout << "\n\nLower bound of 22: "
	44       << *( intMultiset.lower_bound( 22 ) );
	45    cout << "\nUpper bound of 22: " << *( intMultiset.upper_bound( 22 ) );
- line 49 
>> equal_range [pag 667 deitel]
 47    // use equal_range to determine lower and upper bound 
 48    // of 22 in intMultiset
 49    auto p = intMultiset.equal_range( 22 );
The multiset function equal_range returns a pair containing the results of calling both lower_bound and upper_bound. Type pair contains tow public data members called first and second. Line 49 uses function euqal_range to determine the lower_bound and upper_bound of 22 in the multiset.
>> tuple [pag668 deitel]
C++ also includes class template tuple, which is similar to pair, but can hold any number of items of various types. As C++11, class template tuple has been reimplemented using >> variadic templates (= templates that can receive a variable number of arguments)
---------------------------------------
>> set [pag668 deitel] 
(interessante: con questo container a partire da un array contenente doppioni puoi eliminare tutti gli elementi ripetuti due volte)
the set asociative container (from header <set>) is used for afats storage and retrieval of unique keys. The implementation of a set is identical to that of a mutiset, except that a set must have unique keys. Therefore, if an attempt is made to insert a duplicate key into a set, the duplicate is IGNORED.
A set supports bidirectional iterators (but not radom-access iterators). If the order of the keys is not important, you can use unordered_set (header <unordered_set>) instead. 
See example: /home/dia/Deitel-Code_Examples/ch15/fig15_16/Fig15_16.cpp
Extract 
	 14    set< double, less< double > > doubleSet( a.begin(), a.end() );
line14 creates a set of doubles ordered in ascending order, using the function object less<double>. The constructor cal takes all the elements in array a and inserts them into  the set.
	 18    copy( doubleSet.begin(), doubleSet.end(), output );
line18 uses algorithm copy to output the contents of the set. Notice that the value 2.1 which appeared twice in array appears only once in doubleSet.
----------------------------------------
>> multimap associative container [pag669 deitel]
The multimap assiciative container is used for fast storage and retrieval of keys and associated values (often called key value pairs). Many of the funcions used with multisets and sets are also used with multimaps and maps. The lements of multimaps and maps are pairs of keys and values instead of individual values.
When inserting into a multimap or map, a pair object that contains the key and the value is used. 
The ordering of the keys is determined by a >> comparator function object. 
(Ciccio nota: questa tipologia di container mi sembra che sia utilizzata nei sistemi di carte bancarie ATM, itiaf da studiarsi meglio per giocare un po di crack ai sistemi bancari internet)
For example: in a multimap that uses integers as the key type, keys can be sorted in ascending order by ordering them with comparator function object less<int>.
Duplicate keys are allowed in a multimap, so multiple values can be associated with a single key. This is called a >> one to many relationship (>> one-to-many relationship). For example, in a credit card transaction processing system (wow Ciccio ci avevi ragione che fiuto!!!) one credit-card account can have many associated transactions; in a university, one student can take many courses, and one professor can teach many students; in the military, one rank (like "private") has many people. A multimap supports bidirectional iterators, but not random-access iterators. Header <map> must be included to use class multimap. If the order of the keys is not important, you can use unordered_multimap (header <unordered_map>) instead.
Example see /home/dia/Deitel-Code_Examples/ch15/fig15_17/Fig15_17.cpp
eccoti qui alcuni estratti di linee notevoli del sopra citato programma:
  9    multimap< int, double, less< int > > pairs; // create multimap
line 0 creates a multimap in which the key type is int, the type of a key's associated value is double and the elements are ordered in ascending order. 
 14    // insert two value_type objects in pairs
 15    pairs.insert( make_pair( 15, 2.7 ) );
 16    pairs.insert( make_pair( 15, 99.3 ) );
Line 15 uses function inset to add a new key-value pair to the mutimap. The expression make_pair(15, 2.7) creates a pair object in which first is the key (15) of type int and second is the value (2.7) of type double. Function make_pair automatically uses the types that you specified for the keys and values in the multimap's declaration (line 9). As of C++11, you can use list initialization ofr pair bojects, so line 15 can be simplified as  
	pairs.insert ( {15, 2.7} );
similarly C++11 enables you to use list initialization to initalize an object being returned from a function. For example, if a function returns a pair containing an int and a double, you could write:
	return {15, 2.7};
 30    // walk through elements of pairs
 31    for ( auto mapItem : pairs )
 32       cout << mapItem.first << '\t' << mapItem.second << '\n';
line 31-32: the range based for statement in lines 31-32 outputs the contents of the multimap, including both keys and values. We infer the type of the loop's control variable (a pair containing an int key and a double value) with keyword auto. Line 32 accesses the members of the current pair in each element of the multimap. Notice in the output that the keys appear in ascending order.
--------------------------------------------------------------------------------------------------
>> map associative container [pag 671 deitel] [also chapter 7 mooo book pag 124]
The map associative container (from header <map>) performs fast storage and retrival of unique keys and associated values. Duplicate keys are not allowed (a single value can be associated with each key). This is called a >> one-to-one mapping. 
For example, a commercial cargo corporation that uses unique spaceships numbers, such as 1071, 1072, 1073 may have a map that associates spaceship numbers with their propulsion system maximum thrust 2000, 5000, 8000 [unita espresse in MegaTons] respectively.
With a map you specify the key and get back the asociated data quickly. Providing the key in a map's subscript operator [] locates the value associated with that key in th map. Insertions and deletions can be made anywhere in a map. If the order of the keys is not important, you can use unordered_map (header <unordered_map>) instead.
Example see /home/dia/Deitel-Code_Examples/ch15/fig15_18/Fig15_18.cpp
Qui ti scrivo un poco di extract delle lines piu' notevoli:
	  9    map< int, double, less< int > > pairs;
	 10 
	 11    // insert eight value_type objects in pairs
	 12    pairs.insert( make_pair( 15, 2.7 ) );
	 13    pairs.insert( make_pair( 30, 111.11 ) );
	 14    pairs.insert( make_pair( 5, 1010.1 ) );
	 15    pairs.insert( make_pair( 10, 22.22 ) );
	 16    pairs.insert( make_pair( 25, 33.333 ) );
	 17    pairs.insert( make_pair( 5, 77.54 ) ); // dup ignored
	 18    pairs.insert( make_pair( 20, 9.345 ) );
	 ....
	 27    pairs[ 25 ] = 9999.99; // use subscripting to change value for key 25
	 28    pairs[ 40 ] = 8765.43; // use subscripting to insert value for key 40
Lines 27-28 use the subscript operator of class map. When the subscript is a key that's already in the map (line27) the operator returns a reference to the associated value. When the subscript is a key that's not in the map (line 18) the operator inserts the key in the map and returns a reference that can be used to  associate a value with that key. Line 27 replaces the value for the key 25 (previously 33.333 as specified in line 16) with a new value 9999.99. Line 28 inserts a new key - value pair in the map (called creating an association)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> associative container vs >> sequential containers [pag123 moo book]
Associative containers automatically arrange their elements into a sequence that depends on the values of the elements themselves, rather than the sequence in which we inserted them. Moreover, associative containers exploit this ordering to let us locate particular elements much more quickly than do the sequential containers, without our having to keep the container ordered by ourselves. 
Associative containers offer effcient ways to find an element that contains a particular value, and might contain additional information as well. The part of each container element that we can use for these efficient searches is called a key. For example, if we were keeping track of information about students, we might use the student's name as the key, so that we could find students efficiently by name.
	The most common kind of associative data structure is one that stores key (value pairs associating a value with each key), and that lets us insert and retrieve elements quickly based on their keys). When we put a particular key, (value pair into the data structure), that key will continue to be associated with the same value until we delete the pair. Such a data structure is called >> associative arrays (many languanges supports associative arrays like AWK, Perl, Sobol).
In C++ associative arrays are part of the library. The most common kind of associative array in C++ is called a map, and analogous with other containers, it is defined in the <map> header.
In many ways maps behave like vectors. One fundamental difference is that the index of map need not be an integer; it can be a string, or any other type with values that we can compare so as to keep them ordered.
Maps are used to write compact and efficient look-up intensive programs.
------------------------------------------------------------------------ EXAMPLE countn the number of times that each distinct word occurs in the input. 
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/wc.cc]
	#include <iostream>
	#include <map>
	#include <string>
	
	using std::cin;
	using std::cout;
	using std::endl;
	using std::map;
	using std::string;
	
	int main()
	{
		string s;
		map<string, int> counters; // store each word and an associated counter; we must specify the type of the objects that the map will hold [in questo caso "string"] and the type of the key ["int"]. Therefore here counter is defined as a map that holds values of type "int" that are associated with keys of type "string". We often speak of such a container as "a map from string to int", because we can use the map by giving it a string as key, and getting back the associated int data.
		// read the input, keeping track of each word and how often we see it
		while (cin >> s)
			++counters[s];
		// write the words and associated counts
	#ifdef _MSC_VER
		for (std::map<string, int>::const_iterator it = counters.begin();
	#else
		for (map<string, int>::const_iterator it = counters.begin();
	#endif
		     it != counters.end(); ++it) {
			cout << it->first << "\t" << it->second << endl;
/* 
NOTE: la linea precedente usa two elements which are named "first" and "second". These two elements are hold by a simple data structure called ">> pair", companion library of the map container. Each element in a map is really a pair, with a first member that contains the key and a second member that contains the associated value. When we dereference a map iterator, we obtain a value that is of the pair type associated with the map.
The "pair" class can hold values of various types, so when we create a pair, we say what the types of the first and second data members should be. For a map that has a key of type K and a value of Type V, the associated pair type is pair<const K, V> Because the pair key is const, we are prevented from changing the value of an element's key. If the key were not const, we might implicitly change the element's position within the map. Accordingly, the key is always const, so that if we dereference a map<string, int> iterator, we get a pair<const string, int>. Thus, it->first is the current element's key, and it->second is the associated value.  
*/
		}
		return 0;
	}
------------------------------------------------------------------------ END EXAMPLE 
NOTE: >> word counting / >> count how often a word appears in a text / >> line number : get all the line numbers on which a certain word occurred : see example pag 126 moo book 
-------------------------------------------------------------------------- here the code
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/xref.cc]
	#include <map>
	#include <iostream>
	#include <string>
	#include <vector>
	
	#include "split.h"
	
	using std::cin;            using std::cout;
	using std::endl;           using std::getline;
	using std::istream;        using std::string;
	using std::vector;         using std::map;
	
	// find all the lines that refer to each word in the input
	map<string, vector<int> >
		xref(istream& in,
		     vector<string> find_words(const string&) = split)
	{
		string line;
		int line_number = 0;
		map<string, vector<int> > ret;
	
		// read the next line
		while (getline(in, line)) {
			++line_number;
	
			// break the input line into words
			vector<string> words = find_words(line);
	
			// remember that each word occurs on the current line
	#ifdef _MSC_VER
			for (std::vector<string>::const_iterator it = words.begin();
	#else
			for (vector<string>::const_iterator it = words.begin();
	#endif
			     it != words.end(); ++it)
				ret[*it].push_back(line_number);
		}
		return ret;
	}
	
	int main()
	{
		// call `xref' using `split' by default
		map<string, vector<int> > ret = xref(cin);
	
		// write the results
	#ifdef _MSC_VER
		for (std::map<string, vector<int> >::const_iterator it = ret.begin();
	#else
		for (map<string, vector<int> >::const_iterator it = ret.begin();
	#endif
		     it != ret.end(); ++it) {
			// write the word
			cout << it->first << " occurs on line(s): ";
	
			// followed by one or more line numbers
	#ifdef _MSC_VER
			std::vector<int>::const_iterator line_it = it->second.begin();
	#else
			vector<int>::const_iterator line_it = it->second.begin();
	#endif
			cout << *line_it;	// write the first line number
	
			++line_it;
			// write the rest of the line numbers, if any
			while (line_it != it->second.end()) {
				cout << ", " << *line_it;
				++line_it;
			}
			// write a new line to separate each word from the next
			cout << endl;
		}
	
		return 0;
	}
-------------------------------------------------------------------------- End of Code
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> map vs >> hash table / >> associative containers vs hash table [pag136 moo  book]

>> map resume  pag 137 moo book 
map<K, V> is an associative array with key type K and value type V. The elements of a map are key (value pairs), which are maintained in key order to allow efficient access of elements by key. The iterators on maps are bidirectional. Dereferencing a map itertor yields a value of type pair<const K, V>.
Note:
	pair<K, V> is a simple type whose objects hold pairs of values. Access to these data values is through their names, "first" and "second" respectively. 
MAP OPERATIONS:
1) map<K, V> m;		creates a new empty ak, with keys of type const K and values of type V. 
2) map<K, V> m(cmp);		create a anew empty map with keys of type const K and values of type V, that uses the predicate cmp to determine the order of the elements.
3) m[k]		indexes the map using a key, k, of type K, and return a nlvalue of type V. If there is no entry for the given key, a new value initialized element is created and inserted into the map with this key. Because using [] to access a map might create a new element, [] is not allowed on a const map. 
4) m.begin()    m.end()
		Return iterators that can be used to access the element of a map. Note that dereferencing one of thiese iterators yeilds a key (value pair) not just a value. 
5) m.find(k)	returns an iterator referring t the element with key k, or m.end() if no such element exists.	 
For a map<K, V> and an associated iterator p, the following apply:
p->first	Yields an lvalue of type const K that is the key for the element p deonotes.
p->second   Yields an lvalue of type V that is the value part of the element that p denotes.
>> VALUE INITIALIZATION : accessing a "map" element that doesn't yet exist creates an element with a value of V(), where V is the type of the values stored in the map. Such an expression is said to be value-initialized. 

>> 
////////////////////////////////////////////////////////////////////////////////////////

>> SENTENCE GENERATION using "map" [pag 130 moo book]
/////////////////////////////////////////////////////////////////////////////////////////////////
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter07/grammar.cc]
	#ifdef _MSC_VER
	#pragma warning(disable:4503)      // `silence compiler complaints about generated names being too long'
	#endif
	
	#include <algorithm>
	#include <cstdlib>
	#include <iostream>
	#include <map>
	#include <stdexcept>
	#include <string>
	#include <vector>
	
	#include "split.h"
	#include <time.h>
	
	using std::istream;           using std::cin;
	using std::copy;              using std::cout;
	using std::endl;              using std::find;
	using std::getline;           using std::logic_error;
	using std::map;               using std::string;
	using std::vector;            using std::domain_error;
	using std::rand;
	
	typedef vector<string> Rule;
	typedef vector<Rule> Rule_collection;
	typedef map<string, Rule_collection> Grammar;
	
	// read a grammar from a given input stream
	Grammar read_grammar(istream& in)
	{
		Grammar ret;
		string line;
	
		// read the input
		while (getline(in, line)) {
	
			// `split' the input into words
			vector<string> entry = split(line);
	
			if (!entry.empty())
				// use the category to store the associated rule
				ret[entry[0]].push_back(
					Rule(entry.begin() + 1, entry.end()));
		}
		return ret;
	}
	
	void gen_aux(const Grammar&, const string&, vector<string>&);
	
	int nrand(int);
	
	vector<string> gen_sentence(const Grammar& g)
	{
		vector<string> ret;
		gen_aux(g, "<sentence>", ret);
		return ret;
	}
	
	bool bracketed(const string& s)
	{
		return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
	}
	
	void
	gen_aux(const Grammar& g, const string& word, vector<string>& ret)
	{
	
		if (!bracketed(word)) {
			ret.push_back(word);
		} else {
			// locate the rule that corresponds to `word'
			Grammar::const_iterator it = g.find(word);
			if (it == g.end())
				throw logic_error("empty rule");
	
			// fetch the set of possible rules
			const Rule_collection& c = it->second;
	
			// from which we select one at random
			const Rule& r = c[nrand(c.size())];
	
			// recursively expand the selected rule  / >> recursive call example see comments pag 134 moo book
			for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
				gen_aux(g, *i, ret);  // ecco qui la recursive call. Siamo all'interno della funzione gen_aux e in questa linea la funzione chiama se stessa "gen_aux" e funziona! Sembra quasi una sorta di codice frattale!
		}
	}
	
	int main()
	{
		// generate the sentence
		vector<string> sentence = gen_sentence(read_grammar(cin));
	
		// write the first word, if any
	#ifdef _MSC_VER
		std::vector<string>::const_iterator it = sentence.begin();
	#else
		vector<string>::const_iterator it = sentence.begin();
	#endif
		if (!sentence.empty()) {
			cout << *it;
			++it;
		}
	
		// write the rest of the words, each preceded by a space
		while (it != sentence.end()) {
			cout << " " << *it;
			++it;
		}
	
		cout << endl;
		return 0;
	}
	
	// return a random integer in the range `[0,' `n)'
	int nrand(int n)  // >> random : this function is used to select a random element from a vector
	{
		if (n <= 0 || n > RAND_MAX)
			throw domain_error("Argument to nrand is out of range");
	
		const int bucket_size = RAND_MAX / n;
		int r;
	
		do r = rand() / bucket_size;
		while (r >= n);
	
		return r;
	}
	

/////////////////////////////////////////////////////////////////////////////////////////////////

>> at 
[pag435 deitel]
member function of the string class. "at" return  the character at a specific index  in a string (after checking that the index is in range)
example from : /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
   // test subscript out of range with string member function "at"
   try                                                               
   {                                                                 
      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
   } // end try 
NOTE [from pag348 deitel]: member function "at" provide bounds checking, cioe' it throws an exception if its argument is an invalid sbuscript. If the subscript is valid, function at returns the character at thespecified location as a modifiable lvalue or an nonmodifiable lvalue (e.g., a const reference), depending on the context in which the call appears. 
//////////////////////////////////////////////////////////////////

>> AUTO keyword 
[pag 306 deitel e esempio pratico pag305deitel start tag]
C++11 "auto" keyword tells the compiler to infer (determine) a variable's data type based on the variable's initializer value. 
- EXAMPLE di auto in action: i due seguenti nested for sono equivalenti, usando auto la scrittura si semplifica
[pag306deitel]
Sommare tutti gli elementi di un 2D array (insomma di un tensore 2 o la nostra tradizionale matrice)
	total = 0;
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			total += a[ row ][ column ];
usando il C++11 "auto" keyword il precedente nested loop puo' essere riscritto come 
	total = 0;
	for ( auto row : a ) // for each row
		for ( auto column : row ) // for each column in row 
			total += column;


>> BBBBBBB

>> branch of an if statement cioe' ciascuno dei blocchi in cui si entra a seconda che la condizione sia vera o meno, branch visto che il flusso logico si branch si ramifica a seconda delle condizioni settate
[pag26 moo book]

>> BREAKPOINT in visual studio 
1) clicca di sinistro sul numero di riga che sta scritto accanto alla riga in cui vuoi mettere il toogle. La riga verra' cosi' evidenziata in azzurro. 
[cioe' se vuoi breakare alla linea "21" clicca su quel 21 in modo che vedrai la riga colorarsi si azzurro]
2) menu DEBUG -> Toggle Breakpoint [or simply press F9] [or even more simply premi giusto nella striscia grigia accanto alla linea in cui vuoi mettere il breakpoint]
3) starta il debug con debug menu -> debug (or press F5)
4) press CONTINUE per far continuare il programma oltre il breakpoint
Nota come in basso nella finestrella Call Stack vedi la lista di chiamate delle funzioni, e a sinistra nella finestrella Autos vedi il valore che il parametro di input della funziona sta assumendo
[Ciccio courtesy]

> BUILT IN TYPE / >> BUILT-IN TYPE [pag106 mike]: built int types are types that are always available in any C++ program (senza bisogno di usare alcun include), per esempio int and char are built in types. On the contrary "string" type, on the other hand, is not a built-in type. It's defined as a part of the standard library in the file string. 
-----------------------
>> BUILT-IN TYPE vs >> CLASS TYPES [pag155 moo book]
C++ has two kinds of types: built-in types and class types. Built-in types, so called because they are defined as part of the core language, include char, int and double. The types used from the library, such as "string", "vector", "istream" are all class types.
At its most fundamental level, a class type is a mechanism for combining related data values into a data structure, so that we can treat that data structure as a single entity.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CLASS [pag140 jesse]
A class is just a collection of variables (often of different types) combined with a set of related functions. 
For example you can think of levitational hoverboard like a collection of bearing, board, power generator, visibility lights and so forth. Another way is to think avout what a hoverboard can do: it can levitate, speed up, climbing, slow down, landing, and so forth. A class enables you to encapsulate or bundle, these various parts and various functions into one collection, which is called an object. 
Encapsulating everthing you know about an hoverboard into one class has a number of advantages for a programmer. Everything is in one place, which makes it easy to refer to, copy, and call on functions that manipulate data. Likewise, >> clients of your class (= the parts of the program that use your class) can use your object without worrying about what is in it or how it works. 
A class can consist of any combination of the variable types and also other class types. The variables in the class are referred to as the >> member variables or >> data members. A HoverBoard class might have member variables representing the gyroscope, flux capacitor, anticollition system and so forth. 
Member variable also known as data members, are the variables in your class. Member variables are part of you class just as the board and the power unit are part of your hoverboard. 
A calls cal also contain functions called >> member functions or methods. Member functions are as much a part of your class as the member variables. They determine what your class can do. 
The member functions in the class typically manipulate the member variables. For example, methods of the HoverBoard class might include Start() and Levitate(). A Cat class might have data members that represent age and weight; its methods might include Sleep(), Meow() and ChaseMice().

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> BINARY ASCII CONVERTER
[from NEC-radar-antenna.html
procediamo allora in questo modo: aggiungiamo la creazione di un file in parallelo a quello binario gia' creato :
void NasFEMReader::WriteGeoFile( )
{
 ofstream output;
 // ciccio
 ofstream ciccioFile;
 string name = fileName+".txt";
 output.open(name.c_str());
 ciccioFile.open ("ciccio.txt");   // OK il file viene correttamente creato
 ciccioFile << "Ciao Ciccio stiamo testando se si riesce a far ballare i binary in ASCII. \n";
NOTE: OK siamo riusciti a comprendere il perche' in notepad2 ci venivano all'inizio quella serie di NULNUL
E' dovuto al fatto che al posto di usare delle stringe si usano dei character sequences da 80 caratteri:
char Description[80] ="Nastran To Ensight Conversion";
Quindi una volta che i primi 30 caratteri sono occupati da "Nastran To Ensight Conversion" i restanti 50 restano vuoti, per questo sono occupati da NUL, ed in effetti quando ne fai un copy and paste da notepad2 a bluegriffon e come se non vi fossero, non creano alcuno spazio.
creiamo un file in parallelo a quello binario
 output.write((char*) &Npoints ,sizeof(int));   // questa e' la riga originale che crea il tutto in binario
 ciccioFile << "Total points in Nastran file: " << Npoints << " \n";   // questa e' la nostra riga aggiuntiva che printa in ASCII il numero di nodi all'interno del ciccioFile ottenendo :
    Total points in Nastran file: 3833
[sfortunatamente i file originali sono stati portati via da una tempesta di caos biluniano, spero che gli appunti qui sopra ti possano essere di aiuto a navigare oltre l'oceano del disordine
OK te l'ho ritrovato te l'ho salvato in :
G:\Cplusplus-code\NEC-FEAMapper\mapper-with-ASCII-output-binaryASCII-converter]
//////////////////////////////////////////////////////////////////////////////////////////// porzione completa della conversione binary ascii
void NasFEMReader::WriteGeoFile( )
{
 ofstream output;
 ofstream ciccioFile;
 string name = fileName+".txt";
 output.open(name.c_str());
 ciccioFile.open ("outputASCII.txt");   // OK il file viene correttamente creato
 //ciccioFile << "Ciao Ciccio stiamo testando se si riesce a far ballare i binary in ASCII. \n";
 char Title[80] ="Eri and Yui Queens of Prairies";
 //string TitleCiccio = "Eri and Yui Queens of Prairies. \n";
 string TitleCiccio = "BINARY ASCII CONVERTER \n";
 char Description[80] ="Nastran To Ensight Conversion";
 string DescriptionCiccio = "Nastran To Ensight Conversion. \n";
 char Company[80] ="Nihon ESI";
 string CompanyCiccio = "Nihon ESI \n";
 char  NodeId[80] = "node id given";// ode id <off/given/assign/ignore>
 string NodeIdCiccio = "node id given \n";
 char   EleId[80] = "element id given";// ode id <off/given/assign/ignore>
 string EleIdCiccio = "element id given \n";
 char   Gen[80] ="part";
 string GenCiccio = "part \n";
 int  PartId;
 output.write(Title, 80);
 ciccioFile << TitleCiccio;
 output.write(Description,80);
 ciccioFile << DescriptionCiccio;
 // ciccio
 // cout<<"Ciccio why is still binary??"<<endl;  // ok compare!
 //
 output.write(Company,80);
 ciccioFile << CompanyCiccio;
 output.write(NodeId,80);
 ciccioFile << NodeIdCiccio;
 output.write(EleId,80);
 ciccioFile << EleIdCiccio;
 output.write(Gen,80);
 ciccioFile << GenCiccio;
 PartId =1;
 char Des[80]="NewPart";
 string DesCiccio = "NewPart  ";
 output.write((char*)&PartId,sizeof(int));
 output.write(Des,80);
 // le due righe precedenti se scritti in normale formato txt sono riassumibili con 
 ciccioFile << DesCiccio << PartId << " \n";
 memcpy(Des,"coordinates",80);
 output.write(Des,80); 
 //ciccioFile << "Coordinates \n";
 //total points in Nastran file
 output.write((char*) &Npoints ,sizeof(int));
 ciccioFile << "Total points in Nastran file: " << Npoints << " \n";
 map<unsigned int, DefVarType* > ::iterator itC ;// =  NodeCorrdInfo;

 ciccioFile << "Node ID ---------------- next \n"; 

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     int a = (*itC).first;
     a =  MapNodeIdToConsecutive.find((*itC).first)->second; //giving consecutive  node id as ensight does not read missing id
     output.write((char*)&a,sizeof(int));
	 ciccioFile << a << " \n";
 }

ciccioFile << "X Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float x = (*itC).second[0];
    // float theta = (*itC).second[1];
 //    x= x* cos(theta*PI/180.0); 
     output.write((char*)&x,sizeof(float));
	 ciccioFile << x << " \n";
 }

ciccioFile << "Y Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float y = (*itC).second[1];
   
  //   float r = (*itC).second[0];
   //  y = r*sin(y*PI/180.0);


     output.write((char*)&y,sizeof(float));
	 ciccioFile << y << " \n";

 }

 ciccioFile << "Z Coordinates ---------------- next \n";

 for(itC=NodeCorrdInfo.begin();itC!=NodeCorrdInfo.end();itC++)
 {
     float z = (*itC).second[2];
     output.write((char*)&z,sizeof(float));
	 ciccioFile << z << " \n";
 }
 memcpy(Des,"quad4",80);
 output.write(Des,80);
 ciccioFile << "QUAD4 ---------------- next \n"; 
 map<unsigned int,vector<Ele* > > ::iterator  it1;
 //map<int ,DefVarType*  > ElementCGInfo;
   //*it1.first will give part id write 
 //check for null element in vector and write element id 
//writing only 1 part  
 
   output.write((char*)&NumberOfQuadElement,sizeof(int));
   ciccioFile << "Number of Quad Elements \n" << NumberOfQuadElement << "\n";
   ciccioFile << "QUAD4 contID ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     //number Quad of element 
     
     for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) &&  ((*it1).second[i]->NumberOfNode==4)) 
       {
          int ele  = (*it1).second[i]->EleId;
          int contId = MapEleIdToConsecutive.find(ele)->second;
          output.write((char*)&contId,sizeof(int));
		  ciccioFile << contId << " \n";
       }
     }

}
 ciccioFile << "QUAD4 Part element info ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
    for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) && ((*it1).second[i]->NumberOfNode==4))
       {
         for(int j=0;j<4;j++) 
         {
    	       int nodeId  = (*it1).second[i]->NodeId[j];
                nodeId = MapNodeIdToConsecutive.find(nodeId)->second; 
               output.write((char*)&nodeId,sizeof(int));
			   ciccioFile << nodeId << " \n";
        }
       } 
     }
} 
 memcpy(Des,"tria3",80);
 output.write(Des,80);
     output.write((char*)&NumberOfTriElement,sizeof(int));
 ciccioFile << "Number of TRIA Elements \n" << NumberOfTriElement << "\n";
  ciccioFile << "TRIA3 contID ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     //number Quad of element
//     int a = NumberOfQuadElement ;//one is null element
     for(int i =0;i<((*it1).second).size();i++)
     {
       if(((*it1).second[i]!=NULL) &&  (*it1).second[i]->NumberOfNode==3)
       {
          int ele  = (*it1).second[i]->EleId;
          int contId =   MapEleIdToConsecutive.find(ele)->second;
          output.write((char*)&contId,sizeof(int));
		  ciccioFile << contId << " \n";
        //  output.write((char*)&ele,sizeof(int));
//           cout<<"id  "<<contId<<endl;    
       }
     }
}
  ciccioFile << "TRIA3 Part element info ---------------- next \n";
 for(it1=PartElementInfo.begin();it1!=PartElementInfo.end();it1++)
 {
     for(int i =0;i<((*it1).second).size();i++)
     {
       if( ((*it1).second[i]!=NULL) &&  (*it1).second[i]->NumberOfNode==3)
       {
         for(int j=0;j<3;j++)
         {
               int nodeId  = (*it1).second[i]->NodeId[j];
               nodeId = MapNodeIdToConsecutive.find(nodeId)->second;
               output.write((char*)&nodeId,sizeof(int));
			   ciccioFile << nodeId << " \n";
 //              cout<<nodeId<<"  ";
        }
//       cout<<endl;
       }
       
     }
  }


 // ubik
 output.close();
 ciccioFile.close();

}
////////////////////////////////////////////////////////////////////////////////////////////

>> BINARY_SEARCH 
	binary_search
function to determine whether a value is in the array.
[pag302deitel]
Note: the linear search for searching an unordered array is simple but slow compared to the more complex but much faster binary search for searching an ordered array.
example pag303:
   // search for "indigo" in colors
   bool found = binary_search( colors.begin(), colors.end(), "indigo" );
   cout << "\n\n\"indigo\" " << ( found ? "was" : "was not" ) 
      << " found in colors" << endl;
[from fig07_18.cpp]
IMPORTANT: to use binary_search the sequence of values must be sorted in ascending order first.
NOTE: bool found = binary_search( A, B, "C" ); A e B represent the range of elements to search and "C" indicates the search key, cioe' the value to locate in the array. The function returns a bool indicating whether was found.

>> block [chiamato anche "compound statement"]
tutto cio' che e' contenuto tra {}
per esempio un blocco if con multipli statements
	if (conditione)
	{
		statement1;
		statement2;
	} 
[see esempio pratico pag94deitel]
NB [da pag115deitel]: a block can be placed anywhere in a program that a single statement can be placed. 
Just as a block can be placed anywhere a single statement can be placed, it's also possible to have no statement at all, which is called a null statement or an empty statement. Then null statement is represented by placing a semicolon ; where a statement would normally be. [from pag 116 deitel]
mio esempio pratico 
if (condition)
{
	statement1;
	statement2;
}
else
	;  // che poi in questo mio esempio e' puramente accademico tanto vale allora non mettere l'else
///////////////
ATTENTION : [pag116] placing a semicolon after the condition in an if statement leads to 
- a logic error in single selection if statements 
- a syntax error in double-selection if...else statements (when the if part contains an actual body statement)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> bitset [pag677 deitel]
Class bitset makes it easy to create and manipulate bit sets, which are useful for representing a set of bit flags. bitsets are fixed in size at compile time. Class bitset is an alternate tool for bit manipulation, discussed in chapter 22 deitel.
- The declaration 
	bitset< size > b;
creates bitset b, in which every on of the size bits is initially 0 ("off")
- The statement
	b.set ( bitNumber );
sets bit bitNumber of bitset b "on". The expression b.set()  sets all bits in b "on"
- The statement
	b.reset( bitNumber);
"flips" bit bitNumber of bitset b (e,g, if the bit is "on", flip sets it "off"). The expression b.flip() flips all bit in b.
- The statement
	b[ bitNumber ];
returns a reference to the bit bitNumber of bitset b. Similarly
	b.st ( bitNumber );
performs range checking on bitNumber first. Then, if bitNumber is in range, at returns a reference to the bit. Otherwise, at throws an out_of_range exception
- The statement
	b.test( bitNumber );
performs range checking on bitNumber first. If bitNumber is in range, test returns true if the bit is on, false it's off. Otherwise, test throwns an out_of_range exception. 
- The expression 
	b.size()
returns the number of bits in bitset b
- The expression 
	b.count()
returns the number of bits that are set in bitset b
- The expression 
	b.any()
returns true if any bit is set in bitset b
- The  expression 
	b.all()
returns true if all of the bits are set in bitset b. 
- The expression 
	b.none()
returns true if none of the bits is set in bitset b.
- The expressions 
	b == b1
	b != b1
compare the two bitsets for equality and inequality, respectively.
Each of the bitwise assignment operator &=, |= and ^= (discussed in detail in section 22.5 deitel) can be used to combine bitsets. For example
	b &= b1;
performs a bit-by-bit logical AND between bitsets b and b1. The result is stored in b. 
Bitwise logical OR and bitwise logical XOR are performed by 
	b |= b1;
	b ^= b2;
The expression 
	b >>= n;
shifts the bits in bitset b right by n positions. 
The expression
	b <<= n;
shifts the bits in bitset b left by n positions. 
The expressions
	b.to_string()
	b.to_ulong()
convert bitset b to a string and an unsigned long, respectively.   
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> bool : boolean value. It can take one of two values: true or false
size 1 byte 

>> BOOL type 
C++ provides the data type "bool" for variables that can hold only the values "true" and "false", each of these is a C++ keyword.
For compatibility with earlier versions of C, which used integers for Boolean values 
> the bool value "true" also can be represented by any non zero value (compilers typically use 1)
> the bool value "false" also can be represented as the value zero. 
[pag111deitel]

>> BREAK statement
pag178deitel
nice example pag 179deitel
...[ricopiato da Code_Examples/ch05/fig05_13/fig05_13.cpp]
 10    for ( count = 1; count <= 10; ++count ) // loop 10 times
 11    {
 12       if ( 5 == count ) // if count is 5,
 13          break; // break loop only if x is 5
 14
 15       cout << count << " ";
 16    } // end for
 17
 18    cout << "\nBroke out of loop at count = " << count << endl;
 19 } // end main
Observation [from 180deitel]
Even if the use of break in switch statements is acceptable, the effects of break and continue can be achieved by structured programming techniques. Diciamo che structure programming techniques guarantee quality. While break and continue possono improve performance. Quality and performance non sempre vanno a braccetto. Spesso uno e' ottenuto a scapito dell'altro. As a general guideline: first make your code simple and correct (structured program); then make it fast and small, but only if necessary.

>> BREAK and >> CONTINUE STATEMENTS [mike pag55]
In the following example the number 5 is skipped with a continue statement, and the loop ends with a break statement:
	// Finicky Counter
	// Demonstrates break and continue statements
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int count = 0;
		while (true)   // questo technically creates an infinite loop. In realta il loop non e' veramente infinito visto che poi nel suo body vi e' un break che rompera' il loop una volta che count diventa piu' grande di 10
		{
			count += 1;
	
			//end loop if count is greater than 10
			if (count > 10)
			{
				break;
			}
	
			//skip the number 5
			if (count == 5)
			{
				continue;    // it makes you jump directly to the top of the loop
			}                // visto che e' messo prima del cout << quando count == 5  the program goes right back to the top of the loop, il programma se count == 5 non raggiunge quindi l'istruzione cout che viene quindi skipped and never displayed.
	
			cout << count << endl;
		}
	
	    return 0;
	}
//
--------------------------
OUTPUT del programma
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
1
2
3
4
6
7
8
9
10
---------------------------
NOTE: you can use break and continue in any loop you create; but you should use them sparingly. Both break and continue can make it harder for programmers to see the flow of a loop.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> BREAKPOINT / >> DEBUGGING with breakpoint in visual studio 
durante il debug di un console program i breakpoint sono utili per metter in pause in modo da poter vedere l'output nella finestra dos prima che si chiuda.
In Visual Studio 
- clicca dove vuoi inserire il breakpoint, 
- Debug -> Toggle breakpoint (or F9)
- si fa partire il debug
- F5 (or Debug -> Continue) to close the dos window and finish the debug.[nb F5 da premersi una volta cliccato sulla finestra visual e non restando sulla DOS windows] 

>> BUFFERED vs UNBUFFERED STREAM
- when a stream is unbuffered , characters are intended to appear from the source as soon as possible
- when a stream is fully buffered characters are intended to be trasnmitted as a block when a buffer is filled. When a stream is line buffered, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encoutered. 

[COUT << = Character Output Stream pronuncitato see-out]

>> BUFFER FLUSH 
A buffer flush is the transfer of computer data from a temporary storage area to the computer's permanent memory. Here's one example of a buffer flush: when you make changes on a word document, the canges you see on your computer screen are stored temporarily in a buffer. When you save your work, the changes that you've made to your document  since the last time you saved it are flushed from the buffer to permanent storage on the hard disk. ]

>> BUFFER / >> FLUSH [pag 11 moo book] 
In general the input output library saves its output in an internal data structure called a buffer, which it uses to optimize output operatios. Most systems take a significant amount of time to write characters to an output device. To avoid the overhead of writing in response to each output request, the input output library uses the buffer to accumulate the characters to be written, and flushes the buffer, by writing its contents to the output device, only when necessary. 

>> BUILD menu: per vedere il menu BUILD
- Tools -> Setting menu and select Expert Settings

>> BUILDING YOUR OWN COMPUTER !!! 
[pag370deitel] machine language programming!!! 
To dig in itiaf

>> boolalpha
[pag585deitel]
C++ provides data type bool, whose values may be false or true, as a preferred alternative to the old style of using 0 to indicate false and nonzero to indicate true. A bool variable ouputs as 0 or 1 by default. However, we can use stream manipulator boolalpha to set the output stream to display bool values as the string "true" or "false". 
Use [tag >> noboolalpha] noboolalpha to set the output stream to display bool values as integers (i.e. the default setting). 
example from pag 586
////////
	bool booleanValue = true;	
	   // display default true booleanValue
	   cout << "booleanValue is " << booleanValue << endl;
	   // display booleanValue after using boolalpha
	   cout << "booleanValue (after using boolalpha) is "
	      << boolalpha << booleanValue << endl << endl;
/////////
donera' in print:
	 booleanValue is 1
	 booleanValue (after using boolalpha) is true
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> BYTE  = unit of digital information.
Consists of EIGHT BITS 

>> CCCCCCC

>> call by value [pag53 moo book] when the function's parameters are initialized to COPIES of the arguments's value, and do NOT refer DIRECTLY to the arguments themselves. This behaviour is called call by value, because the parameter takes on a copy of the value of the argument. 

>> clear vector [pag57 moo book]
	nomevettore.clear()
utile to get rid of previous contents inside the vector.
/////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CALLING FUNCTIONS / >> COMPUTER MEMORY EXPLAINED / >> RAM and >> STACK POINTER [see bella spiegazione pag 130 jesse]
Explains well what are 
	>> register
	>> code space
	>> stack
>> register are a special area of memory built right into the central processing unit (or CPU).
There is a set of registers responsible for pointing, at any given moment, to the next line of code. These registers, together, can be called the >> instruction pointer. It is the job of the instruction pointer to keep track of which line of code is to be executed next. 
>> code space is that part of memory set aside to hold the binary form of the instructions you created in your program. 
Each line of source code is translated into a series of instructions, and each of these instructions is at a particular address in memory. The instruction pointer has the address of the next instruction to execute. 
>> stack = is a special area of memory allocated for your program to hold the data required by each of the functions in your program. It is called a stack because it is a last-in, first out queue, much like the stack dishes at a cafeteria. 
>> last in first out means that whatever is added to the stack last is the first thing taken off. It is like a stack of coins: if you stack 10 coins of euros on a tabletop and then take some back, the last three you put on top are the first three you take off. 
/////////////////////////////////////////////////////////////////////////////////////////////////

>> clear input / >> clear istream objects [example from pag57 moo book]
nomeinputStream.clear()
utile to disregard whatever condition caused the intput attempt to fail, be it end-of-file or invalid input. We do so by calling nomeinputStream.clear() to reset the error state inside nomeinputStream, which tells the library that input can continue despite the failure.
-----------------------------------------------------------
// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}
------------------------------------------
NOTE: from pag 58 moo book: for istream objects, "clear" resets any error indications so that input can continue; for vector objects, "clear" discards any contents that the vector might have had, leaving us with a empty vector again. 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> CALL BASE CLASS COSTRUCTOR [pag318 mike game programming ]
Being able to call a base class constructor is useful when you wnat to pass specific values to it. 
Here's an example:
	Boss::Boss(int damage): 
	    Enemy(damage)            //call base class constructor with argument
	{}
from the following program
-------------------------------------------------------------------------------------
[full program]
	//Overriding Boss
	//Demonstrates calling and overriding base member functions
	
	#include <iostream>
	
	using namespace std;
	
	class Enemy
	{
	public:
	    Enemy(int damage = 10);
	    void virtual Taunt() const;     //made virtual to be overridden
	    void virtual Attack() const;    //made virtual to be overridden
	 
	private:
	    int m_Damage;
	};
	
	Enemy::Enemy(int damage): 
	    m_Damage(damage)
	{}
	
	void Enemy::Taunt() const
	{
	    cout << "The enemy says he will fight you.\n";
	}  
	
	void Enemy::Attack() const
	{
	    cout << "Attack! Inflicts " << m_Damage << " damage points.";
	}
	
	class Boss : public Enemy
	{
	public:
	    Boss(int damage = 30);
	    void virtual Taunt() const;      //optional use of keyword virtual
	    void virtual Attack() const;     //optional use of keyword virtual
	};
	
	Boss::Boss(int damage): 
	    Enemy(damage)            //call base class constructor with argument
	{}
	
	void Boss::Taunt() const     //override base class member function
	{
	    cout << "The boss says he will end your pitiful existence.\n";
	}  
	
	void Boss::Attack() const    //override base class member function
	{
	    Enemy::Attack();         //call base class member function 
	    cout << " And laughs heartily at you.\n";
	}   
	
	int main()
	{
	    cout << "Enemy object:\n";
	    Enemy anEnemy;
	    anEnemy.Taunt();
	    anEnemy.Attack();
	
	    cout << "\n\nBoss object:\n";
	    Boss aBoss;
	    aBoss.Taunt();
	    aBoss.Attack(); 
	    
	    return 0;
	}
	

[end full program]
-------------------------------------------------------------------------------------

>> CALL BASE CLASS MEMBER FUNCTION [mike pag320 game programming]
You can directly call a base class member function from any function in a derived class. All you have to do is prefix the class name to the member function name with the scope resolution operator "::" example :
	void Boss::Attack() const    //override base class member function
	{
	    Enemy::Attack();         //call base class member function 
	    cout << " And laughs heartily at you.\n";
	}   // in this way when a Boss Attack the boss does exactly what an enemy does and then adds a laugh
TRICK [pag321 mike il seguente mi sembra un suggerimento utile durante code customization]: you can extend the way a member function of a base class works in a derived class by overriding the base class method and then explicitly calling the base class member function from this new definition in the derived class and adding some functionality 
////////////////////////////////////////////////////////////////////////////////////////////////////

>> CHAIN input operations [pag37 moo book]
You can chain input operations just like you can chain output operations so 
	cin >> variableA >> variableB;
has the same effect of 
	cin >> variableA;
	cin >> variableB;
>> CHAIN OF STRING [pag37 moo book] / >> READABILITY SUSUME 
Two or more string literals in a program, separated by whitespace, are automatically concatenated
	cout << "Enter all your homework grades, "
	        "followed by end-of-file: ";
has the same effect of 
	cout << "Enter all your homework grades, followed by end-of-file: ";
Spezzando le linee in tal modo permetti di ottenere dei programmi piu' leggibili.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> CORE LANGUAGE vs >> STANDARD LIBRARY [pag2 moo book]
In C++ many funcdamnetal facilities such as input output are part of the standard library, rather than being part of the core language. This distinction is important because the core language is always available to all C++ programs, but you must explicitly ask for the parts of the standard library that you wish to use.
///////////////////////////////////////////////////////////////////////////////////////

>> CASCADING / >> CASCADE 
example pag 443 deitel
cioe' cin >> phone1 >> phone2; 
viene a coincidere [se ho ben capito itiaf check] con 
	cin >> phone1;
	cin >> phone2

>> cascaded array assignment / >> cascaded assignment
[pag464deitel]

>> pointers why do you need them
Trovi una bella spiegazione @pag134 jesse book 
The changes to the value of function arguments are not reflected in the calling function. This is because arguments passed to a function are passed by value. That means that the argument in the function is actually a copy of the original value. 
So if the argument are passed by value, what do I do if I need to reflect the changes back in the calling function?
You use POINTERS or REFERENCES, in this way you can reflect the changes in the calling function. 
/////////////////////////////////////////////////////////////////////////////////////////

>> C string / >> pointer-based strings
[pag358]
A pointer-based string is a built-in array of characters ending with a null character ('\0')
which marks where the string terminates in memory. A string is accessed via a pointer to its first character. 
Nota come 
	char color[] = "blue";
e 
	char color[] = {'b', 'l', 'u', 'e', '\0' };
sono equivalenti. DIciamo che la seconda rende ancora piu' evidente che la C string altri non e' che un built-in array of characters ending with a null character.
NOTE1: when declaring a built-in array of chars to contain a string, the built-in array must be large enough to store the string AND its terminating null character.
NOTE2: deitel sconsiglia di usare C strings: C++'s string class is preferred for use in new programs, because it eliminates many of the security problems and bugs that can be caused by manipulating C strings [molti programmatori finiti all'ospedale con le mani ustionate, sono vere e proprie mine vaganti]
NOTE3: [pag360] because a C string is a built-in array of characters, we can access individual characters in a string directly with array subscript notation. For example, if we declare:
	char color[] = "blue"; 
color[0] is the character 'b', color[2] is 'u' and color[4] is the null character  
NOTE4: to input an entire line of text into a built-in array of chars [pag360deitel]
For this purpose, the cin object provides the member function "getline", which takes three arguments:
- a buil-in array of chars in which the line of text will be stored
- a length 
- a delimiter character
For example:
	char sentence[ 80 ];
	cin.getline( sentence, 80, '\n' );
declare "sentence" as a built-in array of 80 characters and read a line of text from the keyboard into the built-in array.
The function stops reading characters when 
- the delimiter character '\n' is encountered, 
- when the end-of-file indicator is entered 
- or when the number of characters read so far is one less than the length specified in the second argument (80 nell'esempio sopra)
The last character in the built-in array is reserved for the terminating null character.
NOTE5: [pag361deitel] 
> DISPLAYING C strings
A built-in array of chars representing a null-terminated string can be output with cout and << 
The statement
	cout << sentence;
displays the built-in array sentence. Like cin, cout does not care how large the built-in array of chars is. The characters are output until a terminating null character is encoutered; the null character is not displayed. 
"cin" and "cout" assume that built-in array of chars should be processed as strings terminated by null characters; cin and cout do not provide similar input and output processing capabilities for other built-in array types.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C string vs string object [pag106 mike]
You should opt for string objects whenever possible. String objects have advantages over C-style strings. The most obvious is that they are dynamically sizeable. You don't have to specify a length limit when you create one. 

>> C string mike explanation [pag96 mike]
	char phrase[] = "Game Over!!!";
C stype string terminate with a  character called the null character to signify their end. You can write the null character as "\0". We didn't need to use the null character in the previous code because it is sotred at the end of the string for me. So technically phrase has 13 elements  (however functions that work with C style strings will say that phrase has a length of 12, which makes sense and is in line with how string objects works)
	char phrase[81] = "Game Over!!!";
The previous code creates a C style string that can hold 80 printable characters (plus it terminating null character).
A nice about string objects is that thye're desinged to work seamlessly with C style strings. 
C style string have the same shortcomings as arrays. One of the biggest is that their lengths are fixed. So the moral is :
- use string objects whenever possible, but be prepared to work with C style strings if necessary.


 FUNCTIONS / >> CONVERT FUNCTION  
[pag870 deitel] (un simile ai giochini che gia' facevamo in python)
	>> convert NUMERIC VALUES TO STRING OBJECTS : C++11 to_string function (from the <string> header ) returns the string representation of its numeric argument. 
	>> convert STRING Objects to Numeric Values : C++ provies eight functions for convertin string objects to numerica values. Each function attempts to convert the beginning of its string argument to a numeric value. If no conversion can be performed, each function throws an invalid_argument exception. If the result of the conversion is out of range for the function's return type, each function throws an out_of_range exception. If the result of the conversion is out of range ofr the function's return type, each function throws an out_of_range expection  
FUNCTIONS that convert from string to numeric types:
1) functions that convert to integral types
Function     Return type
stoi         int              [memo trick st = string , o = output , i= int]
stol         long             [memo trick st = string , o = output , l= long]
stoul        unsigned long    [memo trick st = string , o = output , u= unsigned , l= long ]
stoll        long long        
stoull       unsigned long long
2) function that convert to floating point types
stof         float
stod         double
stold        long double
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////    


>> CANOVACCIO per buildare piccoli sorgenti tipo quelli from Deitel Book
// Fig. 17.5: fig17_05.cpp
// Demonstrating standard new throwing bad_alloc when memory
// cannot be allocated.
#include <iostream>
#include <new> // bad_alloc class is defined here
using namespace std;

int main()
{
	double *ptr[50];

	// aim each ptr[i] at a big block of memory
	try
	{
		// allocate memory for ptr[ i ]; new throws bad_alloc on failure
		for (size_t i = 0; i < 50; ++i)
		{
			ptr[i] = new double[50000000]; // may throw exception
			cout << "ptr[" << i << "] points to 50,000,000 new doubles\n";
		} // end for
	} // end try
	catch (bad_alloc &memoryAllocationException)
	{
		cerr << "Exception occurred: "
			<< memoryAllocationException.what() << endl;
	} // end catch
	std::cin.ignore();
} // end main


/***************************************************************************
* Canovaccio Ciccio prima della } di chiusura del blocco main aggiungi     *
* aggiungi la seguente linea in modo da poter vedere l'output nel terminal * 
* /////////////////////                                                    *
* std::cin.ignore();                                                       *
* /////////////////////                                                    *
* Per copiare l'output dal command prompt                                  *
* Alt+Space keyboard combination to bring up the window menu,              *
* then hit the E key, and then the K key to copy.                          *
* vedrai il cursore grigio all'interno della command prompt, draggalo      *
* in modo da selezionare tutta la regione che vuoi copiare, quindi click   *
* destro. Infine CTRL+V nel text editor in cui vuoi copiare il testo.      *
***************************************************************************/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> CATCH exception example 
see pag384 deitel in cui utilizza catch e la member function >> what = member function that displays the exception's error message 
	// attempt to set the time with invalid values
   try
   {
      t.setTime( 99, 99, 99 ); // all values out of range
   } // end try
   catch ( invalid_argument &e )
   {
      cout << "\n\nException: " << e.what() << endl;
   } // end catch
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> Cascading  stream insertion operations 
example 
	std::cout << "Sum is " << number1 + number2 << std::endl;
you can use multiple stream insertion operators << and also perform calculation in output statements. 
A powerful feature of C++ is that you can create your own data types called classes. You can  then "teach" C++  how to input and output values of these new data types using << and >>  operators	 
[pag48deitel]

>> cerr 
utile per display a warning message 
example @ pag 94 deitel
	cerr << "Name \"" << name << "\" exceeds maximum length (25).\n"
         << "Limiting courseName to first 25 characters.\n" << endl;

>> char = Character or small integer, size 1byte, 
signed -128 to 127 (oh lovely! 127!)
unsigned 0 to 255

>> character
to represent a single character we enclose it between single quotes ('), ex: 
'z'
'p'
- Notice that to express a string (which is generally more than one character) we enclose it between double quotes ("") and not ''.
- strings literals can extend to more than a single line of code by putting a backlash sign at the end of each unfinished line. ex scrivendo 
cout << "string express in \ 
two lines "; 
otterrai nella DOS window:
string expressed in two lines 
[cioe' ti permette di scrivere nel sourde code la stringa su piu' righe, anche se poi su schermo tutto apparira' come una singola riga]
- you can also concatenate several string constants separating them by one or several blank spaces. ex
scrivendo 
cout << "this form" " a single" " string";
otterrai su schermo:
this form a single string
- There are characters that have certain pecularities, like the escape codes. These characters are preceded by a backlash like newline \n or tab (\t nella tastiera jp il bachlash coincide con \)
ex : 
cout << "one\ntwo\nthree";
produrra' su schermo 
one 
two 
three
- Here'a list of some of such escape codes:
\n  newline
\r  carriage return
\t  tab
\v  vertical tab
\b  backspace
\f  form feed (page feed)
\a  alert (beep)
\'  single quote (')
\"  double quote (")
\? question mark (?)
\\ backslash (\)
-----------------------------------------------------------------------------------------------------

>> CHARACTER HANDLING LIBRARY / >> character string manipulation 
[pag897 deitel]
The character handling library includes several functions that perform useful tests and manipulations of character data.
Character are often manipulated as integers.
NOTA come il nome delle funzioni sia costituito da "is" + "tipo del carattere" di cui vuoi effettuare la verifica
Prototype                   Description 
int isdigit (int c)         return 1 if c is a digit and 0 otherwise
int isalpha (int c)         return 1 if c is a letter and 0 otherwise
int isalnum (int c)         return 1 if c is a digit or letter and 0 otherwise
int isxdigit (int c)         return 1 if c is a hexadecimal digit and 0 otherwise
int islower (int c)         return 1 if c is a lowercase letter and 0 otherwise
int isupper (int c)         return 1 if c is a uppercase letter and 0 otherwise
per gli altri ti rimando alla tabella di pag898 deitel fig 22.17
NOTE: from pag 903 >> tokenizing strings = separating strings into logical pieces such as the separate words in a sentence
--------------------------------------------------------------------------------------------------------------------------
>> C string manipulation functions [pag903 deitel]
 (ti scrivo qui quelle che ritengo ci possano venire piu' utili, per la lista completa see pag903 deitel)
	char *strcat( char *s1, const char *s2);
		Appends the string s2 to s1. The first character of s2 overwrites the terminating null character of s1. The value of s1 is returned.
	char *strtok( char *s1, const char *s2)
		A sequence  of calls to strtok break string s1 into >> tokens (= logical peces such as words in a line of text + pag 908 deitel). The string is broken up based on the characters contained in string s2 [somiglia un poco | grep 'Solving for Ux' | cut -d' ' che usiamo nei residual files]. For instance, if we were to break the string "this:is:a:string" into tokens based on teh character ':', the resulting tokens would be "this", "is", "a" and "string". Function strtok returns only one token at a time (= the first call contains s1 as the first argument, and sbusequent calls to continue tokenizing the same string contain NULL as the first argument). A pointer to the current token is returned by each call. If there are no more tokens when the function is called, NULL is returned.
Altre funzioni presentate nelle pagine 903 deitel e seguenti:
	strcpy 
	strncpy
	strcat
	strncat
	strcmp
	strncmp
	strtok
	strlen
NOTE1: forgetting to include the <cstring> header when usin functions from the string-handling library causes compilation errors.
NOTE2: function >> strcpy [pag904 deitel] copies its scond argument (= a string) into its first argument (= a character array that must be large enough to store the string and its terminating null character - which is also copied -).
NOTE3: [pag908 deitel] >> COMPARING STRING / >> COMPARE CHARACTERS : how does the computer know that one letter comes before another? All characters are represented inside the computer as numeric codes; when the computer compares two strings, it actually compares the numeric codes of the characters in the strings.
NOTE4: >> tokeninzing more info pag908 deitel: function strtok breaks a string into a series of tokens. A token is a sequence of characters separated by delimiting charactesr (usually spaces or punctuations marks). For example in a line of text, each word can be considered a token, and the spaces separating the words can be considered delimiters.
-----------------------------------------------------------------------------------------------------
>> C string conversion functions [pag910 deitel] ti scrivo qui giusto il nome delle funzioni presentate e ti rimando direttamente al libro per la spiegazione piu' esauriente
	atof   -> converts its argument (a string that represent a floating point number) to a double value [gia' in maniera un po' simile a quanto facevamo nei programmi python]
	atoi   -> converts a string of digit that represents an integer to an int value. 
	atol   -> converts a string of digits representing a long integer to a long value
	strtod 
	strtol
	strtoul
>> SEARCH FUNCTIONS OF THE C STRING HANDLING LIBRARY [pag915 deitel]
	strchr  
		esempio di utilizzo char *strch (const char *s, int c )    Locates the firs occurrence of character c in string s. If c is found, a pointer to c in s is returned. Otherwise, a null pointer is returned [carino! qui si tocca con mano la funzione del pointer, il pointer ti indica do sta cio che cerchi E' una sorta di Navigator!]
	strrchr
	strspn
	strpbrk
	strcspn
	strstr
Sono delle funzioni utili per dirti. L'ultima parola della stringa contenente la lettera "z" e' .... ve ne sono in tutte le salse per maggior info take a look at the pages 910 et seguenti.
-----------------------------------------------------------------------------------------------------
>> MEMORY FUNCTIONS OF THE C STRING HANDLING LIBRARY
pag919 deitel
[detto in parole spiccie sono funzioni che ti permettono ad esempio di copiare gli ultimi ex 10 byte di un array x into the first 10 bytes of array x]
The string handling library functions presented in this section facilitate manipulating, comparing and searching blocks of memory.The functions tresat blocks of memory as arrays of bytes. These functions can manipulate any block of data.
Example 	
	void *memcpy( void *s1, const void *s2, size_t n )    copies n characters from the object pointed to by s2 into the object pointed to by s1. A pointer to the resulting object is returned. The area from which characters are copied is not allowed to overlap the area to which characters are copied. 
NOTE: the pointer parameters to these functions are declared void*. In chapter 8, we saw that a pointer to any data type can be assigned directly to a pointer of type void *. For this reason, these functions can receive pointers to any data type. Remember that a pointer of type void * cannot be assigned directly to a pointer of any other data type. Because a void * pointer cannot be dereferenced, each function receives a size argument that specifies the number of characters (bytes) the function will process. For simplicity, the examples in this section (pag920 deitel) manipulate character arrays (block of characters). 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> CHARACTER CONSTANTS
[pag358lala]
A character constant is an integer value reprenseted as a character in single quotes.
The value of a character constant is the integer value of the character in the machine's character set. 
For example
	'z'
represents the integer value of z (122 in the ASCII character set)
and 
	'\n'
represents the integer value of newline (10 in the ASCII character set)
>> STRINGS
A differenza delle character constant, le Strings usano le double quotation marks " " and sono costituite da una serie di characters treated as a single unit
Example of strings
	"22-50-2nd Street" 


>> CIN  
Character INput
ex
	cin >> first_reactor
ex2
	std::cin >> number1; 
uses the standard input stream object cin (of the namespace std) and the stream extraction operator >> to obtain a value from the keyboard. We like to pronouce the preceding statement as "std::cin gives a value to number1" or simply "std::cin gives number1".
[pag46deitel]
NOTE from pag34 MIKE : >> cin is an object defined in the file iostream, that's used to get data from the standard input stream. 

>> cin.get()
[example pag 173deitel]
esempio 
	int level; // level entered by the user
	level = cin.get()
the cin.get function reads one character from the keyboard and stores that character in integer variable level.	
OBSERVATION from pag 173deitel
nell'esempio si legge un carattere da tastiera e lo si stora in un integer variable. Strano vero? il fatto e' che characters can be stored in any integer  data type, because types short, int, long, and long long are guaranteed to be at least as big as type char. Thus we can treat a character either as an integer of as a character, depending on its use.
See appendix B for the characters and decimal equivalents from the ASCII character set: per esempio a viene rappresentato come 97: 97 is the numerical representation di "a" in the computer.  

>> Client code
per client code si intende per esempio la function main che utilizza una determinata classe. il concetto compariva nel discorso sulla reusability: in order to promote reusability separate the class definition fro mthe client code (e.g. function main)  that uses the class.
[pag86deitel]

>> close file 
[pag605 deitel]
TO close a file you can use the member function close, for example
	// ofstream constructor opens the file
	ofstream ciccioFile("NTTData.txt", ios::out );
	...
	// close the file
	ciccioFile.close();
///////////
NOTE: Error prevention 
always close a file as soon as it's no longer needed in a program.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CMATH [pag204deitel]
the <cmath> header provides a collection of functions that enable you to perform common mathematical calculations.
from fig6.2pag204deitel
	ceil( x )    -> rounds to the smallest integer not less than x   example: ceil(9.2) is 10.0, ceil(-9.8) = -9.0
    floor( x )   -> rounds x to the largest integer not greater than x, example floor(9.2) is 9.0, floor(-9.8) is -10.0
	sin( x )     -> sin di x, x in radiants
	cos( x )     -> cos di x, x in radiants
	tan( x )     -> tangent di x, x in radiants
	exp( x )     -> exponential function e^x  example exp(1.0) = 2.718282
	log( x )     -> natural logarithm of x (base e): example log( 2.718282 ) is 1.0
	log10( x )   -> logarithm of x (base 10) example log10(100) is 2.0
	fabs( x )    -> absolute value of x , example fabs(4.2) is 4.2, fabs(-9.76) is 9.76
	fmod( x, y ) -> remainder of x/y as floating-point number ex: fmod( 2.6, 1.2) is 0.2
	pow( x, y )  -> x raised to power y  ex pow( 2, 7 ) is 128
 	sqrt( x )    -> square root of x (where x>=0)



>> COMMA OPERATOR (,)
The comma operator is used to separate two or more expressions that are included where only one expression is expected. When the set of expression has to be evaluated fora value only the rightmost expression is considered. 
Example:
	a = (b=3, b+2);
prima si assegna il valore 3 a b, quindi si assegna b+2 alla variabile che alla fine conterra' il valore 5, mentre b conterra' il valore 3. 
See also pag161deitel-> comma-separated list of expressions
The comma operator is often used in for statements; its primary application is to enable you to use multiple initialization expression and/or multiple increment expressions. -> see esempio pratico pag 165 deitel [te lo rescrivo qui sotto per comodita']
example 
for ( unsigned int number = 2; // initialization
	  number <= 20; // loop continuation condition
	  total += number, number +=2 )
; //empty body [usando il comma operator sei cosi' in grado di gli even integer from 2 to 20 tutto all'interno del for header]
1 OSSERVAZIONE e consiglio da pag165deitel: e' sconsigliato pero' ai fini della chiarezza, modificazione e debug mergere the statements of the body of a for loop into its header: si puo' fare ma poi risulta piu' difficile da comprendere
2 OSSERVAZIONE [from pag 208]: le virgole usate tra gli arguments di una funzione non sono dei comma operators. 
Example la funzione:
	maximumTonnaggio = maximum( TonsCargo1, TonsCargo2, Tons-Cargo3);
the order of evalution of a function's arguments it's not specified by the C++ standard, thus different compilers can evaluate function arguments in different orders (non necessariamente from left to right). Sometimes when a function's arguments are expressions, such as those with calls to other functions, the order in which the compiler evaluates the arguments could affect the values of one or more of the argumetns. If the evaluation order changes between compilers, the argument values passed to the function could vary, causing subtle logic errors. 
SOLUTION: if you have doubts about the order of evaluation of a function's arguments and whether the order would affect the values passed to the function:
- evaluate the arguments in separate assignment statements before the function call, 
- assign the result of each expression to a local variable, 
- then pass those variables as arguments to the function.

  
 

>> COMMENTS : 
Two ways 
1) // 
// discards everything from where the // is found up to the end of the same line. (non necessariamente devi porlo a inizio di una nuova linea, poi anche sistemarlo dopo il semicolo di un'istruzione, rendendo il tutto piu' compatto) 
2) /* block comment */
discards everything between the /* characters and the first appearance of the */ characters, with the possibility of inlcuding more than one line. 

>> COMPILE LINK and execute a simple program in Linux from command line 
in SHORT:
	g++ edyProgram.cpp -o edyProgram.exe
[l'estensione exe non e' obbligatoria, giusto una nostra abitudine per localizzare meglio i files eseguibili]
o nel caso di multipli files (hearders, main ect) basta che li metti in lista prima dell' "-o" [ciccio courtesy!]
	g++ Array.h Array.cpp fig10_09.cpp -o executable
[source pag11 programming principle bjarne]
ex: execute a simple program consisting of two source files, my_file1.ccp and my_file2.ccp, using the GNU C++ compiler, g++ on a Linux/Unix system:
	g++ -o my_program my_file1.ccp my_file2.ccp
	./my_program
that's all folks!
EXAMPLE with HEADER FILE 
supponi di avere vari files: 
	Array.cpp  Array.h fig10_09.cpp
per compilarli linkarli e creare l'eseguibile:
	g++ Array.h Array.cpp fig10_09.cpp -o executable
[l'ordine con cui elenchi i files da buildare e linkare non e' importante]
In tal modo ti ritroverai l'eseguibile "executable" che potrai lanciare con 
	./executable
[anche il seguente ordine e' valido:
	g++ edyProgram.cpp -o edyProgram
this command compiles the application and produces an executable file called edyProgram
To run the executable type
	./edyProgram
and press enter.
pag23 deitelC++
]  
////////////////////////////////////////////////////////////////////////////////

>> COMPILE in Visual Studio [tested at Orion 1 with visual studio 2013 (quando avevamo ancora tutti i denti!)]
New Project -> Win 32 console application
next => in application settings uncheckiamo il "security development lifecycle", unchecked precompiled header
Next => ti si apre il text editor con il programma => cancella tutto il contenuto copiaci dentro il codice sorgente
Menu Build F7
OK it just works!!!
/////////////////////////////////////////////////////////////////////////////////

>> COMPILING and BUILDING EXAMPLE [from NEC feamapper] / >> BUILDING on linux with cmake 
>> COMPILE / >> BUILD / >> cmake
in short from pawan:
Source code that i send you is compiled in linux.
Code are same except cmakefile And few file in openfoam folder..
      Step 1 create build folder and go inside the folder

     Step 2  run command
                  cmake ../source  
     Step 3 build
IN DETAIL BY CICCIO
Step by step by ciccio:
	pwd 
		/home/serena/edylab/Linux-SourceCode-pawan-150408
	tree -L 2
la struttura e' la seguente:
		--- Source
		|?? -- CMakeLists_12.txt
		|?? -- CMakeLists.txt
		|?? -- CVS
		|?? -- General_Bottom.cmake
		|?? -- General_Top.cmake
		|?? -- README
		|?? -- src
		|?? -- window
		--- Source.tgz
	mkdir built-ciccio
	cd built-ciccio
	cmake ../Source
otterrai:
		-- Configuring done
		-- Generating done
		-- Build files have been written to: /home/serena/edylab/Linux-SourceCode-pawan-150408/built-ciccio
Quindi build with make:
	pwd 
		/home/serena/edylab/Linux-SourceCode-pawan-150408/built-ciccio
	make	
Otterrai come messaggio 
	[ 20%] Building CXX object CMakeFiles/FEAMapper.dir/src/main/main.o
	[ 40%] Building CXX object CMakeFiles/FEAMapper.dir/src/NastranReader/cxx/NastranReader.o
	[ 60%] Building CXX object CMakeFiles/FEAMapper.dir/src/NastranReader/cxx/NastranReader_FEAMesh.o
	[ 80%] Building CXX object CMakeFiles/FEAMapper.dir/src/OpenFOAMReader/cxx/OpenFOAMReader.o
	[100%] Building CXX object CMakeFiles/FEAMapper.dir/src/Octree/cxx/Octree.o
	Linking CXX executable FEAMapper
	[100%] Built target FEAMapper
Otterrai cosi' il nuovo file FEAMapper:
	ls
		CMakeCache.txt  CMakeFiles  cmake_install.cmake  FEAMapper  Makefile
Quindi abbiamo copiato l'eseguibile nella cartella dei files openFOAM (si puo' rinominare l'eseguibile nessun problema)
	mv FEAMapper FEAMapper-linux
	chmod 777 FEAMapper-linux
	./FEAMapper-linux Pipe_Simple_PID2040_OrigR.dat . 1000 static\(p\)_coeff partInfo 0 0
dove abbiamo mettere le parentesi prima di ( e ) per evitare errori. 
tested on VM centOS6.6
[nice esempio di cmake and building here 
http://wiki.blender.org/index.php/Dev:Doc/Building_Blender/Linux/Ubuntu/CMake]
///////////////////////////////////////////////////////////////////

>> COMPILER REQUIRED FOR Deitel Programs / >> programs deitel 
- gnu C++ 4.7 [benche' updatato ed installatolo in Orion1 ubuntu la compilazione ci dava talvolta degli errori]
- microsoft visual C++ 2012
- apple LLVM in Xcode 4.5

>> ERROR CMAKE / >> CMAKE ERROR 
	is not a full path and was not found in the PATH.
	
	Tell CMake where to find the compiler by setting either the environment
	variable "CC" or the CMake cache entry CMAKE_C_COMPILER to the full path to
	the compiler, or to the compiler name if it is in the PATH.
SOLUTION: capita quando utilizzi in windows un cmakelists settato per linux. 
Visto che linux utilizza per i path /../../ bisogna sostituirli con i \..\..\ richiesti da windows. 
///////////////////////////////////////////////////////////////////

>> COMPILER WINDOWS stand-alone no internet connection required.
	The chosen: 
	DEV-Cpp5.11 
	[https://sourceforge.net/projects/orwelldevcpp/]
	-> appena lo installi ti permette di scegliere 
	quindi crea project -> windows console -> cancella tutto quello che c'e' nel programma di default e copiaci
	#include <iostream>
	using namespace std;
	
	int main() 
	{
	    cout << "Cruising Flying Melodies";
	    return 0;
	}
	
	quindi menu -> Execute -> compile Quindi RUN!
	perfect!!
//////////////////////////////////////////////////////////////////////////////////////////////


>> ERROR STATE STREAM / >> STREAM ERROR STATES 
[pag588 deitel]
The state of a stream may be tested through bits in class ios_base.
Example from pag 588 
////////////
   // display results of cin functions
   cout << "Before a bad input operation:"
      << "\ncin.rdstate(): " << cin.rdstate()
      << "\n    cin.eof(): " << cin.eof()
      << "\n   cin.fail(): " << cin.fail()
      << "\n    cin.bad(): " << cin.bad()
      << "\n   cin.good(): " << cin.good()
      << "\n\nExpects an integer, but enter a character: ";

   cin >> integerValue; // enter character value
   cout << endl;

   // display results of cin functions after bad input
   cout << "After a bad input operation:"
      << "\ncin.rdstate(): " << cin.rdstate()
      << "\n    cin.eof(): " << cin.eof()
      << "\n   cin.fail(): " << cin.fail()
      << "\n    cin.bad(): " << cin.bad()
      << "\n   cin.good(): " << cin.good() << endl << endl;

   cin.clear(); // clear stream
/////////////
Donera' in print 
	Before a bad input operation 
    cin.rdstate(): 0
       cin.eof() : 0
       cin.fail(): 0
        cin.bad(): 0
       cin.good(): 1
    Expects an integer, but enter a character: A
	After a bad input operation:
    cin.rdstate(): 2
       cin.eof() : 0
       cin.fail(): 1
        cin.bad(): 0
       cin.good(): 0
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> COMMENTS in options file 
[non lo so se sia vero, ci veniva ancora errore]
[cioe' il file options che trovi all'interno della Make directory]
You can include comments in your options file by starting each comment line with a pound sign (#)
	#comment here
	EXE_INC = \
		-I.. \
		-I$(LIB_SRC)/transportModels/twoPhaseMixture/lnInclude \
		-I$(LIB_SRC)/transportModels \
	...

>> COMPOSITION 
[pag378 introduction]
Composition is a form of a reuse in which a class can have objects of other classes as members.
>> COMPOSITION vs INHERITANCE / >> INHERITANCE vs COMPOSITION
pag385deitel
Often, classes do not have to be created "from scratch". Rather, they can include objects of other classes as members or they may be derived from other classes that provide attributes and behaviors the new classes can use. Such software reuse can greatly enhance productivity and simplify code maintenance. 
- INCLUDING CLASS OBJECTS  as member of other classes is called COMPOSITION (or >> AGGREGATION)
- DERIVING NEW CLASSES from existing classes is called INHERITANCE
[pag404deitel]
Composition is the capability for a class to have objects of other classes as members. 
A common form of software reusability is composition, in which a class has objects of other types as members.		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> INHERITANCE / >> DERIVATION pag 372 jesse book
C++ attempts to represent these relationships by enabling you to define classes that derive from one another. Derivation is a way of expressing the "is a" relationship. You derive a new class, Dog, from the class Mammal. You don't have to state explicity that dogs move because they inherit that from Mammal. 
A class that adds new functionality to an exisiting class is said to derive from that original class. The originalclass is said to be the new class's base class. 
NOTE: >> stubbing out (abbozzare) a function means you'll write only enough to show that the function was called, leaving the detailsfor later when you have more time. 
>> syntax of derivation [pag374 jesse]
When you declare a class, you can indicate what class it derives from by writing a colon after the class name, the type of derivation (public or otherwise) and the class from which it derives. The format of this is : 
	class derivedClass : accessType baseClass
as an example, if you create a new class called Tiger that inherits from the existing class Mammal:
	class Tiger : public Mammal
The class from which you derive must have been declared earlier or you receive a compiler error. 
------------------------------------------------------------------------------------------------------------------ EXAMPLE 
//Listing 12.1 Simple inheritance
#include <iostream>
using namespace std;

enum BREED { GOLDEN, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB };

class Mammal
{
  public:
    // constructors
    Mammal();
    ~Mammal();

    //accessors
    int GetAge()	 const;
    void SetAge(int);
    int GetWeight() const;
    void SetWeight();

    //Other methods
    void Speak() const;
    void Sleep() const;


  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:

    // Constructors
    Dog();
    ~Dog();

    // Accessors
    BREED GetBreed() const;
    void  SetBreed(BREED);

    // Other methods
    WagTail();
    BegForFood();

  protected:
    BREED itsBreed;
};
------------------------------------------------------------------------------------------------------------------ EXAMPLE END 
>> PRIVATE vs PROTECTED pag 376 jesse book
In the above program you can notice a new access keyword "protected". Previously class data had been declared private. 
However, private members are not available outside of the existing class. This privacy even applies to prevent access from derived classes.  You could make itsAge and itsWeight public, but that is not desirable. You don't want other classes accessing these data members directly. What you want is a designation that says "Make these visible to this class and to classes that derive from this class". That designation is "protected". Protected data  members and functions are fully visible to derived classes, but are otherwise private. 
In total, three access specifiers exist:
	public
	protected 
	private
If a function has an object of your class it can access all the public member data and functions. The member functions, in turn, can access all private data members and functions of their OWN class and all protected data members and functions of any class from which they DERIVE. 
Thus the function Dog::WagTail() can access the private data itsBreed and can access the protected data of itsAge and itsWeight in the Mammal class. 
Even if other classes are layered between Mammal and Dog (for example DomesticAnimals) the Dog class will still be able to access the protected members of Mammal, assuming that these other classes all use public inheritance. 
The following listing 12.2 demonstrates how to create objects of type Dog and then how to access the data and methods of that type:
------------------------------------------------------------------------------------------------------------------ EXAMPLE STARTS
//Listing 12.2 Using a derived object
#include <iostream>
using std::cout;
using std::endl;
      
enum BREED { GOLDEN, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB };
       
class Mammal
{
  public:
    // constructors
    Mammal():itsAge(2), itsWeight(5){}
    ~Mammal(){}

    //accessors
    int GetAge() const   { return itsAge; }
    void SetAge(int age) { itsAge = age; }
    int GetWeight() const { return itsWeight; }
    void SetWeight(int weight) { itsWeight = weight; }

    //Other methods
    void Speak()const { cout << "Mammal sound!\n"; }
    void Sleep()const { cout << "shhh. I'm sleeping.\n"; }

  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:

    // Constructors
    Dog():itsBreed(GOLDEN){}
    ~Dog(){}

    // Accessors
    BREED GetBreed() const { return itsBreed; }
    void SetBreed(BREED breed) { itsBreed = breed; }

    // Other methods
    void WagTail() const { cout << "Tail wagging...\n"; }
    void BegForFood() const { cout << "Begging for food...\n"; }

  private:
    BREED itsBreed;
};

int main()
{
   Dog Fido;
   Fido.Speak();
   Fido.WagTail();
   cout << "Fido is " << Fido.GetAge() << " years old" << endl;
   return 0;
}
------------------------------------------------------------------------------------------------------------------ EXAMPLE ENDS
COMPILAZIONE 
	g++ List1202.cpp -o List1202.exe
	./List1202.exe
OUTPUT
	Mammal sound!
	Tail wagging...
	Fido is 2 years old
---------------------------------------------------------------------------------------------------------------------------------------
>> INHERITANCE WITH CONSTRUCTORS AND DESTRUCTORS
Dog objects are Mammal objects. This is the essence of the "is a" relationship. 
When Fido is created, his base construtor is called first, creating a mammal. Then, the Dog constructor is called, completing the construction of the Dog object. Because Fido is given no parameters, the default constructor was called in each case. Fido doesn't exist until he is completely constructed, which means that both his Mammal part and his Dog part must be constructed. Thus, both constructors must be called. 
When Fido is destroyed, first the Dog destructor is called and then the destructor for the Mammal part of Fido is called. Each destructor isgiven an opportunity to clean up after its own part of Fido. 
The following 12.3 listing demonstrates the calling of the constructors and destructors
---------------------------------------------------------------------------------------------------------------------------------------
//Listing 12.3 Constructors and destructors called.
#include <iostream>
using namespace std;
enum BREED { GOLDEN, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB };

class Mammal
{
  public:
     // constructors
     Mammal();
    ~Mammal();

    //accessors
    int GetAge() const { return itsAge; }
    void SetAge(int age) { itsAge = age; }
    int GetWeight() const { return itsWeight; }
    void SetWeight(int weight) { itsWeight = weight; }

    //Other methods
    void Speak() const { cout << "Mammal sound!\n"; }
    void Sleep() const { cout << "shhh. I'm sleeping.\n"; }

  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:

    // Constructors
    Dog();
    ~Dog();

    // Accessors
    BREED GetBreed() const { return itsBreed; }
    void SetBreed(BREED breed) { itsBreed = breed; }

    // Other methods
    void WagTail() const { cout << "Tail wagging...\n"; }
    void BegForFood() const { cout << "Begging for food...\n"; }

  private:
    BREED itsBreed;
};

Mammal::Mammal():
itsAge(3),
itsWeight(5)
{
   std::cout << "Mammal constructor... " << endl;
}

Mammal::~Mammal()
{
   std::cout << "Mammal destructor... " << endl;
}

Dog::Dog():
itsBreed(GOLDEN)
{
   std::cout << "Dog constructor... " << endl;
}

Dog::~Dog()
{
   std::cout << "Dog destructor... " << endl;
}
int main()
{
   Dog Fido;
   Fido.Speak();
   Fido.WagTail();
   std::cout << "Fido is " << Fido.GetAge() << " years old" << endl;
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------- END FILE 
g++ List1203.cpp -o List1203.exe
./List1203.exe 
OUTPUT
	Mammal constructor...     # prima viene chiamato il "Mammal" constructor (della base class)
	Dog constructor...             # quindi viene chiamato il "Dog" constructor della derived class
	Mammal sound!             # now that the Dog fully exists, its methods 
	Tail wagging...                # can be called. 
	Fido is 3 years old
	Dog destructor...            # when Fido goes out of scope, Dog's destructor is called, 
	Mammal destructor...     # followed by a call to "Mammal"'s destructor
---------------------------------------------------------------------------------------------------------------------------------------
>> PASSING ARGUMENTS TO BASE COSTRUCTORS / >> ARGUMENTS BASE CONSTRUCTORS [pag381 jesse]
It is possible that you will want to initialize values in the base constructor. For example, you might want to overload the constructor of "Mammal" to take a specific age, and want to overlaod the Dog constructor to take a breed. How do you get the age and weight parameters passed up to the right constructor in Mammal? What if Dogs want to initialize weight but Mammal don't?
Base Class initialization can be performed during class initialization by writing the base class name, followed by the parameters expected by the base class. The following 12.4 listing demonstrates this: 
----------------------------------------------------------------------------------------------------------------------------------------- FILE STARTS
//Listing 12.4 Overloading constructors in derived classes
#include <iostream>
using namespace std;

enum BREED { GOLDEN, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB };

class Mammal
{
  public:
    // constructors
    Mammal();
    Mammal(int age);    // Mammal's contructor overloading, so that it can take an integer, the Mammal's age
    ~Mammal();

    //accessors
    int GetAge() const { return itsAge; }
    void SetAge(int age) { itsAge = age; }
    int GetWeight() const { return itsWeight; }
    void SetWeight(int weight) { itsWeight = weight; }

    //Other methods
    void Speak() const { cout << "Mammal sound!\n"; }
    void Sleep() const { cout << "shhh. I'm sleeping.\n"; }


  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:

    // Constructors
    Dog();
    Dog(int age);
    Dog(int age, int weight);
    Dog(int age, BREED breed);
    Dog(int age, int weight, BREED breed);
    ~Dog();

    // Accessors
    BREED GetBreed() const { return itsBreed; }
    void SetBreed(BREED breed) { itsBreed = breed; }

    // Other methods
    void WagTail() const { cout << "Tail wagging...\n"; }
    void BegForFood() const { cout << "Begging for food...\n"; }

  private:
    BREED itsBreed;
};

Mammal::Mammal():
itsAge(1),
itsWeight(5)
{
   cout << "Mammal constructor..." << endl;
}

Mammal::Mammal(int age):
itsAge(age),
itsWeight(5)
{
   cout << "Mammal(int) constructor..." << endl;
}

Mammal::~Mammal()
{
   cout << "Mammal destructor..." << endl;
}

Dog::Dog():
Mammal(),
itsBreed(GOLDEN)
{
   cout << "Dog constructor..." << endl;
}

Dog::Dog(int age):
Mammal(age),
itsBreed(GOLDEN)
{
   cout << "Dog(int) constructor..." << endl;
}

Dog::Dog(int age, int weight):
Mammal(age),
itsBreed(GOLDEN)
{
   itsWeight = weight;
   cout << "Dog(int, int) constructor..." << endl;
}

Dog::Dog(int age, int weight, BREED breed):
Mammal(age),
itsBreed(breed)
{
    itsWeight = weight;
    cout << "Dog(int, int, BREED) constructor..." << endl;
}
 
Dog::Dog(int age, BREED breed):
Mammal(age),
itsBreed(breed)
{
    cout << "Dog(int, BREED) constructor..." << endl;
}
 
Dog::~Dog()
{
    cout << "Dog destructor..." << endl;
}
int main()
{
    Dog Fido;
    Dog rover(5);
    Dog buster(6,8);
    Dog yorkie (3,GOLDEN);
    Dog dobbie (4,20,DOBERMAN);
    Fido.Speak();
    rover.WagTail();
    cout << "Yorkie is " << yorkie.GetAge() 
         << " years old" << endl;
    cout << "Dobbie weighs ";
    cout << dobbie.GetWeight() << " pounds" << endl;
    return 0;
}
-----------------------------------------------------------------
OUTPUT
[1034 Day12] >> g++ List1204.cpp -o List1204.exe
[1035 Day12] >> ./List1204.exe 
	Mammal constructor...
	Dog constructor...
	Mammal(int) constructor...
	Dog(int) constructor...
	Mammal(int) constructor...
	Dog(int, int) constructor...
	Mammal(int) constructor...
	Dog(int, BREED) constructor...
	Mammal(int) constructor...
	Dog(int, int, BREED) constructor...
	Mammal sound!
	Tail wagging...
	Yorkie is 3 years old
	Dobbie weighs 20 pounds
	Dog destructor...
	Mammal destructor...
	Dog destructor...
	Mammal destructor...
	Dog destructor...
	Mammal destructor...
	Dog destructor...
	Mammal destructor...
	Dog destructor...
	Mammal destructor...
----------------------------------------------------------------------------------------------------------------------------------------- END of FILE 
>> OVERRIDING BASE CLASS FUNCTION / >> BASE CLASS FUNCTION OVERRIDE [pag385 jesse]
A derived class can also override a base class function. Overrriding a function means changing the implementation of a base class function in a derived class.
When a derived class creates a function with the same return type and signature as a member function in the base class, but with a new implementation, it is said to be overriding that function. When you make an object of the derived class, the correct function is called.  Example listing 12.5
---------------------------------------------------------------------------------------------------------------------------------------
//Listing 12.5 Overriding a base class method in a derived class
#include <iostream>
using std::cout;

enum BREED { GOLDEN, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB };

class Mammal
{
  public:
    // constructors
    Mammal() { cout << "Mammal constructor...\n"; }
    ~Mammal() { cout << "Mammal destructor...\n"; }

    //Other methods
    void Speak()const { cout << "Mammal sound!\n"; }
    void Sleep()const { cout << "shhh. I'm sleeping.\n"; }

  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:
    // Constructors
    Dog(){ cout << "Dog constructor...\n"; }
    ~Dog(){ cout << "Dog destructor...\n"; }

    // Other methods
    void WagTail() const  { cout << "Tail wagging...\n"; }
    void BegForFood() const  { cout << "Begging for food...\n"; }
    void Speak() const { cout << "Woof!\n"; }      // since the Dog class inherits from "Mammal" , Dog has access to the "Speak" method. Here hoever the Dog class overrides this method causing Dog objects to say Woof!  when the speak method is called. 

  private:
    BREED itsBreed;
};

int main()
{
   Mammal bigAnimal;
   Dog fidoFido;
   bigAnimal.Speak();
   fidoFido.Speak();
   return 0;
}
-------------------------------------------
OUTPUT 
[1038 Day12] >> g++ List1205.cpp -o List1205.exe
[1039 Day12] >> ./List1205.exe 
Mammal constructor...
Mammal constructor...
Dog constructor...
Mammal sound!      # from bigAnimal.Speak();
Woof!                      # from fidoFido.Speak();
Dog destructor...
Mammal destructor...
Mammal destructor...
----------------------------------------------------------------------
NOTE : >> overloading vs >> overriding 
These terms are similar, and they do similar things. When you overload a method, you create more than one method with the same name, but with a different signature. When you override a method, you create a method in a derived class with the same name as a method in the base class and the same signature. 
----------------------------------------------------------------------
>> HIDING the base class method. 
In the 12.5 listing above, the Dog class's Speak() method hides the base class's method. This is what is wanted, but it can have unexpected results. If Mammal has a method, Move(), which is overloaded and Dog overrides that method, the Dog method hides all the Mammal method  with that name. 
But suppose, like shown in the following 12.6 listing that Mammal overloads Move () as three methods (one that takes no parameters, one that takes an integer, and one that takes and integer and a direction) and Dog overrides just the Move() method that takes no parameters, it will not be easy to access the other two methods using a Dog object. 
------------------------------------------------------------------------------------------------------------------------- 12.6 listing Starts
//Listing 12.6 Hiding methods
#include <iostream>
using std::cout;

class Mammal
{
  public:
     void Move() const { cout << "Mammal move one step.\n"; } // Move() version with no parameter in input. 
     void Move(int distance) const   // overloading Move, this version accept one parameter in input 
    {
       cout << "Mammal move ";
       cout << distance <<" steps.\n";
    }
  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:
    // You might receive a warning that you are hiding a function!
    void Move() const { cout << "Dog move 5 steps.\n"; }   // overriding the version of Move() with no parameters. 
};

int main()
{
   Mammal bigAnimal;
   Dog Fido;
   bigAnimal.Move();
   bigAnimal.Move(2);
   Fido.Move();
   // Fido.Move(10);   // this line is commented out because it causes a compile time error [there is actually a workaround see "@tagCallBaseMethod@" below]. After you override one of the methods, you can no longer use any of the base methods of the same name. 
// So, although the Dog class coud have called the Move(int) method if it had not overridden the version of Move() without parameters, now that it has done so, it must override both if it wants to use both. Otherwise, it hides the method that it doesn't override. This is reminiscent of the rule that if you supply any constructor, the compiler no longer supplies a default constructor. 
   return 0;
}
------------------------------------------------------------------------------------------------------------------------- 12.6 listing Ends
OUTPUT
[1040 Day12] >> g++ List1206.cpp -o List1206.exe
[1041 Day12] >> ./List1206.exe 
Mammal move one step.
Mammal move 2 steps.
Dog move 5 steps.
REMEMBER : the rule is this : after you override any overloaded method, all the other overrides of that method are hidden. If you want them not to be hidden, you must override them all. It is a common mistake to hide a base class method when you intend to override it, by forgetting to include the keyword "const".  "const" is part of the signature and leaving it off changes the signature, and thus hides the method rather than overrides it. 
>> OVERRIDING vs >> HIDING 
In the next section (pag389) virtual methods are described. Overriding a virtual method supports polymorphism, hiding it undermines polymorphism. You'll see more on this very soon. 
----------------------------------------------------------------------------------------------------------------------------
>> BASE METHOD CALLING / >> CALL BASE METHOD / >> CALLING BASE METHOD after overriding [pag389 jesse book]
If you have overridden the base method, it is still possible to call it by fully qualifying the name of the method. You do this by writing the base name, followed by two colons and then the method name. 
	baseClass::Method()
For example you can call the Move() method of the Mammal class as follows: 
	Mammal::Move()
[@tagCallBaseMethod@] You can use these qualified names just as you would any other method name. It would have been possible to rewrite line "Fido.Move(10);" in the above listing 12.7 so that it would compile by writing 
	Fido.Mammal::Move(10);
This calls the Mammal method explicitly.  Listing 12.7 fullly illustrates this idea
-------------------------------------------------------------------------------------------------------------------------------- 12.7 listing starts
//Listing 12.7 Calling base method from overridden method.
#include <iostream>
using namespace std;

class Mammal
{
  public:
     void Move() const { cout << "Mammal move one step\n"; }
     void Move(int distance) const
    {
       cout << "Mammal move " << distance;
       cout << " steps." << endl;
    }

  protected:
    int itsAge;
    int itsWeight;
};

class Dog : public Mammal
{
  public:
    void Move()const;
};

void Dog::Move() const
{
   cout << "In dog move...\n";
   Mammal::Move(3);
}

int main()
{
   Mammal bigAnimal;
   Dog Fido;
   bigAnimal.Move(2);
   Fido.Mammal::Move(6);
   return 0;
}
-------------------------------------------------------------------------------------------------------------------------------- 12.7 listing ends
OBSERVATION : the programmer wanted to invoke Move(int) on the Dog object, but had a problem. Dog overrides the Move() method (with no parameters), but does not overload the method that takes an integer (it does not provide a version that takes an integer). This is solved by the explicit call to the base class Move(int) method  "Fido.Mammal::Move(6);"
TIP: when calling overridden ancestor class functions using "::" keep in mind that if a new class is inserted in the inheritance hierarchy between the descendant and its ancestor, the descendant will be now making a call that skips past the intermediate class and, therefore, might miss invoking some key capability implemented by the intermediate ancestor.
DO 
	DO extend the functionality of existing, tested classes by deriving. 
	DO change the behaviour of certain functions in the derived class by overriding the base class methods. 
DON'T
	DON'T hide a base class function by changing the function signature.
	DON'T forget that const is a part of the signature.
	DON'T forget that the return type is not part of the signature.
--------------------------------------------------------------------------------------------------------------------------------------- 
>> VIRTUAL METHODS [pag391 jesse book]
This lesson has emphasized the fact that a Dog object is a Mammal. So fat that has meant only that the Dog object has inherited the attributes (data) and capabilities (methods) of its base class. In C++, the "is a" relationship runs deeper than that, however. 
C++ extends its polymorphism to allow pointers to base classes to be assigned to derived class objects. Thus, you can write: 
	Mammal* pMammal = new Dog;
This creates a new Dog object on the heap and returns a pointer to that object, which it assigns to a pointer to Mammal. This is fine because a dog is a mammal. 
NOTE: This is the essence of polymorphism. For example, you could create many types of windows, including dialog boxes, scrollable windows, and list boxes, and give them each a virtual "draw()" method. By creating a pointer to a window and assigning dialog boxes and other derived types to that pointer, you can call "draw()" without regard to the actual runtime type of the object pointed to. The correct "draw()" function will be called. 
You can then use this pointer to invoke any method on Mammal. What you would like is for those methods that are overridden in Dog() to call the correct function. Virtual functions enable you to do that. To create a virtual function, you add the keyword "virtual" in front of the function declaration. Listing 12.8 (below) illustrates how this works, and what happens with non virtual methods.  
-------------------------------------------------------------------------------------------------------------------------------- 12.8 listing starts
//Listing 12.8 Using virtual methods
#include <iostream>
using std::cout;

class Mammal
{
  public:
     Mammal():itsAge(1) { cout << "Mammal constructor...\n"; }
     virtual ~Mammal() { cout << "Mammal destructor...\n"; }
     void Move() const { cout << "Mammal move one step\n"; }
     virtual void Speak() const { cout << "Mammal speak!\n"; }   // Mammal is provided a virtual method speak(). The designer of this class thereby signals that he expects this class eventually to be another class's base type. The derived class will probably want to override this function. 
  
  protected:
     int itsAge;
};

class Dog : public Mammal
{
  public:
    Dog() { cout << "Dog Constructor...\n"; }
    virtual ~Dog() { cout << "Dog destructor...\n"; }
    void WagTail() { cout << "Wagging Tail...\n"; }
    void Speak()const { cout << "Woof!\n"; }
    void Move()const { cout << "Dog moves 5 steps...\n"; }
};

int main()
{
   Mammal *pDog = new Dog;  // a pointer to Mammal is created (pDog), but it is assigned the address of a new Dog object. Because a dog is a mammal, it is a legal assignment. 
   pDog->Move(); // the pointer pDog is then used to call the Move() function. Because the compiler knows pDog only to be a Mammal, it looks to the Mammal object to find the Move() method. Since in the class Mammal Move() is a standard non virtual method [void Move()] so the Mammal's version is called. 
   pDog->Speak(); // the pointer now calls the Speak() method. Because Speak() is virtual [as written in the above Mammal class "virtual void Speak()"] the Speak() method overridden in Dog is invoked.  Ecco perche' nell'output qui sotto compare il messaggio Woof! della Dog class e non il "Mammal speak" della base class Mammal. This is almost magical. As far as yhecalling function knew, it had a Mammal pointer, but here a method on Dog was call. In fact, if you had an array of pointers to Mammal, each of which pointed to a different subclass of Mammal, you could call each in turn, and the correct function would be called. The following 12.9 listing illustrates this idea

   return 0;
}
-------------------------------------------------------------------------------------------------------------------------------- 12.8 listing ends
OUTPUT
	[1042 Day12] >> g++ List1208.cpp -o List1208.exe
	[1043 Day12] >> ./List1208.exe 
	Mammal constructor...
	Dog Constructor...
	Mammal move one step
	Woof!
NOTE: 
aaahh rieccola 
   Mammal *pDog = new Dog;
   pDog->Move();
   pDog->Speak();
questa struttura mi sembra di averla vista piu' di una volta nei codici openFoam
-------------------------------------------------------------------------------------------------------------------------------- 12.9 listing starts
//Listing 12.9 Multiple virtual functions called in turn
// This program illustrates >> virtual functions in their purest form. 
#include <iostream>
using namespace std;

class Mammal
{
  public:
     Mammal():itsAge(1) {  }
     virtual ~Mammal() { }
     virtual void Speak() const { cout << "Mammal speak!\n"; }
  
  protected:
     int itsAge;
};

class Dog : public Mammal    // declaring class Dog derived from Mammal
{
  public:
    void Speak()const { cout << "Woof!\n"; }    // overriding  "virtual void Speak" of the Mammal class
};

class Cat : public Mammal // declaring class Cat derived from Mammal
{
  public:
    void Speak()const { cout << "Meow!\n"; }  // overriding  "virtual void Speak" of the Mammal class
};


class Horse : public Mammal // declaring class Horse derived from Mammal
{
  public:
    void Speak()const { cout << "Winnie!\n"; }   // overriding  "virtual void Speak" of the Mammal class
};

class Pig : public Mammal // declaring class Pig derived from Mammal
{
  public:
    void Speak()const { cout << "Oink!\n"; }   // overriding  "virtual void Speak" of the Mammal class
};

int main()
{
   Mammal* theArray[5];  // array of pointers 
   Mammal* ptr;  // creating pointer
   int choice, i;
   for ( i = 0; i<5; i++)
   {
      cout << "(1)dog (2)cat (3)horse (4)pig: ";
      cin >> choice;
      switch (choice)          // for each of the five loops the user is prompted to pick which object to create and a new pointer to that object is added to the array [vedi @tagAddPoiterToArray]from within the switch statement
      {
        case 1: ptr = new Dog;
                break;
        case 2: ptr = new Cat;
                break;
        case 3: ptr = new Horse;
                break;
        case 4: ptr = new Pig;
                break;
        default: ptr = new Mammal;
                 break;
      }
      theArray[i] = ptr;  // adding the pointer to the array  [@tagAddPoiterToArray]
   }
   for (i=0;i<5;i++)   // here the program loops through the array again. This time, each object in the array has its Speak() method called. Because Speak() was virtual in the vase class, the appropriate Speak() method are called for each type. You can see in  the output below tha tif oyu choose each different type, that the corresponding method is indeed called.
      theArray[i]->Speak();
   return 0;
}
-------------------------------------------------------------------------------------------------------------------------------- 12.9 listing ends
OUTPUT 
[1044 Day12] >> g++ List1209.cpp -o List1209.exe
[1045 Day12] >> ./List1209.exe 
(1)dog (2)cat (3)horse (4)pig: 1     # ad ogni linea ti chiede di inserire un numero da 1 a 4
(1)dog (2)cat (3)horse (4)pig: 3
(1)dog (2)cat (3)horse (4)pig: 2
(1)dog (2)cat (3)horse (4)pig: 4
(1)dog (2)cat (3)horse (4)pig: 7     # se typi un numero non compreso tra 1 e 4 allora come mostrato nell'ultima riga otterrai "Mammal speak" from the virtual Speak() of  Mammal
# una volta che hai terminato di inserire i numeri ti presenta l'output corrispondente a ciascuno degli numeri di input che hai inserito. 
Woof!    # visto che avevamo inserito 1
Winnie!  # visto che avevamo inserito 3
Meow!   # visto che aveavmo inserito 2
Oink!      # visto che avevamo inserito 4
Mammal speak! # visto che avevamo inserito 7, numero non compreso tra 1 e 4. 
-----------------------------------------------------------------------------------------------
NOTE: at the time this program is compiled, it is impossible to know which object types will be created, and thus which Speak() methods will be invoked. The pointer ptr is bound to its object at runtime. This is called >> dynamic binding or >> runtime binding, as opposed to static binding, or compile-time binding. 
FAQ: If I mark a member method as virtual in the base calss, do I need to also mark it as virtual in derived classes?
Answer: No, once a method is virtual, if you override it in derived classes, it remains virtual. It is a good idea (though not required) to continue to mark it virtual (this makes the code easier to understand).
>> VIRTUAL FUNCTIONS how they work [pag395 jesse]
When a derived object such  as a Dog object, is created, first the constructor for the base class is called, and then the constructor for the derived  class is called.
The picture below shows what the Dog object looks like after it is created. Note that the Mammal part of the object is contiguous in memory with the Dog part. 
                               ___________     \
Mammal part   {    |     mammal   |      |
                               -----------------        >  Dog Object
                               |        Dog       |     |
                               -----------------      /

When a virtual function is created in an object, the object must keep track of that function. Many compilers build a virtual function table called v-table (>> v-table / >> v table). One of these is kept for each type, and each object of that type keeps a virtual table pointer ( called >> vptr or  >> v-pointer / >> v pointer / >> v-ptr), which points to that table.
[guarda i disegnini e colori che ti ho messo a pag 396 jesse book ti aiutera' a comprendere]
Each object's vptr points to the v-table, that in turn, has a pointer to each of the virtual functions. When the Mammal  part of the Dog is created, the vptr is initialized to point to the correct part of the v-table. When the Dog constructor is called, and the Dog part of this object is added, the vptr is adjusted to point ot the virtual function overrides (if any) in the Dog object. When a pointer to a Mammal is used, the vptr continues to point to the correct function, depending on the "real" type of the object. Thus, when Speak() is invoked, the correct function is invoked. 
>> V-PTR definition in short (ripreso da pag487 jesse): the v-ptr or virtual function pointer, is an implementation detail of virtual functions. Each object in a class with virtual functions has a v-ptr, which points to the virtual function table for that class. The virtual function table is consulted when the compiler needs to determine which function to call in a particular situation.  
>> METHOD ACCESS from a base class [pag396 jesse]
>> TRYING TO ACCESS METHODS FROM A BASE CLASS
You have seen methods accessed in a derived class from a base class using virtual functions. What if there is a method in the derived class that isn't in the base class? Can you access it in the same way you have been using the base class to access the virtual methods? There shouldn't be a name conflict because only the derived class has the method. If the Dog object had a method, WagTail(), which is not in Mammal, ou could not use the pointer to Mammal to access that method. Because WagTail() is not a virtual function, and because it is not in a Mammal object, you can't get there without either a Dog object or a Dog pointer.  There is a way to access the WagTail() method and it will be explained in the lesson Day15 when multiple inheritance will be explained.
--------------------------------------------------------------------------------------------------------------------------------------
>> SLICING [pag397 jesse]
Note that the virtual function magic operates only on pointers and references. Passing an object by value does not enable the virtual function to be invoked. The following 12.10 listing illustrates this problem: 
---------------------------------------------------------------------------------------------------------------------------- START of FILE
//Listing 12.10 Data slicing with passing by value
#include <iostream>
using namespace std;
 
class Mammal
{
  public:
     Mammal():itsAge(1) {  }
     virtual ~Mammal() { }
     virtual void Speak() const { cout << "Mammal speak!\n"; }
   
  protected:
     int itsAge;
};

class Dog : public Mammal
{
  public:
    void Speak()const { cout << "Woof!\n"; }
};

class Cat : public Mammal
{
  public:
    void Speak()const { cout << "Meow!\n"; }
};

void ValueFunction (Mammal); // this function takes a Mammal object 
void PtrFunction (Mammal*); // this function takes a pointer to a Mammal
void RefFunction (Mammal&); // this function takes a Mammal reference.
int main()
{
   Mammal* ptr=0;
   int choice;
   while (1)
   {
      bool fQuit = false;
      cout << "(1)dog (2)cat (0)Quit: ";
      cin >> choice;
      switch (choice)
      {
        case 0: fQuit = true;
                break;
        case 1: ptr = new Dog;
                break;
        case 2: ptr = new Cat;
                break;
        default: ptr = new Mammal;
                 break;
      }
      if (fQuit==true)
         break;

      PtrFunction(ptr);
      RefFunction(*ptr);
      ValueFunction(*ptr);
   }
   return 0;
}

void ValueFunction (Mammal MammalValue)
{
   MammalValue.Speak();
}

void PtrFunction (Mammal * pMammal)
{
   pMammal->Speak();
}

void RefFunction (Mammal & rMammal)
{
   rMammal.Speak();
}
-------------------------------------------------- OUTPUT 
	[1046 Day12] >> g++ List1210.cpp -o List1210.exe
	[1047 Day12] >> ./List1210.exe 
	(1)dog (2)cat (0)Quit: 1
	Woof!    // from the PtrFunction, with the pointer puoi invocare la corretta Dog->Speak() member function
	Woof!    // from the RefFunction, with the pass by reference puoi invocare la corretta Dog->Speak() member function
	Mammal speak!   // from the ValueFunction:  the function expects a Mammal object, and so the compiler slices down the Dog object to just the Mammal part.  When the Mammal Speak() method is called only Mammal information is available. The Dog pieces are gone. This is reflected in this line of output "Mammal speak!". This effect is called slicing because the Dog portions (your derived class portions) of your object were sliced off when converting  to just a Mammal (the base class). 
	(1)dog (2)cat (0)Quit: 2
	Meow!
	Meow!
	Mammal speak!
	(1)dog (2)cat (0)Quit: 0
---------------------------------------------------------------------------------------------------------------------------- END of FILE
>> VIRTUAL DESTRUCTORS CREATION / >> CREATING VIRTUAL DESTRUCTORS [pag399 jesse]
It is legal and common to pass a pointer to  a derived object when a  pointer to a base object is expected. What happens when a pointer to a derived object subject is deleted? If the destructor is virtual, as it should be, the right thing happens, the derived class's destructor is called. Because the derived class's destructor automatically invokes the base class's destructor, the entire object is properly destroyed. 
The rule of thumb is this: if any of the functions in your class are virtual, the destructor should be as well. 
You should have noticed that the listings in today's lesson have been including virtual destructors. Now you know why! As a general practice, it is wise to always make destructors virtual. 
-------------------------------------------------------------------------------------------------------------------------------
>> VIRTUAL COPY CONSTRUCTORS [pag400 jesse book]
Constructors cannot be virtual, and so, technically, no such thing exists as a virtual copy constructor. Nonetheless, at times, your program desperately needs to be able to pass in a pointer to a base object and have a copy of the correct derived object that is created. A common solution to this problem is to create a Clone() method in the base class and to make that to be virtual. The Clone() method creates a new object copy of the current class and returns that object.
Because each derived class overrides the Clone() method, a copy of the derived class is created. 
------------------------------------------------------------------------- START VIRTUAL COPY CONSTRUCTOR EXAMPLE
//Listing 12.11 Virtual copy constructor
#include <iostream>
using namespace std;

class Mammal
{
  public:
     Mammal():itsAge(1) { cout << "Mammal constructor...\n"; }
     virtual ~Mammal() { cout << "Mammal destructor...\n"; }
     Mammal (const Mammal & rhs);
     virtual void Speak() const { cout << "Mammal speak!\n"; }
     virtual Mammal* Clone() { return new Mammal(*this); }    // adding new virtual method to the Mammal class. This Clone() method returns a pointer to a new Mammal object by calling the copy constructor, passing in itself (*this) as a constant reference. 
     int GetAge()const { return itsAge; }
  protected:
     int itsAge;
};

Mammal::Mammal (const Mammal & rhs):itsAge(rhs.GetAge())
{
   cout << "Mammal Copy Constructor...\n";
}

class Dog : public Mammal
{
  public:
    Dog() { cout << "Dog constructor...\n"; }
    virtual ~Dog() { cout << "Dog destructor...\n"; }
    Dog (const Dog & rhs);
    void Speak()const { cout << "Woof!\n"; }
    virtual Mammal* Clone() { return new Dog(*this); }  // overriding the Clone() method
};

Dog::Dog(const Dog & rhs):
Mammal(rhs)
{
   cout << "Dog copy constructor...\n";
}

class Cat : public Mammal
{
  public:
    Cat() { cout << "Cat constructor...\n"; }
    ~Cat() { cout << "Cat destructor...\n"; }
    Cat (const Cat &);
    void Speak()const { cout << "Meow!\n"; }
    virtual Mammal* Clone() { return new Cat(*this); }  // overriding the Clone() method
};

Cat::Cat(const Cat & rhs):
Mammal(rhs)
{
   cout << "Cat copy constructor...\n";
}

enum ANIMALS { MAMMAL, DOG, CAT};
const int NumAnimalTypes = 3;
int main()
{
   Mammal *theArray[NumAnimalTypes];
   Mammal* ptr;
   int choice, i;
   for ( i = 0; i<NumAnimalTypes; i++)
   {
      cout << "(1)dog (2)cat (3)Mammal: ";
      cin >> choice;
      switch (choice)
      {
        case DOG:   ptr = new Dog;
                   break;
        case CAT:   ptr = new Cat;
                   break;
        default:   ptr = new Mammal;
                   break;
      }
      theArray[i] = ptr;
   }
   Mammal *OtherArray[NumAnimalTypes];
   for (i=0;i<NumAnimalTypes;i++)
   {
      theArray[i]->Speak();
      OtherArray[i] = theArray[i]->Clone();
   }
   for (i=0;i<NumAnimalTypes;i++)
      OtherArray[i]->Speak();
   return 0;
} 
------------------------------------------------------------------------- END VIRTUAL COPY CONSTRUCTOR EXAMPLE 
>> VIRTUAL METHODS COST  [pag403 jesse]
Because objects with virtual methods must maintain a v-table, some overhead occurs in having virtual methods. If you have a very small class from which you do not expect to derive other classes, there might not be a reason to have any virtual methods at all. 
DO 
	- do use virtual methods when ou expect to derive from a class 
	- do use a virtual destructor if any methods are virtual
DON'T
	- don't mark the constructor as virtual 
	- don't try to access private data in a base class from a derived class
PUBLIC INHERITANCE and VIRTUAL FUNCTIONS summary [pag403 jesse book]
- classes inherit all the public and protected data and functions from their base functions
- protected access is public to derived classes and private to all other classes. Even derived classes cannot access private data or functions in their base classes.
- constructors can be initialized before the body of the constructor. At that time, the base constructors are invoked and parameters can be passed to the base class. 
- functions in the base class can be overridden in the derived class. If the base class functions are virtual, and if the object is accessed by pointer or reference, the derived class's functions will be invoked, based on the runtime type of the object pointed to. 
- methods in the base class can be invoked by explicitly naming the function with the prefix of the base class name and two colons. For example, if Dog inherits from Mammal, Mammal's walk() method can be called with Mammal::walk()
- in classes with virtual methods, the destructor should almost always be made virtual. A virtual destructor ensures that the derived part of the object will be freed when delete is called on the pointer. Constructors cannot be virtual. Virtual copy constructors can be effectively created by making a virtual member function that calles the copy constructor.   

Q&A
- Are inherited members and functions passed along to subsequent generations? If Dog derives from Mammal, and Mammal derives from Animal, does Dog inherit Animal's functions and data?
> YES. As derivation continues, derived classes inherit the sum of all the functions and data in all their base classes, but can only access those that are public or protected. 

- If, in the preceding example, Mammal overrides a function in Animal, which does Dog get, the original or the overridden functions?
> If Dog inherits from Mammal, it gets the overridden function. 

- Can a derived class make a public base function private?
> Yes the derive class can override the method and make it private. It then remains private for all subsequent derivation. However, this should  be avoided when possible, because users of your class will expect it to contain the sum of the methods privided by its ancentors. 

- What is a >> v-table ? [pag846 jesse book]
A v-table, or virtual function table, is a common way for compilers to manage virtual functions in C++. The table keeps a list of the addresses of all the virtual functions,  and depending on the runtime type of the object pointed to, invokes the right function.   

- What is a virtual destructor? 
A destructor of any class can be declared to be virtual. When the pointer is deleted, the runtime type of the object will be assessed and the correct derived destructor invoked. 

- How can you create a virtual copy constructor?
By creating a virtual method in your class, which itself calls the copy constructor. 

- How do you invoke a base member function from a derived class in which you've overridden that function?
Base::FunctionName();

- How do you invoke a base member function from a derived class in which you have not overridden that function?
FunctionName();

- If a base class delcares a function to be virtual, and a derived class does not use the term virutal when overriding that clas, is ti still virtual when inherited by a third generation class?
Yes the virtuality is inherited and cannot be turned off.

- What is the "protected" keyword used for?
"protected" members are accessible to the member functions of derived objects. 

- Show the declaration of a virtual function that takes an integer parameter and return void
	virtual void SomeFunction(int); 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> INHERITANCE ADVANCED / >> ADVANCED INHERITANCE [pag 538 jesse]
In the previous lessons of this book, you have worked with single and multiple ineheritance to create a "is-a" relationships. 
Today, you will learn
- what aggretation is and how to model it (the has-a relationship)
- what the delegation is and how to model it 
- how to implement one class in term of another 
- how to use private inheritance
---------------------------------------------------------------------------------------------
>> AGGREGATION [pag 539 jesse]
It is possible for the member data of a class to contain objects of other class types. This is often called aggregation, or the has-a relationship. 
Per fissare le idee mi sembra si possa distinguere la "is-a" relationship from a "has-a" relationship nel seguente modo. 
- IS A relationship example: 
supponi di avere una "WIZARD" class, e una "AVERAGE BOLD MAN" class. Se decidi che la average bold man class erediti dalla wizard class allora il risultato sara' un average bold man that IS A wizard! This is a IS-A relationship
- HAS A relationship example: 
supponi di avere una "PARRUCCA" class e una "AVERAGE BOLD MAN" class. Usando l'aggregation puoi fare in modo che the average bold man HAS A wig. But he IS NOT a wig. He's just not bold anymore because he HAS A wig!
(ti ho fatto anche dei bei disegnini a pag 538 jesse) 
-------------------------------------------------------------- back to Jesse's explanations: 
As an illustration, consider classes such as a Name class and an Address class:
Class Name 
{
	// Class information for Name 
};

Class Address
{
	// Class information for Address
};

As an illustration of aggregation, these two classes could be included as part of an Employee class: 

Class Employee
{
	Name EmpName;
	Address EmpAddress;
	// any other employee class stuff...
};
Thus an Employee class contains member variables for a name and for an address (Employee has-a Name and Employee has-an address o riferendoci al nostro esempio sopra the AVERAGE BOLD MAN has a WIG. He's happy now) 
A more complex example is presented in the Listing 16.1 [please refer to /run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/String01.hpp]
------------------------------------------------------------------------------------------
Listing 16.2 describes an Employee class that contains three string objects. These objects are used to hold an employee's first and last names as well as their address. 
For the source code please see /run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1602.cpp 
NOTE: Aggregated members don't have any special access to the members of the class within which they are aggregated. The only ability they have to access the instance that aggregates them is to have a copy of the owner class "this" pointer passed to them at the creation or at some point thereafter. If this is done, they have the same normal access to that object as they would to any other. 
-------------------------------------------------------------------------------------------------------------------------------------------------------
CONTROLLING ACCESS TO AGGREGATED MEMBERS [pag545 jesse]
Note that the String class provides an overloaded plus operator [ si riferisce a  line 129 of /run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/String01.hpp]
	26:  // creates a new string by adding current
	27:  // string to rhs
	28:  String String::operator+(const String& rhs)
The designer of the Employee class has blocked access to the operator+ being called on Employee objects by declaring that all the string accessors, such as GetFirstName(), return a constant reference. Because operator+ is not (and can't be) a const function (it changes the object it is called on), attempting to write the following causes a compile-time error: 
	String buffer = Edie.GetFirstName() + Edie.GetLastName();
GetFirstName() returns a constant String, and you can't call operator+ on a constant object. 
To fix this, overload GetFirstName() to be non-const:
	const String & GetFirstName() const {return itsFirstName; }
	String & GetFirstName() { return itsFirstName; }
Note that the return value is no longer "const" and that the member function itself is no longer "const". Changing just the return value is not sufficient to overload the function name, you must change the "constness" of the function itself.
------------------------------------------------------------------------------------------------------------------------------------------------------
>> AGGREGATION COST / >> COST OF AGGREGATION [pag547 jesse]
When you have aggregated objects, there can be a cost in performance. Each time an Employee string is constructed or copied, you are also constructing each of its aggregated string objects. E cio' ha puo' avere un certo costo in performance. 
-----------------------------------------------------------------------------------------------------------------------------
>> INHERITANCE vs >> AGGREGATION/DELEGATION [pag552 jesse]
At times one class wants to draw on some of the capabilities of another class. For example, suppose you need to create a PartsCatalog class. The specification you've been given defines a PartsCatalog as a collection of parts; each part has a unique part number. The PartsCatalog does not allow duplicate entries and does allow access by part number. 
The listing for the week in review for week 2 provides a PartsList class. This PartsList is well tested and understood, and you'd like to build on that when making your PartsCatalog, rather than inventing it from scratch. 
You could create a new PartsCatalog class and have it contain a PartsList. The PartsCatalog could delegate management of the linked list to its aggregated PartsList object. 
An alternative would be to make the PartsCatalog derive from PartsList and, thereby, inherit the properties of a PartsList. Remembering, however that public inheritance provides an "is-a" relationship, you should ask whether a PartsCatalog really is a type of PartslIst. 
One way to answer the question of whether PartsCatalog is a PartsList is to assume that PartsList is the base and PartsCatalog is the derived class, and then to ask these other questions: 

1) is anything in the base class that should not be in the derived? For example, does the PartList base class have functions that are inappropriate for the PartsCatalog class? If so, you probably don't want public inheritance
2) Might the class you are creating have more than one of the base? For example, might a PartsCatalog need two PartsLists to do its job? If it might, you almost certainly want to use aggregation. 
3) Do you need to inherit from the base class so that you can take advantage of virtual  functions or access protected members? If so, you must use inheritance, public or private. 

Based on the answers to these questions, you must choose between public inheritance (the is-a relationship) and either private inheritance (explained later today) or aggregation (the has-a relationship)
TERMINOLOGY SUMMARY 
>> AGGREGATION = declaring an object as a member of another class contained by that class. This is also referred to as has-a
>> DELEGATION = using the members of an aggregated class to perform functions for the containing class. 
>> IMPLEMENTED IN TERM OF = building  one class on the capabilities of another without using public inheritance (for instance, by using protected or private inheritance).
-----------------------------------------------------------------------------------------------------
>> DELEGATION [pag 533 jesse]
Why not derive PartsCatalog from PartsList? The PartsCatalog isn't a PartsList because PartsLists are ordered collections, and each member of the collection can repeat. The PartsCatalog has unique entries that are not ordered. The fifth member of the PartsCatalog is not part number 5. 
Certainly, it would have been possible to inherit publicy from PartsList and then overide Insert() and the offset operator() to do the right thing, but then you would have changed the essence of the PartsLIst class. Instead you'll build a PartsCatalog that has no offset operator, does not allow duplicates, and defines the operator+ to combine two sets.
The first way to accomplish this is with aggregation. The PartsCatalog will delegate list management to an aggregated PartsList. Listing 16.5 illustrates this approach (see /run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1605.cpp).
NOTE from the program: 
- some compilers cannot compile line 264, 
	void ShowAll() { thePartsList.Iterate(Part::Display); }
even though it is legal in C++. If your compiler complains about this line, change it to
	void ShowAll() { thePartsList.Iterate(&Part::Display); }
(note the addition of the ampersand in front of Part::Display.) If this fixes the problem, immediately call your compiler vendor and complain. (o chiama la polizia, querelali per truffa)
PUNTI notevoli del programma: 
- there is a new class "PartsCatalog" that has a PartsList as its data member to which it delegates list management. Another way to say this is that the PartsCatalog is IMPLEMENTED IN TERM OF this ParsList. 
	class PartsCatalog
	{
	  public:
		void Insert(Part *);
		int Exists(int PartNumber);
		Part * Get(int PartNumber);
		operator+(const PartsCatalog &);
		void ShowAll() { thePartsList.Iterate(Part::Display); }
	  private:
		PartsList thePartsList;  // delegation of the list management to the data member PartsList
	};
----------------------------------------
NOTE that clients of the PartsCatalog do not have access to the PartsList directly. You can see that PartsList is declared as a private member. The interface to this is through the PartsCatalog, and as such, the behaviour of the PartsList is dramatically changed. For example, the PartsCatalog::Insert() method [te lo riporto qui sotto] does not allow duplicate entries into the PartsList:
---------------------------------------
void PartsCatalog::Insert(Part * newPart)
{
   int partNumber =  newPart->GetPartNumber(); // come vedi ti chiede il Part Number per la nuova parte da inserire
   int offset;

   if (!thePartsList.Find(offset, partNumber))   // in modo che qualora il partNumber fosse gia' presente, viene Rejected
// nota come nella if condition utilizzi il "Find" method per vedere se il part number sia gia' presente o meno.
   {
      thePartsList.Insert(newPart);
   }
   else     
   {
      cout << partNumber << " was the ";
      switch (offset)
      {
        case 0:  cout << "first "; break;
        case 1:  cout << "second "; break;
        case 2:  cout << "third "; break;
        default: cout << offset+1 << "th ";
      }
      cout << "entry. Rejected!" << endl;
   }
}
---------------------------------------
NOTE: the mechanism of the actual iinsertion and the maintenance of the linked list, as well as searching and retreiving from the linked list, are maintained in the aggregated PartsList member of PartsCatalog. No reason exists for PartsCatalog to reproduce this code; it can take full advantage of the well-defined interface. 
This is the essence of reusability withing C++ : PartsCatalog can reuse the PartsList code, and the designer of PartsCatalog is free to ignore the implementation details of PartsList. The interface to PartsList (that is the class declaration) provides all the information needed by the designer of the PartsCatalog class. 
/////////////////////////////////////////////////////////////////////////////////////////////////////
------------------------------------------------------------------------------------------
[source code location 
/run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16]
-------------------------------------------------------------------------------------------
>> PRIVATE INHERITANCE [pag562 jesse]
If PartsCatalog needed access to the protected members of PartsList (in this case, none exist) or needed to override any of the PartsList methods, the PartsCatalog would be forced to inherit from PartsList. 
Because a PartsCatalog is not a PartsList object, and because you don't want to expose the entire set of functionality of PartsList to clients of PartsCatalog, you would need to use private inheritance. Private inheritance allows you to inherit from another class and to keep the internals of that class completely private to your derived class. 
The first thing to know about private inheritance is that all the base member variables and functions are treated as if they were declared to be private, regardless of their actual access level in the base. Thus, to any function that is not a member function of PartsCatalog, every function inherited from PartsList is inaccessible. This is critical: Private inheritance does not involve inheriting interface, only implementation. 
To clients of the PartsCatalog class, the PartsList class is invisible. None of its interface is available to them: they can't call any of its methods. They can call PartsCatalog methods; however, PartCatalog methods can then access all of PartsList because PartsCatalog is derived from PartsList. The important thing here is that the PartsCatalog isn't a PartsList, as would have been implied by public inheritance. It is implemented in terms of a PartsList, just as would have been the case with aggretation. 
Listing 16.6 demonstatrates the use of private inheritance by rewriting the PartsCatalog class as privately derived from PartsList. 
---------------------------------------------------------------------------------------------------------------------------------------------------------
source code see 
/run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1606.cpp
PUNTI SALIENTI del programma 
- line 253 : 
	class PartsCatalog : private PartsList // PartsCatalog is declared to derived privately from PartsList.
- line 260 :
	    void ShowAll() { Iterate(Part::Display); } // The PartsCatalog ShowAll() function on line 260 calls PartsList Iterate() with the appropriate pointer to member function of class Part. ShowAll() acts as a public interface to Iterate(), providing the correct information but preventing  client classes from calling Iterate() directly. Although PartsList might allow  other functions to be passed to Iterate(), PartsCatalog does not. 
- line 264 : 
	void PartsCatalog::Insert(Part * newPart)
	{
	   int partNumber =  newPart->GetPartNumber();
	   int offset;	 
	   if (!Find(offset, partNumber))  // FInd() now is called directly becauase it is inherited from the base class.
	   {
		  PartsList::Insert(newPart);  // Instert must be fully qualified (lo devi far precedere da "PartsList::" or it would endlessly recourse to itself)
	   }
// In short when methods of PartsCatalog want to call PartsList methods, they can do so directly. The only exception is when PartsCatalog has overridden the method and the PartsList version is needed, in which case the function name must be qualified fully. 
Private inheritance enables the PartsCatalog to inherit what it can use, but still provides mediated access to Insert() and other methods to which client classes should not have direct access. 
------------------------------------------------------------------------------
DO 
	- DO intherit publicy when the derived object is a kind of the base class.  [cioe' usa la public inheritance quando l'oggetto che derivi si puo' considerare come un "kind" cioe' una categoria/tipologia/specializzazione della base class]
	- DO use aggregation when you want to delegate functionality to another class, but you DON'T NEED ACCESS to its protected members. 
	- DO  use private inheritance when you need to implement one class in terms of another, and you NEED ACCESS to the base class's protected members. 

DON'T
	- DON'T use private inheritance when you need to use more than one instance of the base class. You must use aggregation. For example, if PartsCatalog needed two PartsLists, you could not have used private inheritance.
	- DON'T use public inheritance when members of the base class should not be available to clients of the derived class. 
-----------------------------------------------------------------------------------------------------------------------------------------------
>> FRIEND CLASSES / >> ADDING FRIEND CLASS [pag571 jesse]
IN SHORT 
if you want to expose your private member data or functions to another class, you must declare that class to be a FRIEND. and remember: 
- friendship cannot be transferred (= although you are my friend and Joe is your friend, that doesn't mean Joe is my friend)
- friendship is not inherited (= although you are my friend and I'm willing to share my secrets to you, that doesn't mean I'm willing to share my secrets with your children)
- friendship is not commutative (= you might be willing to tell me your secrets, but that doesn't mean I am willing to tell you mine)
IN LONG 
Sometimes, you will create classes together, as a set. For example, PartNode and PartsList were tightly coupled, and it would have been convenient if PartsList could have read PartNode's Part pointer "itsPart" directly.
You wouldn't want to make itsPart public, or even protected, because this is an implementation detail of PartNode and you want to keep it private. You do want to expose it to PartsList, however. 
If you want to expose your private member data or functions to another class, you must declare that class to be a friend. This extends the interface of your class to include the friend class. After a class declares another to be its friend, all of the declaring classes' member data and functions are public to the friend class. For example, if PartsNode declares PartsList to be a friend, all PartsNode's member data and functions are public as far as PartsList is concerned. 
It is important to note that friendship cannot be transferred. Although you are my friend and Joy is your friend, that doesn't mean Joe is my friend. Friendship is not inherited, either. Again, although you are my friend and I'm willing to share my secrets with you, that doesn't mean I'm willing to share my secrets with your children.
Finally, friendship is not commutative. Assigning Class One to be a friend of Class Two does not make Class Two a friend of Class One. You might be willing to tell me your secrets, but that doesn't mean I am willing to tell you mine. 
To declare a class as a friend, you use the C++ friend keyword: 
	class ClassOne
	{
		public:
			friend class BefriendedClass;
			...
In this example, ClassOne has declared BefriendedClass as its friend. This means that BefriendedClass now has full access to any of ClassOne's members. 
Listing 16.7 illustrates friendship by rewriting the example from Listing16.6 making PartsList a friend of PartNode. Note that this does not make PartNode a friend of PartsList.
Source code see 
/run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1607.cpp
PUNTI SALIENTI del programma
- line 79
    friend class PartsList;  // declaring PartsList as "friend" to the PartNode.
// This friend declaration has been placed in the public section, but this is not required. It can be put anywhere in the class declaration without changing the meaning of the statement. Because of this statement, all the private member data and functions are now available to any member function of class PartsList. 
- line 157-160
	Part*   PartsList::GetFirst() const
	{
	   if (pHead)
		  return pHead->itsPart;
// the implementation of GetFirst() reflects the change of declaring PartsList as friend to PartNode. Rather than returning  pHead->GetPart, this function can now return the otherwise private member data by writing pHead->itsPart. Similary  
ACHTUNG! / ATTENZIONE! / ATTENTION please : declarations of friend classes should be used with extreme caution. If two classes are inextricably entwined, and one must frequently access data in the other, good reason might exist to use this declaration. But use it sparingly; it is often just as easy to use the public accessor methods, and doing so enables you to change one class without having to recompile the other.
NOTE: you will often hear novice C++ programmers complain that friend declaration "undermine" the encapsulation so important to object-oriented programming. This is not necessarily true. The friend declaration makes the declared friend part of the class interface and does not have to undermine encapsulation. Use of a friend implies a commitment  to parallel maintenance of both classes, which could reduce modularity. 
SUMMARY FRIEND CLASS:
Friend Class:  Declare one class to be friend of another by putting the wod "friend" into the class granting the access rights. That is, I can declare you to be my friend, but you can't declare yourself  to be my friend. 
Example 
 	class PartNode
	{
		public:
			friend class PartsList; // declares PartsList to be a friend of PartNode
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> FRIEND FUNCTIONS [pag 580 jesse]
You just learned that declaring another class a friend gives it total access. At times, you might want to grant this level of access not to an entire class, but only to one or two functions of that class. You can do this by declaring the member functions of the other class to be friends, rather than declaring the entire class to be  a friend. In fact, you can deeclare any function, regardless of whether it is a member function of another class, to be a friend function. 
>> FRIEND FUNCTIONS and OPERATOR OVERLOADING [pag580jesse]
Listing 16.1 provided a String class that overrode the operator +. It also provided a constructor that took a constant character pointer, so that string objects could be created from C-style strings. This enabled you to create a string  and add it to it with a C-style string. 
NOTE: C-style strings are null-terminated character arrays, such as char myString[] = "Hello World". 
What you could not do, however, was create a C-style string (a character string) and add to it using a string object, as shown in this example:
	char cString[] = {"Hello"};
	String sString(" World");
	String sStringTwo = cString + sString; // error!
C-style strings don't have an overloaded operator+. As discussed on Day 10, "Working with Advanced Functions", when you say cString + sString; what you really calling is cString.operator+(sString). Because you can't calll operator+() on a C-style string, this causes a compile-time error. 
You can solve this problem by declaring a friend  in String, which overloads operator+ but takes two string objects. The C-style string is converted to a string object by the appropriate constructor, and then operator+ is called using the two string objects. To clarify this, take a look at Listing 16.8 [/run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1608.cpp]
PUNTI SALIENTI del CODICE: 
- line 20 
	    friend String operator+(const String&, const String&); // a new operator+ is overloaded to take two constant string references and to return a string, and this function is declared to be friend. 
// note that this operator+ is not a member function of this or any other class. It is declared within the declaration of the String class only so that it can be made a friend, but because it is declared, no other function prototype is needed. 
- lines 143-154 : implementation of the operator+ that takes two strings and accesses them both through their public accessor methods. 
	// creates a new string by adding
	// one string to another
	String operator+(const String& lhs, const String& rhs)
	{
	   int  totalLen = lhs.GetLen() + rhs.GetLen();
	   String temp(totalLen);
	   int i, j;
	   for (i = 0; i<lhs.GetLen(); i++)
		  temp[i] = lhs[i];
	   for (j = 0, i = lhs.GetLen(); j<rhs.GetLen(); j++, i++)
		  temp[i] = rhs[j];
	   temp[totalLen]='\0';
	   return temp;
	}
- line 172 now the operator+ can be called on a C-style string: 
 	s5 = c1 + s2;
--------------------------------------------------------------------------------------------------------------------------------------------
>> FRIEND FUNCTIONS SUMMARY [pag585 jesse]
Declare a function to be a friend by using the keyword "friend" and then the full specification of the function. Declaring a function to be a friend does not give the friend  function access to your "this" pointer, but it does provide full access to all private and protected member data and functions. 
Example : 
	class PartNode
	{   // ...
		// make another class's member function a _friend
		friend void PartsList::Insert(Part *);
		// make a global function a friend 
		friend int SomeFunction();
		...
	};
---------------------------------------------------------------------------------------------------------------------------------------
>> INSERTION OPERATOR OVERLOADING / >> OVERLOADING INSERTION OPERATOR [pag585 jesse]
You are finally ready to give your String class the capability to use cout the same as any other type. Until now, when you've wanted to print a string, you've been forced to write the following : 
	cout << theString.GetString();
What you would like to do is write this: 
	cout << theString;
To accomplish this, you must override operator <<(). Day 17, "Working with streams" presents the ins and outs of working with iostreams; for now the following listing 16.9 illustrates how operator << can be overloaded using a friend function. 
SOURCE CODE see 
	/run/media/alseny/BLACKBIRD/Source-Code-Books/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day16/List1609.cpp
TRATTI SALIENTI DEL CODICE : 
- line 21 and 22
    friend ostream& operator<<
       ( ostream& theStream,String& theString);
// in these lines operator << is declared to be a friend function that takes an ostream reference and a String reference and then returns an ostream reference.  
// Note that this is not a member function of String. It returns a reference to an ostream so that you cadn concatenate calls to operator <<  such as this: 
	cout << "myAge: " << itsAge << " years." ;
- line 157-161 here you find the implementation of this friend function. 
	// int String::ConstructorCount =
	ostream& operator<< ( ostream& theStream,String& theString)
	{
	   theStream << theString.itsString;
	   return theStream;
	}
// all this really does is hide the implementation details of feeding the string to the ostream, and that is just as it should be. 
---------------------------------------------------------------------------------------------------------------------------------------
SUMMARY [pag589 jesse]
In this lesson, e say how to delegate functionality to an aggregated object. You also saw how to implement one class in terms of another by using either aggregation or private inheritance. Aggregation is restricted in that the new class does not have access to the protected members of the aggregated class, and it cannot override the member function of the aggregated object. Aggregation is simpler to use than inheritance, and should be used when possible. 
You also saw how to declare both friend classes and friend functions. Using a friend function, you saw how to overload the extraction operator, to allow your new classes to use cout the same as the built-in classes do. 
Remember that public inheritance expresses "is-a", aggregation expresses "has-a", and private inheritance expresses "implemented in terms of ". The relationship "delegates-to" can be expressed using either aggregation or private inheritance, although aggregation is more common.  
----------------------------------------------------------------------------------------------
Q&A
	- Q: why is it so important to distinguish between a "is-a" , "has-a" and "implemented in terms of"
	> A: the point of C++ is to implement well-designed, object oriented programs. Keeping these relationships straight helps to ensure that your design corresponds to the reality of what you are modelling. Furthermore, a well-understood design will more likely be reflected in well-design code. 

	- Q: what is >> containment ?
	> A: Containment is another word for aggregation.

	- Q: Why is aggregation preferred over private inheritance ?
	> A: The challenge in modern programming is to cope with complexity. The more you can use objects as black boxes, the fewer details you have to worry about and the more complexity you can manage. Aggregated classes hide their details; private inheritance exposes the implementation details. To some extent, this is also true for conventional public inheritance, which is sometimes used when aggregation would be a better solution. 

	- Q: Why not make all classes friends of all the classes they use?
	> A: Making one class a friend of another exposes the implementation details and reduces encapsulation. The idea is to keep as many of the details of each class hidden from all other classes as possible. 	

	- Q: If a function is overloaded, do I need to declare each form of the function to be  a friend?
	> A: Yes, if you overload a function and declare it to be a friend of another class, you must declare a friend for each form to which you want to grant this access. 

	- Q: How do you establish an is-a relationship?
	> A: An is-a relationship is established with public inheritance.

	- Q: How do you establish a has-a relationship?
	> A: A has-a relationship is established with aggregation (containment); that is, one class has a member that is an object of another type.

	- Q: What is the difference between aggregation and delegation?
	> A: Aggregation describes the idea of one class having a data member that is an object of another type. Delegation expresses the idea that one clas uses another class to accomplish a task or goal.

	- Q: What is the difference between delegation and "implemented in terms of" ?
	> A: Delegation expresses the idea that one class uses another class to accomplish a task or goal. "Implemented in terms of" expresses the idea of inheriting implementation from another class.

	- Q: What is a friend function?
	> A: A friend function is a function declared to have access to the protected and private members of your class.

	- Q: What is a friend class?
	> A: A friend class is a class declared so that all of its member functions are friend functions of your class. 

	- Q: Where must the declaration of a friend function appear?
	> A: A declaration for a friend function can appear anywhere within the class declaration. It makes no difference whether you put the declaration within the "public:", "protected:", or "private:" access areas.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> COMPOUND ASSIGNMENT OPERATORS (+=, -=, /=, *=)
They are useful when we want to perform an operation on the value currently stored in that variable. 
    Expression:        | Is equivalent to:
    value += increase; | value = value + increase;
    a -= 5;            | a = a - 5;
    a /= b;            | a = a / b;
    price *= units +1; | price = price * (units +1);
NB notare come sebbene la right left rule sia sempre valida, l'operatore doppio viene letto nella direzione left->right (a -=5 : prima sottrai [-] 5 ad a quindi assegni [=] il risultato ottenuto ad a

 OPERATION [tipo per convertire un "char" in "int" ect] / >> CAST OPERATOR
[pag 467 deitel]
You can use "cast operators" to force conversions among fundamental types.
A conversion operator (also called a cast operator) can be used to convert an object of one class to another type. Such conversion operator must be a non-static member function. 
Nel caso di conversione tra user-defined types (cioe' type che sono stati definiti dall'utente) since the compiler cannot know in advance how to convert something defined by the user, we need to use a conversion constructor 
NOTE: from pag 468 deitel
Onde evitare indotti da implicit conversions, meglio usare >> explicit constructors example
	explicit Array (int = 10) ; 
the reason to declare every single argument contructor preceded by the keyword explicit is to suppress implicit conversions via conversion constructors when such conversion should not be allowed.
In tal modo anziche' cadere nella nebbia confusa della conversione implicita, con l'esplicito, qualora avvenisse una conversione non ammessa ti esce bello chiaro un messaggio di errore.
Tipo [pag 470]
>> ERROR
cannot convert parameter ... Reason: cannot convert from 'int' to 'const Array'
Constructor from class 'Array' is declared 'explicit'    
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 USER DEFINED / >> USER DEFINED CONVERSION [pag214 moo book]
User defined conversion say how to transform to and from objects of class type. As with built-in conversions, the compiler will apply user defined conversions to convert a value into the type that is needed.

 operators [pag222 moo book] 
A conversion operator says how to convert an object from its type to a target type.

>> CONDITIONAL OPERATOR ?:
[pag113 deitel] [see also >> conditional ternary operator pag 94 jesse ]
Example
	cout << ( antiGrav >= 1000 ? "Levitating" : "Not levitating");
the first operand is a condition, the second operand is the value for the entire conditional expression if the condition is true and the third operand is the value for the entire conditional expression if the condition is false. 
The conditional operator is l'unico operatore ternario in C++, cioe' l'unico operatore che prenda 3 operandi. The operands, together with the conditional operator, form a CONDITIONAL EXPRESSION.
NB: le parentesi tonde nell'espressione sopra sono necessarie visto che la priorita' del conditional operator e' bassa (the precedence of the conditional operator is low).
Se non vuoi usare le parentesi puoi anche scriverlo nel seguente modo 
	antiGrav >= 1000? cout << "Levitating" : cout << "Not levitating";
[questa sintassi e' valida visto che the values in a conditional expression also can be actions to execute]
la precedente espressione e' letta: se antiGrav > 1000 then cout << "Levitating"; otherwise cout << "Not levitating"
ADDITIONAL INFO from stackoverflow
>> ? meaning
 http://stackoverflow.com/questions/795286/what-does-do-in-c

condition ? result_if_true : result_if_false

... if the condition evaluates to true, the expression evaluates to result_if_true, otherwise it evaluates to result_if_false.

quindi le due forme sottostanti sono del tutto equivalenti 
	int qempty()
	{
		return (f == r ? 1 : 0);
	}
equivale a :
	int qempty()
	{
	  if(f == r)
	  {
		  return 1;
	  }
	  else
	  {
		  return 0;
	  }
	}
/////////////////////////////////////////////////////////////////////////

>> CONSOLE PROGRAM : it is a program that uses text to communicate with the user and to show their results (per esempio attraverso una delle classiche DOS black windows)

>> CONST 
with the const prefix we can declare constants with a specific type in the same way as you would do with a variable: 
ex
	const int pathwidth = 100; 
	const char tabulator = '\t';
- here pathwidth and tabulator are treated just like regular variables except that their values cannot be modified after their definition

>> const object and >> const Member functions
[pag402deitel]
You may use keyword "const" to specify that an object is not modifiable and that any attempt to modify the object should result in a compilation error. The statement
	const Time noon( 12, 0, 0);
declares a "const" object noon of class "Time" and initializes it to 12 noon. It's possible to instantiate "const" and "non-const" objects of the same class.
PERFORMANCE: declaring variables and objects "const" when appropriate can improve performance: compilers can perform optimization on constants that cannot be performed on non-const variables.
NOTE: C++ disallows member function calls for "const" objects unless the member functions themselves are also declares "const". This is true even for "get" member functions that do not modify the object. This is also a key reason for declaring as "const" all member-functions that do not modify the objects on which they're called.
Note2: defining as "const" a member function that modifies a data member of the object is a compilation error. 
Note3: defining as const a member function that calls a non-csont member function of the class on the same object is a compilation error.
Note4: invoking a non-const member function on a const object is a compilation error.
Note5: an interesting problem arises for constructores and destructors, each of which typically modifies objects. A constructor must be allowed to modify an object so that the object can be initialized properly. A destructor must be able to perform its termination housekeeping chores before an object's memory is reclaimed by the system. Attempting to declare a constructor or destructor const is a compilation error.

>> CONSTANT VARIABLES
[pag284deitel] 
Constant variables (also called "named constant" or "read-only variables") must be initialized when they are declared and cannot be modified thereafter. 
Example 1 [corretto] 
#include <iostream>
using namespace std;
int main()
{
   const int x = 7; // initialized constant variable
   cout << "The value of constant variable x is: " << x << endl;
} // end main
// ------------------------------------------------------------
Example 2 [incorretto]
int main()
{
   const int x; // Error: x must be initialized
   x = 7; // Error: cannot modify a const variable
} // end main
// ------------------------------------------------------------
/////////////////////////
Altro esempio from Mike pag29
	const int ALIEN_POINTS = 150;
una volta definita tale costante possiamo usare ALIEN_POINTS just like any integer literal. Also notice that the name we chose for the constant is in all CAPITAL LETTERS. This is just a convention, but it's a common one. An identifier in all caps tells a programmer that it represents a constant value. 
NOTE: you can't assign a new value to a constant. If you try, you'll get a compile error.
	

	vedi anche voce >> ASSAY SIZE specifying with constant variable

>> CONSTRUCTOR [pag190 moo book]
The role of any constructor is to ensure that the object is correctly initialized. 

>> CONSTRUCTOR 
[pag79deitel]
A constructor can be used to initialize an object of the class when the object is created. 
A constructor is a special member function that must be defined with the SAME NAME as the class, so that the compiler can distinguish it from the class's other member functions
See example pag 80 
- An important difference between constructors and other functions is that constructors cannot return values, so they cannot specify a return type (not even void).
- Also a constructor cannot be declared const (because initializing an object modifies it)
> INITIALIZING OBJECTS with constructors see pag 81
Observation
- notice that both the constructor and the member function (like line 21 pag80) can use the same parameter. You can use the same parameter names in different functions because the parameters are local to each function - they do not interfere with one another.
- Constructor notation in UML diagram [pag83]
1) to distinguish a constructor from a class's operations, the UML places the word "constructor" between << >> before the constructor's name. Example
	<<constructor>> + GradeBook( name : String )
2) By convection, you list the class's constructor before other operations in the third compartment.
- DEFAULT CONSTRUCTOR (pag82) = a default constructor is any constructor that takes no arguments. 
EXAMPLES
- pag 300 bel esempio pratico di applicazione lessicale "constructor, data member" : 
Come al solito abbiamo i tre personaggi 
un GradeBook.cpp where the classes are defined
un GradeBook.h where the classes are declared
un main.cpp where the classes are used
> the class constructor is DECLARED in the GradeBook.h
> the class constructor is DEFINED in the GradeBook.cpp
> the program that contains the main{} creates a GradeBook object and passes an existing int array to the constructor, which copies the array's values into the DATA MEMBERS grades (in the *.cpp module, where the functions are defined)
[see also 
http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
http://www.tutorialspoint.com/cplusplus/cpp_constructor_destructor.htm
salvati in blackbird]

>> CONSTRUCTOR with DEFAULT ARGUMENTS
[pag387 deitel]
Esempio di constructor with default argument [gli arguments vengono settati di default all'interno dell'header file]
A) Extract from the Time.h in directory fig09_04_06
	public:
	   explicit Time( int = 0, int = 0, int = 0 ); // default constructor
e il suo relativo main ccp file Time.cpp: 
	// Time constructor initializes each data member 
	Time::Time( int hour, int minute, int second ) 
	{ 
	   setTime( hour, minute, second ); // validate and set time
	} // end Time constructor
B) Extract from the Time.h [esempio di constructor senza default parameters] in dir fig09_01_03
	public:
   		Time(); // constructor
e il suo relativo main ccp file Time.cpp file:
	// Time constructor initializes each data member to zero.
	Time::Time() 
	   : hour( 0 ), minute( 0 ), second( 0 )
NOTE: quali sono i vantaggi di assegnare default arguments to the constructor come nell'esempio A?
	explicit Time( int = 0, int = 0, int = 0 );
The default arguments  to the constructor ensure that, ven if no values are provided in a constrcutor call, the constructor still initializes data members. A constructor that defaults all its arguments is also a default constructor (that is a constructor that can be invoked with no arguments). There can be at most one default constructor per class.
NOTE2[pag388deitel]: any change to the default argument values of a function requires the client code to be recompiled (to ensure the program still functions correctly)
NOTE3: pag391deitel If a member function of a class already provides all or part of the functionality required by a constructor (or other member function) of the class, call that member function from the constructor (or other member function). This simplifies the maintenance of the code and reduces the likehood of an error if the implementation of the code is modified. As a general rule : Avoid repeating code. AVOID REPEATING CODE. 
//////////////////////////////////////////////////////////////////////////////////

>> CONSTRUCTOR [pag 164 moo book]
We know that the library guarantees that when we create an object of a library calss, the object starts with an appropriate value. For example when we define a string or a vector without an initial value, we get an empty string or vector. 
Constructors are special member functions that define how objects are initiazed. There is no way to call a constructor explicitly. Instead, creatin an object of class type cals the approrate constructor automatically as a side effect.
The synthesized constructor will initialize the data members to a value that depends on how the object is being created. [the rules are a bit complicated for the details please see star tag at pag 164 we gotta go for topology quantum gravity and navier stokes smoothness]
Quando non si usano constructor, al momento della creazione dell'oggetto si avra' una default initialization, this can give to the object undefined values, meaning they will hold whatever garbage happens to be in memory when the object is created. Cio' e' del tutto harmless a patto che prima di effettuare delle operazioni sugli oggetti non ci dimentichiamo di inizializzarli assegnando loro delle valori appropriati. 
However it is normally good practice to ensure that every data member as a sensible value at all times. For example, it is possible that later we (or a subsequent maintainer of our code) will add operations that examine these data members. If we don't initialize them in the constructor, then these new operations might cause future failures. 
CONSTRUCTORS are distinguished from other member functions in two ways: 
1) They have the same name as the name of the class itself.
2) They have no return type.
>> DEFAULT CONSTRUCTOR [pag165 moo book]
The constructor that takes no arguments is known as the default constructor. Its job is normally to ensure that its object's data members are properly initialized. 
In the case of Student_info objects (example at pag165) we want the "homework" member to be an empty vector, the n member to be an empty string, and the midterm and final members to be initialized to zero
	Student_info::Student_info(): midterm(0), final(0) { }
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter09/Student_info.cc]
The constructor definition uses some new syntax. Between the : and the { is a sequence of >> constructor initializers, which tell the compiler to initialize the given members with the values that appear between the corresponding parentheses [cioe' i valori compresi tra le parentesi tonde "0" e "0" verranno assegnati rispettivamente a midterm e final]
Understading constructor initializers is crucial to understading how to create and iniliaze objects. 
When we create a new class object, several steps happen in sequence:
	1) the implementation allocates memory to hold the object
	2) it initializes the object using initial values as specified in the initializer list
	3) it executes the construtor body.
Cioe' detto con una metafora sociologica
	1) prepari le culle
	2) ci metti dentro i pargoli (~ valori initiali)
	3) fai andare i pargoli a scuola, in modo da modificarli e renderli utili alla "societa'" del programma.
The constructor body may change these initial values subsequently, but the initialization happens before the constructor body begins execution. It is usually better to give a member an initial value explicitly, rather than assigning to it in the body of the constructor. By initializing rather than assigning a value, we avoid doing the same work twice.
>> CONSTRUCTORS WITH ARGUMENTS [pag166]
example in  /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter09/Student_info.cc]
	Student_info::Student_info(istream& is) { read(is); }	
this constructor delegates the real work to the "read" function. The constructor has no explicit initializer, so the homework and n members will be initialized by the default constructors for vector and string respectively. The midterm and final members will have explicit initial values only if the object is being value-initialized. This lack of initialization doesn't matter, because read immediately gives these variables new values.
//////////////////////////////////////////////////////////////////////////////////


>> CALL FUNCTION / >> MAIN FUNCTION [pag2 moo book]   
A function is a piece of program that has a name, and that another part of the program can CALL, or cause to run. Every C++ program must contain a function named "main". When we ask the C++ implementation to run a program, it does so by calling the "main" function.
The main function is required to yield an integer as its result, the purpose of which is to tell the implementation whether the program ran successfully. A zero value indicates success; any other value means there was a problem. 
Example 	
	int main()
to say that we are defining a function named main that returns a value of type int.

>> CALL FUNCTION simple example from SAMS Jesse Book [pag35 jesse]
#include <iostream>
  
// function Demonstration Function
// prints out a useful message
void DemonstrationFunction()    // header of the function = return_type FUNCTION_NAME (parameters to that function)
{
   std::cout << "In Demonstration Function\n";
}
  
// function main - prints out a message, then
// calls DemonstrationFunction, then prints out
// a second message.
int main()
{
    std::cout << "In main\n" ;
    DemonstrationFunction();
    std::cout << "Back in main\n";
    return 0;
}
////////////////////////////////////////////////////////////////////////////////////


>> constructors and destructors for local objects // >> local object constructor deconstructors // >> deconstructors local objects // >> call constructors and destructors 
[pag394deitel]
The constructor for a local object is called when execution reaches the point where that object is defined.
The corresponding destructor is called when execution leaves the object's scope (i.e. the block in which that object is defined has finished executing). Constructors and destructors for local objects are called each time execution enters and leaves the scope of the object. Destructors are not called for local objects if the program terminates with  call to function "exit" or function "abort"
IN SOSTANZA: come spiegato nell'esempio di pagina 395-396deitel l'oggetto il cui constructor verra' chiamato per primo, sara' quello il cui destructor sara' chiamato per ultimo. Cioe' che accade nelle pagine 395-396 fig 9.9 sara' schematizzabile cosi'
---- global object "first" -- constructor chiamato per primo -----------------------------|
---- local object "second" -- constructor chiamato per secondo --------------------|      |
---- static object "third" -- constructor chiamato per terzo -------------|        |      |
---- local object "fourth" -- constructor chiamato per ultimo --|         |        |      |
                                                             fourth     third    second  first
----------------------------- destructor chiamato per primo ----|         |        |      |
----------------------------- destructor chiamato per secondo ------------|--------|      |
----------------------------- destructor chiamato per terzo --------------|               |
 ---------------------------- destructor chiamato per ultimo -----------------------------|
NOTE: global is called before any statements in main execute and its destructor is called at program termination after the destructors for all objects with automatic storage duration have run.
NOTE2: lo static object "third" sopravvive a "second" visto che non e' local bensi "static". A "static" object exists until program termination. The destructor for object third is called before the destructor for global object "first" but after all other objects are destroyed.
//////////////////////////////////////////////////////////////////////////////////////////

>> constructors and destructors for static objects
[pag394deitel]
The cosntructor for a static local object is called only "once", when the execution first reaches the point where the object is defined. The corresponding destructor is called when main terminates or the program calles function exit. Global and static objects are destroyed in the reverse order of their creation. Destructors are not called for static objects if the program terminates with a call to function "abort".
>> CONSTRUCTOR AND DECONSTRUCTOR CALLING DEMONSTRATION -> see CreateandDestroy.h chapter 9 [/home/dia/Deitel-Code_Examples/ch09/fig09_07_09/]

>> CONSTRUCTORS [PAG246 MIKE game programming]
when you instantiate objects, you often want to do some initialization (usually assigning values to data members). Luckily, a class has a special member function known as a constructor that is called automatically every time a new object is instantiated. This is a big convenience because you can use a constructor to perform initialization of the new object.
NOTE: the constructor has no return type. And you have to give it the same name as the class ifself.
HINT: [pag248 mike game programming] A default constructor requires no arguments. If you don'T define a default constructor, the compiler defines a minimal one for you that simply calls the default constructors of any data members of the class. If you write your own constructor, then the compiler won't provide a default constructor for you. It's usually a good idea to have a default constructor, so you should make sure to supply your own when necessary. One way to accomplish this is to supply default arguments for all parameters in a constructor definition.
--------------------------------------------------------------- FULL EXAMPLE  [from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/constructor_critter.cpp]
	//Constructor Critter
	//Demonstrates constructors	
	#include <iostream>
	using namespace std;
	class Critter
	{
	public:
	    int m_Hunger;
	    // >> DECLARE CONSTRUCTOR EXAMPLE in the following line / >> CONSTRUCTOR DECLARE / >> CONSTRUCTOR PROTOTYPE
	    Critter(int hunger = 0);       // constructor prototype
// NOTE about the line precedente where we declare a constructor
// the constructor has no return type. It can't; it's illegal to specify a return type for a construtor. Also you have no flexibility when naming a constructor. And you have to give it the same name as the class ifself.
	    void Greet();
	};
	
    // >> DEFINE CONSTRUCTOR EXAMPLE in the following line / >> CONSTRUCTOR DEFINE
	Critter::Critter(int hunger)       // constructor definition
	{
	    cout << "A new critter has been born!" << endl;
	    m_Hunger = hunger;
	}
    // >> END CONSTRUCTOR DEFINITION
	// note: the constructor initializes the oject's m_Hunger data member with the argument value passed to the constructor. IF NO VALUE IS PASSED, then the constructor uses the default argument value of 0.
	
	void Critter::Greet()             
	{
	    cout << "Hi. I'm a critter. My hunger level is " << m_Hunger << ".\n\n";
	}
	
	int main()
	{    
// calling a constructor automatically: you don't explicitly call a constructor; however, whenever you instantiate a new object, its constructor is automatically called. We put the constructor into action with the following code:
	    Critter crit(7); 
// NOTE: when "crit" is instantiated its constructor is automatically called and the message "A new critter has been born!" is displayed
// then the constructor assigns 7 to the object's m_Hunger data member.	
	    crit.Greet(); // to prove that the constructor worked, back in main(), we call the object's Greet() member function and sure enough, it displays "Hi. I'm a critter. My hunger level is 7."

	    return 0;
	}
--------------------------------------------------------------- END FULL EXAMPLE
OUTPUT of the program:
	A new critter has been born!
	Hi. I'm a critter. My hunger level is 7.
---------------------------------------------------------------
>> MEMBER INITIALIZATION / >> MEMBER INITIALIZERS [pag248 mike game programming]
You can use member initializers as a shorthand way to assign value to data members in a construtor. To write a member initialiser, start with a colon after the constructor's parameter list. Then type the name of the data member you want to initialize, followed by the expression you want to assign to the data member, surrounded by parentheses. If you have multiple initializers, separate them with commas. This is much simpler than it sounds (and it's really useful too). Here's an example that assigns hunger to m_Hunger and boredom to m_Boredom. Member initializers are especially useful when you have many data members to initialize.
	Critter::Critter(int hunger = 0, int boredom = 0):
		m_Hunger(hunger),
		m_Boredom(boredom)
	{} // empty constructor body 
///////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINER 
[pag213deitel]
Containers store data during program execution. There are various headers of the C++ standard library che implementano containers.
- <array>         |
  <vector>        |
  <list>          |
  <forward_list>  |
  <deque>         |
  <queue>         |----> these headers contain classes 
  <stack>         |      that implement the C++ standard library 
  <map>           |      containers [anche qui navi portacontainers]. 
  <unordered_map> |      
  <unordered_set> |
  <set>           |
  <bitset>        |  
/////////////////////////////////////////////
>> performance and choosing the appropriate container [pag 649 deitel]
Each container typically provides a variety of other capabilities. Many of these are common to several containers, but they're not always equally efficient for each container.
NOTE1: it's usually preferable to reause Standard Library containers, rather than developing customized templatized data structures. For novice, "vector" is typically satisfactory for most applications.
NOTE2 performance tip: insertion at the back of a "vector" is efficient. The vector simply grows, if necessary, to accommodate the new item. It's expensive to insert (or delete) an element in the middle of a "vector" (the entire portion of the vector after the insertion (or deletion) point must be moved, because vector elements occupy contiguous cells in memory)
NOTE3: applications that require frequent insertion and deletions at both ends of a container normally use a "deque" rather than a vector. Although we can insert and delete elements at the fron and back of both a vector and a deque, class deque is more efficient than vector for doing insertions and deletions at the front.
NOTE4: applications with frequent insertion and deletions in the middle and or at the extremes of a container normally use a "list", due to its efficient implementation of insertion and deletion anywhere in the data structure.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINERS and ITERATORS resume / >> CONTAINERS SUMMARY [pag96 moo book]
The standard library is designed so that similar operations on different containers have the same interface and the same semantics.
I container presentati a pag 96 97 moo book, sono dei sequential containers. 
All the sequential container and the "string" type provide the following operations: 
	container<T>::iterator
	container<T>::const_iterator
			The name of the type of the iterator on this container.
	container<T>..size_type
			The name of the appropriate type to hold the size of the largest possible instance of this container.
	c.begin()
	c.end()      Iterator referring to the last and (one past) the last element in the container
	c.rbegin
	c.rend()     Iterator referring to the last and (one beyond) the first element in the container that grant access to the container's elements in reverse order. 
	container<T> c;
	container<T> c(c2);   Defines c as a container that is empty or a copy of c2 if given
	container<T> c(n);    Defines c as a continer with n elements that are value-initialized according to the type of T. If T is a clas type, that type will control how to initialize the elements. If T is a built-in arithmetic type, then the elements will be initialized to 0.
	container<T> c(n, t); Defines c as a container with n elements that are copies of t.
	container<T> c(b, e); Creates a container that holds a copy of the elements denoted by iterators in the range [b, e). 
	c = c2       Replaces the contents of container c with a copy of the container c2
	c.size()     Returns the number of elements in c as a size_type
	c.empty()    Predicate that indicates whether c has no elements 
	c.insert(d, b, e)     Copies elements denoted by iterators in the range [b, e) and inserts them into c immediately before d.	
	c.erase(it)	
	c.erase(b, e)  Removes the element denoted by "it" or the range of elements denoted by [b, e) from the container c. Returns an iterator referring to the position immediately after the erasure. This operation is fast for list, but can be slow for vector and string, because for these types it involves copying all the elements after the one(s) removed. Invalidates any iterators referring to the element(s) that are erased, and , if the container is "vector" or "string" also invalidates all iterators referring to elements after the erasure.
	c.push_back(t)    Append an element with the value t to the end of c
Containers that support random access, and the string type, also provide the following:
	c[n]    =  the container element ( which is a single character if c is a string) at position n in the container c. The initial element is positioned at 0 [cioe' detto in parole povere, c[n] ti dona l'n-esimo elemento del container c]
ITERATOR OPERATIONS 
	*it     Dereferences the iterator "it" to obtain the value stored in the continer at the position that "it" denotes. This operation is often combined with "." to obtain a member of a class object, as in (*it).x, which yields the member x of the object denoted by the iterator "it".
	it->x   Equivalent to (*it).x, which returns the member x denoted by the object obtained by deferencing the iterator "it". Same precedence as the . operator.
	++it 
	it++    Increments the iterator so that it denotes the next element in the container
	b == e  
	b != e  Compares two iterators for equality or inequality
STRING TYPE
The string type offers iterators that support the same operations as do iterators on vectors. In particular, string supports full random access. In addition to the operations on containers, string also provides:
	s.substr(i, j)   Creates a new string that holds a copy of the characters in "s" with indices in the range [i, i+j)
	getline(is, s)   Reads a line of input from "is" and stores it in "s"
	s += s2     Replaces the value of s by s+s2
VECTOR TYPE
The vector type offers the most powerful iterators, called random-access iterators, of any of the library containers. 
Although all the functions we've written have relied on dynamically allocating our vector elements, there are also mecanis for preallocatin elements, and an operation to direct the vecotr to allocate, but not to use, additional memory in order to avoid the overhead of repeated memory allocations.
	v.reserve(n)	Reserves space to hold n elements, but does not initialize them. This operation does not change the size of the container. It affects only the frequency with "vector" may have to allocate memory in response to repeated calls to insert or push_back. 
   v.resize(n) 		Gives v a new size equal to n. If n is smaller than the current size of v, elements beyond n are removed from the vector. If n is greater than the current size, then new elements are added to v and initialized as appropriate to the type in v. 
LIST TYPE 
The list type is optimzed for efficiently inserting and deleting an elements at any point in the container. Among the list operations we also have 
	l.sort()	
	l.sort(cmp)		Sorts the elements in l using the < operator for the type in the list, or the predicate cmp
>> CCTYPE header [pag98 moo book]
The <cctype> header provides useful functions for manipulating character data:
	isspace(c)	true if c is a whitespace character
	isalpha(c)  true if c is an alphabetic character
	isdigit(c)  true if c is a digit character
	isalnum(c)  true if c is a letter or a digit
	ispunct(c)  true if c is a punctuation character
	isupper(c)  true if c is an uppercase letter
	islower(c)  true if c is a lowercase letter
	toupper(c)  Yields the uppercase equivalent to c
	tolower(c)  Yields the lowercase equivalent to c
-----------------------------------------------------------------------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONTAINER ADAPTER / >> container adapters
[pag673 deitel]
The three container adapters are 
    - stack, 
	- queue and 
	- priority_queue. Container adapters are not first-calls containers, because they do not provide the actual data structure implementation in which elements can be stored and because adapters do not support iterators. The benefit of an adapter class is that you can choose an appropriate underlying data structure. All three adapter classes provides member functions push and pop that properly inset an lement into each adapter data structure and properly remove an element from each adapter structure. The next several subsections provide examples of the adapter classes.
[nota come le parole "container adapter" richiamo il significato della loro funzione: (>> itiaf: mia interpretazione itiaf verificami se corretta) sono degli adattatori di containers, un po' come l'adapter di un hard disk, l'adapter ciuccera' l'energia (~ informazione) dalla presa e la stora nel container (data structure) che gli viene abbinato ]
-------------------------------
>> STACK ADAPTER [commonly referred as >> last in first out data structure]
Class stack (from header <stack>) enables insertions into and deletions from the underlying container at one end called the top, so a stack is commonly referred to as a last-in first-out data structure.
A stack can be implemented with vector, list or deque. This example creates three integer stacks, using vector, list and deque as the underlying data structure to represent the stack. By default, a stack is implemented with a deque. 
The stack operations are :
- push to insert an element at the top of the stack (implemented by calling function push_back of the underlying container), 
- pop to remove the top element of the stack (implemented by calling function pop_back of the underlying container), 
- top to get a reference to the top element of the stack (implemented by calling function back of the underlying container), 
- empty to determine whether that stack is empty (implemented by the calling function empty of the underlying container) and
- size to get the number of elements in the stack (implemented by calling function size of the undrelying container)
Example /home/dia/Deitel-Code_Examples/ch15/fig15_19/Fig15_19.cpp + explanation pag 673 e 675 deitel star tag
-------------------------------
>> queue Adapter 
[pag 675 deitel]
A queue is similar to a waiting line. The item that has been in the queue the lingest is th next one removed [esattamente come accade nella coda di uno sportello de la Poste], so a queue is referred to as a first-in first out (>> FIFO / >> first in first out) data structure. 
Class queue (from header <queue>) enables insertions at the back of the underlying data structure and deletions from the front. 
A queue can store its elements in objects of the Standard Library's list or deque containers. Bu default, a queue is implmented with a deque. The common queue operations are 
- >> push to insert an element at the back of the queue (implemented by calloing function push_back of the underlying container).
- >> pop to remove the element at the front of the queue (implemented by calling function pop_front of the underlying container) [da qui si tocca con mano il significato semantico di pop, simile a po up qualcosa che viene fuori da un container.]
- >> front to get a reference to the first element in the queue (implemented by calling function front of the underlying container) 
- >> back to get a reference to the last element in the queue (implemented by calling function back of the underlying container)
- >> empty to determine whether the queue is empty (implemented by calling function empty of the underlying container)
- >> size to get the number of elements in the queue (implemented by calling function size of the underlying container).
See example /home/dia/Deitel-Code_Examples/ch15/fig15_20/Fig15_20.cpp  + pag675-676 per un commento delle lines notevoli del programma.
>> priority_queue Adapter
[pag676 deitel]
Class priority_queue (from header <queue>) provides functionality that enables insertions in sorted order into the underlying data structure and deletions from the front of the underlying data structure. 
By default a priority_queue's elements are stored in a vector. When elements are added to a priority_queue, they're inserted in prioprity order, such that the highest priority element (ie.e the largest value) will be the first element removed from the priority_queue. This is usually accomplished by arranging the elements in a data structure called a heap (not to be confused with the heap for dynamically allocated memory) that always maintains the largest value (i.e. highest-priority element) at the front of data structure. 
The comparison of elements is performed with comparator function object less<T> by default, but you can supply a different comparator.
There are several common priority_queue operations. 
- >> push function inserts an element at the appropriate location based on priority order of the priority_queue (implmented by calling function push_back of the underlying container, which then reorders the elements in priority order)
- >> pop functionremoves the highest-priority element of the priority_queue (implemented by calling function pop_back of the underlying container after removing the top element of the heap).
- >> top gets a reference to the top element of the priority_queue (implemented by calling function front for the underlying container)
empty determines whether the priority_queue is empty (implemented by calling function empty of the underlying container).
- >> size tets the number of elements in the priority_queue (implemented by calling function size of the underlying container).
See example /home/dia/Deitel-Code_Examples/ch15/fig15_21/Fig15_21.cpp
[visto che non e' molto lungo te lo ricopio qui sotto]
	// Fig. 15.21: fig15_21.cpp
	// Standard Library adapter priority_queue test program.
	#include <iostream>
	#include <queue> // priority_queue adapter definition
	using namespace std;
	int main()
	{
	   priority_queue< double > priorities; // create priority_queue
	   // push elements onto priorities
	   priorities.push( 3.2 );
	   priorities.push( 9.8 );
	   priorities.push( 5.4 );
	   cout << "Popping from priorities: ";
	   // pop element from priority_queue
	   while ( !priorities.empty() ) 
	   {
	      cout << priorities.top() << ' '; // view top element
	      priorities.pop(); // remove top element
	   } // end while
	   cout << endl;
	} // end main
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> CONTINUE STATEMENT 
pag179deitel
example 


>> CONTROL STRUCTURES
Bohm and Jacopini's work demonstreted that all programs could be written in terms of only 3 control structures, namely: 
	1) the sequence structure 
	2) the selection structure 
	   2A-> if (single selection statement)
       2B-> if else (double-selection statement)
       2C-> switch (multi-selection statement) [pag109deitel] 
	3) the repetition structure 
	   3A-> while (performs the action 0 or more times a seconda che condizione sia soddisfatta)
	   3B-> do while (performs the action at least once)
       3C->	for
The term "control structure"  comes from the field of computer science. When we introduce C++'s implementations of control structures, we'll refer to them in the terminology of the C++ standard documents as "control statements" 
[pag107deitel + trovi nice discussio of goto statement, spaghetti code, goto-less programming]
Control statements can be connected only in two ways: [pag110deitel]
A- control statement stacking 
B- control statement nesting
Control statement stacking consiste nel connettere l'exit point di un control statement con l'entry point of the next control statement. This is similar to the way a child stacks building blocks, that's why is called control-statement stacking
I MAGNIFICI SETTE
	Any C++ program can be constructed from only seven different types of control statements ("sequence", "if", "if...else", "switch", "while", "do...while", "for") combined in only two ways (control-statement stacking and control-statement nesting)

>> COUNTER CONTROLLED REPETION / DEFINITE REPETITION 
[pag118deitel]
The counter-controlled repetition uses a variable called a counter to control the number of times group of statements will execute. 
Counter-controlled repetition is often called definite repetition becuase the number of repetition is known before the loop begins executing. 
EXAMPLE see pag159deitel  (example while cycle / while loop)
	unsigned int counter = 1;
	while ( counter <= 10 )
	{
		cout << counter << " ";
		++counter;
	}
	cout << endl;
o in maniera piu' condensata 
	counter = 0;
	while (++counter <= 10)
		cout << counter << " ";
//------------------------------------
ATTENTION : in counting loops only use integer variables as control variable, not floating point number
In maniera ancora piu' concisa possiamo scrivere the counter controlled repetition in ONE line using the for repetition statement:
	for ( unsigned int counter = 1; counter <= 10; ++counter )
[pag159deitel]
@pag161deitel trovi bel confronto for vs while loop structure

>> cout << "Hello World!";
IN SHORT from mike pag34 : cout is an object, defined in the file iostream, that's used to send data to the standard output stream (generally the computer screen)  
IN LONG
COUT represents the standard output stream in C++, and the meaning of the entire statement is to insert a sequence of charactes  (in this case the Hello World sequence of characters) into the standard output stream (which usually is the scream). To use cout we must declare at the beginning of the program: 
#include <iostream>
using namespace std;
[see also STANDARD OUTPUT]
---------------------------
>> << / >> standard output / >> output mike pag8
	std::cout << "TRON is IGNITE!" << std::endl;
"TRON is IGNITE" is a string, technically a string literal, meaning it's literally the characters between the quotes. 
>> cout is an object, defined in the file iostream, that is used to send data to the standard output stream. In most programs (including this one), the standard output stream simply means the console window on the computer screen. 
We use the output operator << to send the string to cout. You can think of the output operator like a funnel (= imbuto): it takes whatever is on the open side and funnels it to the pointy side. So the string is funneled to the standard output, the screen.
example :
// visto e' proprio come un funnel (= imbuto or channel del bob di running man) cout << parte la stringa 7 + 3 = quindi il risultato dell'operatione 7 + 3 viene << fiuuuuuuu inviato e compare su schermo, quindi endl << fiuuuu anche lui inviato su schermo e ti manda a capo per le righe successive.
We use std to prefix cout to tell the compiler that we mean cout from the standard library. std is a >> namespace [mike pag9]. You can think of a namespace like an area code of a phone number (cioe' puoi pensare uno namespace come fosse il prefisso di un numero telefonico), it identifies the group to which something belongs [l'elenco telefonico in C++ style userebbe 0171::260911].
[
	>> namespace [pag3 moo book definition] = a namespace is a collection of related names. Quindi quando vedi scritto 
	std::cout means cout is part of the namespace std = collezione di tutti i nomi definiti nella standard library
]
The std::endl. >> endl [mike pag9] is defined in iostream and is also an object in the std namespace. Sending endl to the standard output acts like pressing the Enter key in the console window. In fact, if we were to send another string to the console window, it would appear on the next line. 
    ___________ STANDARD C++ __________
    |                                  |
	|         Standard Library         |
    |                                  |
    |   |--------------------------|   |
    |   |                          |   |
    |   |         iostream         |   |
    |   |                          |   |
    |   |   |-----------------|    |   |
    |   |   |       cout      |    |   |
    |   |   |-----------------|    |   |
    |   |                          |   |
    |   |--------------------------|   |
    |                                  |
    |----------------------------------|

>> statement [mike pag9] : is the basic unit controlling the execution flow. All of your statements must end with a semicolon ;
example 
	return 0;
this is a statement that return 0 to the operating system.
Returning 0 from main() is a way to indicate that the program ended without problem. The operating system doesn't have to do anything with the return value.
-----------------------------------
>> namespace / >> using directive
// TRON 2.0
// Demonstrates a >> using directive

#include <iostream>
using namespace std;   // con questo statement non hai piu' bisogno di mettere std:: davanti a cout
// >> using directive gives me direct access to elements of the std namespace. se facciamo la metafore che il namespace sia come un prefisso telefonico, then this line says that all of the elements in the std namespace should be like local phone numbers to us now. That is, we don't have to use their area code (the std:: prefix) to access them. 
int main()
{
	cout << "TRON IGNITION!" << endl;
	return 0;
}
///////////////////////////////////
-----------------------------------
Un altra maniera e':
-----------------------------------
// TRON 3.0
// Demonstrates >> using declarations

#include <iostream>

using std::cout;	 
using std::endl;  // the advantage of this technique is that it clearly spells out those elements we plan to use. Plus, it doesn't make local a bunch of other elements that I have no intention of using. 
int main()
{
	cout << "TRON IGNITION!" << endl;
	return 0;
}
/////////////////////////////////
---------------------------------
But which is the best technique? A language purist would say you should always prefix each and every element from a namesapce with its identifier. But that's like calling your best fiend by his first and last name all the time. It just seems a little too formal. 
If you have typing you can employ the using directive come in TRON 2.0 sopra. A decent compromise is to employ using declarations. 
//////////////////////////////////////////////////////////////////////////////////////////////////////

>> function [mike pag8] a function is group of programming code that can do some work and return a value. All function headers have a pair of parenthesis after the function name 
example 
	int main()
All C++ programs must have a function called main() which is the starting point of the program. 
All function are delimited by a pair of {} (= curly braces), and everything between them is part of the function. 
Code between curly braces is called a >> block and is usually indented to show that it forms a unit. The block of code that makes up an entire function is called the >> body of the function. 

>> CUSTOM TEMPLATE / >> CUSTOM CLASS TEMPLATE
[pag766 deitel]
Function templates and class templates enable you to conveniently specify a variety of related (overloaded) functions (called >> function template specializations) or a variety of related classes (called >> class template specializations)
cioe'
	
	Function template  -> define related overloaded function -> function template specializations
    class template     -> define related classes -> class template specializations

This is called >> generic programming.
Function templates and class templates are like stencils out of which we trace shapes; function template specializations and clas template specializations are like the separate tracings that all have the same shape, but could, for example, be dranw in different colors and textures.
>> CLASS TEMPLATES 
It's possible to understand the concept of a stack (a data structure into which we insert items only at the top and retrieve those items only from the top in last-in, first-out order independent of the type of hte items bein placed in the stack). However, to instantiate a stack, a data type must be specified. This creates a nice opportunity for software reusability.
Class templates are called >> parameterized types, because they require on or more type parameters to specify now to customize a generic class template to form a class template specialization.
When a particular secialization is needed, you use a concise, simple notation, and the compiler writes the specialization source code. One Stack class template, for example, could thus become the basis for creating many Stack class template specializations used in a program.
NOTE: To create a template specialization with a userfefined type, the user defined type must meet the template's requirements. If the user defined type does not overload the required operator or provide the required functions, compilation errors occur.
>> template< typename T >  [pag 767 deitel]
[from /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/]
All class templates begin with keyword template followed by a list of template parameters enclosed in >> angle brackets (< and >); each template parameter that represents a type must be preceded by either of the interchanegable keywords typename or class. The type parameter T acts as a placeholder for the Stack's element type. The names of type parameters must be unique inside a template definition. You need not specifically use identifier T (any valid identifier can be used).
NOTE Software Engineering information: templates are typically defined in headers, which are then #included in the appropriate client source-code files. For class templates, this means that the member functions are also defined in the header- tipically inside the class definition's body. 
Extract from /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/
	// Fig. 18.1: Stack.h
	// Stack class template.
	#ifndef STACK_H
	#define STACK_H
	#include <deque>
	
	template< typename T >
	class Stack 
	{
	public:
	   // return the top element of the Stack
	   T& top()
	   {
	      return stack.front();
	   } // end function template top
	
	   // push an element onto the Stack
	   void push( const T &pushValue ) 
	   {
	      stack.push_front( pushValue );
	   } // end function template push
	
	   // pop an element from the stack
	   void pop()
	   {
	      stack.pop_front();
	   } // end function template pop
	
	   // determine whether Stack is empty
	   bool isEmpty() const 
	   { 
	      return stack.empty(); 
	   } // end function template isEmpty
	
	   // return size of Stack
	   size_t size() const
	   {
	      return stack.size();
	   } // end function template size
	
	private:
	   std::deque< T > stack; // internal representation of the Stack
	}; // end class template Stack	
	#endif
--------------------------------------------------------------------------------
NOTE1: vector vs deque / >> deque vs vector [pag768 deitel]
In line 42 we use a deque as the underlying container for our Stack class. 
A deque is the default representation for the Standard Library's stack adapter because a deque grows more efficiently than a vector. 
1) a vector is maintained  as a contiguous block of memory: when that block is full and a new element is added, the vector allocates  alarger contiguous block of memory and copies the old elements into that new block. 
2) A deque, on the other hand is typically implemented as list of fixed-size, built-in arrays. : new fixed size built-in arrays are added as necessary and none of the existing elements are copied when new items are added to the front or back. 
NOTE2: The member function definitions of a class template are function templates, but are not preceded with the template keyword and template parameters in angle brackets when they're defined within the class template's body.
Our Stack class template does not define it's own constructos : the default constructor provided by the compiler will invoke the deque's default constructor.
Nota come le member function dell'esempio sopra (top, push, pop, isEmpty, size) delegates its responsibility to the appropriate member function of class template deque.
NOTE3: declaring a class template's member functions outside the class template definition
Member function definitions can also appear outside a class template definition. If you do this, each must begin with the template keyword followed by the same set of template parameters as the class template. If you do this, each must begin with the template keyword followed by the same set of template parameters as the class template. In addition, the member functions must be qualified with the class name and scope resolution operator. For example, you can define the pop function outside the class template definiftion as follows:
	template< typename T >
	inline void Stack<T>::pop()
	{
		stack.pop_front();
	} // end function template pop
-------------------------------------
Stack<T>:: indicates that pop is in the scope of class Stack<T>. The Standard Library's container classes tend to define all their member functions inside their class definitions.
NOTE4: >> pronunciation Stack<double> is pronounced Stack of double come ad esempio in 
/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch18/fig18_01_02/fig18_02.cpp
--------------------------------------
	int main()
	{
	   Stack< double > doubleStack; // create a Stack of double 
Similmente line 
 34    Stack< int > intStack; // create a Stack of int
"Stack< int > intStack" si pronuncia "intStack is a Stack of int"
-------------------------------------- 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> generic functions  and >> template functions [chapter 8 pag 139 moo book]
A generic function is a function with arugment and return types that we do not know until we use the functions. For example "find" function, takes two iterators and a value as arguments. We can use the same find function to find values of any appropriate type in any kind of container. This usage implies that we do not know what find's argument or result types will be until we use it. Such function is called a generic function.
The language feature that implements generic functions is called >> TEMPLATE FUNCTIONS [pag140 moo book]
Templates let us write a single definition for a family of functions that behave similarly, except for differences that we can attribute to the types of their template parameters. 
	They key idea behind templates is that objects of different types may nevertheless share common behaviour. Template parameters let us write programs in terms of that common behviour, even though we do not know the specific types that correspond to the template parameters when we define the template.  
>> TEMPLATE HEADER [pag141 moo book]
--------------------------------------------------------- 
extract from [/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter08/median.h]
	template <class T>
	T median(vector<T> v)
	{
	        typedef typename std::vector<T>::size_type vec_sz;
		vec_sz size = v.size();
		if (size == 0)
			throw domain_error("median of an empty vector");
	
		sort(v.begin(), v.end());
	
		vec_sz mid = size/2;
	
		return size % 2 == 0 ? (v[mid] + v[mid-1]) / 2 : v[mid];
	}
------------------------------------------------------------
The first novelty here are the template header 
	template <class T>
and the use of T in the parameter list. THe template header tells the implementation that we are defining a template function, and that the function will take a "type parameter". Type parameters operate much like function parameters: they define names that can be used within the scope of the function. HOWEVER, type parameters refere to types, not to variables. Thus wherever T appears in the function, the implementation will assume that T names a type. In the median function, we use the type parameter explicitly to say what type of objects the vector named "v" holds, and to specify the return type of the function.
When we call this median function, the implementation will bind T to a type that it determines at that point, during compilation. For example,we might take the median of a vector<int> obejct named vi by calling median(vi). From this call, the implmentation can infer that T is int. Wherever we use T in this function, the implementation generates code as if we had written int. In effect the implementation instantiates our code as if we had written a specific version of median that took a vector<int> and returned an int. 
	The next novelty is the use of typename in the definition of vec_sz. It is there to tell the implementation that "vector<T>::size_type" is the name of a type, even though the implementation doesn't yet know what type T represents. Whenever you have a tpye, such as vector<T>, that depends on a template parameter, and you want to use a member of that type, such as size_type, that is itseflt a type, you must precede the entire name by typename to let the implementation know to treat the name as a type. Although the standard library ensures that vector<T>::size_type is the name of a type for any T, the implementation, having no special knowledge of the standard library types, has no way of knowing this fact.  
>> TEMPLATE INSTATIATION observations [from pag142 moo book]:
When we call "median" [see example above] on behalf of a vector<int>, the implementation will effectively create and compile an instance of the function that replaces every use of T by "int". If also call "median" for a vector<double>, then the implementation will again infer the types from the call. In this case, T will be bound to "double", and the implementation will generate another version of "median" using "double" in place of T.
	The C++ standard says nothing about how implementations should manage template instantiation, so every implementation handles instaintiation in its own particulat way. Keep in mind that the definition of the template, not just the declaration, has to be accessible to the implementation. Generally, this requirement implies access to the source files that define the template, as well as the header file. Many implementation expect the header file for the template to include the source file, either directly or via #include.
>> ITERATOR CATEGORIES [pag145 moo book]
The C++ library defines FIVE iterator categories, each one of which corresponds to a specific collection of iterator operations. The iterator categories give us a way to understand which containers can use which algorithms [cioe' detto in parole spicciole se prendi un algoritmo tipo per esempio "sort" potrai richidergli di ordinarti "vectors" and "strings" e lo fara' usando operations su una specifica CATEGORIA di iteratori che permetterranno l'accesso e il riordino degli elementi all'interno di un vector/string]
At pag 145 they describe each access strategy, show an algorithm that uses it, and describe the corresponding iterator category.
1) SEQUENTIAL READ-ONLY ACCESS [pag145 moo book]
that is to access a sequence by reading its elements sequentially. Among the library functions that does so is "find"
	>> input operator definition pag 146 moo book
2) SEQUENTIAL WRITE-ONLY ACCESS [pag146 moo book]
	like the >> copy function [pag146 moo book]
	pag147 moo book : >> output iterator definition and requirements.
3) SEQUENTIAL READ-WRITE ACCESS [pag147 moo book]
	Suppose we want to be able to read and write the elements of a sequence, but only seqeuntially: we intend to advance iterators forward but never backward. An example of a library function that does so is replace, from the <algorithm> header.
	>> FORWARD ITERATOR requirements [pag148 moo book]
4) REVERSIBLE ACCESS [pag148 moo book]
	Some functions need to get at a container's elements in reverse order. The most straightforward example of such a function is "reverse", which the standard library defines in the <algorithm> header.
	>> BIDIRECTIONAL ITERATOR requirements [pag148 moo book]
5) RANDOM ACCESS [pag148 moo book]  
Some functionsneed to be able to jump around in a container. One good example of such a function is the classical binary search algorithm. One of the standard library implementation of this algorithm is "binary_search".
NOTE: the "vector" and "string" iterators are random-access iterators. However the "list" iterator is not; it supports only bidirectional iterators. Why?
The essential reason is that lists are optimized for fast insertion and deletion. Hence, there is no quick way to navigate to an arbitrary element of the list. The only way to navigate through a list is to look at each element in sequence.
NOTE2: in the above algorithms, usually they use the convention to take two arguments to specify ranges. The first argument refers to the first element of the range; the second argument refers to one past the last element of the range. Why do we specify one past the end of the range? 
Mainly for 3 reasons -> see them at pag 149-150 book     
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> template class definition [pag188 moo book]
When we define a template class, we have to signal that the class is a template, and list the type parameters that will be used in the class definition:
	template <class T> class Vec {
	public:
		// interface 
	private:
		// implementation 
	};
This code says that Vec is a template class, with one type parameter named T. As with other class types, we can assume that there will be public and private parts that define the interface and implementation respectively.
For example you can implement a vector by storing the initial element address, and one past the address of the last element (queste due informazioni ti saranno poi sufficienti per ricavarti il size del vettore): then our vector class would become 
	template <class T> class Vec {
	public:
		// interface 
	private:
		T* data; // first element in the Vec
		T* limit; // one past the lsat element in the Vec 
	};
[qui sotto segue una bella esemplificazione della >> <> [tag >> < > / >> < ] notation (tipo Vec<int> v;) che si ritrova spesso]
This class definition says that Vec is a template type, and that it takes a single type parameter. In the body of the class definition, we'll call that type T. Whenever we use T, the compiler will replace it with whatever type the user names when creating a Vec. So for example if we write 
	Vec<int> v;
this definition will cause the compiler to instantiate a version of the Vec class in which it replaces each reference to T by "int".
Because we used the type parameter T in the declaration of data and limit, the type of these pointers depends on the type of the objects that the Vec will hold. 
This type is not known until the definition of a Vec is instantiated. Once we say that we want a Vec<int>, the types of data and limit are known: They will be int* for this instance of Vec. 


>> custom templatized data structures / >> data structures custom templatized [pag778 deitel]
in this chapter are discuss several popular and important data structures and implement programs that create and manipulate them:
    >> linked lists: are collections of data items logically lined up in a row"  (insertions and removals are made anywhere in a linked list)
        >> node [pag780 deitel] : a linked list is a linear collection of self referential class objects called nodes connected by pointer links.
    >> stacks are important in compilers and operating systems : insertions and removals are made only at one end of a stack (its top) [see also pag795 deitel]
    >> queues present waiting lines; insertions are made at the back (also referred to as the tail) of a queue and removals are made from the front (also referred to as the head) of a queue
    >> binary trees facilitate searching and sorting data, duplicate elimination and compiling expressions into machine code. [see pag803deitel]
NOTE: from pag 780 deitel: stacks and queues are linear data structures and they can be viewed as constrained versions of linked lists. Trees are nonlinear data structures.
NOTE2: basic terminology dei trees structures [from pag803 deitel]
	>> root node	deitel p803
	>> child node 	deitel p803
	>> siblings 	deitel p803
	>> leaf node 	deitel p803
	>> left child	deitel p803  non nel senso di bambino lasciato solo, ma di "bambino sul lato sinistro
	>> right subtree deitel p803
	>> left subtree	deitel p803
Linked lists provide several advantages over array objects and built-in arrays. A linked list is appropriate when the number of data elements is unpredictable. Linked lists are dynamic, so the length of a list can increase or decrease as necessary.
- Array non puoi cambiare il size <-> mentre con le list possono cambiare in size [ti aiutano ad evitare sprechi di memoria]
- insertion and deletion in a sorted arrays can be time consuming <-> mentre a linked list allows efficient insertion operations anywhere in the list
- the elements of an array object or built-in array are stored contiguously in memory. This allows immediate access to any element, because an element's address can be calculated directly based on its position relative to the beginning of the array. <-> Linked lists do not afford such immediate direct access to their access, so accessing individual elements can be considerably more expensive.
Linked-list nodes typically are not stored contiguously in memory, but logically they appear to be contiguous.
---------------
>> forward declaration [pag785 deitel] tells the compiler that a type exists, even if it has not yet been defined.
>> predicate function [pag786 deitel] 
>> insert node at front of a list [nice explanation at pag 789deitel con tuo esempio carino del treno, vagoni e locomotiva]
>> insert node to the end of a list [pag790 deitel] carina la tua analogia di lastPtr come "fanalino rosso di coda" che sposti dall'ex ultimo vagone al nuovo vagone che attracchi in coda.
>> remove node from the front of a list [pag791 deitel]
>> singly linked list [pag792 deitel]
a singly linked list begins with a pointer to the first node, and each node contains a pointer to the next node in sequence. This list terminates with a node whose pointer member has the value nullptr. A singly linked list may be traversed in only one direction. 
>> circular singly linked list / >> circular list [pag793 deitel] = begins with a pointer to the first node, and each node contains a pointer to the next node. The last node does not contain nullptr; rather the pointer in the last node points back to the first node, thus closing the circle.
>> doubly linked list [pag793 deitel] = allows traversals both forward and backward. Such a list is often implemented with two start pointers :
- one that points to the first element of the list to allow front-to-bakc traversal of the list and 
- one that points to the last element of the list to allow back-to-front traversal. 
Each node has both a >> forward pointer to the next node in the list in the forward direction and a backward pointer to the next node in the list in the backward direction. 
>> circular doubly linked list [pag794 deitel] = the forward pointer of the last node points to the first node, and the backward pointer of the first node points to the last node, thus closing the "circle".
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> DDDDDDD

>> DANGLING POINTER [pag237 mike programming game] : a dangling pointer is a pointer to an invalid memory address. Dangling pointers are often caused by deleting an object to which a pointer pointed. Dereferencing such a pointer can lead to disastrous results.

>> DANGLING-ELSE problem
[pag115 deitel]
C++ compiler always associate an else with the immediately preceding if unless to do otherwise by the placement of braces {}
Example se volessi eseguire
if (x > 5)
	if ( y > 5)
		cout << "x and y are > 5";
else  // dove desideriamo che questo else sia associato alla (condizione x > 5) 
	cout << "x is <=5";
in realta il compiler interpretes the statement as:
if (x > 5)
	if ( y > 5)
		cout << "x and y are > 5";
	else
		cout << "x is <=5";
quindi supponi che x > 5, allora si checka se y sia > 5 e se non lo e' viene printato x <=5 perche' l'else e' stato come di regola associato all'if immediatamente precedente. 
therefore the CORRECT WAY is :
if (x > 5)
{
	if ( y > 5)
		cout << "x and y are > 5";
}
else
	cout << "x is <=5";
//////////////////////////////////


>> DANGLING POINTER
[pag463deitel]
if the copy constructor simply copied the pointer in the source object to the target object's pointer, the nboth would point to the same dynamically allocated memory. The first destructor to execute would delete the dynamically allocated memory, and the other object's ptr would point to memeory that's no longer allocated, a situation called dangling pointer -> this would likely result in a serious runtime error (such as early program termination)
 

>> DANGLING REFERENCES [pag240deitel]
Functions can return references, but this can be dangerous. When returning a reference to a variable declared in the called function, unless the variable is declared as "static", the reference refers to an automatic variable that's discarded when the function terminates. An attempt to access such a variable yields undefined behaviour. References to undefined variables are called dangling references.	

>> DATA MEMBER 
When each object of a class maintains it own copy of an attribute, the variable that represents the attribute is known as a data member [each object (instance) of the class has a separate copy of the variable in memory.]
There are variable for which each object of a class does not have a separate copy. That is the case with static data members, which are also known as class variables. 
When objects of a class containing static data members are created, all the objects share ony copy of the class's static data members.  static data member can be accessed within the class definition and the member-function definitions like any other data member.  A public static data member can be also accessed outside of the class, even when no objects of the class exist, using the class name followed by the scope resolution operator (::) and the name of the data member. 
[from pag300 recall also section 3.4 pag74deitel]

>> DATA STRUCTURES 
[pag279deitel] 
Data structures = collections of related data items

>> DEBUGGING
the program /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp [itiaf]
[2004 fig10_01] >> g++ -o string-test-prog fig10_01.cpp 
fig10_01.cpp: In function ?eint main()?f:
fig10_01.cpp:75:12: error: expected type-specifier before ?eout_of_range?f
fig10_01.cpp:75:25: error: expected ?e)?f before ?e&?f token
fig10_01.cpp:75:25: error: expected ?e{?f before ?e&?f token
fig10_01.cpp:75:26: error: ?eex?f was not declared in this scope
fig10_01.cpp:75:29: error: expected ?e;?f before ?e)?f token
////////////////////////////////////////////////

>> DEFAULT VALUE [pag116 jesse]
A default value is a value to use if none if supplied example 
	long myFunction (int x = 50);
This prototype says "myFunction() returns a long and takes an integer as parameter. If an argument is not supplied, use the default value of 50.
Restriction : if any of the parameters does not have a default value, no previous parameter can have a default value 
If the function prototype looks like 
	long myFunction (int Param1, int Param2, int Param3);
you can assign a default value to Param2 only if you have assigned a default value to Param3. You can assign a default value to Param1, only if you've assigned default values to both Param2 and Param3. 
NOTE1: don't try to create a default value for a first parameter if no default value exists for the second 
NOTE2: don't forget that arguments passed by value cannot affect the variables in the calling function.
Here's a full example demonstrating default values:
------------------------------------------------------------------------------------------------
// Listing 5.7 - demonstrates use
// of default parameter values
#include <iostream>
  
int AreaCube(int length, int width = 25, int height = 1);  // prototype of the function AreaCube
  
int main()
{
   // inizializzi i parametri di input
   int length = 100;
   int width = 50;
   int height = 2;
   int area;
  
   area = AreaCube(length, width, height); // calling the function AreaCube
	// gli stai passando tutti e 3 i valori quindi usa 100 * 50 * 2 e ti dona in output 10000
   std::cout << "First area equals: " << area << "\n";
  
   area = AreaCube(length, width); // in questo caso gli stai solo donando i primi due parametri, quindi come terzo parametro utilizzera' l'altezza di default
	// quindi il risultato di output sara' 100 * 50 * 1 = 5000
   std::cout << "Second time area equals: " << area << "\n";
  
   area = AreaCube(length); // in questo caso gli doni come parametro di input giusto la lunghezza
	// quindi il risultato di output sara' 100 * 25 * 1 = 2500
   std::cout << "Third time area equals: " << area << "\n";
   return 0;
}
  
AreaCube(int length, int width, int height)   // definition of the function AreaCube
{
  
   return (length * width * height);
}

////////////////////////////////////////////////////////////////////////////////////////////////


>> DECLARATION OF A CLASS / >> CLASS DECLARATION / >> DECLARATION CLASS
[pag141 jesse]
Declaring a class tells the compiler about the class. To declare a class use the "class" keyword followed by the class name, an opening brace, and then a list of the data members and methods of that class. End the declaration with a closing bracket and the semicolon 
example 
	class LevitatingMachine
	{
		unsigned int QuantumStateNumber;
		unsigned int RiderWeight;
		void Levitate();
	};
Declaring thsi class does not allocate memory for "LevitatingMachine". It just tells the compiler what a "LevitatingMachine" is, what data members it contains (QuantumStateNumber and RiderWeight), and what it can do [Levitate()]. Although memory is not allocated, it does let the compiler know how big a "LevitatingMachine"  is, that is how much room the compiler must set aside for each "LevitatingMachine" that you will create. 
>> CLASS NAMING CONVENTIONS [pag141 jesse]
Many programmers name the member variables with the prefix my (tipo myWeight, mySpeed). This helps to distinguish member variables from nonmember variables. 
Many programmers also use the convention to name all classes with initial capitalization tipo LevitatingMachine (insomma usa la prima lettera maiuscola se e' il nome di una classe.)
>> OBJECT DEFINE / >> DEFINE OBJECT 
After you declare a class, you can then use it as a new type to declare variables of that type. You declare an object of your new type the same as you declare an integer variable.
	unsigned int GrossWeight;  // define an unsigned integer
	LevitatingMachine McFly; // define a LevitatingMachine
This code defines a variable called GrossWeight, whose type is an unsigned integer. It also defines "McFly", which is an object whose class (or type) is LevitatingMachine.
NOTE: >> classes versus objects / >> objects vs classes [pag142 jesse]
You never recharge the definition of a LevitatingMachine, you recharge a specific, concrete levitating machines. You draw a distinction between the idea of a levitating machine, and the particular levitating machine that right now is staying in your backyard. In the same way C++ differentiates between the class LevitatingMachine which is the idea of a levitating machine, and each individual LevitatingMachine object. Thus "McFly" is an object of type "LevitatingMachine" in the same way that GrossWeight is a variable of type unsigned int;
An >> object is an individual instance of a class
---------------------------------------------------
>> Access class members / >> class members access [pag142 jesse]
After you defined an actual object "LevitatingMachine" for example 
	LevitatingMachine McFly; 
you use the dot operator (.) to access the members of that object. Therefore to assign 50 to McFly's RiderWeight member variable you would write:
	McFly.RiderWeight = 50;	
In the same way, to call the "Levitate()" function you would write
	McFly.Levitate();
When you use a class method, you call the method. In this example, you are calling "Levitate()" on "McFly".
NOTE from pag 143 jesse
In C++ you don'T assign values to types; you assign values to variables. For example 
	int = 5;  // wrong !!!!!
you can't assign 5 to an integer. Rather, you must define an integer variable and assign 5 to that variable. For example, 
	int x; // define x to be an int  
	x = 5; // set x's value to 5
This a shorthand way of saying "assign 4 to the variable x, which is of type int". In the same way, you wouldn't write 
	LevitatingMachine.RiderWeight = 5; // wrong!!
Instead you should write:
	LevitatingMachine McFly; // just like int x;
	McFly.RiderWeight = 5;	 // just like x = 5;
NOTE from pag 144 jesse: don't confuse a declaration with a definition. A declaration says what a class is. A definition sets aside memory for an object. 
/////////////////////////////////////////////////////////////////////////////////////////////////

>> DECLARATION of VARIABLE
- bisogna specificare un type e un identifier, for example:
	int a; 
dove int e' il type e a e' l'identifier.
To declare more variable of the same type: 
	int a, b, c;
si possono dichiare in a single statement, by separating their identifiers with commas
- mentre dichiari una variabile puoi anche inizializzare il suo valore, example: 
		inter number1 = 0;
although it's not always necessary to initialize every variable explicitly, doing so will help you avoid many kinds of problems. 
- All variables must be declared with a name and a data type before they can be used in a program. (=> Dichirazione variabile E' obbligatoria, mentre la sua inizializzazione e' opzionale)
- Good programming practice: declare only one variable in each decalration and provide a comment that explains the variable's purpose in the program. 
- Placement of variable declaration : can be placed almost anywhere in the program, but they must appear before their correspoding variables are used in the program. 
- [pag121deitel] in general variables should be declared just before they're used. Declare each variable on a separate line with its own comment for readability. 
- always initialize variables when they are declared. 

>> DEFAULT ARGUMENTS
[pag240deitel]
It's common for a program to invoke a function repeatedly with the same argument value for a particular parameter. In such cases, you can specify that such a parameter has a default argument, i.e. a default value to be passed to that parameter.
Example 
	// function prototype that specifies default arguments
	unsigned int boxVolume( unsigned int length = 1, unsigned int width = 1,
	   unsigned int height = 1 );
	....
	// function boxVolume calculates the volume of a box
	unsigned int boxVolume( unsigned int length, unsigned int width,
	   unsigned int height )
	{
	   return length * width * height;
	} // end function boxVolume
Quindi se poi usi un programma dove la funzione viene chiamata omettendo gli argument per i parameters, allora si useranno quelli di default
Example 
	cout << " The default box volume is: " << boxVolume();
ti printera' visto il modo in cui sono stati specificati i default arguments:
	The default box volume is: 1
OSSERVAZIONI : the default arguments must be the rightmost (trailing) arguments in a function's parameter list.	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DEFAULT ARGUMENTS [pag162 mike programming game]
When you write a function in which a parameter almost always gets passed the same value, you can save the caller the effort of constantly specifying this value by using a "default argument"	
EXAMPLE 
	int askNumber(int high, int low = 1);
the second parameter low it's assigned the value 1. The 1 is default argument, meaning that if a value isn't passed to low when the function is called, low is assigned 1. 
NOTE: once you specify a default argument in a list of parameters, you must specify default arguments for all remaining parameters. So the following prototypes is valid 
	void setDisplay (int height, int width, int depth = 32, bool fullScreen = true);  // OK!
while the following one is illegal:
	void setDisplay (int height, int width, int depth = 32, bool fullScreen);\81@\81@// DAME!
NOTE: you don't repeat the default argument in the function definition, as you can see in the function defition of askNumber () below
FULL EXAMPLE 
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int askNumber(int high, int low = 1);  // i default parameters li definisci in fase di prototipazione della funzione 
		
		int main()
		{
		    int number = askNumber(5);
		    cout << "Thanks for entering: " << number << "\n\n";
		    
		    number = askNumber(10, 5);
		    cout << "Thanks for entering: " << number << "\n\n";
		
		    return 0;
		}
		
		int askNumber(int high, int low)      // mentre in fase di definition della funzione non bisogna piu' specificare i valori dei default arguments
		{
		    int num;
		    do
		    {
		        cout << "Please enter a number" << " (" << low << " - " << high << "): ";
		        cin >> num;
		    } while (num > high || num < low);
		
		    return num;
		}

---------------------------------------------------------------------------------------------
OUTPUT:
	[2037 chapter05] >> ./give_me_a_number 
	Please enter a number (1 - 5): 0     // finche non immetti un numero compreso tra 1 e 5  ti ripete la domanda
	Please enter a number (1 - 5): 3
	Thanks for entering: 3
	
	Please enter a number (5 - 10): 13   // ora avendo usato number = askNumber(10, 5); ti chiede un numero compreso tra 5 e 10
	Please enter a number (5 - 10): 7
	Thanks for entering: 7
NOTE: when you are calling a function with default arguments, once you omit an argument, you must omit arguments for all remaining parameters. For example, given the prototype:
	void setDisplay (int height, int width, int depth = 32, bool fullScreen = true);  
a valid call to the function would be
	setDisplay(1680, 1050);
while an illegal call would be
	setDisplay(1680, 1050, false);
perche' una volta che hai saltato "depth" non e' piu' lecito specificare "fullScreen"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	


>> DELEGATING CONSTRUCTOR 
[pag392deitel]
Just as a constructor can call a class's other member functions to perform tasks, C++11 allows constructors to call other constructors in the same calss. The calling constructor is known as delegating constructor = it delegates its work to another constructor. This is useful when overloaded constructors have common code that previously would have been defined in a "private" utility function and called by all the constructors.
see example pag 393 deitel


>> #DEFINE
you can define your own names for constants that you use very often without having to resort to memory consuming variables. ex
	#include <iostream>
	using namespace std;
	#define PI 3.14159
	#define NEWLINE '\n'
	int main()
	{
		double r=5.0;
		double circle;
		circle = 2 * PI * r;
    	cout << circle;
    	cout << NEWLINE; 
    	return 0;
	�p
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




>> deque sequence container = Double Ended QUEue sequence container
[pag 662 deitel]
Class deque provides many of the benefits of a vector and a list in one container. The term deque is short for double ended queue.
Class deque is implemented to provide efficient indexed access (using subscripting) for reading and modifying its elements, much like a vector.
Class deque is alos implemented for efficient insertion and deletion operations and its front and back, much like a list (although a list is also capable of efficient insertions and deletion in the middle of the list). 
One of the most common uses of a deque is to maintain a first-in first-out queue of elements.
Due to the noncontiguous memory layout of a deque, a deque iterator must be more intelligent than the pointers that are used to iterate through vectors, arrys or built-in arrays.
NOTE1 performance
	in general, deque has higher overhead than vector
NOTE2 performance
	insertions and deletions in the middle of a deque are optimized to minimize the number of elements copied, so it's more efficient than a vector but less efficient than a list for this kind of modification.
	vector < deque < list da un punto di vista dell'efficiency middle insertion/deletion
Class deque provides the same basic operations as class vector, but like list adds member functions push_front and pop_front to allow insertion and deletion at the beginning of the deque respectively. 
NOTE3: nella sezione degli include dovrai scrivere 
	#include <deque>
in order to use class deque
esempio pratico /home/dia/Deitel-Code_Examples/ch15/fig15_14/Fig15_14.cpp
    // Fig. 15.14: Fig15_14.cpp
	// Standard Library deque class template.
	#include <iostream>
	#include <deque> // deque class-template definition
	#include <algorithm> // copy algorithm
	#include <iterator> // ostream_iterator
	using namespace std;
	int main()
	{ 
	   deque< double > values; // create deque of doubles   // <--- >> deque instantiation example 
	   ostream_iterator< double > output( cout, " " );
	   // insert elements in values
	   values.push_front( 2.2 );
	   values.push_front( 3.5 );
	   values.push_back( 1.1 );
	   cout << "values contains: ";
	   // use subscript operator to obtain elements of values
	   for ( size_t i = 0; i < values.size(); ++i )   // in this way we ensure that we do not attempt to access an element outside the bounds of deque
	      cout << values[ i ] << ' ';
	   values.pop_front(); // remove first element
	   cout << "\nAfter pop_front, values contains: ";
	   copy( values.cbegin(), values.cend(), output );
	   // use subscript operator to modify element at location 1
	   values[ 1 ] = 5.4;
	   cout << "\nAfter values[ 1 ] = 5.4, values contains: ";
	   copy( values.cbegin(), values.cend(), output );
	   cout << endl;
	} // end main
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DESTRUCTOR
[pag378deitel]
A destructor is a special member function that is part of every class and is used to perform "termination housekeeping" on an object before it's destroyed.
[pag304 mike game programming definition]
A destructor ia a member function that 's called just before an object is destroyed. If you don't write a destructor of your own, the compiler will supply a default destructor for you.
[see also http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
http://www.tutorialspoint.com/cplusplus/cpp_constructor_destructor.htm]
[pag393deitel]
A destructor is a type of special member function. The name of the destructor for a class is the tilde character (~) followed by the class name.
The destructor is the complement of the constructor. 
The destructor itself does not actually release the object's memory, it performs termination housekeeping before the object's memory is reclaimed, so the memory may be reused to hold new objects.
If you do not explicitly define a destructor, the compiler defines an "empty" destructor. 
[la seguente e' davvero una bella frase, quasi poetica] Constructors and destructors are called implicitly by the compiler. The order in which these function calls occur depends on the order in which execution enters and leaves the scopes where the objects are instantiated. Generally destructor calls are made in the revers order of the corresponding constructor calls. 
>> ~  quando vedi questo simbolo seguito da il nome di una classe ex ~nomeClasse() significa che ti trovi davanti a un destructor
>> DESTRUCTOR pag 200 moo book
Like constructors, which say how to create objects, there is a special member function, called a destructor, that controls what happens when objects of the type are destroyed. Destructors have the same name as the name of the class prefixed by a tilde (~). Destructors take no arguments and have no return value
The work of the destructor is to do any cleanup that should be done whenever an object goes away. Typically, this clean up involves releasing resources, such as memory, that the constructor has allocated.
	template <class T> class Vec {
	public:
		~Vec() {uncreate(); }
		// as before
	};
------------------------------------------------------------
>> DEFAULT CONSTRUCTOR / >> DEFAULT OPERATIONS [pag201 moo book]
If you not explicitly define a copy constructor, assignment operator, or destructor, the compiler synthesiszes default versions of the unspecified operations.
It is important to note that if a class defines any constructor explicitly, even a copy constructor, then the compiler will not synthesize a default constructor for that class. 
>> MEMORY ALLOCATION MANAGEMENT / >> RULE OF THE THREE / >> RULE OF THE 3 / >> THREE RULE / >> 3 rule [pag201 moo book]
Classes that manage resouces such as memory require close attention to copy control. In general, the default operations will not suffice for such classes. Failure to control every copy can confuse users of the class and often will lead to run time errors.
[...]
For example if we do not define a destructor, then the default destructor will be used. That destructor will destroy the pointer, but destroying a pointer does not free the space to which it points. The result will be a memory leak: the space consumed will never be reclaimed.
If we fix the leak by providing a destructor, but we do not also add the copy constructor and assignment operator, then we set things up so that a crash is likely. In such flawed implementation, it would be possible for two objects to share the same underlying storage, and when of one of those objects is destroyed, the destructor will destroy that shared storage. 
Classes that allocate resources in their constructors required that every copy deal correctly with those resources. Such classes almost surely need a destructor to free the resources. If the class needs a destructor, it almost surely needs a copy constructor, as well as an assignment operator. Copying or assigning objects of classes that allocate resources, usually allocates those resources in the same way that creating an object from scractch does.  To control how every object of class T deals with its resources, you need:
	T::T()                    one or more constructors, perhaps with arguments 
	T::~T()                   the destructor
    T::T(const T&)            the copy constructor 
	T::operator=(const T&)    the assignment operator
Once we have defined these operations, the compiler will invoke them whenever an object of your type is created, copied, assigned, or destroyed. Remember that objects may be created, copied or destroyed implicitly. Whether implicitly or explicitly, the compiler will invoke the appropriate operation. 
Because the copy constructor, destructor and assignment operator are so tightly coupled, the relationsihp among them has become known as the 
RULE OF THREE: "If you class need a destructor, it probably needs a copy constructor and an assignment operator too. "
	1) DESTRUCTOR 
	2) COPY CONSTRUCTOR
	3) ASSIGNMENT OPERATOR 
se hai bisogno di definire 1) [visto che magari hai bisogno di liberare memoria] allora anche 2) e 3) vanno definiti. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DO...WHILE REPETITION STATEMENT / DO WHILE / WHILE LOOP
[from pag168deitel]   / >> do while loop  also at pag 137 moo book
Similar to the while statement but the loop body always execute at least once. 
example 
	unsigned int counter = 1; initialize counter
	do 
	{
		cout << cout << " "; // display counter
	} while (counter <= 10 );
[nota come a differenza dell'header del for  a destra della ) ci sia il ; ]



>> DOWNCASTING 
pag526 deitel
downcasting is a potentially dangerous operation
>> DOWN cast [from jesse pag 488] what is down cast ? A down cast (also called ">> casting down") is a declaration that a pointer to a base class is to be treated as  pointer to a derived class.

>> DRIVER PROGRAM 
[pag84deitel]
il driver program altri non e' che il source-code file *.cpp containing function "main" and used to test our classes. A source-code file with "main" can use the class definition found in a header to create objects of a class. 

>> double : double precision floating point number
size: 8byte 
range: +/-1.7e+308 =(~15 digits)
NOTE: [advice from p37 moo book] for floating point computation use double, much better than using >> float (= single precision floating point type. Usato nei tempi antichi quando le memorie dei computer erano piccole e care.)
On modern computer double is usually much more accurate than float and not much slower. Sometimes double is even faster.

>> doxygen 
te reinvio alla voce >> doxygen in the OpenFOAM txt file

>> DYNAMIC BINDING / >> DYNAMIC BINDING / >> STATIC BINDING [pag527 deitel]
+ pag 547 example of static binding Each member function invocation in lines 32-37 is an example of static binding- at compile time, because we are using name handles (not pointers or references that could be set at execution time), the compiler can identify each object's type to determine which print and earnings functions are called.
>> DYNAMIC BINDING under the hood -> nice picture pag 551
>> OVERHEAD OF POLYMORPHISM pag550 in terms of additional memory consumption and processor time.
- virtual functions and dynamic binding enable polymorphic programming as an alternative to switch logic programming. Optimizing compilers normally generate polymorphic code that's nearly as efficient as hand-coded switch-based logic. Polymorphism's oeverhead is acceptable for most applications. In some situations (such as real-time applications) with stringent performance requirements - polymorphism's overhead may be too high.

>> OVERHEAD [in senso generale]
In informatica, la parola inglese overhead (letteralmente in alto, che sta di sopra) serve per definire le risorse accessorie, richieste in sovrappiù rispetto a quelle strettamente necessarie per ottenere un determinato scopo in seguito all'introduzione di un metodo o di un processo più evoluto o più generale.
Nei linguaggi di programmazione ad alto livello, un esempio di overhead riguarda il tempo di esecuzione dei sottoprogrammi: al tempo da questi impiegato per svolgere il loro compito (ad esempio il calcolo di una radice quadrata) si aggiunge infatti il tempo necessario a gestire il meccanismo stesso di chiamata a sottoprogramma attraverso record di attivazione. Questo tempo aggiuntivo può essere ridotto con un uso accorto di specifiche tecniche di ottimizzazione, ma non può essere eliminato del tutto.
[source https://it.wikipedia.org/wiki/Overhead]

>> dynamic_cast 
[pag556 deitel]

>> DYNAMIC MEMORY ALLOCATION / >> unique_ptr
[pag755 deitel]
A common programming practice is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory and >> deallocate the memory with delete when the memory is no longer needed. 
If an exception occurs after successful memory allocation but before the delete statement executes, a >> memory leak could occur. 
C++11 provides class template >> unique_ptr in header <memory> to deal with this situation. 
An object of class >> unique_ptr maintains a pointer to dynamically allocated memory. When a unique_ptr object destructor is called (for example, when a unique_ptr object goes out of scope), it performs a delete operation on its pointer data member. Class template unique_ptr provides overloaded operator * and -> so that a unique_ptr object can be used just as a regular pointer variable is.
See example /home/dia/Deitel-Code_Examples/ch17/fig17_07_09/fig17_07_09.cpp
NOTE [from pag757 deitel]
The class is called unique_ptr because only one unique_ptr at a time can own a dynamically allocated object. By using its overloaded assignment operator or copy constructor, a unique_ptr can transfer ownership of the dynamic memory it manages. The last unique_ptr object that maintains the pointer to the dynamic memory will delete the memory. 
This makes unique_ptr an ideal mechanism for returning dynamically allocated memory to client code. When the unique_ptr  goes out of scope in the client code, the unique_ptr's destructor destroys the dynamically allocated object and deletes its memory.
NOTE2: you can also use a unique_ptr to manage a dynamically allocated built-in array. For example consider the statement:
	unique_ptr< string [] > ptr ( new string [ 10 ] );
which dynamically allocates an array of 10 strings managed by ptr. The type string[indicates that the managed memory is a built-in array containing strings. When a unique_ptr that manages an array goes out of scope it deletes the memory with delete []  so taht every element of the array receives a destructor call.
A unique_ptr that manages an array provides an overloaded [] operator for accessing the array's elements. For example, the statement
	ptr [2] = "hello";
assign "hello" to the string at ptr[2] and the statement
	cout << ptr[2] << endl;
displays that string.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY MANAGEMENT 
[pag451deitel]
You can control the allocation and deallocation of memory in a pogram for objects and for arrays of any built-in or user-defined type. This is known as dynamic memory management and is performed with the operators >> new and >> delete. 
Un poco di terminologia
>> allocate = reserve (a certain amount of memory)
The new operator can be used to dynamically allocate the exact amount of memory required to hold an object or built-in array at execution time. The object or built-in array is created in the >> free store (also called the >> heap), that is a region of memory assigned to each program for storing dynamically allocated objects [operator "new" could fail to obtain the needed memory, in which case  a "bad_alloc" exception will occur]
Once memory is allocated in the free store, you can access it via the pointer that operator "new" returns. When you no longer need the memory, you can return it to the free store by using the "delete" operator to >> deallocate (= release) the memory, which can be reused by future new operations 
- Obtaining dynamic memory with "new"
	Time *timePtr = new Time(); [example e spiegazione di tale espressione pag451]
- Releasing Dynamic Memory with delete
To destroy a dynamically allocated object and free the space for the object, use the delete operator as in the following example
	delete timePtr;
This statement first calls the destructor for the object to which timePtr points, then deallocates the memory associated with the object, returning the memory to the free store.
WARNINGS
1) >> memory leak : not releasing dynamically allocated memory when it's no longer needed can causes the system to run out of memory prematurely. This is sometimes called a "memory leak".
2) Do not delete memory that was not allocated by "new". Doing so results in undefined behaviour
3) After you delete a block of dynamically allocated memory be sure not to delete the same block again. One way to guard against this is to immediately set the pointer to nullptr. Delete a "nullptr" has no effect.
- Initializing dynamic memory [pag452deitel]
example
	double *ptr = new double ( 3.14159 );
which initializes a newly creatd double to 3.14159 and assigns the resulting pointer to "ptr". 
- >> Dynamically allocating built-in arrays with new[]
example: allocate a 10-element integer array can be allocated and assigned to gradesArray as follows:
	int *gradesArray = new int[ 10 ]();
which declares "int" pointer "gradesArray" and asignes to it a pointer tothe first element of a dynamically allocated 10-elements array of ints. The parentheses following new int[10] value initialize the array's elements (fundamental numeric types are set to 0, bools are set to false, pointers are set to nullptr and class objects are initialized by their default constructor). 
The size of an array created at compile time must be spcified using an integral constant expression [una volta che l'hai compilato quel size resta e non lo si puo' modificare]
However, a dynamically allocated array's size can be specified using any non negative integral expression that ca be evaluated at execution time. [<= questo e' davvero utile!!! puoi immaginare per esempio di calcolare dopo un cyclo for quale sia il numero N di elementi da detectare, e allocare un array di dimensione pari a N (essendo variabile usi bene le risorse della memoria, senza rischiare di allocare un vettore troppo piccolo o troppo grande)] 
NOTE [pag453]:  in C++11 you can use a list initilizer to initialize the elements of a dynamically allocated built-in array, as in 
	int *gradesArray = new int [ 10 ]{};
in the braces {} you can also write a comma-separated list of initializers for the arra's elements. Se la lasci vuota come nell'esempio sopra, inidicates that default initialization should be used for each element.
>> RELEASE Dynamically allocated built-in arrays with delete[] / >> delete[]
[pag453deitel]
supponi di aver inizializzato dinamicamente int *gradesArray = new int [ 10 ]{};
To deallocate the memory to which "gradesArray" points, use the statement:
	delete [] gradesArray;
The statement first calls the destructor for every object  in the array, then deallocates the memory. 
COMMON PROGRAMMING ERROR: using "delete" instead of delete[] for built-in arrays of objects can lead to runtime logic errors. To ensure that every object in the array receives a destructor call, always delete memory allocated as an array with operator delete[].
>> unique_ptr [pag453 deitel] 
C+11 unique_ptr is a smart pointer for managing dynamically allocated memory. When a unique_ptr goes out of scope, its destructor automatically returns the managed memory to the free store. 
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY [mike pag269 game programming] + >> Dynamic Allocate Memory pag277 mike game programming
C++ gives a game programmer a highdegree of control over the computer. One of the most fundamental abilities is direct control over memory, like for example dynamically allocate and free memory. But with great power comes great responsability, in the following comments we will show you the pitfalls of dynamic memory and how to avoid them.
>> AGGREGATION [pag269 mike programming] = combining of objects so that one is part of another. 
Game objects are often composed of other objects. For example, in a racing game, a drag racer could be seen as a single object composed of other individual objects, such as a body, four tires and an engine.
--------------------------------------------------------------FULL EXAMPLE START critter_farm.cpp
	//Critter Farm
	//Demonstrates object containment
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	class Critter
	{
	public:
	    Critter(const string& name = "");
	    string GetName() const;  
	   
	private:
// one way to use aggregation when defining a class is to declare a data member that can hold another object. 
// that's what we do in the following line. 
	    string m_Name; // we declare the data member m_Name to hold ... jump to "UBIKstring"
	};
	
	Critter::Critter(const string& name):
	    m_Name(name)   // ... UBIKstring m_Name to hold a string object.
// Generally, you use aggregation when an object has another object. In this case critter has a name. These kind of relationships are called a >> has-a / >> has a relationships. 
	{}
	
	inline string Critter::GetName() const 
	{
	    return m_Name;
	}
	
	class Farm
	{
	public:
	    Farm(int spaces = 1); 
	    void Add(const Critter& aCritter);
	    void RollCall() const;
	    
// >> CONTAINER DATA MEMBERS example [pag273 mike game programming]
	private:
	    vector<Critter> m_Critters;  // this data member is simply a vector that holds Critter objects called m_Critter
	};
	
	Farm::Farm(int spaces)  // quando nel main viene lanciato il comando Farm "myFarm(3);" spaces diventa uguale a 3. 
	{
	    m_Critters.reserve(spaces);  // and this line allocates memory for 3(=spaces) Critter objects in the Farm object's m_Critter vector. 
	}
	
	void Farm::Add(const Critter& aCritter) // next we add three critters to the farm by calling the Farm object\81fs Add() member function.
	{
	    m_Critters.push_back(aCritter);
// note : push_back() adds a copy of an object to a vector [this means that I create an extra copy of each Critter object every time I call Add()]. This is not big deal in the Critter Farm program, but if we were adding many large objects, it could become a performance issue. You can reduce this overhead by using, say, a vector of pointers to objects.
	}
	
	void Farm::RollCall() const
	{
	    for (vector<Critter>::const_iterator iter = m_Critters.begin(); 
	         iter != m_Critters.end(); 
	         ++iter)
		{
	        cout << iter->GetName() << " here.\n";
		}
	}
	
	int main()
	{
	    Critter crit("Poochie");
	    cout << "My critter's name is " << crit.GetName() << endl; 
	
	    cout << "\nCreating critter farm.\n";
	    Farm myFarm(3);
	    
	    cout << "\nAdding three critters to the farm.\n";
	    myFarm.Add(Critter("Moe"));
	    myFarm.Add(Critter("Larry"));
	    myFarm.Add(Critter("Curly"));
	
	    cout << "\nCalling Roll...\n";
	    myFarm.RollCall();
	       
	    return 0;
	}

--------------------------------------------------------------END FULL EXAMPLE START critter_farm.cpp
OUTPUT of the program:
	My critter's name is Poochie
	
	Creating critter farm.
	
	Adding three critters to the farm.
	
	Calling Roll...
	Moe here.
	Larry here.
	Curly here.
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMICALLY ALLOCATE MEMORY / >> DYNAMIC MEMORY ALLOCATION [pag277 mike game programming]
So far, whenever you've declared a variable, C++ has allocated the necessary memory for it. When the function that the variable was created in ended, C++ freed the memory. This memory, which is used for local variables, is called the >> STACK. But there's another kind of memory that persists independent of the functions in a program. You the programmer, are in charge of allocating and freeing this memory, collectively called the >> HEAP (or >> FREE STORE / >> FREESTORE - termine che tra l'altro ritrovi anche in alcune pagine doxygen di OF).
At this point, you might be thinking "Why bother with another type of memory? THe stack works just fine, thank you." Using the dynamic memory of the heap offers great benefits that can be summed up in one word: EFFICIENCY. By using the heap, you can use only the amount of memory you need at any given time. If you have a game with a level that has 100 enemies, you can allocate the memory for the enemies at the beginning of the level and free the memory at the end. The heap also allows you to create an object in one function that you can access even after that function ends (without having to return a copy of the object). Dynamic memory is an important tool in writing any significant game.
PUNTI SALIENTI DEL PROGRAMMA SOTTOSTANTE
>> NEW / >> new [pag280 mike game programming]: new operator allocates memory on the heap and returns its address. You use "new" followed by the type of value you want to reserve space for:
	 int* pHeap = new int;
The new int part of the statement allocates enough memory on the heap for one "int" and returns the address on the heap for that chunk of memory. The other part of the statement int* pHeap, declares a local pointer, pHeap, which points to the newly allocated chunk of memory on the heap.
By using pHeap, we can manipulate the chunk of memory on the heap reserved for an integer. That's what we can do with 
	*pHeap = 10;
we assign 10 to the chunk of memory and then we display that value stored on the heap, as we would with any other pointer to int. The only difference is that pHeap points to a piece of memory on the heap, not the stack.
HINT: you can initialize memory on the heap at the same time you allocate it by palcing a value, surrounded by parentheses, after the type. For example:
	int* pHeap = new int(10);
this line allocates a chunk of memory on the heap for an int variable and assigns 10 to it. The statement then assigns the address of that chunk of memory to pHeap.
One of the major advantages of memory on the heap is that it can persist beyond the function in which it was allocated, meaning that you can create an object on the heap in one function and return a pointer or reference to it. That's what we can demonstrate with the line:
	 int* pHeap2 = intOnHeap();
The statements calls the function intOnHeap(), which allocates a chunk of memory on the heap for an int and assigns 20 to it.
	int* intOnHeap()
	{
	    int* pTemp = new int(20);
	    return pTemp;
	}
Then the function returns a pointer to this chunk of memory. Back in main() the assignment statement assigns the address of the chunk of memory on the heap to pHeap2. Next we use the returned pointer to display the value.
	cout << "*pHeap2: " << *pHeap2 << "\n\n";
HINT: up until now (chapter 1-8 mike programming) , if you wanted to return a value created in a function, you had to return a copy of the value. But by using dynamic memory, you can create an object on the heap in a function and return a pointer to the new object.
>> DELETE OPERATOR [pag281 mike game programming]
Ulike storage for local variables on the stack, memory that you've allocated on the heap must be explicitly freed. When you're finished with memory that you've allocated with "new", you should free it with "delete". That's what we do with the line 
	delete pHeap;
which frees the memory on the heap that stored 10.
That memory is returned to the heap for future use. The data tha was stored in it is no longer available.
TRICK: because you need to free memory that you've allocated once you're finished with it, a good rule of thumb is that every "new" should have a corresponding "delete". In fact, some programmers write the "delete" statement just after writing the "new" statement whenever possible, so they don't forget it.
NOTE: an important point to understand here is that the two previous statements free the memory on the heap, but they do not directly affect the local variables pHeap and pHeap2. This creates a potential problem because pHeap and pHeap2 now point to memory that has been returned to the heap, meaning that they point to memory that the computer can use in some other way at any time. Pointers like this are called
	>> DANGLING POINTERS [pag 280 mike game programming]
and they are quite dangerous. You should never attempt to dereference a dangling pointer. One way to deal with dangling pointers is to assign 0 to them, and that's what we do with the lines 
	pHeap = 0;
	pHeap2 = 0;
Another good way to deal with a dangling pointer is to assign a valid memory address to it.
TRAP: using delete on a dangling pointer can cause your program to crash. Be sure to set a dangling pointer to 0 or reassign it to point to a new, valid chunk of memory.
>> MEMORY LEAKS AVOIDANCE / >> LEAKED MEMORY [pag282 mike game programming]
One problem with allowing a programmer to allocate and free memory is that he might allocate memory and lose any way to get at it, thus losing any way to ever free it. When memory is lost like this, it's called a MEMORY LEAK. Given a large enough leak, a program might run out of memory and crash. As a game programmer, it's your responsability to avoid memory leaks.
Here's an example of what you should NOT do:
	void leak1()
	{
	    int* drip1 = new int(30);
	}
this function leak1() simply allocates a chunk of memory on the heap for an int value and then ends. 
If we were to call this function, memory would be lost foverer (okay, it would be lost until the program ended). The problem is that "drip1" which is the only connection to the newly acquired chunk of memory on the heap, is a local variable and ceases to exist when the function leak1() ends. There is no way to free the allocated memory. To avoid this memory leak, we could do one of two things: 
- use delete to free the memory in leak1()
- return a copy of the pointer drip1. If we choose the second option, we have to make sure to free this memory in some other part of the program.
Here's another example that creates a memory leak:
	void leak2()
	{
	    int* drip2 = new int(50);
	    drip2 = new int(100);
	    delete drip2;
	}
This memory leak is a little more subtle but there is still a leak. The line "int* drip2 = new int(50);" allocates a new piece of memory on the heap, assigns 50 to it, and has drip2 point to that piece memory. 
The second line "drip2 = new int(100);"  points drip2 to a new piece of memory on the heap, which stores the 100. The problem is taht the memory on the heap that stores 50 now has nothing pointing to it, so there is no way for the program to free that memory. As a result, that piece of memory has essentially leaked out of the system. The last statement "delete drip2;" frees the memory that stores 100, so this won't be the source of another memory leak. But remember, the memory on the heap that stores 50 has still leaked out of the system. Also we don't worry about drip2, which technically has become a dangling pointer, because it will cease to exist when the function ends.
-------------------------------------------------------------------------- START FULL EXAMPLE DYNAMIC MEMORY ALLOCATION 
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/heap.cpp]
	// Heap
	// Demonstrates dynamically allocating memory
	
	#include <iostream>
	
	using namespace std;
	
	int* intOnHeap();  //returns an int on the heap
	void leak1();      //creates a memory leak
	void leak2();      //creates another memory leak
	
	int main()
	{
	    int* pHeap = new int; // il programma dynamically allocates memory on the heap for an integer variable
	    *pHeap = 10; // assigns it a value 
	    cout << "*pHeap: " << *pHeap << "\n\n"; // and then display it 
	    
	    int* pHeap2 = intOnHeap(); // call of the function intOnHeap that dynamically allocates memory on the heap for another integer variable [vedi la sua definizione sotto]
	    cout << "*pHeap2: " << *pHeap2 << "\n\n"; // displayin the value of the returned pointer 
	    
	    cout << "Freeing memory pointed to by pHeap.\n\n";
	    delete pHeap;  // frees the allocated memory on the heap
	
	    cout << "Freeing memory pointed to by pHeap2.\n\n";
	    delete pHeap2;
	    
	    //get rid of dangling pointers
	    pHeap = 0; 
	    pHeap2 = 0;
	   
	    return 0;
	}
	
	int* intOnHeap()   // this the function that dyanmically allocates memory on the heap for an integer variable and assigns it a value
	{
	    int* pTemp = new int(20);  
	    return pTemp;   // return a pointer 
	}
	
	void leak1() // function to demonstrate the misuse of dynamic memory
	{
	    int* drip1 = new int(30);
	}
	
	void leak2() // function to demonstrate the misuse of dynamic memory
	{
	    int* drip2 = new int(50);
	    drip2 = new int(100);
	    delete drip2;
	}
	

-------------------------------------------------------------------------- FINE  FULL EXAMPLE DYNAMIC MEMORY ALLOCATION 
///////////////////////////////////////////////////////////////////////////////////////////

>> MEMORY MANAGEMENT  / >> FLEXIBLE MEMORY MANAGEMENT  [pag203 moo book]
There are standard library facilities designed to support flexible memory management.  The core language itself does not have any notion of memory allocation, because the properties of memory are too variable to wire into the language itself.
For example, modern computers have many kinds of memory. There may be many different speeds of memory on the machine. There may be memory with special properties, such as graphical buffers or shared memory. There may be memory that is persistent across power failures. Because users might want to allocate any of these (or other) kinds of memory, it is best left to the library to specify how we allocate and manage memory. The standard library doesn't support all these kinds of memory; instead, it offers a facility to manage memory along with a uniform interface for memory managers. As with the decision to make input-output a library rather than a language facility, the decision to make memory management part of the library gives us greater flexibility in using these different kinds or memory.
>> ALLOCATOR class see pag204 moo book
>> CLASS INVARIANT see pag206 moo book
//////////////////////////////////////////////////////////////////////////////////////////////////

>> DATA MEMBERS and HEAP / >> HEAP DATA MEMBERS [pag284 mike game programming]
You've seen how you can use aggregation to declare data members that store objects, but you can also declare data members that are pointers to values on the heap. You might use a data member that points to a value on the heap for some of the reasons your would use pointers in other situations. For example, you might want to declare a data member for a large 3D scene; however, you might only have access to the 3D scene through a pointer. Unfornately problems can arise when you use a data member that points to a value on the heap because of the way that some default object behaviour work. But you can avoid these issues by writing member functions to change these default behaviours.
In the example below "heap_data_member.cpp" the program defines a new type of critter with a data member that is a pointer, which points to an object stored on the heap. The class defines a few new member functions to handle situations in which an object is destroyed, copied, or assigned to another object. The program destroys, copies, and assigns objects to show that the objects behave as you'd expect, even with data members pointing to values on the heap.
NOTE: >> DESTRUCTORS DEFINITION / >> DESTRUCTORS DECLARATION [pag288 mike game programming]
One problem that can occur when a data member of an object points to a value on the heap is a memory leak. That's beacuse when the object is deleted, the pointer to the heap value disappears along with it (quindi perdi l'informazione di dove sia il campo di memoria che avevi allocato, quindi leakka, bye bye is over e andato finche' il programma non termina). If the heap value remains, it produces a memory leak. To avoid a memory leak, the object should clean up after itself before it is destroyed by deleting its associated heap value. 
[>> DESTRUCTORS why we need them]
Fortunately, there's a member function, the destructor, that's called just before an object is destroyed, which can be used to perform the necessary cleanup.
A default destructor, which is created for you by the compiler if you don't write your own, DOES NOT attempt to free any memory on the heap that a data member might point to. This behaviour is usually fine for simple classes, but when you have a class with data members that point to values on the heap, YOU SHOULD WRITE your OWN DESTRUCTOR so you can free the memory on the heap associated with an object before the object disappears, avoiding a memory leak.
As you can see in the program below first si dichiara il destructor all'interno della class definition. Il destructor has the sname of the class preceded by ~ and does not have any parameters or return value 
	class Critter   // class definition begins 
	{
     ...
	    ~Critter();  // >> DESTRUCTOR DECLARATION 
     ...
	}
--------------------------------------------------
>> COPY CONSTRUCTORS [pag289 mike game programming]
Sometimes an object is copied automatically for you. This occurs when an object is 
	- passed by value to a function
	- returned from a function 
	- initialized to another object through an initializer
	- provided as a single argument to the object's constructor
The copying is done by a special member function called the "COPY CONSTRUCTOR". Like constructors and destructors, a default copy constructor is supplied for you if you don't write one of your own. The default copy constructor simply copies the value of each data member to data members fo the same name in the new object ( a member wise copy)
For simple classes, the default copy constructor is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing you own copy constructor. Why? Imagine a Critter object that has a data member that's apointer to a string object on the heap. With only a default copy constructor, the automatic copying of the object would result in a new object that points to the same single "string" on the heap because the pointer of the new object would simply get a copy of the address stored in the pointer of the original object. [>> SHALLOW COPY] This member wise copying produces a shallow copy in which the pointer data members of the copy point to the same chunks of memory as the pointer data members in the original object. Why this is a problem? Perche' una volta che il destructor free the memory on the heap, the pointer della shallow copy finirebbe per diventare un dangling pointer (= point to memory that has been freed) [see full explanation pag 290 mike game programming].
[>> DEEP COPY mike game programming pag 291] What you really need is a copy constructor that produces a new object with its own chunk of memory on the heap for each data member that points to a heap object (= a deep copy).
That's what we do when we define a copy constructor for the class, which replaces the default one provided by the compiler. First inside the class definition we declare the copy constructor:
	Critter(const Critter& c);    //copy constructor prototype
Next, outside the class definition, we define the copy constructor:
	Critter::Critter(const Critter& c)        //copy constructor definition
	{
	    cout << "Copy Constructor called\n";
	    m_pName = new string(*(c.m_pName));
	    m_Age = c.m_Age;
	}
Just like this one, a copy constructor must have the same name as the class. It returns no value, but accepts a reference to an object of the class (the object that needs to be copied). The reference should be made a constant reference to pretext the original object from being changed during the copy process.
The job of a copy constructor is to copy any data members from the original object to the copy object. If a data member of the original object is a pointer to a value on the heap, the copy constructor should request memory from the heap, copy the original heap value to this new chunk of memory, and then point the appropriate copy object data member to this new memory.
NOTE from pag 292 mike game programming figure 9.10: With a proper copy constructor, the original and the copy each point to their own chunk of memory on the heap. Then, when the copy is destroyed, the original is unaffected.
HINT: when you have a class with data members that point to memory on the heap, you should consider writing a copy constructor that allocates memory for a new object and creates a deep copy.
>> WISE COPY vs DEEP COPY / >> DEEP COPY vs WISE COPY 
[pag304 mike game programming ]
The copy constructor is a member function that's invoked when an automatic copy of an object is made. A default copy constructor is supplied for a class if you don't write one of your own. 
	The default copy constructor simply copies the value of each data member to data members with the same names in the copy, producing a member wise copy. 
	[>> member wise copy pag 304 mike game programming]
	Member wise copying can produce a shallow copy of an object, in which the pointer data members of the copy point to the same chunks of memory as the pointers in the original object. 
	[>> deep copy]
	A deep copy is a copy of an object that has no chunks of memory in common with the original.
 ASSIGNMENT OPERATOR (cioe' operatore = , il segno uguale che assegna al membro sinistro il membro a destra) [from pag 293 mike game programming and search "//overloaded assignment op" per ritrovarlo nel programma qui sotto] When both side of an assignment statement are object of the same class, the class' assignment operator member function is called. Like a default copy constructor, a default assignment operator member function is supplied for you if you don't write one of your own. Also like the default copy constructor, the default assignment operator provides only member-wise duplication. 
For simple classes, the default assignment operator is usually fine. However, when you have a class with a data member that points to a value on the heap, you should consider writing an overloaded assignment operator of your own. If you don't, you'll end up with shallow copies of objects when you assign one object to another. To avoid this problem, we overload the assignment operator for Critter. First, inside the class definition, we write the declaration:
	  Critter& Critter::operator=(const Critter& c);  //overloaded assignment op
Next, outside the class definition, we write the member function definition
	Critter& Critter::operator=(const Critter& c)  //overloaded assignment op def
// nota come questa member function operator=() abbia il goal to assign the values of all the data members of a critter object to another critter object, while making sure each critter object has its own chunks of memory on the heap for any pointer data members.
	{
	    cout << "Overloaded Assignment Operator called\n";
	    if (this != &c) // this condition checks whether the address of crit1 is not equal to the address of crit2. That is, it tests if the object isn't being assigned to ifself. 
	    {
	        delete m_pName; // frees the memory on the heap
	        m_pName = new string(*(c.m_pName)); // allocate new chunk of memory on the heap, get a copy of the object and copies into the new heap memory, and points the m_pName data member ... descrizione dettagliata continua a pag 294 mike game programming -> ti rimando alla lettura diretta del libro
	        m_Age = c.m_Age;
	    }
	    return *this; // the member function returns a reference to a Critter object. For robust assignment operation, return a reference from the overloaded assignment operator member function.
	}
------------------------------------------------------------------------------------------- START heap_data_member.cpp program
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/heap_data_member.cpp]
	//Heap Data Member
	//Demonstrates an object with a dynamically allocated data member
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Critter   // CLASS DEFINITION BEGINS
	{
	public: 
	    Critter(const string& name = "", int age = 0);  
	    ~Critter();                   //destructor prototype  : qui si dichiara il destructor all'interno della class definition. Il destructor has the sname of the class preceded by ~ and does not have any parameters or return value 
	    Critter(const Critter& c);    //copy constructor prototype
	    Critter& Critter::operator=(const Critter& c);  //overloaded assignment op
	    void Greet() const; 
	
	private:
// to declare a data member that points to a value on the heap we first need to declare a data member that's a pointer, as done in the
// following line:
	    string* m_pName;
	    int m_Age;
	};               // CLASS DEFINITION ENDS
	
// start constructor definition 
	Critter::Critter(const string& name, int age)
	{
	    cout << "Constructor called\n";
// with the following line we allocate memory on the heap, assign a value to the memory and then point a pointer data member to the memory.
	    m_pName = new string(name); // we allocate memory for a string object, assigns "name" to it, and points the pointer "m_pName" to that chunck of memory on the heap. 
	    m_Age = age;  
	}
// end constructor definition	

	Critter::~Critter()                        //destructor definition
	{
	    cout << "Destructor called\n";
	    delete m_pName;
	}
	
	Critter::Critter(const Critter& c)        //copy constructor definition
	{
	    cout << "Copy Constructor called\n";
	    m_pName = new string(*(c.m_pName));
	    m_Age = c.m_Age;
	}
	
	Critter& Critter::operator=(const Critter& c)  //overloaded assignment op def
	{
	    cout << "Overloaded Assignment Operator called\n";
	    if (this != &c)
	    {
	        delete m_pName;
	        m_pName = new string(*(c.m_pName));
	        m_Age = c.m_Age;
	    }
	    return *this;
	}
	
	void Critter::Greet() const
	{
	     cout << "I'm " << *m_pName << " and I'm " << m_Age << " years old. ";
	     cout << "&m_pName: " << &m_pName << endl;
	}
	
	void testDestructor();
	void testCopyConstructor(Critter aCopy);
	void testAssignmentOp();
	
	int main()
	{
	    testDestructor();  
	    cout << endl;
	    
	    Critter crit("Poochie", 5);
	    crit.Greet();
	    testCopyConstructor(crit);
	    crit.Greet();
	    cout << endl;
	    
	    testAssignmentOp();
	
	    return 0;
	}
	
	void testDestructor()
	{
	    Critter toDestroy("Rover", 3);
	    toDestroy.Greet();
	}
	
	void testCopyConstructor(Critter aCopy)  
	{
	    aCopy.Greet();
	}
	
	void testAssignmentOp()
	{
	    Critter crit1("crit1", 7);
	    Critter crit2("crit2", 9);
	    crit1 = crit2;
	    crit1.Greet();  
	    crit2.Greet();
	    cout << endl;
	        
	    Critter crit3("crit", 11);
	    crit3 = crit3;
	    crit3.Greet();
	}
------------------------------------------------------------------------------------------- END heap_data_member.cpp program
OUTPUT PROGRAM:
non venuto ci veniva l'errore:
[2084 chapter09] >> g++ heap_data_member.cpp -o heap_data_member
heap_data_member.cpp:15:14: error: extra qualification \81eCritter::\81f on member \81eoperator=\81f [-fpermissive]
ITIAF...extra qualification Critter my ass! Alien Reply omage
///////////////////////////////////////////////////////////////////////////////////////////

>> DYNAMIC MEMORY IN ACTION, PRACTICAL EXAMPLE  from mike game programming pag296
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/game_lobby.cpp]
---------------------------------------------------------------------------------- START game_lobby.cpp
	//Game Lobby
	//Simulates a game lobby where players wait
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Player
	{
	public:  
	    Player(const string& name = "");
	    string GetName() const;
	    Player* GetNext() const;
	    void SetNext(Player* next);
	    
	private:
	    string m_Name;
	    Player* m_pNext;  //Pointer to next player in list
	};
	
	Player::Player(const string& name): 
	    m_Name(name), 
	    m_pNext(0) 
	{}
	
	string Player::GetName() const
	{
	    return m_Name;
	}
	
	Player* Player::GetNext() const
	{
	    return m_pNext;
	}
	
	void Player::SetNext(Player* next)
	{
	    m_pNext = next; // [pag 298 mike game programming] each Player object has an m_pNext data member, therefore you can link 
						// a bunch of Player objects in a >> linked list. Individual elements of linked lists are often called nodes.
    					// see bella figura pag 298 mike game programming o la nostra piccola text art figure qui sotto 
						// One way to think about the player nodes is as a group of train cars (= vagoni del treno) that carry cargo 
						// and are connected. In this case the train cars carry a name as a cargo and are linked through a pointer data
						// member, m_pNext

//
//          m_pHead
//          ---------
//          |       |
//          ----|----
//              |              COME I VAGONI DI UN TRENO 
//              V           
//          ---------                  ----------                  ----------
//  m_Name  | "Mike"|          m_Name  | "Steve"|          m_Name  | "Larry"|
//          ---------                  ----------                  ----------
//  m_pNext |    ---|------->  m_pNext |   -----|------->  m_pNext |    ----|------> NULL     
//          ---------                  ----------                  ----------
//
//
//

	}
	
	class Lobby    // the Lobby class allocates memory on the heap for each Player object in the list
	{
	    friend ostream& operator<<(ostream& os, const Lobby& aLobby);
	    
	public:
	    Lobby();
	    ~Lobby();
	    void AddPlayer();  // AddPlayer istanzia a Player object on the heap and adds it to the end of the list. 
	    void RemovePlayer(); // RemovePlayer() removes the first Player object in the list, freeing the allocated memory.
	    void Clear();
	    
	private:
	    Player* m_pHead;  // the data member m_pHead is a pointer that points to a Player object, which represents the first person in line. 
                          // m_pHead represents the head of the line.
	};
	
	Lobby::Lobby():    // questo e' il >> constructor: it simply initializes the data member m_pHead to 0, making it a null pointer.
	    m_pHead(0)
	{}
	
	Lobby::~Lobby()    // questo e' il >> destructor. The destructor simply calls Clear(), which removes all the Player objects 
	{                  // from the list, freeing the allocated memory.
	    Clear();
	}
	
	void Lobby::AddPlayer()  // pag299 mike game programming. The Lobby::AddPlayer() member function adds a player to the 
	{                        // end of the line in the lobby.
	    //create a new player node
	    cout << "Please enter the name of the new player: ";
	    string name;
	    cin >> name;
	    Player* pNewPlayer = new Player(name);
	
	    //if list is empty, make head of list this new player
	    if (m_pHead == 0)
	    {
	        m_pHead = pNewPlayer;
	    }
	    //otherwise find the end of the list and add the player there
	    else
	    {
	        Player* pIter = m_pHead;
	        while (pIter->GetNext() != 0)
	        {
	            pIter = pIter->GetNext();       
	        }
	        pIter->SetNext(pNewPlayer);
	    }
	}
	
	void Lobby::RemovePlayer()
	{
	    if (m_pHead == 0)
	    {
	        cout << "The game lobby is empty.  No one to remove!\n";
	    }
	    else
	    {
	        Player* pTemp = m_pHead;
	        m_pHead = m_pHead->GetNext();
	        delete pTemp;
	    }
	}
	
	void Lobby::Clear()
	{
	    while (m_pHead != 0)
	    {
	        RemovePlayer();
	    }
	}
	
	ostream& operator<<(ostream& os, const Lobby& aLobby)
	{
	    Player* pIter = aLobby.m_pHead;
	
	    os << "\nHere's who's in the game lobby:\n";
	    if (pIter == 0)
	    {
	        os << "The lobby is empty.\n";
	    }
	    else
	    {
	        while (pIter != 0)
	        {   
	            os << pIter->GetName() << endl;
		        pIter = pIter->GetNext();
	        }
	    }
	
	    return os;
	}
	
	int main()
	{
	    Lobby myLobby;
	    int choice;
	    
	    do
		{
		    cout << myLobby;
	        cout << "\nGAME LOBBY\n";
	        cout << "0 - Exit the program.\n";
	        cout << "1 - Add a player to the lobby.\n";
	        cout << "2 - Remove a player from the lobby.\n";
	        cout << "3 - Clear the lobby.\n";
	        cout << endl << "Enter choice: ";
	        cin >> choice;
	
	        switch (choice)
	        {
	            case 0: cout << "Good-bye.\n"; break;
		        case 1: myLobby.AddPlayer(); break;  
	            case 2: myLobby.RemovePlayer(); break;
	            case 3: myLobby.Clear(); break;
	            default: cout << "That was not a valid choice.\n";
	        }
		}
	    while (choice != 0);
	    
	    return 0;
	}

---------------------------------------------------------------------------------- END game_lobby.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> EEEEEEE

>> end line / >> line end [pag 3 moo book]
usa std::endl = ends the current line of output
example 
	std::cout << "Hello, world!" << std::endl;
NOTE: ricordati di includere 
	#include <iostream>
nell'inizio del programma

>> EOF / >> end of file signal [pag36 moo book]
CTRL + z in windows systems
CTRL + d in linux systems

>> ERROR HANDLING / >> EXCEPTION HANDLING [pag 716 jesse book]
It is rare for a real world sized program not to have some sort of error or bug. The bigger the program, the more likely there will be bugs. In fact, in larger programs, it is often the case that many bugs actually "get out of the door" and into final, released software. That this is true does not make it okay. Making robust, bug-free program should be the number one priority of anyone serious about programming. 
The single biggest problem in the software industry is buggy, unstable code. One of the biggest expenses in many major programming  efforts is testing and fixing. The person who solves the problem of producing good, solid, bulletproof programs at low cost and on time will revolutionize the software industry. 
A number of discrete kinds of errors can trouble a program. 
- The first is poor logic: the  program does just what you asked, but you haven't thought through the algorithms properly. 
- The second is syntactic: You used the wrong idiom, function, or structure. 
These two are the most common, and they are the ones most programmers. are on the lookout for. 
Research and real world experience have shown that the later in the development process you find a logic problem, the more it costs to fix it. The least expensvice problems or bugs to fix are the ones you manage to avoid creating. The next cheapest are those spotted by the compiler. The C++ standards force compilers to put a lot of energy into making more and more bugs show up at compile time. 
Errors that get compiled in your program, but are caught at the first test (cioe' errori che il compiler non rileva li processa e produce l'eseguibile, ma una volta che lanci l'eseguibile crasha), that is those that crash every time, are less expensive to find and fix than those that are flakly and only crash once in a while. 
A more common runtime problem than logic or syntactic bugs is >> fragility : your program works just fine if the user enters a number when you ask for one, but it crashes if the user enters letters. Other programs crash if they run out of memory, if the floppy disk is left out of the drive, or if an Internet connection is lost. 
To combat this kind of fragility, programmers strive to make their programs bullefproof. A >> bulletproof program is one that can handle anything that comes up at runtime, from bizarre user input to running out of memory. 
It is important to distinguish between 
- bugs which arise because the programmer made a mistake 
- logic errors which arise because the programmer misunderstood the problem or how to solve it 
- and >> exceptions  which arise because of unusual but predictable problems such as running out of memory (memory or disc space).
>> EXCEPTIONAL CRICUMSTANCES [pag717 jesse book]
You can't eliminate exceptional circumstances; you can only prepare for them. What happens if your program requests memory to dynamically allocate an object, and there isn't any available? How will your program respond? Or, what will your program do if you cause one of the most common math errors by dividing by zero? Your choices include: 
	- crash 
	- inform the user and exit gracefully 
	- inform the user and allow the user to try to recover and continue 
	- take corrective action and continue without disturbing the user 
Consider the following listing 20.1 which is extremely simple and ready to crash. However, it illustrates a problem that makes it into many programs and that is extremely serious!
----------------------------------------------------------------------------------	
// questo programmino tenta di effettuare una divisione per zero. 303 infinity!
#include <iostream>
using namespace std;

const int DefaultSize = 10;

int main()
{
   int top = 90;
   int bottom = 0;
   
   cout << "top / 2 = " << (top/ 2) << endl;

   cout << "top divided by bottom = ";
   cout << (top / bottom) << endl;  // 90/0 division by zero causes an exceptional problem to occur, a crash. The program ends and an exception is displayed by the operating system. 

   cout << "top / 3 = " << (top/ 3) << endl;

   cout << "Done." << endl;
   return 0;
}
-------------------------------------------------------------------------------------
OUTPUT 
[1118 Day20] >> g++ -o List2001.exe List2001.cpp 
[1119 Day20] >> ./List2001.exe 
top / 2 = 45
Floating point exception (core dumped)    // aaah ecco il tipico messaggio che parecchie volte ci compare in openFOAM!
// il messaggio Floating point exception non proviene dal programma, il programma crasha e the exception message is displayed by the operating system. 
---------------------------------------------------------------------------------------
Although it is not always necessary (or even desiderable) to automatically and silently recover from all expeptional circumstances, it is clear that you must do better than this program. You can't simply let your program crash. 
C++ exception handling provides a type-safe, integrated method for coping with the predictable but unusual conditions that arise while running a program. 
----------------------------------------------------------------------------------------
THE IDEA BEHIND EXCEPTIONS [pag718 jesse]
The basic idean behind exceptions is fairly straightforward:
	- the computer tries to run a piece of code. This code might try to allocate resources such as memory, might try to lock a file, or any of a variety of tasks. 
	- logic (code) is included to be prepared in case the code you are tying to execute fails for some exceptional reason. For example, you would include code to catch any issues, such as memory not being allocated, a file being unable to be locked, or any of a variaty of other issues. 
	- In cause your code is being used by other code (for instance, one function calling another) you also need a mechanism to pass information about any problems (exceptions) from your level up to the next. There should be  a path from the code where an issue occurs to the code that can handle the error condition. If intervening layers of functions exist, they should be given an opportunity to clean the issue but should not be required to include code whose only purpose is to pass along the error condition. 
Exception handling makes all three of these points come together, and they do it in a relatively straightforward manner.
--------------------------------------------------------------------------------------------
EXCEPTION HANDLING PARTS / The parts of exception handling [pag719 jesse]
To handle exceptions, you have first identify that you want a particular piece of code to be watched for any exceptions. This is accomplished by using a try block. 
You should create a "try" block around any area of code that you believe has the potential to cause problem. The basic format of the try block is 

	try
	{
		SomeDangerousFunction();
	} 
	catch (...)
	{
	}

In this case, when SomeDangerousFunction() executes, if any exception occurs, it is noted and caught. Adding the keyword try and teh braces is all that is required to have your program start watching for exceptions. Of coarse, if an exception occurs, then you need to act upon it. 
[>> thrown exception]
When the code within a try block is executed, if an exception occurs, the  exception is said to be "thrown" . Thrown exceptions can then be caught, and as shown previously, you catch an exception with a catch block! When an exception is thrown, control transfers to the appropriate  catch block following the current try block. In the previous exemple "catch(...)" means that it will catch any type of exception. But you can also can specific type of exceptions. To do this, you use one or more catch blocks following your try block. For example : 

	try
	{
		SomeDangerousFunction(); // if when this function is executed an exception is thrown...
	}
	catch(OutOfMemory)  // ... then control transfer to this catch block immediately following the try block. 
    // this catch block has a type parameter "OutOfMemory" therefore the exception is checked to see if it matches the indicated type. If there is no match then... 
	{
		// take some actions 
	}
	catch(FileNotFound) // ... then we jump here and we check again if the exception type match. If not then...
	{
		// take other action 
	}
                                                                                            // ... then we land into this last block.  
	catch(...)  // per tutte le altre possibili exceptions 
	{
	}

The exception thrown will be checked until either a match is found or something other than a catch block is found. When the first match is found, that catch block is executed. Unless you really intended to let other types of exceptions through, it is always a good idea to have the last catch use the >> ellipse parameter = per ellipse parameter si intende "(...)" / >> ellipse = "(...)" cioe' la notazione segue catch(...) in modo to refers to any exception. 
NOTE1 : A catch block is also called a >> handler because it can handle an exception. 
NOTE2 : You can look at the catch blocks, as being like overloaded functions. When the matching signature is found, that function is executed.
The basic steps in handling exceptions are : 
1) identify those areas of the program in which you begin an operation that might raise an exception, and put them in "try" blocks. 
2) Create "catch" blocks to catch the exceptions if they are thrown. You can either create a catch for a specific type of exception (by specifying a typed parameter for the catch block) or all exception (by using an ellipses (...) as the parameter ).
The following listing 20.2 adds basic exception handling to listing 20.1. You can see this with the use of both a "try" block and a "catch" block. 
----------------------------------------------------------------------------------------- LISTING 20.2 STARTS
	#include <iostream>
	using namespace std;

	const int DefaultSize = 10;

	int main()
	{
	   int top = 90;
	   int bottom = 0;

	   try  // a try block i added around the code where a potential issue could occur. 
	   {
		  cout << "top / 2 = " << (top/ 2) << endl;  // this works

		  cout << "top divided by bottom = ";
		  cout << (top / bottom) << endl;  // this throws an exception visto che e' una divisione per 0, e la possiamo catchare.

		  cout << "top / 3 = " << (top/ 3) << endl;  // questa linea non viene piu' eseguita visto che l'exception ci fa saltare via dal blocco try
	   }
	   catch(...) // this catch block handles the exception 
	   {
		  cout << "something has gone wrong!" << endl;
	   }
       // una volta che catch ha eseguito l'handling (= in questo caso scrivere su screen that "something has gone wrong")
	   // then the program continues normalmente e il messaggio "Done" viene printato su schermo a segno che il programma non ha crashato, l'eccezione e' stata gestita e il programma ha terminato correttamente. 
	   cout << "Done." << endl; 
	   return 0;
	}
----------------------------------------------------------------------------------------- LISTING  20.2 ENDS
Unlike prior listing, executing listing 20.2 doesn't cause a crash. Rather the program is able to report an issue and exit gracefully. 
In this listing we used the general catch(...) but as you will see later it is often better to look for more specific types of exceptions so that can customize the handling of each. 
NOTE: nella nostra linux machine l'output e' un poco diverso da quello del libro. Al posto di avere 

	top / 2 = 45
	top divided by bottom = something has gone wrong!
	Done. 
Noi otteniamo : 
	[1124 Day20] >> g++ -std=c++11 -o List2002.exe List2002.cpp 
	[1125 Day20] >> ./List2002.exe 
	top / 2 = 45
	Floating point exception (core dumped)
Forse e' legato all'osservazione scritta a pagina 720 jesse? -> Some very old compilers do not support exceptions. Exceptions are part of the ANSI C++ standard, however, and every compiler vendor's latest edition fully supports exceptions. If you have an older compiler, you won't be able to compile and run the exercises in today's lesson. It's still a good  idea to read through the entire chapter, however, and return to this material when you upgrade your compiler.
...mmmm is it really that old? 
	[1126 Day20] >> g++ --version
	g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)
	Copyright (C) 2015 Free Software Foundation, Inc.
e' piu' giovane del libro...
-------------------------------------------------------------------
SUMMARY 
>> try blocks [pag722 jesse]
A try block is a series of statements that begins with the keyword try; it is followed by an opening brace and ends with a closign brace. 
Example 
	try
	{
		Function();
	}

>> catch blocks [pag 722 jesse]
A catch block is a piece of code that begins with the keyword catch, followed by an exception type in parenthesis, followed by an opening brace { and ending with a closing brace }. catch blocks are only allowed to follow a try block. 
Example
	try
	{
		Function() 
	};
	catch (OutOfMemory)
	{
		//take action
	}
----------------------------------------------------------------------------------------------------------------------------------
>> CAUSING YOUR OWN EXCEPTIONS / >> EXCEPTIONS CUSTOMIZED HANDLERS [pag722 jesse]
The listing 20.2 above illustrated tow of the aspects of exception handling (= 1. marking the code to be watch and 2. specifying how the exception is to be handled). However, only predefined excepetions were handled. The third part of exception handling is the ability for you to create your own types of exceptions to be handled. By creating  your own exceptions, you gain the ability to have customized handlers (catch blocks) for exceptions that are meaninful to your application. 
To create an exception that causes the try statement to react, the keyword "throw" is used. In essence, you "throw"  the exception and hopefully, a handler (catch block) catches it. The basic format of the throw statement is: 
	throw exception;
with this statement,  "exception" is thrown.  This causes control to be passed to a handler. If a handler can't be found, the program terminates. The value that you throw in the exception can be of virtually any type. As mentioned earlier, you can set up corresponding handlers for each type of object your program might throw. The following listing 20.3 illustrates how to throw a basic exception by modifying  Listing 20.2
---------------------------------------------------------------------------------------- LISTING 20.3 STARTS
// Throwing 
#include <iostream>

using namespace std;

const int DefaultSize = 10;

int main()
{
   int top = 90;
   int bottom = 0;

   try
   {  
      cout << "top / 2 = " << (top/ 2) << endl;
                                                    
      cout << "top divided by bottom = ";
      if ( bottom == 0 ) // we check if the value of botto is equal to zero
         throw "Division by zero!"; // if "bottom == 0" we throw an exception, in this case the exception is the string value ""Division by zero!"

      else
         cout << (top / bottom) << endl;

      cout << "top / 3 = " << (top/ 3) << endl;
   }
   catch( const char * ex ) // on this line a catch statement starts a handler. This handler is looking for a constant character pointer. With exceptions/Nel caso delle eccezioni, strings  are matched to a contanst character pointer. So this handler "catch( const char * ex )" catches the throw in 18 (che appunto lanciava una string value as exception).
   {
      cout << "\n*** " << ex << "***" << endl;  // with this line the string that was passed is displayed between asterisks.
   }
   catch(...)
   {
      cout << "something has gone wrong!" << endl;
   } // after this the control goes to the first line follow the "catch" statements

   cout << "Done." << endl;
   return 0;
}
---------------------------------------------------------------------------------------- LISTING 20.3 ENDS 
NOTE: 
If you exception had been a more serious problem, you could have exited  the application after printing the message in line 26 [cioe' "cout << "\n*** " << ex << "***" << endl;"]. If you throw your exception in a function that was called by another function, you could have passed the exception up. To pass an exception, you can simply call the throw command without any parameter. This causes the existing exception to be rethrown from the current location.
---------------------------------------------------------------------------------------- 
>> CREATING AN EXCEPTION CLASS [pag724 jesse]
You can create much more complex classes for throwing an exception. The listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2004.cpp
presents a somewhat stripped-down Array class, based on the template developed on Day 19 "Templates".
In this listing exception handling is added in case the array goes out of bounds. 
------------------------------------ PUNTI salienti del programma: 
- On line 24
	24     class xBoundary {};  // define the exception class
a new class xBoundary is declared within the declaration of the outer class Array. This new class is not in any way distinguished as an exception class. It is just a class the smae as any other. This partiuclar class is incredibly simple; it has no data and no methods. Nonetheless, it is a valid class in every way. 
In fact, it is incorrect to say it has no mehods bcause the compiler automatically assigns it a default constructor, destructor, copy constructor, and the assignment operator (operator equals); so it actually has four class functions, but no data. Note that declaring it from within Array serves only to couple the two classes together. As discussed on Lesson 16 "Advanced Inheritance" Array has no special access to xBoundary, nor does xBoundary have preferential access to the members of Array. 
- On lines 63-70 and 72-79 the offset operators are modified to examine the offset requested:
	 63 int& Array::operator[](int offSet)
	 64 {
	 65    int size = GetitsSize();
	 66    if (offSet >= 0 && offSet < GetitsSize())
	 67       return pType[offSet];
	 68    throw xBoundary();
	 69    return pType[0]; // appease MSC
	 70 }
	 71 
	 72 const int& Array::operator[](int offSet) const
	 73 {
	 74    int mysize = GetitsSize();
	 75    if (offSet >= 0 && offSet < GetitsSize())
	 76       return pType[offSet];
	 77    throw xBoundary();
	 78    return pType[0]; // appease MSC
	 79 }
if the offset is out of range, it throws the xBoundary class as an exception. 
- On line 99 the handler has been declared to catch any xBoundary exceptions.
	 99    catch (Array::xBoundary) 
- On lines 91-98  a try block is created in which each member of the array is initialized. 
	 91    try
	 92    {
	 93       for (int j = 0; j< 100; j++)
	 94       {
	 95          intArray[j] = j;
	 96          cout << "intArray[" << j << "] okay..." << endl;
	 97       }
	 98    }
When j (line 93 marquez) is incremented to 20, the member at offset 20 is accessed. This causes the test on line 66 to fail, and operator [] raises an xBoundary exception on line 67.
Program control switches to the catch block on line 99, and the exception is caught or handled by the catch on the same line, which prints an error message. Program flow drps through the end of the catch block on line 102: 
	100   {
	101      cout << "Unable to process your input!" << endl;
	102   }
---------------------------------------------------------------------
>> TRY BLOCKS LOCATION  / >> CATCH BLOCKS LOCATION : placing try blocks and catch blocks [pag728 jesse]
Figuring out where to put your try blocks can be hard: it is not always obvious which actions might raise an exception. 
The next question is where to catch the exception. It might be that you'll want to throw all memory exceptions where the memory is allocated, but you'll want to catch the exceptions high in the program where you deal with the user interface. 
When trying to determine try block locations, look to where you allocate memory, or use resourses. Other things to look for are out-of-bounds errors, illegal input, and so forth. At the very least put a try/catch around all of the code in main(). Try/catch usually belongs in high-level functions, particularly those that know about the program's user interface. 
For example a utility class should not generally catch exceptions that need to be reported to the user because it might be used in windowed programs or console programs, or even in programs that communicate with the users via the Web or messaging.
------------------------------------------------------------------------
>> HOW CATCHING EXCEPTIONS WORKS / >> EXCEPTION WORKFLOW [pag728 jesse]
Here's how it works: When an exception is thrown, the call stack is examined. The >> call stack is the list of function calls created when one part of the program invokes another function. The call stack tracks the execution path. If main() calls the function Animal::GetFavoriteFood(), and GetFavoriteFood() calls Animal::LookUpPreferences(), which in turn, calls "fstream::operator>>()", all these are on the call stack. A recursive function might be on the call stack many times.  [wow interesting! si tocca con mano proprio la lista di chiamate delle funzioni. Sarebbe carino poter visualizzare il call stack di quando si lancia un OF solver]
The exception is passed up the call stack to each enclosing block. This is called ">> unwindling the stack". As the stack is unwound, the destructors for local objects on the stack are invoked, and the objects are destroyed. One or more catch statements floow each try block. If the exception matches one of the catch statements, it is considered to be handled by having that statement execute. If it doesn't match any, the unwinding of the stack continues. 
If the exception reaches all the way to the beginning of the program (main()) and is still not caught, a build-in handler is called that terminates the program. 
It is important to note that the exception unwinding of the stack is a ONE WAY street. As it progresses, the stack is unwound and the objects on the stack are destroyed. THERE IS NO GOING BACK: After the exception is handled, the program continues after the try block of the catch statement that handled  the exception. 
Remember that when an exception is raised, program flow continues after the catch block, not after the point where the exception was thrown. 
----------------------------------------------------------------------------
>> MULTIPLE CATCHES / >> CATCHES MULTIPLE / >> using more than one catch specification 
It is possible for more than one condition to cause an exception. In this case, the catch statements can be lined up one after another, much like the conditions in a switch statement. The equivalent to the default statement is the "catch everything" statement, indicated by "catch(...)" The listing SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2005.cpp illustrates multiple exception conditions. 
--------------------------------------------------------------------------------- PUNTI SALIENTI DEL PROGRAMMA 
- Four new classes are created in lines 26-29, xTooBig, xTooSmall, xZero, and xNegative. 
	 26     class xTooBig {};
	 27     class xTooSmall{};
	 28     class xZero {};
	 29     class xNegative {};
- In the constructor in lines 56-71 the size passed to the constructor is examined. If it's too big, too small, negative or zero, an exception  is thrown. 
	 56 Array::Array(int size):
	 57    itsSize(size) 
	 58 {  
	 59    if (size == 0)
	 60       throw xZero();
	 61    if (size < 10)
	 62       throw xTooSmall();
	 63    if (size > 30000)
	 64       throw xTooBig();
	 65    if (size < 1)
	 66       throw xNegative();
	 67       
	 68    pType = new int[size];
	 69    for (int i = 0; i < size; i++)
	 70       pType[i] = 0;
	 71 } 
- The try block is changed to include catch statements for each condition other than negative, which is caught by the "catch everything" statement catch(...) shown on line 101. 
	 75    try
	 76    {
	 77       Array intArray(0);
	 78       for (int j = 0; j < 100; j++)
	 79       {
	 80          intArray[j] = j;
	 81          cout << "intArray[" << j << "] okay..." << endl;
	 82       }
	 83    }
	 84    catch (Array::xBoundary)
	 85    {
	 86       cout << "Unable to process your input!" << endl;
	 87    }
	 88    catch (Array::xTooBig)
	 89    {
	 90       cout << "This array is too big..." << endl;
	 91    }
	 92    catch (Array::xTooSmall)
	 93    {
	 94       cout << "This array is too small..." << endl;
	 95    }
	 96    catch (Array::xZero)
	 97    {
	 98       cout << "You asked for an array";
	 99       cout << " of zero objects!" << endl;
	100    }
	101    catch (...)
	102    {
	103       cout << "Something went wrong!" << endl;
	104    }
	105    cout << "Done." << endl;
	106    return 0;
- Try this with a number of values for the size of the array. Then try putting in "-5". You might have expected xNegative to be called, but the order of the tests in the constructor prevented this: size < 10 was evaluated before size < 1. To fix this, swap lines 61 and 62 with lines 65 and 66 and recompile. 
After the constructor has been invoked, memory has been allocated for the object. Therefore, throwing any exception from the constructor can leave the object allocated but unusable. Generally, you should wrap the constructor in a try/catch, and if an exception occurs, mark the object (internally) as unsuable. Each member function should check this "valid" flag to be certain additional errors won't occur when someone uses an object whose initialization was interrupted. 
---------------------------------------------------------------------------------------
>> EXCEPTION HIERARCHIES / >> EXCEPTION DERIVATION [pag732 jesse]
Exceptions are classes, and as such, they can be derived from. It might be advantageous to create a  class "xSize" and to derive from it xZero, xTooSmall, xTooBig, and xNegative. Thus, some functions might just catch xSize errors, and other functions might catch the specific type of xSize error. The listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2006.cpp 
illustrates this idea.  
------------------------------------------------- PUNTI salienti del programma 
- the significant change is on lines 27-30, where the class hierarchy is established. Classes xTooBig, xTooSmall, and xNegative are derived from xSize, and xZero is derived from xTooSmall. 
	 26     class xSize {}; 
	 27     class xTooBig : public xSize {};
	 28     class xTooSmall : public xSize {};
	 29     class xZero  : public xTooSmall {};
	 30     class xNegative  : public xSize {};
The Array is created with size zero but what's this? The wrong exception appears to be caught! Examine the catch block carefully, however, and you will find that it looks for an exception of type xTooSmall before it looks for an exception  of type xZero. Because an xZero object is thrown and an xZero object is an xTooSmall object, it is caught by the handler xTooSmall. After being handled, the exception is not passed on to the other handlers, so the handler for xZero is never called. 
The solution to this problem is to 
	!! carefully order the handlers so that the most specific handlers come first and the less specific handlers come later!! 
In this particular example, switching the placement of the two handlers xZero and xTooSmall fixes the problem. 
------------------------------------------------------------------------------------------------------------------------------------
>> DATA IN EXCEPTIONS AND NAMING EXCEPTION OBJECTS / >> EXCEPTION INFO EXTRACTION / >> EXCEPTION DATA EXTRACTION 
Often, you will want to know more than just what type of exception was thrown so you can erspond properly to the error. Exception classes are the same as any other class. You are free to provide data, initialize that data in teh constructor, and read that data at any time. The following listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2007.cpp
illustrates how to do this. 
----------------------------------------------------------------------------------------------------- PUNTI SALIENTI DEL PROGRAMMA 
- The declaration of xSize has been modified to include a member variable, itsSize, on line 33 (vedi estratto qui sotto), and a member function GetSize(), on line 31. In addition a constructor has been added that takes an integer and initializes the member variable, as shown on line 29. 
	 26     class xSize
	 27     {
	 28       public:
	 29         xSize(int size):itsSize(size) {}
	 30         ~xSize(){}
	 31         int GetSize() { return itsSize; }
	 32      private:
	 33         int itsSize;
	 34     };  
The derived classes declare a constructor that does nothing but initialize the base class. No other functions were declared, in part to save space in the listing. 
The catch statements on line 113-135 are modified to name the exception they catch "theException" and to use this object to access the data stored in itsSize. 
	113    catch (Array::xBoundary)
	114    {
	115       cout << "Unable to process your input!" << endl;
	116    }
	117    catch (Array::xZero theException)
	118    {
	119       cout << "You asked for an Array of zero objects!" << endl;
	120       cout << "Received " << theException.GetSize() << endl;
	121    }
[...]
	127    catch (Array::xTooSmall theException)
	128    {
	129       cout << "This Array is too small..." << endl;
	130       cout << "Received " << theException.GetSize() << endl;
	131    }
	132    catch (...)
	133    {
	134       cout << "Something went wrong, but I've no idea what!\n";
	135    }
-----------------------------------------------
NOTE: keep in mind that if you are constructing an exception, it is because an exception has been raised: something has gone wrong, and your exception should be careful not to kick off the same problem. Therefore, if you are creating an OutOfMemory exception, you probably don't want to allocate memory in its constructor. 
---------------------------------------------------------------
It is tiedious and error-prone to have each of these catch statements individually print the appropriate message. This job belongs to the object, which knows what type of object it is and what value it received. The listing 
		SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2008.cpp
It takes a more object-oriented approach to this problem, using virtual functions so that each exception "does the right thing". 
------------------------------------------------------------------------------------------ punti salienti di List2008.cpp (how to pass by reference and using virtual function in exceptions)
- we declare a virtual method on lines 33-37 in the xSize class, PrintError(), that prints an error message and teh actual size of the class. This is overridden in each of the derived classes. 
	 33         virtual void PrintError()
	 34         {
	 35            cout << "Size error. Received: ";
	 36            cout << itsSize << endl;
	 37         }  
- on line 141 in the exception handler, he exception object is declared to be a reference. 
	141    catch (Array::xSize& theException)
	142    {
	143       theException.PrintError();
	144    }
When PrintError() is called with a reference to an object, polymorphism causes the correct version of PrintError() to be invoked. The code is cleaner, easier to understand, and easier to maintain. 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> EXCEPTIONS WITH TEMPLATES  [pag742 jesse]
When creating exceptions to work with templates, you have a choice : 
	You can create an exception for each instance of the template, 
or 
	you can use exception classes declared outside the template declaration. 
The listing 
 	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day20/List2009.cpp
illustrates both approaches. 
------------------------------------------------------------------------------ PUNTI SALIENTI DI LIST2009.cpp (using exception with templates)
- The first exception, xBoundary, is declared outside the template definition on line 4
	  4 class xBoundary {};   // dichiarazione fuori della template definition 
	  5 
	  6 template <class T>   // inizio della template definition
	  7 class Array
	  8 {
	  9   public:
[...]
	 26     // define the exception classes
	 27     
	 28     class xSize {}; // dichiarazione all'interno della template definition 
- The second exception, xSize, is declared from within the definition of the template on line 28
The exception xBoundary is not tied to the template class, but it can be used the same as any other class. xSize is tied to the template and must  be called based on the instantiated "Array". You can see the difference in the syntax for the two catch statements. Line 105 shows catch(xBoundary)
	105    catch (xBoundary)
	106    {
	107       cout << "Unable to process your input!" << endl;
	108    }
but line 109 shows catch (Array<int>::xSize). The latter is tied to the instantiation of an integer Array. 
	109    catch (Array<int>::xSize)
	110    {
	111       cout << "Bad Size!" << endl;
	112    }
-----------------------------------------------------------------------------------------------------------------------------------
>> EXCEPTIONS WITHOUT ERRORS [pag745 jesse]
When C++ programmers get togeher for a virtual beer in the cyberspace bar after work, talk often turns to whther exceptions shouldbe used for routine conditions. 
Some (i puristi puritani) maintain that by their nature, exceptions should be reserved for those predictable but exceptional circumstances (hance the name!) that a programmer must anticipate, but that are not part of the routine processing of the code. 
Others (i pragmatici, noi ci mettiamo in questo gruppo) point out that exceptions offer a powerful and clean way to return through many layers of function calls without danger of memory leaks. A frequent example is this: The user requests an action in a graphical user interface (GUI) environment. The part of the code that catches the request, which calls code that decides which dialog box to use, which, in turn, calls code to put up the dialog box, which finally calls code that processes the user's input. If the user clicks Cancel, the code must return to the very first calling method where the original request was handled. 
One approach to this problem is to put a "try" block around the original call and catch CancelDialog as an exception, which can be raised by the handler for the Cancel button. This is SAFE and EFFECTIVE, but clicking  Cancel is a routine circumstance, not an exceptional one [no, I would say that pigiare sul Cancel button is exceptional. Usually a user wants to do a task, he does not wake up every morning to cancel what he's trying to do. To "cancel" is an exception in your workflow, not a routine. So I would say that a cancel button belongs to the exception kingdom].
This frequently becomes something of a religous argument, but a reasonable way to decide the question is to ask the following: Does use of exceptions in this way make the code easier or harder to understand? Are there fewer risks of errors and memory leaks, or more? Will it be harder or easier to maintain this code? These decisions, like so many others, require an analysis of the trade offs; no single obvious right answer exists.   
------------------------------------------------------------------------------------------------------------------------------------
>> CODE ROT [CODICE MARCIO, come salvare il salvabile una volta che la muffa ricopre i tuoi function objects] [pag746 jesse]
A word about code rot. [questo paragrafo fa proprio sorridere, bello humour!]
Code rot is a well known phenomenon  in which software deteriorates due to being neglected. A perfectly well-written fully debugged program will turn bad on your customer's shelf just weeks after you deliver it. After a few months, your customer will notice that a green mold has covered your logic, and many of your objects have begun to flake apart. 
Besides shipping your source code in air-tight containers, your only protection is to write your programs so that when you go back to fix the spoilage, you can quickly and easily identify where the problems are.
This means that your code must be written to be understood, and commented where tricky. Six months after you deliver your code, you will read it with the eyes of a total stranger, bewildered by how anyone could ever have written such convoluted and twisted logic.
NOTE: Code rot is a programmer's joke, which teaches an important lesson. Programs are enormously complex, and bugs, errors, and mistakes can hide for a long time before turning up. Protect yourself by writing  easy-to-maintain code. 
--------------------------------------------------------------------------------------------------------------------------------------------------------
>> BUGS and >> DEBUGGING / >> SYMBOLIC DEBUGGERS [pag747 jesse]
Nearly all modern development environments include one or more high-powered debuggers. The essential idea of using a debugger is this: you run the debugger, which loads your source code, and then you run your program from within the debugger. This enables you to see each instruction in your program as its executes and to examine your variables as they change during the life of your program. All compilers let you compile with or without symbols. Compiling with symbols tells the compiler to create the necessary mapping between your source code and the generated program; the debugger uses this to point to the line of source code that corresponds to the next action in the program. 
Full screen symbolic debuggers make this chore a delight. When you load your debugger it reads through all your source code and shows the code in a window. You can step over function calls or direct the debugger to step into the function, line by line. 
With most debuggers, you can switch between the source code and the output to see the results of each executed statement. More powerfully, you can examine the current state of each variable, look at complex data structures, examine teh value of member data within classes, and look at the actual values in memory of various pointers and other memory locations. You can execute several types of control within a debugger that include setting breakpoints, settings watch points, examining memory, and looking at the assembler code. 
- >> BREAKPOINTS [pag746 jesse]
Breakpoints are instructions to the debugger that when a particular line of code is ready to be executed, the program should stop. This allows you to run your program unimpeded until the line in question is reached. Breakpoints help you analyze the current condition of variables just before and after a critical line of code.
- >> WATCH POINTS [pag746 jesse]
It is possible to tell the debugger to show you the value of a particular variable or to break when a particular variable is read or written to. Watch points enable you to set these conditions, and, at times, even to modify the value of a variable while the program is running. 
- >> MEMORY INSPECTION / >> EXAMINING MEMORY
At time it isi important to see the actual values held in memory. Modern debuggers can show values in the form of the actual variable; that is, strings can be shown as characters, longs as numbers rather than as four bytes, and so forth. Sophisticated C++ debuggers can even show complete classes and provide the current value of all the member variables, including the this pointer. 
- >> ASSEMBLER 
Although reading through the source code can be all that is required to find a bug, when all else fails, it is possible to instruct the debugger to show you the actual assembly code generated for each line of your source code. You can examine the memory registers and flags, and generally delve as deep into the inner workings of your program as required. 

	Learn to use your debugger. It can be the most powerful weapon in your holy war against bugs. 
	Runtime bugs are the hardest to find and squash, and a powerful debugger can make it possible, 
	if not easy to find nearly all of them. 
----------------------------------------------------------------------------------------------------------- 
	NOTE: ti ho cercato >> symbolic debugger e salvato un piccolo tutorial about gdb in linux 
	/run/media/alseny/BLACKBIRD/Cplusplus/symbolicDebugger/gdb Tutorial.html  [originally downloaded from : ]
	that shows how to use breakpoints and creare ponti con il source code to locate the error reason in case of crash of a program.  
OK proviamo a toccare con mano un po di symbolic debugging. In linux terminal 
	cp -r  /run/media/alseny/BLACKBIRD/Cplusplus/symbolicDebugger /home/alseny/edylab/CPlusPlusPlayGround/
	cd /home/alseny/edylab/CPlusPlusPlayGround/symbolicDebugger
	# lancio del gcc compiler usando la flag -ggdb to include debugging symbols. 
	g++ -ggdb -Wall -o main main.cc # l'istruzioni l'abbiamo ricavata a partire dal Makefile included in the same directory
OUTPUT 
	main.cc:9:22: fatal error: iostream.h: No such file or directory
	 #include <iostream.h>
		                  ^
	compilation terminated.
mmmm non riusciamo a compilare, forse provare nella virtual machine?
	cd /home/serena/edylab/symbolicDebugger  # now we are in the virtual machine CentOS7
	# lanciamo make che andra' a leggere il Makefile 
	make
OUTPUT : 
	g++ -ggdb -Wall -o main main.cc
	main.cc:9:22: fatal error: iostream.h: No such file or directory
	 #include <iostream.h>
		                  ^
	compilation terminated.
	make: *** [main] Error 1
No stesso errore. Therefore ITIAF.
--------------------------------------------------------------------------------------------------------------
Today you learned the basics for creating and using exceptions. Exceptions are objects that can be created and thrown at points in the program where the executing code cannot handle the error or other exceptional condition that has arisen. Other parts of the program, higher in the call stack, implement catch blocks that catch the exception and take appropriate action. 
Exceptions are normal, user-created objects, and as such can be passed by value or by reference. They can contain data and method, and the catch block can use that data to decide how to deal with the exception. 
It is possible to create multiple catch blocks, but after an exception matches a catch block's signature, it is considered to be handled and is not given to teh subsequent catch blocks. It is important to order the catch blocks appropriately so that more specific catch blocks have first chance, and more general catch blocks handle those not otherwise handled. 
Today's lesson also mentioned the fundamentals of symbolic debuggers, including using watch points, breakpoints, and so forth. These tools can help you zero in on the part of your program that is causing the error and let you see the value of variables as they change during the course of the execution of the program.   
--------------------------------------
Q&A

Q) Why bother with rasing exceptions? Why not handle the error right where it happens?
A) OFten the saem erro can be generated in different parts of the code. Exceptions let you centralize the handling of errors. In addition, the part of the code that generates the error might not be the best place to determine how to handle the error. 

Q) Why generate an object? Why not just pass an error code?
A) Objects are more flexible and powerful than error codes. They can convey more information, and the constructor/destructor mechanisms can be used for the creation and removal of resources that might be required to properly handle the exceptional condition. 

Q) Why not use exceptions for non error conditions? Isn't it convenient to be able to express-train back to previous areas of the code, even when nonexceptional conditions exists?
A) Yes, some C++ programmers use exceptions for just that purpose. The danger is that exceptions might create memory leaks as the stack is unwound and some objects are inadvertently left in the free store. With careful programming techniques and a good compiler, this can usually be avoided. Otherwise, it is a matter of personal aesthetic; some programmers feel that, by their nature, exceptions should not be used for routine conditions. 

Q) Does an exception have to be caught in the same palce where the try block created the exception?
A) No, it is possible to catch an exception anywhere in the call stack. As the stack is unwould, the exception is passed up the stack until it is handled. 

Q) Why use a debugger when I can use cout and other such statement?
A) The debugger provides a much more powerful mechanism for stepping through your code and watching values change without having to clutter your code with thousands of debugging statements. In addition, there is a significant risk each time you add or remove lines from your code. If you have just removed problems by debugging, and you accidentally delete a real code line when deleting your use of cout, you haven't helped the situation. 

1) What is an exception?
An exception is an object that is created as a result of invoking the keyword throw. It is used to signal an exceptional condition, and is passed up the call stack to the first catch statement that handles its type. 
2) What is a try block? 
A try block is a set of statements that might generate an exception. 
3) What is a catch statement?
A catch statement is a routine that has a signature of the type of exception it handles. If follows a try block and acts as the receiver of exceptions raised withing the try block. 
4) What information can an exception contain?
An exception is an object and can contain any information that can be defined within a user-created class. 
5) When are exception objects created?
Exception objects are created when the program invokes the keyword throw. 
6) Shoud you pass exceptions by value or by reference?
In general, exception should be passed by reference. If you don't intend to modify the contents of the exception object, you should pass a const reference. 
7) Will a catch statement catch a derived exception if it is looking for the base class?
Yes, if you pass the exception by reference. 
8) If two catch statements are used, one for base and one for derived, which should come first?
catch statements are examined in the order they appear in the source code. The first catch statement whose signature matches the exception is used. In general, it is best to start with teh most specific exception and work toward the most general. 
9) What does catch(...) mean?
catch(...) means any exception of any type 
10) What is a breakpoint?
A breakpoint is a place in the code where the debugger stops execution. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONDITIONAL COMPILATION [pag751 jesse]
Most of what you write in your source code files is C++. This is interpreted by the compiler and turned into your program. Before the compiler runs, however, the preprocessor runs, and this provides an opportunity for conditional compilation. In this lesson you will learn: 
	- what conditional compilation is and how to manage it 
	- how to write macros using the preprocessor 
	- how to use the preprocessor in finding bugs 
	- how to manipulate individual bits and use them as flags 
	- what the next steps are in learning to use C++ effectively 
-------------------------------------------------------------------------
>> PREPROCESSOR and COMPILER 
Every time you run your compiler, your preprocessor runs first. The preprocessor looks for preprocessor instructions, each of which begins with a pound symbol (#   , >> # viene chiamato "pound symbol"). The effect of each of these instructions is a change to the text of the source code. The result is a new source code file (a temporary file that you normally don't see, but that you can instruct the compiler to save so you can examine it if you want to). 
[inciso aah mi sembra che anche the compiling on the fly technique used in OF 
		codeInclude
		#{
		    #include "pointField.H"
		#};
is using the preprocessor.  fine inciso]
The compiler does not read your original source code file; it reads the output of the preprocessor and compiles that file. You've seen the effect of this already with the #include directive. This instructs the preprocessor to find the file whose name follows the #include directive and to write it into the intermediate file at that location. It is as if you had typed that entire file right into your source code, and by the time the compiler sees the source code, the included file is there. 
[cavoli sarebbe carino poter visualizzare questo intermediate file per esempio per simpleFoam.C in modo da vedere tutti gli include esplicitati]
TIP: nearly every compiler has a switch that you can set either in the Integrated Development Environment (IDE) or at the command line, which instructs the compiler to save the intermediate file. Check your compiler manual for the right switches to set for your compiler if you want to examine this file. 
>> #DEFINE PREPROCESSOR DIRECTIVE / >> SUBSTITUTE STRING / >> define [pag752 jesse]
You can create string substitutions using the #define command you write
	#define BIG 512
you have instructed the precompiler to substitute the string 512 wherever it sees the string BIG. This is not a string in the C++ sense. The characters "512" are substituted in your source code where the word "BIG" is seen. Thus if you write 
	#define BIG 512
	int myArray[BIG];
the intermediate file produced by the precompiler looks like this : 
	int myArray[512];
Note that the #define statement is gone. Precompiler statements are all removed from the intermediate file; they do not appear in the final source code at all. 

-----------------------------------------------------------------------------------
>> #DEFINE for constants [pag753 jesse]
One way to use #define is as a substitute for constants. This is almost never a good idea, however, because #define merely makes a string substitutition and does no type checking. As explained in the section on constants, tremendous advantages exist in using the const keyword rather than #define. 
>> #DEFINE for tests [pag753 jesse]
A second way to use #define is simply to declare that a particular character string is defined. Therefore, you could write 
	#define DEBUG 
Later in your listing, you can test to determine whether DEBUG has been defined and take action accordingly. To check if it is define, you can use the preprocessor #if command followed by the defined command: 
	#if defined DEBUG 
	cout << "Debug defined";
	#endif
The defined expression evaluates to true if the name it tests (DEBUG in this case) has been defined already. Keep in mind that this happens in the preprocessor, not in the compiler or in the executing program. When the preprocessor reads the #if defined, it checks a table it has built to see whether you have defined the value that follows. If you have, defined evaluates to true, and everything between "#if defined DEBUG" and its "#endif" is written into the intermediate file for compiling. If it evaluates to false, nothing between #if defined DEBUG and #endif is written into the intermediate file; it is as if it were never in the source code in the first place. [aaah da qui comprendo il significato di "compilare in debug mode", significa avere "#if defined DEBUG" conditions that evaluate true, so additional lines of code are added into the intermediate file and you get a binary that provides more verbose output utile for diagnosticare il code and find bugs]
A shorcut directive also exists for checking defined values. This is the >> #ifdef directive: 
	#ifdef DEBUG
	cout << "Debug defined";
	#endif
You can also test to see if a value is not defined. This is done by using the not operator with the defined directive: 
	#if !defined DEBUG
	cout << "Debug is not defined";
	#endif
There is also a shorcut version for this as well, >> #ifndef : 
	#ifndef DEBUG
	cout << "Debug is not defined.";
	#endif 
Note that #ifndef is the logical reverse of #ifdef. 
"#ifndef" evaluates to true if the string has not been defined up to that point in the file. 
You should notice that all of these checks required that #endif also be included to indicate the end of the code impacted by the check.  
---------------------------------------------------------------------------------------------------------------------------------------------------------------
>> #else / >> the #else precompiler command  [pag754 jesse]
As you might imagine, the term #else can be inserted between either #ifdef or #ifndef and the closing #endif. The following listing 21.1 illustrates how these terms are used. 
------------------------------------------------------ LISTING 21.1 STARTS  - Using #define 
#define DemoVersion  // DemoVersion is defined
#define SW_VERSION 5 // SW_VERSION is defined. Tutte le volte che il preprocessor trovera' SW_VERSION lo sostituira con la stringa "5"
#include <iostream>

using std::endl;
using std::cout;

int main()
{
   cout << "Checking on the definitions of DemoVersion,";
   cout << "SW_VERSION, and WINDOWS_VERSION..." << endl;

   #ifdef DemoVersion // the definition of DemoVersion is tested, and because DemoVersion is defined, the test is true
      cout << "DemoVersion defined." << endl;   // therefore this string will be printed 
   #else
      cout << "DemoVersion not defined." << endl;   // since DemoVersion is defined this string will not be printed. 
   #endif

   #ifndef SW_VERSION // here we test if SW_VERSION is not defined. Since SW_VERSION is defined
      cout << "SW_VERSION not defined!" << endl;  // this line will not be printed
   #else 
      cout << "SW_VERSION defined as: "   // instead we jump here, so this line will be printed. Nota che quando SW_VERSION e' all'interno di quoted string non viene sostituito
                << SW_VERSION << endl;  // solo quando si trova all'esterno come in questa linea allora the string "5" is substituted for the word "SW_VERSION"
// Ecco quindi perche' nel terminal vedrai printato "SW_VERSION defined as: 5" 
   #endif

   #ifdef WINDOWS_VERSION // in this line we tests for WINDOWS_VERSION. Because we did not define WINDOWS_VERSION
      cout << "WINDOWS_VERSION defined!" << endl;   // this fails
   #else
      cout << "WINDOWS_VERSION was not defined." << endl;  // instead we jump here so this line will be printed. 
   #endif

   cout << "Done."  << endl;
   return 0;
}
------------------------------------------------------ LISTING 21.1 ENDS
OUTPUT 
[1147 Day21] >> g++ -o List2101.exe List2101.cpp 
[1148 Day21] >> ./List2101.exe 
Checking on the definitions of DemoVersion,SW_VERSION, and WINDOWS_VERSION...
DemoVersion defined.
SW_VERSION defined as: 5
WINDOWS_VERSION was not defined.
Done.
-----------------------------------------------------------------------------------------------------------------------------------------------
>> INCLUSION and INCLUSION GUARDS [pag755 jesse]
You will create projects with many different files. You will probably organize your directories so that each class has 
1) its own header file (for example, .hpp) with the class declaration 
and 
2) its own implementation file (for example .cpp) with the source code for the class methods. 
Your main() function will be in its own .cpp file, and all the .cpp files will be compiled into .obj files, which will then be linked into a single program by the linker. 
Because your programs will use methods from many classes, many header files will be included in each file. Also, header files often need to include one another. For example the header file for a derived class's declaration must include the header file for its base class. 
Imagine that the Animal class is declared in the file ANIMAL.hpp. The Dog class (which derived from Animal) must include the file ANIMAL.hpp in DOG.hpp, or Dog will not be able to derive from Animal. The Cat header also includes ANIMAL.hpp for the same reason. 
If you create a program that uses both a Cat and a Dog, you will be in danger of including ANIMAL.hpp twice. This generates a compile-time error because it is not legal to declare a class (Animal) twice, even though the declarations are identical. 
You can solve this problem with inclusion guards. At the top of your ANIMAL header file, you write these lines :
	#ifndef ANIMAL_HPP
	#define ANIMAL_HPP
	...   // the whole file goes here (intende tutto il programma che usa both Cat e Dog e in cui sei in pericolo di includere ANIMAL_hpp twice) 
	#endif
This says, if you haven't defined the term ANIMAL_HPP, go ahead and define it now. Between the "#define" statement and the closing "#endif" are the entire contents of the file (cioe' suppongo intenda "del program che usa both Cat e Dog e in cui sei in pericolo di includere ANIMAL_hpp twice"). 
The first time your program includes this file (cioe' suppongo l'Animal header file in cui hai copiato tra #define ANIMAL_HPP e #endif tutto il contenuto del programma che usa both Cat and Dog)
	#ifndef ANIMAL_HPP
	#define ANIMAL_HPP
	...   // the whole file goes here (intende tutto il programma che usa both Cat e Dog e in cui sei in pericolo di includere ANIMAL_hpp twice) 
	#endif
it reads the first line and the test evaluates to true; that is, you have not yet defined ANIMAL_HPP. So, it defines it and then includes the entire file. 
The second time your program includes the ANIMAL.hpp file, it reads the first line and the test evaluates to false because you have already included ANIMAL.hpp. The preprocessor, therefore, doesn't process any lines until it reaches the next #else (in this case, there isn't one) or the next #endif (at the end of the file). Thus, it skips the entire contents of the file, and the class is not declared twice. 
The actual name of the defined symbol (ANIMAL_HPP) is not important, although it is customary to use the filename in all uppercase with the dot (.) changed to an underscore. This is purely convention (in OpenFOAM vedi estratto sotto non usa capital letters); however because you won't be able to give two files the same name, this convetion works. 
(aaah si' e' usato assai spesso in OF: example 
./fvMotionSolver/fvMotionSolvers/fvMotionSolver/fvMotionSolver.H:
	#ifndef fvMotionSolver_H // queste sono delle inclusion guards!!
	#define fvMotionSolver_H
)   
NOTE: IT NEVER HURTS TO USE INCLUSION GUARDS. Ofter, they will SAVE YOU HOURS OF DEBUGGING TIME!
---------------------------------------------------------------------------------------------------------------------------------------------------------------
>> MACRO FUNCTIONS  [pag756 jesse]
The #define directive can also be used to create macro functions. A macro function is a symbol created using #define that thakes an argument, much like a function does. The preprocessor substitutes the substitution string for whatever argument it is given. For example, you can define the macro TWICE as 
	#define TWICE(x) ( (x) * 2 )
and then in your code you write 
	TWICE(4)
The entire string TWICE(4) is removed, and the value ( (4) * 2 ) is substituted. When the precompiler sees the 4, it substitutes ( (4) * 2 ), which then evaluates to 4 * 2, or 8.
A macro can have more than one parameter, and each parameter can be used repeatedly in the replacement text. Two common macros are MAX and MIN:
[>> MIN , >> MAX macros example]

	#define MAX(x,y) ( (x) > (y) ? (x) : (y) )
	#define MIN(x,y) ( (x) < (y) ? (x) : (y) )

Note that in a macro function definition, the opening parenthesis for the parameter list must immediately follow the macro name, with no spaces. The proprocessor is not as forgiving of whitespace as is the compiler. If there is a space, a standard substitution is used like you saw earlier in today's lesson. 

For example 
WRONG VERSION with space between MAX and (
if you write : 

	#define MAX (x,y) ( (x) > (y) ? (x) : (y) )    // you put a space between MAX and (
	int x = 5, y = 7, z;
	z = MAX(x,y);

the intermediate code becomes 

	int x = 5, y = 7, z;
	z = (x,y) ( (x) > (y) ? (x) : (y) ) (x,y);  // you just get a simple text substitution, rather than invoking the macro function. 

not what you want

CORRECT VERSION with no space between MAX and (

	#define MAX(x,y) ( (x) > (y) ? (x) : (y) )    // no space between MAX and (
	int x = 5, y = 7, z;
	z = MAX(x,y);

the intermediate code becomes 

	int x = 5, y = 7, z;
	z = ( (5) > (7) ? (5) : (7) );	

and this, of coarse then evaluates to 7. 

OBSERVATION : Why all this parenthesis??
You might be wondering why so many parentheses are in many of the macros presented so far. The preprocesor does not demand that parentheses be placed around the arguments in the substitution string, but the parentheses help you to avoid unwanted side effects when you pass complicated values to a macro. For example, if instead of  
	#define MAX(x,y) ( (x) > (y) ? (x) : (y) ) 
you define MAX as 
	#define MAX(x,y)  x > y ? x : y
and pass in the values 5 and 7, the macro works as intended. But if you pass in a more complicated expression, you receive uninteded results, as shown in following listing 21.2:
-------------------------------------------------------- LISTING 21.2 STARTS Using Parenthesis in Macros 
// Listing 21.2 Macro Expansion
#include <iostream>
using namespace std;

#define CUBE(a) ( (a) * (a) * (a) )  // we define the macro CUBE putting the argument "a" into parenthesis each time it is used. 
#define THREE(a) a * a * a // we define the macro THREE just like CUBE but without putting the argument "a" between parenthesis. 

int main()
{
   long x = 5;
   long y = CUBE(x); // this expand to ( (5) * (5) * (5) ) = 125 OK 
   long z = THREE(x); // this expand to  5 * 5 * 5 = 125 OK 

   cout << "y: " << y << endl;
   cout << "z: " << z << endl;

   long a = 5, b = 7;
   y = CUBE(a+b);   // this expand to ( (5+7) * (5+7) * (5+7) ) =  ( (12) * (12) * (12) )  = 1728 
   z = THREE(a+b);  // this expand to  5+7 * 5+7 * 5+7 => (visto che la moltiplicazione ha precedenza) = 5 + 35 + 35 + 7 = 82    as you can see not using parenthesis to expend in a different way from what you had in mind. 

   cout << "y: " << y << endl;
   cout << "z: " << z << endl;
   return 0;
}
-------------------------------------------------------- LISTING 21.2 ENDS 
OUTPUT 
	[1150 Day21] >> g++ -o List2102.exe List2102.cpp 
	[1151 Day21] >> ./List2102.exe 
	y: 125
	z: 125
	y: 1728
	z: 82
-------------------------------------------------------------------------------------------------------------------------------------
>> STRING MANIPULATION [pag 759 jesse]
The proprocessor provides two special operators for manipulating strings in macros:
	1) the stringizing operator (#) substitutes a quoted string for whatever follows the stringizing operator. 
	2) the concatenation operator bonds two strings into one. 
>> STRINGIZING  [pag759 jesse]
The stringizing operator puts quotes around any character following the operator, up to the next whitespace. Thus, if you write 
	#define WRITESTRING(x) cout << #x
and then call 
	WRITESTRING(This is a string);
the precompiler turns it into : 
	cout << "This is a string";
Note that the string "This is a string" is put into quotes, as required by cout. 
>> CONCATENATION [pag759 jesse]
The concatenation operator allows you to bond more than one term into a new word. The new word is actually a token that can be used as a class name, a variable name, an offset into an array, or anywhere else a series of letters might appear. 
Assume for a moment that you have five functions named fOnePrint, fTwoPrint, fThreePrint, fFourPrint, fFivePrint. You can then declare
	#define fPRINT(x) f ## x ##Print 
and then use it with fPRINT(Two) to generate fTwoPrint, and with fPRINT(Three) to generate fThreePrint. 
At the conclusion of Week 2, a PartsList class was developed. This list could only handle objects of type List. Suppose that this list works well, and you want to be able to make lists of animals, cars, computers, and so forth. 
One approach is to create AnimalList, CarList, ComputerList, and so on, cutting and pasting the code in place. This quickly becomes a nightmare because every change to one list must be written to all the others. 
An alternative is to use macros and the concatenation operator. For example you could define : 
	#define Listof(Type) class Type##List \
	{ \
	public: \
	Type##List(){} \
	private:
	int itsLength; \
	};
This example is overly sparse, but the idea is to put in all teh necessary methods and data. When you are ready to create an AnimalList, you write: 
	Listof(Animal)
and this is turned into the declaration of the AnimalList class. Some problems occur with this approach, all of which were discussed in detail in Lesson 19, "Templates"
-----------------------------------------------------------------------------------------------------------------------------
>> PREDEFINED MACROS [pag760 jesse]
Many compilers predefine a number of useful macros, including 
	__DATE__
	__TIME__
	__LINE__
	__FILE__ 
Each of these names is surrounded by two underscore characters to reduce the likelihood that the names will conflict with names you've used in your program. 
When the precompiler sees one of these macros, it makes the appropriate substitutes. 
For 
	__DATE__     -> the current date is substituted
	__TIME__      -> the current time is substituted
	__LINE__       -> is replaced with the source code line number 
	__FILE__        -> is replaced with the file name 
You should note that this substitution is made when the source is precompiled, not when the program is run. If you ask the program to print __DATE__, you do not get the current date; instead you receive the date the program was compiled. These defined macros are very useful for debugging, as mentioned on Day 20, "Handling Errors and Exceptions" during the discussion of exceptions. 
---------------------------------------------------------------------------------------------------------------------------------------
>> ASSERT() macro [pag761 jesse]
Many compilers offer an assert() macro. The assert() macro returns true if its parameter evaluates to true and takes some kind of action if it evaluates false. Many compilers abort the program on an assert() that fails; others throws an exception (see Lesson Day 20). 
The assert() macro is used for debugging your program before you release it. In fact, if DEBUG is not defined, the preprocessor collapses the assert() so that no code from it is included in the genereated source for the compiler. This is a great help during development, and when the final product ships, there is no performance penalty or increase in the size of the executable version of the program. 
Rather than depending on the compiler-provided assert(), you are free to write your own assert() macro. The following listing 21.3 provides a simple custom assert() macro and shows its use. 
--------------------------- LIST 21.3 starts 
// Listing 21.3 ASSERTS
#define DEBUG // the term DEBUG is defined. Typically this is done from the commadn line (or the IDE) at compile time, so you can turn this on and off at will. 
#include <iostream>
using namespace std;
  
#ifndef DEBUG // the term DEBUG is tested. If it is not defined, ASSERT()  is defined to create no code at all. 
   #define ASSERT(x)   // when not defined it produces no code. 
#else
   #define ASSERT(x) \         // in the following lines the ASSERT() macro is defined
         if (! (x)) \      // the value passed in as a parameter is tested. If it is true no action is taken. 
         { \                 // if it evaluates false, the statements on these 3 following lines are invoked, printing an error message. 
            cout << "ERROR!! Assert " << #x << " failed" << endl; \
            cout << " on line " << __LINE__  << endl; \
            cout << " in file " << __FILE__ << endl;  \
         }  // end of ASSERT() macro defintion. NOTE: typically the ASSERT() macro definition is done in a header file, and that header (assert.hpp) is included in all your implementations files.
#endif
int main()
{
   int x = 5;
   cout << "First assert: " << endl;
   ASSERT(x==5);
   cout << "\nSecond assert: " << endl;
   ASSERT(x != 5);
   cout << "\nDone." << endl;
   return 0;
}

--------------------------- LIST 21.3 ends 
OUTPUT 
 [1152 Day21] >> g++ -o List2103.exe List2103.cpp 
[1153 Day21] >> ./List2103.exe 
First assert: 

Second assert: 
ERROR!! Assert x != 5 failed
 on line 24
 in file List2103.cpp

Done.
-------------------------------------------------------
NOTE nel programma sopra vedi tanti \ alla fine di ogni riga: 
   #define ASSERT(x) \                                                                           // 1
         if (! (x)) \                                                                                        // 2
         { \                                                                                                   // 3
            cout << "ERROR!! Assert " << #x << " failed" << endl; \          // 4
            cout << " on line " << __LINE__  << endl; \                              // 5 
            cout << " in file " << __FILE__ << endl;  \                                 // 6
         }                                                                                                     // 7
this is because, dal punto di vista del precompiler, the  ASSERT() itself is one long statement split across seven source code lines 
-------------------------------
NOTE2: >> DEBUGGING with ASSERT() advantages 
When writing your program, you will often know deep down in your soul that something is true: A function has a certain value, a pointer is valid, and so forth. It is the nature of bugs that what you know to be true might not be so under some conditions. For example, you know that a pointer is valid, yet the program crashes. assert() can help you find this type of bug, but only if you make it a regular practice to use assert() liberally in your code. Every time you assign or are passed a pointer as a parameter or function return value, be certain to assert that the pointer is valid. Any time your code depends on a particular value being in a variable, assert() that that is true. 
No penalty is assessed for frequent use of assert(); it is removed from the code when you undefine debugging. It also provides good internal documentation, reminding the reader of what you believe is true at any given moment in the flow of the code. 
-------------------------------------------------------------
>> ASSERT() vs >> EXCEPTIONS / >> using assert() versus exceptions [pag764 jesse]
Yesterday, you saw how to work with exceptions to handle error conditions. It is important to note that assert() is not intended to handle runtime error conditions such as bad data, out-of-memory conditions, unable to open file, and so forth. assert() is created to catch programming errors only. That is, if an assert() "fires", you know you have a bug in your code. 
This is critical because when you ship your code to your customer, instances of assert() are removed. You can't depend on an assert() to handle a runtime problem because the assert() won't be there.  
It is a common mistake to use assert() to tes the return value from a memory assignment :
	Animal *pCat = new Cat;
	Assert(pCat); // bad use of assert 
	pCat->SomeFunction();
This is a classic programming error; every time the programmer runs the program, enough memory is available and the assert() never fires. After all, the programmer is running with lots of extra RAM to speed up the compiler, debugger, and so forth. The programmer then ships the executable, and the poor user, who has less memory, reaches this part of the program and the call to "new" fails [si riferisce alla linea "Animal *pCat = new Cat;" sopra] and returns NULL. The assert(), however, is no longer in the code and nothing indicates that the pointer points to NULL. As soon as the statement pCat->SomeFunction() is reached, the program crashes.
Getting NULL back from a memory assignment is not a programming error, although it is an exceptional situation. Your program must be able to recover from this condition, if only by throwing an expection. The entire assert() statement is gone when DEBUG is undefined. 
NOTE: SIDE EFFECTS 
It is no uncommon to find that a bug appears only after the instances of assert() are removed. This is almost always due to the program unintentionally depending on side effects of things done in assert() and other debug-only code. For example, if you write 
	ASSERT(x = 5)
when you mean to test whether x == 5, you create a particularly nasty bug. 
Suppose that just prior to this assert(), you called a function that sets x equal to 0. With this assert(), you think you are testing whether x is equal to 5; in fact, you are setting x equal to 5... The test returns true because x = 5 not only sets x to 5, but returns the value 5, and because 5 is nonzero, it evaluates as true. 
When you pass the assert() statement, x really is equal to 5 (you just set it!). Your program runs just fine. You're ready to ship it, so you turn off the debugging. Now, the assert() disappears, and you are no longer setting x to 5. Because x was set to 0 just before this, it remains at 0 and your program breaks. 
In frustration, you turn debugging back on, but hey! Presto! The bug is gone. Again, thi is rather funny to watch, but not to live through, so be VERY careful about side effects in debugging code. If you see a bug that only appears when debuggers is turned off, take a look at your debugging code with an eye out for nasty side effects. 
------------------------------------------------------------------------------------------------------------------------------------------------------------- 
>> INVARIANTS / >> CLASS INVARIANTS [pag764 jesse]
Most classes have some conditions that should always be true whenever you are finished with a class member function. These class invariants are the sine qua non of your class. For example, it might be true that your CIRCLE object should never have a radius of zero or that your ANIMAL should always have an age greater than zero and less than 100. 
It can be very helpful to declare an Invariants() method that returns true only if each of these conditions is still true. You can then ASSERT(Invariants()) at the start and the completion of every class method. The exception would be that your Invariants() would not excpect to return true before your constructor runs or after your destructor ends [cioe' mi sembra voglia dire: si ha eccezione se l'invariant returns false before constructor runs, or after the destructor ends].
The listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day21/List2104.cpp
demonstrates the use of the Invariants() method in a trivial class. 
---------------- HIGHliGHTs of the program
- on lines 9-15 the ASSERT() macro is defined. If DEBUG is defined, this writes out an error message when the ASSERT() macro evaluates false.
	  9    #define ASSERT(x) \
	 10          if (! (x)) \
	 11          { \
	 12             cout << "ERROR!! Assert " << #x << " failed" << endl; \
	 13             cout << " on line " << __LINE__  << endl; \
	 14             cout << " in file " << __FILE__ << endl;  \
	 15          }
- on line 39 the String class member function Invariants() is declared: 
	 39     BOOL Invariants() const; 
- it is defined in lines 143-150
	 143 BOOL String::Invariants() const
	144 {
	145     #ifdef SHOW_INVARIANTS
	146        cout << "String Tested OK ";
	147     #endif
	148     return ( (itsLen && itsString) || (!itsLen && !itsString) );
	149 }
- The constructor is declared on lines 49-55 
	 48 // default constructor creates string of 0 bytes
	 49 String::String()
	 50 {
	 51    itsString = new char[1];
	 52    itsString[0] = '\0';
	 53    itsLen=0;
	 54    ASSERT(Invariants());  // after the object is fully constructed, Invariants() is called to confirm proper construction. 
	 55 }
This pattern is repeated for the other constructors, and the destructor calls Invariants() only before it sets out to destroy the object. The remaining  class functions call Invariants() before taking any action and then again before returning. This both affirms and validates a fundamental principle of C++: Member functions other than constructors and destructors should work on valid objects and should leave them in a valid state. 
--------------------------------------------------------------------------------------------------------
>> PRINT INTERIM VALUES / >> POINTERS PRINT / >> DEBUG by OUTPUTTING TO SCREEN critical VALUES  [pag769 jesse]
In addition to asserting that something is true using the ASSERT() macro, you might want to print the current value of pointers, variables, and strings. This can be very helpful in checking your assumptions about the progress of your program and in locating off-by-one bugs in loops. The following listing 21.5 illustrates this idea:
---------------------------------------------------------------- LIST 21.5 starts
	// Listing 21.5 - Printing values in DEBUG mode
	#include <iostream>
	using namespace std;
	#define DEBUG

	#ifndef DEBUG
	   #define PRINT(x)
	#else
	   #define PRINT(x) \    // this PRINT macro provides printing of the current value of the supplied parameter. 
		     cout << #x << ":\t" << x << endl; // note that the first thing fed to cout on this line is "<< #x" the stringized version of the parameter; that is, if you pass in x, cout receives "x" (cioe' su schermo non printa il valore di x, ma la stringa stessa "x"). Next cout receives the quoted string ":\t" , which prints a colon and then a tab. Third, cout receives the value of the parameter "<< x" and then finally (con la quale si printa effettivamente il valore di x), endl, which writes a new line and flushes the buffer. 
	#endif

	enum BOOL { FALSE, TRUE } ;

	int main()
	{
	   int x = 5;
	   long y = 73898l;
	   PRINT(x);
	   for (int i = 0; i < x; i++)
	   {
		  PRINT(i);
	   }

	   PRINT (y);
	   PRINT("Hi.");
	   int *px = &x;
	   PRINT(px);
	   PRINT (*px);
	   return 0;
	}
---------------------------------------------------------------- LIST 21.5 ends
OUTPUT : 
[1158 Day21] >> g++ -o List2105.exe List2105.cpp 
[1159 Day21] >> ./List2105.exe 
x:	5
i:	0
i:	1
i:	2
i:	3
i:	4
y:	73898
"Hi.":	Hi.
px:	0x7fffc8b3c0c4
*px:	5
-----------------------------------------------------------------------------------------------------------------------------------------
>> MACROS vs >> FUNCTIONS vs >> TEMPLATES / >> Macros versus functions and templates [pag771 jesse]
Macros suffer from four problems in C++. 
1) the first is that they can be confusing if they get large because all macros must be defined on one line. You can extend that line by using the backslash character (\) but large macros quickly become difficult to manage. 
2) the second problem is that macros are expanded inline each time they are used. This means that if a macro is used a dozen times, the substitution appears a dozen times in your program, rather than appearing once as a function call does. On the other hand, they are usually quicker than a function call because the overhead of a function is avoided.
3) The fact that they are expanded inline leads to the third problem, which is that the macro does not appear in the intermediate source code used by the compiler; therefore, it is unavailable in most debuggers. This makes debugging  macros tricky.
4) The final problem, however, is the biggest: Macros are not type-safe. Although it is convenient that absolutely any argument can be used with a macro, this completely undermines the strong typing of C++ and so is an anathema to C++ programmers. Of course, the right way to solve this is with templates, as explained in lesson 19.  
---------------------------------------------------------------------------------------------------------------------------------------------
>> INLINE FUNCTIONS  [pag771]
It is often possible to declare an inline function rather than a macro. For example, Listing 21.6 creates an inline Cube() function, which accomplishes the same thing as the CUBE macro in listing 21.2, but it does so in a type-safe way.
Osservazione: nel seguente programma le funzioni Square e Cube sono declared to be inline, so like a macro function, these are expanded in palce for each call, and no function call overhead occurs. 
As reminder, expanded inline means that the content of the function is placed into the code wherever the function call is made  (come per esempio nella linea "cout  << Square(x);" del codice qui sotto ). Because the function call is never made, there is no overhead of putting  the return address and the parameters on the stack. 
------------------------------------------------------------------------------ LISTING 21.6 STARTS 
#include <iostream>
using namespace std;

inline unsigned long Square(unsigned long a) { return a * a; }  // defining inline function Square 
inline unsigned long Cube(unsigned long a) { return a * a * a; } // defining inline function Cube 
int main()
{
   unsigned long x=1 ;
   for (;;)
   {
      cout << "Enter a number (0 to quit): ";
      cin >> x;
      if (x == 0)
         break;
      cout << "You entered: " << x;
      cout << ".  Square(" << x << "): "; 
      cout  << Square(x);  // because Square is an inline function, it is exactly as if this line had been written like cout  << x * x;
      cout<< ". Cube(" << x << "): ";
      cout << Cube(x) << "." << endl; // because Cube is an inline function, it is exactly as if this line had been written like cout  << x * x *x << "." << endl;
   }
   return 0;
}
------------------------------------------------------------------------------ LISTING 21.6 ENDS 
[1164 Day21] >> g++ -o List2106.exe List2106.cpp 
[1165 Day21] >> ./List2106.exe 
Enter a number (0 to quit): 7
You entered: 7.  Square(7): 49. Cube(7): 343.
Enter a number (0 to quit): 2
You entered: 2.  Square(2): 4. Cube(2): 8.
Enter a number (0 to quit): 1
You entered: 1.  Square(1): 1. Cube(1): 1.
Enter a number (0 to quit): 0
---------------------------------------------------------------------------------
DO 
	- DO use CAPITALS for your macro names. This is a pervasive convention, and other programmers will be confused if you don't. 
	- DO surround all arguments with parenthesis in macro functions. 
DON'T
	- DON'T allow your macros to have side effects. Don't increment variables or assign values from within a macro. 
	- DON'T use #define  values when a constant variable will work. 
------------------------------------------------------------------------------------------------------------------------------------------------------------
>> BIT TWIDDLING / >> BITWISE OPERATORS  that act upon the individual bits of a variable [pag773 jesse]
Often, you will want to set flags in your objectst to keep track of the state of your object. (Is it in AlarmState? Has this been initiazed yet? Are you coming or going?)
You can do this with user-defined Booleans, but some applications (particularly those  with low-level drivers and hardware devices) require you to be able to use the individual bits of a variable as flags. Each byte has eight bits, so in a four-byte long you can hold 32 separate flags. A bit is said to be "set" if its value is 1 and "clear" if its value is 0. 

	>> CLEAR = 0 
	>> SET  = 1

When you set a bit, you make its value 1, and when you clear it, you make its value 0. (Set and clear are both adjectives and verbs). You can set and clear bits by changing the value of the long, but that can be tedious and confusing. 
C++ provides bitwise operators that act upon the individual bits of a variable. These look like, but different from the logical operators, so many novice programmers confuse them. The bitwise operators are presented in the following table:

	------------------------------
	SYMBOL    OPERATOR 
	------------------------------
	&                 AND
	|                  OR
	^                 exclusive OR
	~                  complement 
	-----------------------------

>> AND OPERATOR (the  BITWISE AND OPERATOR, not the logical one)  [pag773 jesse]
The AND operator (&) is a single ampersand, in contrast to the logical AND, which is two ampersand. When you AND two bits, the result is 1 if both bits are 1, but 0 if either or both bist are 0. The way to think of this is the following: The result is 1 if bit 1 is set andif bit 2 is set; otherwise, the result is 0. 
>> OR OPERATOR | (the bitwise OR operator not the logical one) [pag 774 jesse]
The second bitwise operator is OR (|). Again, this is a single vertical bar, in contrast to the logical OR, which is two vertical bars. When you OR two bits, the result is 1 if either bit is set or if both are. If neither bit is set, the value is 0. 
>> EXCLUSIVE OR operator  ^ [pag 774 jesse]
The third bitwise operator is exclusive OR (^). When you exclusive OR two bits, the result is 1 if the two bits are different. The result is 0 if both bits are the same (if both bits are set or neither is set).
>> COMPLEMENT operator ~ [pag 774 jesse]
The complement opeartor (~) clears every bit in a number that is set and sets every bit that is clear. If the current value of the number is 10100011, the complement of that number is 01011100
----------------------------------------------------------------
>> BIT SETTING / >> SETTING BITS  [pag774 jesse]
When you want to set or clear a particular bit, you use masking operations. If you have a four-byte flag and you want to set bit 8 so that it is true (on), you need to OR the flag with the value 128. 
Why? 127 is 1000 0000 in binary; thus, the value of the eighth bit is 128. Whatever the current value of that bit (set or clear), if you OR it with the value 128, you will set  that bit and not change any of the other bits. Assume that the current value of the eight bits is 1010 0110 0010 0110. ORing 128 to it looks like this 
bit position ->  8765 4321
	1010 0110 0010 0110    // bit 8 is clear (= 0). Nota che la posizione dei bit si conta da destra verso sinistra. 
|   0000 0000 1000 0000    // 128
    ------------------------------
	1010 0110 1010 0110    // bit 8 is set (= 1)

You should note a few more things. First, as usual, bits are counted from right to left. Second, the value 128 is all zeros except for bit 8, the bit you want to set. Third, the starting number 	1010 0110 0010 0110 is left unchanged by the OR operation, except that bit 8 was set. Had bit 8 already been set, it would have remained set, which is what you want. 
------------------------------------------------------------------
>> CLEARING BITS [pag774 jesse]
If you want to clear bit 8, you can AND the bit with the complement of 128. The complement of 128 is the number you get when you take the bit pattern of 128 (1000 0000), set every bit taht is clear, and clear every bit that is set (0111 1111). When you AND  these numbers, the original number is unchanged, except for the eighth bit, which is forced to zero. 

bit position ->  8765 4321
	1010 0110 1010 0110    // bit 8 is set (= 1). Nota che la posizione dei bit si conta da destra verso sinistra. 
&  1111 1111 0111 1111    // ~128
    ------------------------------
	1010 0110 0010 0110    // bit 8 is clear (= 0)

To fully understand this solution, each time both bits are 1, write 1. If either bit is 0, write 0 in the answer. And the answer is the original number except that bit 0 was cleared.  
-------------------------------------------------------------------
>> FLIPPING BITS [pag775 jesse]
Finally, if you want to flip bit 8, no matter what its state, you exclusive OR the number with 128. If you do this twice, you end up back with the original setting. Thus, 

bit position ->  8765 4321
	1010 0110 1010 0110    // number
^  0000 0000 1000 0000    // 128       EXCLUSIVE OR -> if the two bits are equal -> result is 0
    ------------------------------
	1010 0110 0010 0110    // bit flipped 
^  0000 0000 1000 0000    // 128
    ------------------------------
	1010 0110 1010 0110    // flipped back
-------------------------------------------------------------------------------------------------------------------------------------------------------

DO 
	- DO set bits by using masks ad the OR operator 
	- DO clear bits by using masks and the AND operator 
	- DO flip bits using masks and the exclusive OR operator 
DON'T
	- DON'T confuse the different bit operators. 
	- DON'T forget to consider bits to the left of the bit(s) you are flipping. One byte is eight bits; you need to know how many bytes are in the variable you are using. 

-------------------------------------------------------------------------------------------------------------------------------------------------------
>> BIT FIELDS [pag775 jesse]
Under some circumstances, every byte counts, and saving six or eight bytes in a  class can make all the difference. If your class or structure has a series of Boolean variables or variables that can have only a very small number of possible values, you might save some room using bit fields. 
Using the standard C++ data types, the smallest type you can use in your class is a type char, which might be just one byte. You will usually end up using an int, which is most often four bytes on a machine with a 32-bit processor. By using bit fields, you can store eight binary values in a char and 32 binary values in a four-byte integer. 
Here's how bit fields work: Bit fields are named and accessed the same as any class member. Their type is always declared to be unsigned int. After the bit field name, wirte a colon followed by a number. 
The number is an instruction to the compiler as o how many bits to assign to this variable. If you write 1, the bit represents either the value 0 or 1. If you write 2, two bits are used to represent numbers; thus, the field would be able to represent 0, 1, 2 or 3, a total of four values. A three bit field can represent eight values, and so forth. 
The listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day21/List2107.cpp
illustrates the use of bit fields.
--------------------------------------- PUNTI SALIENTI Di List2107.cpp
- On line 4-7 several enumberated types are defined. These serve to define the possible values for the bit fields within the student class declared on lines 9-28: 
  4 enum STATUS { FullTime, PartTime } ;
  5 enum GRADLEVEL { UnderGrad, Grad } ;
  6 enum HOUSING { Dorm, OffCampus };
  7 enum FOODPLAN { OneMeal, AllMeals, WeekEnds, NoMeals };
- the student class has all the data packed into five vits on lines 24-27
 24     unsigned myStatus : 1; // the first bit represents the student's status, full time or part time 
 25     unsigned myGradLevel: 1; // the second bit represents whether this is an undergraduate
 26     unsigned myHousing : 1; // the third bit represents whether the student lives in a dorm
 27     unsigned myFoodPlan : 2; // the final two bits represent the four possible food plans. 
- the most important thing about using bit fields is that the client of the class need not worry about the data storage implementation. Because the bit fields are private, you can feel free to change them later and the interface will not need to change. 
 23   private:
 24     unsigned myStatus : 1;
 25     unsigned myGradLevel: 1;
 26     unsigned myHousing : 1;
 27     unsigned myFoodPlan : 2;
---------------------------------------------------------------------------------
OUTPUT 
[1171 Day21] >> g++ -o List2107.exe List2107.cpp 
[1172 Day21] >> ./List2107.exe 
Jim is part-time
Jim is full-time
Jim is on the No Meals food plan.
---------------------------------------------------------------------------------------------------------------------------------------------------------
>> PROGRAMMING STYLE [pag779 jesse]
As stated elsewhere in this book, it is important to adopt a consistent coding style, although in many ways it doesn't matter which style you adopt. A conssitent style makes it easier to guess what you meant by a particular part of the code, and you avoid having to look up whether you spelled the function with an initial cap the last time you invoked it. 
The following guidelines are arbitrary; they are based on the guidelines used in projects done in the past, and they've worked well. You can just as easily make up your own, but these will get you started. 
As Emerson said, "Foolish consistency is the hobgoblin of small minds", but having some consistency in your code is a good thing. Make up your own, but then treat it as if it were dispensed by the programming gods. 
>> INDENTING [pag779 jesse]
If you use tabs, they should be three spaces. Be certain your editor converts each tab to THREE spaces.
>> BRACES [pag779 jesse]
How to align braces can be most controversial topic between C++ programmers. Here are a few suggested tips: 
	1) Matching braces should be aligned vertically
	2) The outermost set of braces in a definition or declaration should be at the left margin. Statements within should be indented. All other sets of braces should be in line with their leading statements. 
	3) No code should appear on the same line as a brace. For example the following indentation is a good way to offer good readability: 
		if (condition == true)
		{
			j = k;
			SomeFunction();
		} 
		m++;
----------------------------------------------------------
>> LONG LINES and >> FUNCTION LENGTH [pag780 jesse]
Keep lines to teh width displayable on a single screen. Code that is off to the right is easily overlooked, and scrolling horizontally is annoying. 
When a line is broken, indent the following lines. Try to break the line at a reasonable place, and try to leave the intervening operator at the end of the previous line (instead of at the beginning of the following line) so that is clear that the line does not stand alone and more is coming. 
[ quindi per tradurre le parole sopra suppongo un esempio pratico sarebbe 
	cout << "This is a unique line printing the x value " << x << \    // prima del break "\" scrivo l'operator << in modo da far capire che qualcosa ancora segue nella riga successiva
		endl;
]
In C++ functions tend to be much shorter than they were in C, but the old, sound advice still applies. Try to keep your functions short enough to print the entire function on one page. 
-----------------------------------------------------------------------------------------
>> SWITCH STATEMENTS STRUCTURE / >> Structuring switch statements [pag780 jesse]
Indent switches as follows to conserve horizontal space : 
	
	switch(variable)
	{
		case ValueOne:	
			ActionOne();
			break;
		case ValueTwo:
			ActionTwo();
			break;
		default:	
			assert("bad Action");
			break;
	}

As you can see, the case statements are slightly indented and lined up. In addition the statements within each case are lined up. With this layout, it is generally easy to find a case statement and easy to then follow its code. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> PROGRAM TEXT CONVENTIONS  [pag780 jesse]
You can use several tips to create code that is easy to read. Code that is easy to read is generally easier to maintain. 
	- Use whitespace to help readability 
	- Don't use spaces between object and array names and their operations (., ->, []).
	- Unary operators are associated with their operands, so don't put a space between them. Do put a space on the side away from the operand. Unary operators include !, ~, ++, --, -, * (for pointers), & (casts), and sizeof. 
	- Binary operators should have spaces on both sides : +, =, *, /, %, >>, <<, <, >, ==, !=, &, |, &&, ||, ?:, =, +=, and so on 
	- Don't use lack of spaces to indicate precedence (4+ 3*2)
	- put a space after commas and semicolons, not before.
	- parentheses should not have spaces on either side. 
	- keywords, shuch as if, should be set off by a space: if (a == b).
	- The body of a single-line comment should be set off from the // with a space. 
	- Place the pointer or reference indicator next to the type name, not the variable name: 
		char* foo;
		int& theInt;
	rather than 
		char *foo;
		int &theInt;
	- Do not declare more than one variable on the same line. 
>> NAMING IDENTIFIERS GUIDELINES  [pag781 jesse] (identifiers, cioe' i nomi che scegli di dare a funzioni, variabili etc)
The following are guidelines for working with identifier names: 
	- identifier names should be long enough to be descriptive
	- avoid cryptic abbreviations 
	- take the time and energy to spell things out. 
	- do not use Hungarian notation. C++ is strongly typed and there is no reason to put the type into the variable name. With user-defined types (classes), Hungarian notation quickly breaks down. The exceptions to this might be to use a prefix for pointers (p) and references (r) as well as for class member variables (its).
	- short names (i, p, x, and so on) should be used only where their brevity makes the code more readable and where the usage is so obvious that a descriptive name is not needed. In general, however, you should avoid this. Also, avoid the use of the letters i, l, and o as variable names because they are easy to confuse with numbers. 
	- the length of a variable's name should be proportional to its scope. 
	- be certain identifiers look and soud different from one another to minimize confusion 
	- function (or method) names are usually verbs or verb-noun phrases: Serch(), Reset(), FindParagraph(), ShowCursor(). Variable names are usually abstract nouns, possibly with an additional noun: count, state, windSpeed, windowHeight. Boolean variables should be named appropriately: windowIconized, fileIsOpen. 
>> SPELLING and CAPITALIZATION OF NAMES [pag782 jesse]
Spelling and capitalization should not be overlooked when creating your own style. Some tips for these areas include the following: 
	- Use all uppercase and underscore to separate the logical words of #defined names, such as SOURCE_FILE_TEMPLATE. Note, however, that these are rare in C++. Consider using constants and templates in most cases. 
	- All other identifiers should use mixed case (no underscores). Function names, methods, class, typedef, and struct names should begin with a capitalized letter. Elements such as data members or locals should begin with a lowercase letter. 
	- Enumerated constant should begin with a few lowercase letters as an abbreviation for the enum. For example : 
		enum TextStyle 
		{
			tsPlain, 
			tsBold, 
			tsItalic, 
			tsUnderscore,
		};
-------------------------------------------------------------
>> COMMENTS [pag782 jesse]
Comments can make it much easier to understand a program. Sometimes, you will not work on a program for several days or even months. In that time, you can forget what certain code does or why it has been included. Problems in understading code can also occur when someone else reads your code. Comments that are applied in a consistent whell-thought-out style can be well worth the effort. Several tips to remember concerning comments include the following: 
	- whereever possible, use C++ single-line // comments 
rather than the /* */ style. Reserve the multiline style (/* */) for commenting  out blocks of code that might include C++ single line comments. 
	- higher-level comments are infinitely more important than process details. Add value; do not merely restate the code. 
		n++; // n is incremented by one
	This comments isn't worth the time it takes to type in. Concentrate on the semantics of functions and blocks of code. Say what a function does. Indicate side effects, types of parameters, and return values. Describe all assumption that are made (or not made) such as ""assumes n is nonnegative" or "will return -1 is x is invalid". Withing complex dlogic, use comments to indicate the conditions that exist at that point in the code (questa e' una pratica che gia' usavamo in matlab/scilab).
	- Use complete English sentences with appropraite punctuation and capitalization. The extra typing is worth it. Don't be overly cryptic and don't abbreviate. What seems exceedingly clear to you as you write code will be amazingly obtuse in a few months. 
	- Use blank lines freely to help the reader understandn what is going on. Separate statements into logical groups. 
>> SETTING UP ACCESS / >> ACCESS SETUP [pag783 jesse]
The way you access portions of your program should also be consistent. Some tips for access include the following : 
	- Always use public: , private: , and protected: labels; don't rely on the defaults. 
	- List the public members first, then protected, then private. List the data members in a group after the methods. 
	- Put the constructor(s) first  in the appropriate section, followed by the destructor. List overloaded methods with the same name adjacent to each other. Group accessor functions together whenever possible. 
	- Consider alphabetizing (metter in ordine alfabetico) the method names within each group and alphabetizing the member variables. Be certain to alphabetize the filenames in include statements. 
	- Even though the use of the virtual keyword is optional when overriding, use it anyway; it helps to remind you that is virtual, and it also helps the declaration consistent. 
>> CLASS DEFINITIONS [pag783 jesse]
Try to keep the definitions of methods in the same order as the declarations. It makes things easier to find. 
When defining a function, place the return type and all other modifiers on a previous line so that the class name and function name begin at the left margin. This makes it much easier to find functions.
>> INCLUDE FILES [pag784 jesse]
Try as hard you can to minimize the use of #include, and thus minimize the number of files being included in header files. 
The ideal minimum is the header file for the class from which this one derives. Other mandatory includes are those for objecst that are members of the class being declared. Classes that are merely pointed to or referenced only need forward references of the form. 
Don't leave out an include file in a header just because you assume that whatever .cpp file includes this one will also have the needed include. And don't add extra ones to try to "help out" other included files.   
	TIP: all header files should use inclusion guards. 
-----------------------------------------------------------
>>  ASSERT() usage [pag784 jesse]
You learned about assert() earlier today. Use assert() freely. It helps find errors, but it also greatly helps a reader by making it clear what the assumptions are. It also helps to focus the writer's thoughts around what is valid and what isn't. 
>> CONSTANT items / >> making items constant with const [pag784 jesse]  
Use const whereever appropriate: for parameters, variables, and methods. Often, there is a need for both a const and a non-const version of a method; don't use thi as an excuse to leave one out. Be very careful when explicitly casting from const to non-const and vice versa (at times, this is the only way to do something), but be certain that it makes sense, and include a comment. 
--------------------------------------------------------------------------------------------------------------------------------------------------------
NExT STEPS in your C++ developmet  [towards la Gerusalemme Celeste pag 784 jesse]
You've been spent long weeks working at C++, and you are likely to have the basics needed to be a competent C++ programmer, but you are by no means finished. There is much more to learn and many more places you can get valuable information as you move from novice C++ programmer to expert. 
The following sections recommend a number of specific sources of information, and these recommendations reflect only personal experience and opinions. Dozens of books and thousands of articles are available on each of these topics, however, so be certain to get other options before purchasing. 
>> HELP and >> ADVICE where to find 
THe very first thing you will wnat to do as a C++ programmer will be to tap into one or more of the C++ communities on the Internet. These groups supply immediate contact with hundreds or thousands of C++ programmers who can answer you questions, offer advice and provide a sounding board for your ideas. 
The C++ Internet newsgroups 
	comp.lang.c++
	comp.lang.c++.moderated
are recommended as excellent sources of information and support. There are also site such as 
	http://www.CodeGuru.com 
	http://www.CodeProject.com 
These are two sites have hundreds of thousands of C++ developers come to them every month. They offer resources such as articles, tutorials, news, and discussions  on C++. Numerous other such communities are available as well. 
Finally compiler vendors such as Borland and Microsoft have newsgroups that can be invaluable sources of information about their development environment and the C+ language. 
RELATED C++ TOPICS 
	>> C#
	>> .NET from Microsoft 
	>> Managed C++ 
Microsoft .NET platform is radically changing the way many of us develop for the internet. A key component of .NET is the new language, C#, as wel as a number of serious extensions to C++ called Managed Extensions. 
C# is a natural extension of C++, and is an easy bridge to .NET for C++ programmers. A number of good books on C# are available, including Programming C# (O'Reilly Press)
As a programming language, C# has some differnces from C++. For example, multiple inheritance is not allowed in C#; though the use of interfaces provides similar capabilities. In addition, C# avoids the use of pointers. This removes issues with dangling pointers and other such problems, at the price of making the language less capable of low-level real-time programming. The final item worth mentioning on C# is that it uses a runtime  and a garbage collector (>> GC = garbage collect un po CS chicken shit collector AmericanGraffiti). The GC takes care of freeing resouces when they are needed so you, the programmer, don't have to. 
Managed C++ is also from Microsoft and a part of .NET. In very simple terms, this is an extension to C++ that gives C++ the ability to use all the features of .NET, including the gargabe collector an more. 
--------------------------------------
DO 
	- DO look at other books. There's plenty to learn and no single book can teach you everything you need to know 
	- DO join a C++ user group
DON'T	
	- DON'T just read code! The best way to learn C++ is to write C++ programs.   
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> expression [pag4 moo book] = asks the implementation to compute something.
Expression contains operators and operands
Example in the expression 
	std::cout << "Hello, world!" << std::endl;
the operands are 
	std::cout
	"Hello, world!"
	std::endl
mentre << is an operator. 
Every operand has a type. 
>> type : a type denotes a data structure and the meanings of operations that make sense for that data structure.
///////////////////////////////////////////////////////////////////////


>> else clause 
[mike pag43]
You can add an else clause to an if statement to provide code that will only be executed if the tested expression is false. Here's the form of an if statement that includes an else clause:
	if (expression)
		statement1;
	else
		statement2;
If expression is true, statement1 is executed. Then the program skips statement2 and executes the statement following the if suite. IF expression is false, statement1 is skipped and statement2 is executed. After statement2 completes, the program executes the statement following the if suite.
Example 
	// Score Rater 2.0
	// Demonstrates an else clause
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int score;
		cout << "Enter your score: ";
		cin >> score;
	
	    if (score >= 1000)
		{
	        cout << "You scored 1000 or more. Impressive!\n";
		}
		else
		{
			cout << "You scored less than 1000.\n";
		}
	
	    return 0;
	}
/////////////////////////////////////////////////////////////////////////////

>> executable creation process [mikepag3]
editor -> source code -> compiler (translate the source code *.cpp into an object file *.obj)-> object code -> linker (link the object file to any external files as necessary, then creates the executable file, which generally ends with the extension .exe) -> executable file
To help automate this process, it's common for a programmer to use an all in one tool for development, called an >> IDE = integrated development environment. An IDE typically combinesan editor, a compiler and a linker along with other tools. 

>> COMPILE HOW TO
//                 ,  ,
//                / \/ \,'| _
//               ,'    '  ,' |,|
//              ,'           ' |,'|
//             ,'                 ;'| _
//            ,'                    '' |
//           ,'                        ;-,
//          (___                        /
//        ,'    `.  ___               ,'
//       :       ,`'   `-.           /
//       |-._ o /         \         /
//      (    `-(           )       /                 To compile the files type in the terminal:
//     ,'`.     \      o  /      ,'                 g++ file_name.C -o executable_name
//    /    `     `.     ,'      /
//   (             `"""'       /
//    `._                     /
//       `--.______        '"`.
//          \__,__,`---._   '`;
//               ))`-^--')`,-'
//             ,',_____,'  |
//             \_          `).
//               `.      _,'  `
//               /`-._,-'      \
//
//
//*********************************************************************************************************************************




>> ERROR TYPES [mike pag4]
	>> Compile errors = these occur during code compilation. As a result, an object file is not produced.
	>> link errors = these occur during the linking process and may indicate that something the program references externally can't be found. These errors are usually solved by adjusting the offending reference and startin the compile link process again. 
	>> run time erros = these occur when the executable is run. If the program does something illegal, it can crash abruptly. But a more subtle form of run-time error, a logical error, can make the program simply behave in unintended ways.

>> empty 
empty is a member function of the string class. "empty" determines  whether a string is empty.
[pag435 deitel]
/home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
line 11
		string s3; // creation of an empty string ; ricorda come l'inizializzazione di una string non empty fosse string s3("nanika");
line 27
	   if ( s3.empty() )	
	   {
	      cout << "s3 is empty; assigning s1 to s3;" << endl;
	      s3 = s1; // assign s1 to s3
	      cout << "s3 is \"" << s3 << "\"";
	   } // end if
/////////////////////////////////////////////////////////////

>> EMPTY PARAMETER LISTS
[pag235]
In C++ an empty parameter list is specified by writing either void or nothing at all in parentheses.
Per esempio per dichiarare and use functions with empty parameter lists we can
	void function();
or also 
	void function( void );
Queste righe un po come le suore che bastino si mettono sui banconi vicino all'altare del prete per svolgere la loro funzione, si mettono giusto prima dell'int main {...}  

>> endl 
	endl 
stands for end line 	
example 
	std::cout << "Sum is " << sum << std::endl; // display sum, end line
endl is a stream manipulator that belongs to the namespace std. The std::endl outputs a newline, then "flushes the output buffer". This simply means that, on some system where outputs accumulate in the machine until there are enough to "make it worthwhile" to display them on the screen, std::endl forces any accumulated outputs to be displayed at that moment.  

>> ENLIGHTMENT / >> ZEN MOMENT >> UNDERSTANDING what classes and object technology is all about / >> OBJECT and CLASSES an enlightment case study
[pag434deitel and pag 453deitel] this is one of the most important case studies in deitel book. Many students have indicated that the Array case study is their ">> light bulb moment" in truly understanding what classes and object technology are all about.
Once you master this Array class, you'll indded understand the essence of object technology (crafting, using and reusing valuable classes)

>> ENUM / >> ENUMERATION 
[pag222deteil + pag29 mike]
IN SHORT [pag34 mike]: an enumeration is a sequence of unsigned int constants.
IN LONG
a user-defined type called an enumeration is 
    introduced by the keyword enum 
and followed by a type name (in the example Status) 
// -------------------------------------------------------
                and a set of integer constants represented by identifiers (che nell'esempio sono CONTINUE WON e LOST)  
 // enumeration with constants that represent the game status
    enum Status { CONTINUE, WON, LOST }; // all caps in constants
 ...
 Status gameStatus = CONTINUE;
// -------------------------------------------------------
The values of this enumeration constants start at 0 unless specified otherwise and increment by 1. Quindi in the preceding enumeration: 
- the constant CONTINUE has the value 0, 
- WON has the value 1
- LOST has the value 2
OSSERVAZIONE 
> variable of user-defined type Status (gameStatus in the above example) can be assigned only one of the three values (CONTINUE or WON or LOST) declared in the enumeration
> capitalize the first letter of an identifier used as a user-defined type name (mi sembra si riferisca a "Status" nell'esempio sopra) 
> use only uppercase letters in enumeration constant names. This makes these constants stand out in a program and reminds you that enumeration constants are not variables.
EXAMPLE 2 Month enumeration 
	enum Months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
which creates user-defined type Months with enumeration constants representing the months of the year. The first value in the preceding enumeration is explicitly set to 1, so the remaining values increment from 1, resulting in the values 1 through 12. Any enumeration constant can be assigned an integer value in the enmeration definition, and subsequent enumeration constants each have a value 1 higher than the preceding constant in the list until the next explicit setting. 
Quindi mi sembra di capire che se per esempio scrivessi
	enum Months { JAN = 1, FEB, MAR, APR = 7, MAY, JUN};
otterrei JAN = 1, FEB = 2, MAR = 3, APR =7, MAY =8, JUN=9 
OBSERVATION 
- the previous enums are also called unscoped enums per differenziarli dagli scoped enums introdotti con C++11
The problem with unscoped enums is that multiple enums may contain the same identifiers. Using such enums in the same program can lead to naming collisions and logic errors. To eliminate these problems, C++11 introduces  so-called scoped enums, which are declared with the keywords enum class (or the synonym enum struct). For example the previous example enum Status { CONTINUE, WON, LOST }; becomes
	enum class Status { CONTINUE, WON, LOST };
- To reference a scoped enum constant, you must qualify the constant with the scoped enum's type name (Status) an the scope-resolution operator (::) , as in Status::CONTINUE. This explicitly identifies CONTINUE as a constant in the scope of enum class Status. Thus, if another scoped enum contains the same identifier for one of its constants, it's always clear which version of the constant is being used.
- Use scoped enums to avoid potential naming conflicts and logic errors from unscoped enums that contain the same identifiers.
- [pag223] C++11 allows you to specify an enum's underlying integral type by following the enum's type name with a colon (:) and the integral type. For example, we can specify that the constants in the enum class Status should have type unisgned int, as in 
	enum class Status : unsigned int { CONTINUE, WON, LOST };
Attention : a compilation error occurs if an enum constant's value is outside the range that can be represented by the enum's underlying type. see nostro esempio pag224 deitel [ad ogni modo il limite e' talmente grande che in liste normali e' improbabile che lo possa superare.]
----------------------------------------------------------------------------------------------------------------------------------------
>> enumeration from pag29 mike
An enumeration is a set of unsigned int constnats, called enumerators. Usually the enumerators are related and have a particular order. Here's an example of enumeration:
	enum difficulty {NOVICE, EASY, NORMAL, HARD, UNBEATABLE};
This defines an enumeration named difficulty. By default, the value of enumerators begins at zero and increases by one. So NOVICE is 0, EASY is 1, NORMAL is 2, HARD is 3, UNBEATABLE is 4. Next we can create a variable of this new enumeration type.
	difficulty myDifficulty = EASY;
The variable myDifficulty is set to EASY which is equal to 1. myDifficulty is of type difficulty, so it can only hold one of the values defined in the enumeration. That means myDifficulty can only be assigned NOVICE, EASY, NORMAL, HARD, UNBEATABLE, 0, 1, 2, 3, 4. 
see program /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/game_stats3.cpp
Nello stesso programma trovi anche questo tipo di enumerator:
	enum shipCost {FIGHTER_COST = 25, BOMBER_COST, CRUISER_COST = 50};
this line of code ddefines the enumeration shipCost, which represents the cost for three kind of spaceships in a strategy game. In it, we assign specific integer values to some of the enumerators. The numbers represent the Resource Point value of eac ship. You can assign values to the enumerators if you want. Any enumerators that are not assigned values get the value of the previous enumerator plus one. Because we didn't assign a value to BOMBER_COST, it's initialized to 26. 
Next we define a variable of type "shipCost" e le assegniamo il valore BOMBER_COST
	shipCost myShipCost = BOMBER_COST;   // visto l'enumerator definito sopra ora myShipCost = 26
	cout << "\nTo upgrade my ship to a Cruiser will cost " 
         << (CRUISER_COST - myShipCost) << " Resource Points.\n";    // since CRUISER_COST = 50 and myShipCost = 26 we need : 50 -26 = 24
Esattamente come viene outputtato dal programma:
	To upgrade my ship to a Cruiser will cost 24 Resource Points.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> ENUMERATION see also pag.61 jesse book 
example1 
	enum COLOR { RED, BLUE, GREEN, WHITE, BLACK };
this statement performs two tasks:
	1) it makes COLOR the name of an enumeration; this is a new type
	2) it makes RED a symbolic constant with the value 0, BLUE a symbolic constant with the value 1, GREEN a symbolic constant with the value 2, and so forth. If you don't specify otherwise, the first constant has the value 0, and the rest count up from there. Any one of the constants can be initialized with a particular value, however, and those that are not initialized count upward from the ones before them. Thus, if you write
	enum Color { RED=100, BLUE, GREEN=500, WHITE, BLACK=700 };
then RED has value 100, BLUE the value 101, GREEN the value 500, WHITE the value 501, and BLACK the value 700.
You can define variables of type COLOR, but they can be assigned only one of the enumerated values (in this case RED, BLUE, GREEN, WHITE or ahinoi BLACK.)
-------------------------------------------
example:
-------------------------------------------
#include <iostream>
int main()
{
   enum Days { Sunday, Monday, Tuesday,
            Wednesday, Thursday, Friday, Saturday };
  
   Days today;
   today = Monday;
 
    if (today == Sunday || today == Saturday)
      std::cout << "\nGotta' love the weekends!\n";
   else
      std::cout << "\nBack to work.\n";
  
    return 0;
}
----------------------------------------------------------------------------------------------------------------
NOTE se al posto delle enumerated constants volessi usare le tradizionali constant integers allora il programma diviene:
#include <iostream>
int main()
{
   const int Sunday = 0;
   const int Monday = 1;
   const int Tuesday = 2;
   const int Wednesday = 3;
   const int Thursday = 4;
   const int Friday = 5;
   const int Saturday = 6;
  
   int today;
   today = Monday;
  
   if (today == Sunday || today == Saturday)
      std::cout << "\nGotta' love the weekends!\n";
   else
      std::cout << "\nBack to work.\n";
  
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> EOF end of file
[pag173deitel]
EOF is a symbolic integer constant that is included into the program via the <iostream> header.
EOF can be used as a sentinel value to terminate for example a while loop cycle come nell'esempio di pag 172deitel
- in OS X / linux/UNIX systems end-of-file is entered by typing CTRL+d
- in windows by typing CTRL + z
NOTE in some cases you must press ENTER after the preceding key sequence
NOTE2: quindi quando in un programma vedi richiesto
	Enter end-of-file to end input
significa premere CTRL + Z in windows e CTRL + D in mac/linux
PORTABILITY : testing for the symbolic constant EOF rather than -1 makes programs more portable.


>> eof 
[pag589 deitel]
The eofbit is set for an input stream after end-of-file is encountered. A program can use member function eof to determine whether end-of-file has been encountered on a nstream after an attempt to extract data beyond the end of the stream. The call 
	cin.eof()
returns true if end-of-file has been encountered on cin and flase otherwise.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> ERROR compiling 
You attempt to compile a program that uses type "size_t"  and receive errors indicating that it's not defined
SOLUTION 
Include <cstddef> in your program. 
	#include <cstddef>
li' dalle righe dove sta di solito scritto 
	#include <iostream>
[pag282deitel]

>> ERROR 
	g++ -o hello Hello.ccp 
gives:
	Hello.ccp: file not recognized: File format not recognized
	collect2: ld returned 1 exit status
SOLUTION 
mv Hello.ccp Hello.cpp
/////////////////////////////////////////////////////////////// 
 
>> ESCAPE SEQUENCE
The escape sequence is a pair of characters that begins with a backslash \, which represent special printable characters.
Alcuni esempi di escape sequence da usarsi all'interno di string literals.
	\n     
newline
	\t     
horizontal tab. move the screen cursor to the next tab stop  [ >> \t]
	\r     
carriage return. Position the screen cursor to the beginning of the current line; do not advance to the next line
	\a 
alert. sound the  system bell
	\\
backslash. Used to print a backslash character
	\'
single quote. Used to print a single quote character
	\"
double quote. Used to print a double quote character 	
	\0 
null character
	\b
backspace
	\f
form feed
	\t
horizontal tab
	\v
vertical tab
	\x
hexadecimal number
[pag42deitel and pag22 mike]
And example from pag22 mike
	cout << "\nscore: " << score << endl;
in this example the escape sequence is \n which represents a new line. When sent to cout as part of a string, it's like pressing the Enter key in the console window. 



>> ESCAPE CHARACTER / >> skip character

[http://stackoverflow.com/questions/10220401/c-string-literals-escape-character]

>> EXAMPLE NICE 
Ti elenco qui alcuni nice example che magari ti potrebbero tornare in mente e se ti domandassi "ah dov'era gia' che l'avevo visto, ecco cerco qui di darti un aiutino.
- Example of print bar in chart, printare un tot di asterischi a seconda della frequenza con cui un evento si ripete
	  0-9 :   
	10-20 : **
	20-30 : *****
	30-40 : ***
	40-50 : *
see pag296 e relativo codice pagina 299

>> EXCEPTION HANDLING 
[pag318deitel + pag741 deitel]
In case of out-of-range subscript, we can create fault-tolerant programs with expection handling to continue executing as if no problems were encountered.
More severe problems might prevent a program from continuing normal execution, instead requiring the program to notify the user of the problem, then terminate. When a function detects a problem, such as an invalid array subscript or an invalid argument, it throws an exception (that is an expection occurs)   
To handle an expection, place any code that might throw an expection in a try statement
The try block contains the code that might throw an exception, and the catch block contains the code that handles the exception if one occurs.
Example from fig07_25.cpp [pag316deitel]
   header <stdexcept>
   ....
   vector< int > integers( 10 ); // 10-element vector< int >
   ....
   try 
   {   
      cout << "\nAttempt to display integers.at( 15 )" << endl;
      cout << integers.at( 15 ) << endl; // ERROR: out of range visto che il nostro vettore ha solo 10 elementi
   } // end try
   catch ( out_of_range &ex )
   {   
      cerr << "An exception occurred: " << ex.what() << endl;
   } // end catch
//--------------------------------------------------------------
Nota come nella riga "cout << integers.at( 15 )", the vector member function "at" provides bounds checking and throws an exception if its argument is an invalid subscript. Nell'esempio sopra "at" lancera' un out_of_range exception (from header <stdexcept>) to notify that 15 is out of the range of array "integers" (il cui range e' 10, e' solo un array di 10 elementi)
At this point the try block terminates immediately and the catch block begins executing.
The catch block declares a type (out_of_range) and an exception parameter (ex) that it receives as a reference. The catch block can handle exceptions of the specified type. Inside the block, you can use the parameter's identifier to interact with a caught exception object.
Note2: nella riga ex.what(): this line calls the exception object's "what" member function to get the error message that is stored in the exception object and display it. Once the message is displayed in the example, the exception is considered handled and the program continues with the next statement after the catch block's closing brace. 
////////////////////////////////////////////////////////////////
>> EXCEPTION HANDLING [pag72 moo book]
try { // code  Initiates a block that might throw an exception 
{ catch(t) { /* code */}
			   Concludes the try block and handles excpetions that match the type t. 
			   The code following the catch performs whatever action is appropriate to handle the exception reported in t. 
throw e        Terminates the current function; throws the value e back to the caller
---------------
Exception classes :the library defines several expcetion classes whose names suggest the kinds of problems they might be used to report:
	logic_error 
	domain_error
	invalid_argument
	length_error
	out_of_range
	runtime_error
	range_error
	overflow_error
	underflow_error
e.what()   returns a value that reports on what happened to cause the error.
////////////////////////////////////////////////////////////////
>> exception handling 
[pag741 deitel]
Exception handling enables you to create applications that can resolve (or handle) exceptions. The feautre presented in chapter 17 deitel enable you to write robust and fault-tolerant programs that can deal with problems and continue executing or terminate gracefully.
NOTE
Incorporate your exception-handling strategy into your system from its inception. Including  effective exception handling after a system has been implmented can be difficult.
NOTE2 (from pag 750 deitel): when to use exception handling
Exception handling is designed to process >> synchronous errors, which occur when a statement executes, such as 
	- out of range array subscripts 
	- arithmetic overflow
	- division by zero
	- invalid function parameters 
	- unsuccessful memory allocation (due to lack of memory) 
Execption handling is not desinged to process errors associatd with >> asynchronous events (e.g. disk I/O completions, netword message arrivals, mouse clicks and keystrokes), which occur in parallel with and independent of the program's flow of control.  
EXAMPLES 
- exception handling division by zero -> pag 741-742 deitel
[/home/dia/Deitel-Code_Examples/ch17/fig17_01_02/fig17_01_02.cpp]
nota: l'abbiamo lanciato in visualstudio abbiamo carito il main come al solito in canovaccio.cpp, quindi dall'esplorer tree sulla sinitra -> click destro su header e abbiamo selezionato -> add quindi abbiamo selezionato l'*.h che avevamo copiato nella stessa cartella contenente il main.
	double quotient( int numerator, int denominator )
	{
	   // throw DivideByZeroException if trying to divide by zero
	   if ( denominator == 0 )
	      throw DivideByZeroException(); // terminate function
	
	   // return division result
	   return static_cast< double >( numerator ) / denominator;
	} // end function quotient
in this example (fig17_01_02.cpp line 10) we define a function named quotient that receives two inteegers input by the user and divides its first int parameter by its second int parameterBefore performing the devision , the function casts the first int parameter's value to type double. Then, the second int parameter's value is (implicitly) promoted to type double for the calculation. So function quotient actually performs the division using two double values and returns a double result.
The example consists of two files DivideByZeroException.h defines an exception class that represents the type of the problem that might occur in the example, and fig17_02.cpp (fig17.2) defines the quotient function and the main function that calls it. Function main contains the code that demonstrates exception handling.
[segue extract from /home/dia/Deitel-Code_Examples/ch17/fig17_01_02/DivideByZeroException.h]
	class DivideByZeroException : public std::runtime_error 
	{
	public:
	   // constructor specifies default error message
	   DivideByZeroException()
	      : std::runtime_error( "attempted to divide by zero" ) {}
	}; // end class DivideByZeroException
///////////////////////////
DivideByZeroException.h defines class DivideByZeroException as a derived class of Standard Library class runtime_error (from header <stdexcept>). Class runtime_error (a derived class of exception) (from header <exception>) is the C++ standard base class for representing runtime errors. Class exception is the standard C++ base class for exception in the C++ Standard Library. 
Every exception class that derives directly or indirectly from exception contains the virtual function what, which returns an exception object's error message. You're not required to derive a custom exception class, such as DivdieByZeroException, from the standard exception classes provided by C++. However, doing so allows you o use the virtual function what to obtain an appropriate message error.
------------------------
Qualche osservazione sul programma principale /home/dia/Deitel-Code_Examples/ch17/fig17_01_02/fig17_01_02.cpp: 
 32       try
 33       {
 34          double result = quotient( number1, number2 );
 35          cout << "The quotient is: " << result << endl;
 36       } // end try
 37       catch ( DivideByZeroException &divideByZeroException )
 38       {
 39          cout << "Exception occurred: "
 40             << divideByZeroException.what() << endl;
 41       } // end catch
Nota come in questo esempio, because the invocation of function quotient (line34) can throw an exception, we enclose this function invocation ina a try block. The as seen in section 7.10 at least one "catch" handler must immediately follow each try block.
An exception parameter should always be declared as a reference to the type of exception the catch handler can process (DivideByZeroException in this case). This prevents copying the exception boejct when it's caught and allows a catch handler to properly catch derived-class  expcetions as well.
NOTE1: it'a sintax error to place code between a try block and its corresponding catch handlers or between its catch handlers.
NOTE2: Each catch handler can have only a single parameter; specifying a comma-separated list of exception parameters is a syntax error.
------------------------------------------------
Termination model of exception handling
If an exception occurs as the result of a statement in a try block, the try block expires (i.e. terminates immediately). Next, the program searches for the first catch handler that can process the type of eception that occurred. THe program locates the matching catch by comparing the thrown exception's type to each catch's exception-parameter type until the program finds a match. A match occurs if the types are identical or if the thrown exception's type is a derived class of the exception-parameter type. 
When a match occurs, the code in the matching catch handler executes. 
When a catch handler finishes processing by reaching its closing right brace (}) the exception is considered handled and the local variables defined within the catch handler (including the catch parameter) go out of scope. Program control does not return to the point at which the exception occured  (known as >> throw point), because the try block has expired. Rather control resumes with the first statement (line 43) after the lastcatch handler following the try block.  
This is known as the 
	>> termination model of exception handling. 
Some languages use the 
	>> resumption model of exception handling, in which after an exception is handled, control resumes just after the throw point. As with any other block of code, when a try block terminaes, local variables defined in the block go out of scope.
 27    // enable user to enter two integers to divide
 28    while ( cin >> number1 >> number2 )
 29    {
 30       // try block contains code that might throw exception
 31       // and code that will not execute if an exception occurs
 32       try
 33       {
 34          double result = quotient( number1, number2 );
 35          cout << "The quotient is: " << result << endl;
 36       } // end try
 37       catch ( DivideByZeroException &divideByZeroException )
 38       {
 39          cout << "Exception occurred: "
 40             << divideByZeroException.what() << endl;
 41       } // end catch
 42 
 43       cout << "\nEnter two integers (end-of-file to end): ";
 44    } // end while
NOTE: logic errors can occur if you assume that after an exception is handled, control will return to the first statement after the throw point.
If the try block completes its execution successfully (= no exceptions occur in the try block) then the program ignores the catch handlers and program control continues with the first statement after the last catch following that try block.
NOTE2: >> stack unwinding : If an exception that occurs in a try block has no matching catch handler, or if an exception occurs in a statement that is not in a try block, the function that contains the statement terminates immediately, and the program attempts to locate an enclosing try block in the calling function. This process is called stack unwinding. 
NOTE3: To throw an exception we uses the keyword throw followed by an operand of the type of exception to throw. Normally, a throw statement specifies one operand. (in section 17.3 we discuss how to use a throw statement with no operand). The operand of a throw can be of any type (but it must be copy constructable). If the operand is an object, we call it an >> exception object (in the example above the exception object is of type DivideByZeroException)
 10 double quotient( int numerator, int denominator )
 11 {
 12    // throw DivideByZeroException if trying to divide by zero
 13    if ( denominator == 0 )
 14       throw DivideByZeroException(); // terminate function
 15 
 16    // return division result
 17    return static_cast< double >( numerator ) / denominator;
 18 } // end function quotient
NOTE4: when line 14 throws the exception, function quotient exits immediately. So, line 14 throws the exception before function quotient can perform the division in line 17. This ia a central characteristic of exception handling: If your program explicitly throws an exception, it should do so before the error has an opportunity to occur.
------------------------------------------------------------------------------------
>> Exception rethrowing / >> rethrowing an exception
[pag747 deitel]
EXAMPLE
/home/dia/Deitel-Code_Examples/ch17/fig17_03/fig17_03.cpp
NOTES: a function might use a resource (like a file) and might want to >> release the resource (i.e. close the file) if an exception occurs. An exception handler, upon receviving an exception, can release the resource then notify its caller than an exception occurred by rethrowing the exception via the statement
	throw;
Regardless of whether a handler can process an exception, the handler can rethrow the exception for further processing outside the handler. The next enclosing try block detects the rethrown exception, which a catch handler listed after that enclosing try block attemps to handle. 
ATTENTION: executing an empty throw statement outside a catch handler abandons exception processing and terminates the program immediately.
-------------------------------------------------------------------------------------------------------------
>> stack unwinding
[pag748 deitel]
When an exception is thrown byt not caught in a particular scope, the function call stack is "unwound" and an attempt is made to catch  the exception in the next outer try...catch block. Unwinding the function call stack means that the function in which the exception was not caught terminates, and control returns to the statement that originally invoked that function. If a try block encloses that statement, an attempt is made to catch the exception. If a try block does not enclose that statement, stack unwinding occurs again. If no catch handler ever catches this exception, the program terminates.
EXAMPLE:
	/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_04/fig17_04.cpp
OUTPUT 
function1 is called inside main
function2 is called inside function1
function3 is called inside function2
In function 3
Exception occurred: runtime_error in function3
Exception handled in main
------------------------------------------------------------------------
>> exeception handling destructors constructors / >> constructors and exception handling / >> destructors and exception handling
[pag751 deitel] 
How should an object's constructor respond when it receives invalid data?
The preferred way is to require the constructor to throw an exception that contains the error information, thus offering an opportunity for the program to handle the failure.
- Destructor should catch exceptions to prevent program termination.
- Do not throw exceptions from the constructor of an object with static storage duration. Such exception cannot be caught.
------------------------------------------------------------------------
>> exception and inheritance / >> inheritance and exception 
[pag752 deitel]
If a catch handler catches a reference to an exception object of a base-class type, it also can catch a reference to all objects of classes publicly derived from that base class - this allows for polymorphic processing of related exceptions.
--------------------------------------------------------------------------
>> bad_alloc / >> failures processing 
[pag752 deitel]
When operator new fails, it throws a bad_alloc exception (defined in header <new>). 
A) >> new throwing bad_alloc on failure [pag752 deitel]
EXAMPLE 
	/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_03/fig17_03.cpp
///////////////////////////////////
	// Fig. 17.3: fig17_03.cpp
	// Rethrowing an exception.
	#include <iostream>
	#include <exception>
	using namespace std;
	
	// throw, catch and rethrow exception
	void throwException() 
	{
	   // throw exception and catch it immediately
	   try 
	   {
	      cout << "  Function throwException throws an exception\n";
	      throw exception(); // generate exception
	   } // end try
	   catch ( exception & ) // handle exception
	   {
	      cout << "  Exception handled in function throwException"
	         << "\n  Function throwException rethrows exception";
	      throw; // rethrow exception for further processing
	   } // end catch
	
	   cout << "This also should not print\n";
	} // end function throwException
	
	int main()
	{
	   // throw exception
	   try 
	   {
	      cout << "\nmain invokes function throwException\n";
	      throwException();
	      cout << "This should not print\n";
	   } // end try
	   catch ( exception & ) // handle exception
	   {
	      cout << "\n\nException handled in main\n";
	   } // end catch
	
	   cout << "Program control continues after catch in main\n";
	} // end main
////////////////////////////////
OUTPUT [su orion I]
	ptr[0] points to 50,000,000 new doubles
	ptr[1] points to 50,000,000 new doubles
	ptr[2] points to 50,000,000 new doubles
	ptr[3] points to 50,000,000 new doubles
	Exception occurred: bad allocation
------------------------
NB: the output shows that the prorgam performed only four iterations of the loop before new failed and threw the bad_alloc excetion. Your output might differ based on the physcal memory, disk space available for virtual memory [cioe' quello che mi sembra si chiami swap memory] on your system and the compiler you're using. 

B) >> new returning nullptr on failure [pag753 deitel]
The C++ standard specifies that programmers can use an older version of new that returns nullptr upon failure. For this purpose, header <new> defines object nothrow (of type nothrow_t) which is used as follows:
	double *ptr = new( nothrow ) double [ 50000000 ];
MA :
CONSIGLIO: to make programs more robust, use the version of new that throws bad_alloc exceptions on failure (cioe' l'opzione A) esposta poco sopra).
C) >> set_new_handler [pag754 deitel] / >> handling new failures using function set_new_handler
[pag754 deitel]
An additonal feature for handling new failures is function set_new_handler (prototyped in standard header <new>).
This function takes as its argument a pointer to a function that takes no arguments and returns void. This pointer points to the function that will be called if new fails. This provides you with a uniform approach to handling ALL "new" failures, regardless of where a failure occurs in the program. Once set_new_handler registers a new handler in the program, operator new does not throw bad_alloc on failure; rather, it defers the error handling to the new-handler function.
- If new allocates memory successfully, it returns a pointer to that memory. 
- If new allocates memory successfully, it returns a pointer to that memory. If new fails to allocate memory and set_new_handler did not register a new-handler function, new throws a bad_alloc exception.
See example : /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch17/fig17_06/fig17_06.cpp
-------------------------------------------------------------------------------------------------
>> EXCEPTION HIERARCHY / >> STANDARD LIBRARY EXCEPTION HIERARCHY
[pag758 deitel]
Some of the standard library exception classes
    
                                 exception
                                     |
            ---------------------------------------------------
            |                        |                        |
        runtime_error                |                   logic_error
            |                        |                        | 
    -------------------              |           -------------------------------
    |                 |              |           |            |                |
overflow_error    underflow_error    |    invalid_argument   length_error   out_of_range
                                     |
            -------------------------------------------
            |           |            |                |
         bad_alloc   bad_cast     bad_type_id     bad_exception

The Standard library includes a hierarchy of exception classes, some of which are shown in the sketch above [Thanks Ciccio]
This hierarchy is headed by base-class exception (defined in header <exception>), which contains virtual function what that derived classes can override to issue appropriate error messages. 
-------------------------
[vediamo il ruolo di alcune delle classi presentatenell'esempio sopra]
>> invalid_argument [vedi sopra] = indicates that a function received an invalid agurment.
>> length_error indicates that a length larger than the maximum size allowed for the object being manipulated was used for that objects.
>> out_of_rage = indicates that a value, such as a subscript in to an array, exceeded its allowed range of values. 
>> overflow_error = describes an arithmetic overflow error (i.e. the result of an arithmetic operation is larger than the largest number that can be stored in the computer)
>> underflow_error = describes an arithmetic underflow error (i.e. the result of an arithmetic operation is smaller than te smallest number that can be stored in the computer)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C# [pag34 mike]: C# is a progamming language created by Microsoft intended to be both simple and general purpose. C# was influenced by and bears much similarity to C++ but the two are separate and distinct languages. 


>> EXIT 
[pag 392deitel]
the function exit forces a program to terminate immediately and does not execute the destructors of local objects. 
The "exit" function often is used to terminate a program when a fatal unrecoverable error occurs.

>> EXPONENTIAL COMPLEXITY 
[nell'ambito delle recursive functions]
[pag255deitel]
A word of caution is in order about recursive programs like the one we used (pag253) to generate Fibonacci numbers. The number of recursive calls that are required to calculate the nth Fibonacci number is on the order of 2^n.
Calculating the 30th Fibonacci number would require on the order of 2^30 or about a billion calls. Computer scientists refer to this as exponential complexity. Problems of this nature humble even the world's most powerful computers! Complexity issues in general, and exponential complexity in particular, are discussed in detail in the upper-level computer science course generally called "Algorithms".


>> FFFFFFF

>> failbit 
[pag589 deitel]
failbit is set for a stream when a format error occurs on the stream and no characters are input (e.g. when you attempt to read a number and the user enters a string). When such an error occurs, the characters are not lost. The fail member function reports whether a stream operation has failed. Usually recovering from such errors is possible.
>> badbit is set for a stream when an error occurs that results in the loss of data. The "bad" member function reports whether a stream operation failed. Generally such serious failures are not recoverable.
>> goodbit [pag589 deitel]
>> rdstate [pag589 deitel]
>> clear : clear member function is used to restore a stream's state to "good" so that I/O may proceed on the stream. The default argument for clear is goodbit, so the statement 
	cin.clear()
clear cin and sets goodbit for the stream. The statement
	cin.clear(ios::failbit)
sets the failbit.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> false true and difference between equality (==) and assignment (=) operators.
In C++ any expression that produces a value can be used in the decision portion of any control statement. It the value of the expression is zero, it's treated as the value false, and if the value is nonzero, it's treated as the value true.
Per evitare di confondere == equality con = assignment un possibilita' e' quella di non scrivere x == 7 bensi' 7 == x 
in tal modo you'll be protected by the compiler if you accidentally replace the == operator with =. In effetti 7 == x e' corretto (si sta giusto verificando se x sia uguale a 7) mentre 7 = x dona errore visto che una costante non puo' essere modificata. 
Nomenclatura:
lvalues = variable names are said to be lvalues (for left values) because they can be used on the left side of an assignment operator. Constant are said to be rvalues (for right values) because they can be used on only the right side of an ssignment operator. Lvalues can also be used as rvalues but not vice versa. 
[pag185deitel] 

>> FRAME GREETING / >> SIZE ADJUSTABLE FRAME GREETING [pag12 moo book]
---------------------------------------------------------------------- START 
// ask for a person's name, and generate a framed greeting
#include <iostream>
#include <string>

int main()
{
	std::cout << "Please enter your first name: ";
	std::string name;
	std::cin >> name;

	// build the message that we intend to write
	const std::string greeting = "Hello, " + name + "!";

	// build the second and fourth lines of the output
	const std::string spaces(greeting.size(), ' ');  // nota come il secondo parametro di spaces sia un ' ' character literal. 
    // A >> character literal [pag14 moo book] is always enclosed in single quotes; 
    // a string is always enclosed in double quotes.
    // The type of a character literal is the built-in char.
	// A character literal represents a single character. 	
	// The characters that have special meaning inside a string literal have the same special 
	// meaning in a character literal 
	// thus if we want ' or \ we must precede it by \.
	const std::string second = "* " + spaces + " *";    // >> CONCATENATE STRING / >> CONCATENATE STRING example 
                             // questo e' anche un esempio pratico di  [pag13 moo book]: when an operator has different meanings for operands of different types, we say that the operator is overloaded. 

	// build the first and fifth lines of the output
	const std::string first(second.size(), '*');   

	// write it all
	std::cout << std::endl;
	std::cout << first << std::endl;
	std::cout << second << std::endl;
	std::cout << "* " << greeting << " *" << std::endl;
	std::cout << second << std::endl;
	std::cout << first << std::endl;

	return 0;
}
----------------------------------------------------------- END
OUTPUT 
Please enter your first name: EriKlein_DialinEastWood_YuiLee

******************************************
*                                        *
* Hello, EriKlein_DialinEastWood_YuiLee! *
*                                        *
******************************************
verykool!!!
------------------------------------------
Trovi anche un altro esempio di Framing a picture a pag 92 moo book 
Gli dai in input un vettore di stringe per esempio un vector string is cui elementi sono 
	"this is an"
	"example"
	"to"
	"illustrate"
	"framing"
e ti dona in output 
    **************
	* this is an *
	* example    *
	* to         *
	* illustrate *
	* framing    *
    **************	
in modo che la stringa piu' lunga del vettore stringa, impartisce la larghezza del frame.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> C++ FEATURES from chapter 23 Jordan deitel [pag939]
the following interesting features are presented :
	>> const_cast operator [deitel p939]: this operator allows you to add or remove the const qualification of a variable. 
	[>> volatile pag939 deitel]
		C++ provides the const_cast operator for casting away const or volatile qualification. You declare a variable with the >> volatile qualifier when you expect the variable to modified by hardware or other programs not known to the compiler. Declaring a variable volatile indicates that the compiler should not optimize the use of that variable because doing so could affect the ability of those other programs to access and modify the volatile variable.
		DEMO: DANGER! in general it's dangerous to use the const_cast operator, because it allows a program to modify a variable that was declared const. There are cases in which it's desirable, or even necessary to cast away const-ness. Example you could pass non const data to a function that treats the data as if it were constant, then returns that data as a constant. In such cases, you might need to cast away the const-ness of the returned data. [>> cast away the const-ness = gettar via, buttar via la "const"anza della variabile, renderla quindi modificable da altri operatori/programmi]
		In conclusione: in general a const_cast should be used only when it is known in advance that the original data is not constant. Otherwise, unexpected results may occur.
	>> namespaces : can be used to ensure that every identifier in a program has a unique name and can help resolve naming conflicts caused by using libraries that have the same variable, function or class names.
	>> operator keywords: useful for programmers who have keyboards that do not support certain characters used in operator symbols, such as !, &, ^, ~ and | . 
	>> multiple inheritance : enables a derived class to inherit the members of several base classes. As part of this introduction, we discuss potential problems with multiple inheritance and how virtual inheritance can be used to solve them. 
---------------------------------------------------------------------------------------------------
	>> mutable class members [deitel pag941]: consider a lined list that maintains its contents in sorted order. Searching through the  linked list does not require modifications to hte data of the linked list, so the search function could be a const member function of the linked list class. However, it's conceivable that a linked-list object, in an effort to make future searches more efficient, might keep track of the location of the last successful match. If the next search operation attempts to locate an item that appears later in the list, the search could begin from the location of the last successufl match, rather than from the beginning of the list. To do this, the const member function that performs the search must be able to modify the data member that keeps track of the last successful search. 
If a data member such as the onle described above should always be modifiable, C++ provides the storage-class specifier mutable as an alternative to const_cast. A mutable data member is always modifiable, even in a const member function or const object. 
	mutable and const_cast are used in different context. FOr a const objectwith no mutable data members, operator const_cast must be used every time a member is to be modified. This greatly reduces the chance of a member being accidentally modified because the member is not permanently modifiable. Operations involving const_cast are typically hidden in a member function's implementation. The user of a class might not be aware that a member is being modified. 
NOTE: mutable members are useful in classes that have "secret" implementation details that do not contribute to a client's use of an object of the class.
EXAMPLE 
	#include <iostream>
	using namespace std;
	// class TestMutable definition
	class TestMutable
	{
	public:
	   TestMutable( int v = 0 )
	   {
	      value = v;
	   } // end TestMutable constructor
	
	   int getValue() const
	   {
	      return value++; // increments value
	   } // end function getValue
	private:
	   mutable int value; // mutable member
	}; // end class TestMutable
	int main()
	{
	   const TestMutable test( 99 );
	
	   cout << "Initial value: " << test.getValue();
	   cout << "\nModified value: " << test.getValue() << endl;
	} // end main
///////////////////////////////////////////////////////////////
Output 
Initial value: 99
Modified value: 100
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> FINAL member function 
pag532deitel
In C++11 a base class virtual function that's declared final in its prototype, as in 
	virtual someFunction (parameter) final;
cannot be overridden in any derived class.

>> file 
[pag600 deitel]
C++ views file simply as a sequence of bytes. Each file ends either with an end-of-file marker or at a specific byte number recorded in an operating system maintained, administrative data structure.
When a file is opened, an object is created and a stream is associated with the object.
>> file processing [pag 600 deitel]
to perform file processing in C++ headers <iostream> and <fstream> must be included. 
see fig 14.2 pag 601 per una rappresentazione della strem I/O template hierarchy
NOTE: C++ imposes no structure on a file. Thus, a concept  like that of a >> record does not exist in  C++ file. You must structure files to meet the application's requirements. The example 14.3 pag 602 deitel shows how you can impose a simple record structure on a file. 
At line 
   // ofstream constructor opens file                
   ofstream outClientFile( "clients.txt", ios::out );
we can see that two argument are passed to  the object's constructor: 
	- the filename 
	- the open mode
For an ofstream object, the file-open mode can be either ios::out (the default) to output data to a file or ios::app to append data to the end of a file (without modifying any data already in the file). Since ios::out is the default, the second constructor argument in line 12 is not required. Existing files opened with mode ios::out are >> truncated = all data in the file is discarded. If the specified file does not yet exist, then the ofstream object creates the file, using that filename. 
NOTE: use caution when opening an existing file for output (ios::out) especially when you want to preserve the file's contents, which will be discarded without warning.
The line 
   ofstream outClientFile( "clients.txt", ios::out );
[from fig 14.3 pag 602 deitel] creates an ofstream object named outClientFile associated with the file clients.txt that's opened for output. The arguments "clients.txt" and ios::out are passed to the ofstream constructor, which opens the file (this establishes a line of communication with the file). By default, ofstream objects are opened for output, so the previous line could also been written by simply using
   ofstream outClientFile( "clients.txt");
to open clients.txt for output. There are other file-open mode:
[>> FILE OPEN MODES pag 603 deitel]
	>> ios::app		append all output to the end of the file
	>> ios::ate		open a file for output and move to the end of the file (normally used to append data to a file). Data can be written anywhere in the file
	>> ios::in 		open a file for input
	>> ios::out 	open a file for output
	>> ios::trunc 	discard the file's contents (this also is the default action for ios::out)
	>> ios::binary  open a file for binary, i.e. nontext, input or output
NOTE puoi anche aprire un file usando the open Member function. See voce FILE OPEN
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> Flag meaning in C++
ASNWER1
[also: http://www.dreamincode.net/forums/topic/260211-what-does-flag-really-mean/]
a flag is a boolean variable, and a boolean variable is a variable that has only two possible values: true or false.
It is used when you want your program to make a decision based on the answer to a question that must be answered only 'yes' or 'no'.
For example, if you want your program to continue asking the user for input as long as the user has input to enter, you might write (in pseudocode)
1    my_flag_variable <= "yes"
2     
3    while my_flag_variable is "yes"
4        print "please enter input"
5        process user's input
6        print "do you want to continue?" (yes or no)
7        my_flag_variable <= user's response
8     
9    finished with input; do something else
In that example I used "yes" to represent true and "no" to represent false. In actual code you would use the constants true and false, or you might use 1 to represent true and 0 to represent false. Theoretically the specific values don't matter, as long as there are only 2 possibilities.
The point is that the program makes a decision (keep asking for input, or stop) based on the yes/no value of the flag variable.
ANSWER2
[source : http://forum.codecall.net/topic/41978-what-is-the-meaning-of-flag-in-c/]
A flag, or sentinel, is any variable that's sole purpose is to indicate when a key point in the processing has been reached. This include things like breaking out of a loop, being able to access a resource shared between threads, etc.
the code would resemble this:
	bool isprime=true;
	for (int i=2;i<n;i++){
	  if n%i == 0 then isprime=false;
	}
	if isprime cout<<n<<" is prime"
	else cout<<n<<" is not prime";
in this case, isprime is a flag
ANSWER3
Flags can also be fixed values for indicating state, mode, behavior, or similar. A fine example is the modes given to fstream:: open in C++. One can pass either ios_base::app, ios_base::ate, ios_base::binary, ios_base::in, ios_base:: out, ios_base::trunc or even several of them together. Each of them will change how the file is being opened.

>> float : floating point number; 4 bytes; 
range +/-3.4e  +/-38 (~7digits)
ex
3.14159
6.02e23  // questa notazione = 6.02*10^23
            [e' il mitico numero di Avogadro!]
1.6e-19  // = 1.6*10-19 [charge of an electron]
- NB: the default type for floating point literals is double. If you explicity want to express a float or long double numerical literal :
3.14159L // long double 
6.02e23f // float  
[le lettere L e f le puoi sia scrivere in minuscole che maiuscole, e' indifferente.]

>> FOR LOOP / FOR CYCLE
esempio un ciclo for che viene ripetuto 10 volte
	for ( unsigned int counter = 1; counter <= 10; ++counter )   // for header
	{
          ...istruzioni;
	}
[pag159deitel]
non devi necessariamente scrivere tutte e tre gli statements all'interno delle ()�@del for cycle
Per esempio se vuoi creare un infinite loop puoi omettere la condition
	for ( unsigned int counter = 1; ; ++counter ) // infinite loop
    {
		..istruzioni;
    }
ATTENTION: DO NOT write a ; after the ) of a for header because the ; would make the body of that "for" statement an empty statement.
[pag162deitel]
altro esempio questa volta from pag28 moo book, usando un integer counter:
	for (int i = 0; i != limit; ++i)    // >> for header 
	{
		... istruzioni        // >> for body
	}

NOTE: "i" will take the range [0,limit) cioe' un >> half open range dove [,) la parentesi quadra a sinistra sta ad indicare che i assume il valore 0, mentre ) sta ad indicare che "i" non riesce mai ad assumere il valore limit. 
NOTE: strong advice [from pag 30 31 moo book] meglio sempre usare contatori che partono da 0, e non da 1, evita confusione ed e' piu' chiaro. Vedi ragioni a pag30-31 moo book
NOTE: il precedente ciclo for e' la forma piu' compatta e del tutto equivalente del seguente ciclo while:
	int i = 0;
	while (i != limit) 
	{
		...istruzioni 
		++i;
	}
------------------------------------
Other observations from pag162deitel
- for statement  can contain arithmetic expressions
- the increment of a for statement can be negative => the loop actually counts downwards.
- if the loop-continuation condition is initially false, the body of the for statement is not performed. Instead execution proceeds with the statement following the for
- although the value of the control variable can be changed in the body of a for statement, avoid doing so, because this can lead to subtle logic errors.
- do not use equality operators != or == in a loop continuation condition if the loop's control variable increments or decrements by more than 1 (reason -> see star tag @pag164deitel)
- SOME FOR STATEMENT EXAMPLE pag163deitel
esempio 1
	for (unsigned int i = 1; i <= 100; ++i ) // vary the control variable from 1 to 100 in increments of 1
esempio 2 : vary the control variable from 100 down to 0 in decrements of 1. 
	for ( int i = 100; i >= 0; --i)
Notice we use type int poiche' la condition does not becomes false until control variable i contains -1, so the control variable must be able to store both positive and negative numbers.
esempio 3
	for (unsigned int i = 7; i <= 77; i += 7 ) // pag164deitel
vary control variable from 7 to 77 in steps of 7
esempio 4
	for (unsigned int i = 20; i >= 2; i -= 2 )
vary the control variable from 20 to 2 in steps of -2
------------------------------------------------------------------------------------
>> FOR LOOP MIKE pag 77
Like its cousin while loop, the for loop lets you repeat a section of code, but for loops are particularly suited for counting an moving through a sequence of things (like the items ina an Role Playing Game character's intentory). 
The generic form of for loop is:
	for (initialization; test; action)
		statement;
initialization is a statement that setps up some initial condition ofr the loop. (for example it might set a counter variable to 0). The expression test is tested each time before the loop body executes, just as in a while loop. If test is false, the program moves on to the statement after the loop. If test is true, the program executes statement. Next, action is executed (which often involves incrementing a counter variable). The cycle repeats until test is false, at which point the loop ends.
Example:
////////
// Counter
// Demonstrates for loops

#include <iostream>

using namespace std;

int main()
{
    cout << "Counting forward:\n";
    for (int i = 0; i < 10; ++i)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting backward:\n";
    for (int i = 9; i >= 0; --i)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting by fives:\n";
    for (int i = 0; i <= 50; i += 5)
	{
        cout << i << " ";
	}

    cout << "\n\nCounting with null statements:\n";
    int count = 0;
    for ( ; count < 10; )   // anche questa forma e' del tutto legale, visto che in questo caso initializzi il count prima del loop e incrementi la variabile all'interno del loop body
    {
        cout << count << " ";
        ++count;
    }   // il risultato di un loop del genere finisce quindi per essere 
        // del tutto equivalente al primo loop scritto sopra  
        // for (int i = 0; i < 10; ++i)	{   cout << i << " ";}

	// >> nested loop example
    cout << "\n\nCounting with nested for loops:\n";
    const int ROWS = 5;
    const int COLUMNS = 3;
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << i << "," << j << "  ";
		}

        cout << endl;
    }

	return 0;
}
--------------------------------------------------------- OUTPUT

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
Counting forward:
0 1 2 3 4 5 6 7 8 9

Counting backward:
9 8 7 6 5 4 3 2 1 0

Counting by fives:
0 5 10 15 20 25 30 35 40 45 50

Counting with null statements:
0 1 2 3 4 5 6 7 8 9

Counting with nested for loops:
0,0  0,1  0,2
1,0  1,1  1,2
2,0  2,1  2,2
3,0  3,1  3,2
4,0  4,1  4,2

C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>pause
\91\B1\8Ds\82\B7\82\E9\82ɂ͉\BD\82\A9\83L\81[\82\F0\89\9F\82\B5\82Ă\AD\82\BE\82\B3\82\A2 . . .
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> FOO meaning 
ASNWER1
Used very generally as a sample name for absolutely anything, esp. programs and files (esp. scratch files). 
    First on the standard list of metasyntactic variables used in syntax examples. See also bar, baz, qux, quux, garply, waldo, fred, plugh, xyzzy, thud.
    When 'foo' is used in connection with 'bar' it has generally traced to the WWII-era Army slang acronym FUBAR ('Fucked Up Beyond All Repair' or 'Fucked Up Beyond All Recognition'), later modified to foobar. Early versions of the Jargon File interpreted this change as a post-war bowdlerization, but it it now seems more likely that FUBAR was itself a derivative of 'foo' perhaps influenced by German furchtbar (terrible) - 'foobar' may actually have been the original form.
    For, it seems, the word 'foo' itself had an immediate prewar history in comic strips and cartoons. The earliest documented uses were in the Smokey Stover comic strip published from about 1930 to about 1952. Bill Holman, the author of the strip, filled it with odd jokes and personal contrivances, including other nonsense phrases such as "Notary Sojac" and "1506 nix nix". The word "foo" frequently appeared on license plates of cars, in nonsense sayings in the background of some frames (such as "He who foos last foos best" or "Many smoke but foo men chew"), and Holman had Smokey say "Where there's foo, there's fire".
    According to the Warner Brothers Cartoon Companion Holman claimed to have found the word "foo" on the bottom of a Chinese figurine. This is plausible; Chinese statuettes often have apotropaic inscriptions, and this one was almost certainly the Mandarin Chinese word fu (sometimes transliterated foo), which can mean "happiness" or "prosperity" when spoken with the rising tone (the lion-dog guardians flanking the steps of many Chinese restaurants are properly called "fu dogs"). English speakers' reception of Holman's 'foo' nonsense word was undoubtedly influenced by Yiddish 'feh' and English 'fooey' and 'fool'.
    Holman's strip featured a firetruck called the Foomobile that rode on two wheels. The comic strip was tremendously popular in the late 1930s, and legend has it that a manufacturer in Indiana even produced an operable version of Holman's Foomobile. According to the Encyclopedia of American Comics, 'Foo' fever swept the U.S., finding its way into popular songs and generating over 500 'Foo Clubs.' The fad left 'foo' references embedded in popular culture (including a couple of appearances in Warner Brothers cartoons of 1938-39; notably in Robert Clampett's "Daffy Doc" of 1938, in which a very early version of Daffy Duck holds up a sign saying "SILENCE IS FOO!") When the fad faded, the origin of "foo" was forgotten.
    One place "foo" is known to have remained live is in the U.S. military during the WWII years. In 1944-45, the term 'foo fighters' was in use by radar operators for the kind of mysterious or spurious trace that would later be called a UFO (the older term resurfaced in popular American usage in 1995 via the name of one of the better grunge-rock bands). Because informants connected the term directly to the Smokey Stover strip, the folk etymology that connects it to French "feu" (fire) can be gently dismissed.
    The U.S. and British militaries frequently swapped slang terms during the war (see kluge and kludge for another important example) Period sources reported that 'FOO' became a semi-legendary subject of WWII British-army graffiti more or less equivalent to the American Kilroy. Where British troops went, the graffito "FOO was here" or something similar showed up. Several slang dictionaries aver that FOO probably came from Forward Observation Officer, but this (like the contemporaneous "FUBAR") was probably a backronym . Forty years later, Paul Dickson's excellent book "Words" (Dell, 1982, ISBN 0-440-52260-7) traced "Foo" to an unspecified British naval magazine in 1946, quoting as follows: "Mr. Foo is a mysterious Second World War product, gifted with bitter omniscience and sarcasm."
    Earlier versions of this entry suggested the possibility that hacker usage actually sprang from FOO, Lampoons and Parody, the title of a comic book first issued in September 1958, a joint project of Charles and Robert Crumb. Though Robert Crumb (then in his mid-teens) later became one of the most important and influential artists in underground comics, this venture was hardly a success; indeed, the brothers later burned most of the existing copies in disgust. The title FOO was featured in large letters on the front cover. However, very few copies of this comic actually circulated, and students of Crumb's oeuvre have established that this title was a reference to the earlier Smokey Stover comics. The Crumbs may also have been influenced by a short-lived Canadian parody magazine named 'Foo' published in 1951-52.
[source http://www.catb.org/jargon/html/F/foo.html]
nice website about jargon actually http://www.catb.org/jargon/html/index.html
ANSWER2
It's a metasyntactic variable. A metasyntactic variable is a placeholder name used in computer science, a word without meaning intended to be substituted by some objects pertaining to the context where it is used. The word foo as used in IETF Requests for Comments is a good example.
By mathematical analogy, a metasyntactic variable is a word that is a variable for other words, just as in algebra letters are used as variables for numbers.[1] Any symbol or word which does not violate the syntactic rules of the language can be used as a metasyntactic variable. For specifications written in natural language, nonsense words are commonly used as metasyntactic variables.
Metasyntactic variables have a secondary, implied meaning to the reader (often students), which makes them different from normal metavariables. It is understood by those who have studied computer science that certain words are placeholders or examples only and should or must be replaced in a production-level computer program
[sources http://en.wikipedia.org/wiki/Metasyntactic_variable]
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////


>> FOR STATEMENT MULTIDIMENSIONAL ARRAY / >> for statement 2-D arrays / >> for 2-D arrays / >> for 2d arrays
[pag306deitel]
We use a nested loop in which the outer loop iterates through the rows and the inner loop iterates through the columns of a given row.
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
	{
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			cout << a[ row ][ column ] << ' ';
		cout << endl;
	} // end outer for 
[see example pratico pag305]

>> FOR STATEMENT UML activity diagram
see pag 163deitel

>> FORMAL PARAMETER 
cioe' i parametri che trovi all'interno delle parentesi ( ) quando si chiama una funzione
vedi per esempio line 56 pag 20deitel
nella linea 56 trovi la function call
	maximumGrade = maximum (grade 1, grade2, grade3 );
e a partire dalla linea 60 comincia la function definition 
	int GradeBook::maximum( int x, int y, int z ) const
nota come there must be one argument in the function call for each parameter (also called  formal parameter) in the function definition.
Inoltre la riga 60 della function definition matches the function prototype and indicates that the parameter names are x, y, z. 

>> FORMAT NUMERIC OUTPUT 
[see pag167deitel]
trovi esempi utili su come giustificare dei numeri a destra, sinistra, allinearli in modo da far coincidere il punto decimale ect.

>> format resetting / >> fmtflags />> flags
[pag586 deitel]
Puoi use flags al fine di return an output stream's format to its default state after having applied several manipulations.
Member function flags without an argument return the current format settings as an fmtflags data type (of class ios_base) [fmtflags = format flags], which represent the format state. Member function flags with an fmtflags argument sets the format state as specified by the argument and return the prior state settings.
Ex fig 13.21 pag 587 uses member function flags to save the stream's original format state (line 17)
///////
   // use cout flags function to save original format
   ios_base::fmtflags originalFormat = cout.flags();
   cout << showbase << oct << scientific; // change format
///////
then restore the original format setting (line25)
///////
   // display flags value, int and double values (original format)
   cout << "The restored value of the flags variable is: " 
      << cout.flags()
///////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> FRIEND FUNCTIONS / >> FRIEND CLASSES 
[pag410 deitel]
A friend function of a class is a non-member fuction that has the right to access the public and non-public class members. 
To declare a function as a "friend" of a class, precede the function prototype in the class definition with keyword "friend". To declare all member functions of ClassTwo as friends of ClassOne, place the declaration of the form
	friend class ClassTwo;
in the definition of class ClassOne.
NOTE: 
- Friendship is granted, not taken: for class B to be a friend of class A, class A must explicitly declare that class B is its friend. 
- Friendship is not symmetric: if class A is a friend of class B, you cannot infer that clas B is friend of class A. 
- Friendship is not transitive: if class A is a friend of class B and class B is friend of class C, you cannot infer that class A is a friend of class C. 
See example fig 9.22 pag 410 deitel
/////////////////////////////////////////////////////////////////


>> FRIEND FUNCTIONS and >> OPERATOR OVERLOADING [pag274 mike game programming]
Friend functions have complete access to any member of a class. Operator overloading allows you to define new meanings for built-in operators as they relate to objects of your own classes. You can use friend functions and operator overloading together.
----------------------------------------------- EXAMPLE  FRIEND FUNCTION AND OPERATOR OVERLOADING
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter09/friend_critter.cpp]
	//Friend Critter
	//Demonstrates friend functions and operator overloading
	
	#include <iostream>
	#include <string>
	
	using namespace std;
	
	class Critter
	{
	    //make following global functions friends of the Critter class
// >> FRIEND FUNCTION EXAMPLE 
	    friend void Peek(const Critter& aCritter);  // global function Peek() is a friend of Critter. This means Peek() can access any member of Critter even though it's not a member function of the class.
	    friend ostream& operator<<(ostream& os, const Critter& aCritter);
// >> note: you specify that a function is a friend of a class by listing the function prototype preceded by the keyword "friend" inside 
// the class definition.	    
	public:
	    Critter(const string& name = "");
	     
	private:
	    string m_Name;
	};
	
	Critter::Critter(const string& name):
	    m_Name(name)
	{}
	
	void Peek(const Critter& aCritter);
	ostream& operator<<(ostream& os, const Critter& aCritter);
	
	int main()
	{
	    Critter crit("Poochie");
	
	    cout << "Calling Peek() to access crit's private data member, m_Name: \n";
	    Peek(crit);
	    
	    cout << "\nSending crit object to cout with the << operator:\n";
	    cout << crit;
	    
	    return 0;
	}
	
	//global friend function that can access all of a Critter object's members
	void Peek(const Critter& aCritter)
	{
	    cout << aCritter.m_Name << endl;
	}
	
	//global friend function that can access all of Critter object's members
	//overloads the << operator so you can send a Critter object to cout
// qui overloaddiamo the "<<" operator, by defining a function named "operator<<"
	ostream& operator<<(ostream& os, const Critter& aCritter)
	{
	    os << "Critter Object - ";
	    os << "m_Name: " << aCritter.m_Name;
	    return os;
	}
// >> OVERLOAD OPERATOR pag276 mike game programming: Operator overloading lets you give meaning to built-in operators used with new types that you define. For example, you could overload the multiplication operator * so that when it is used with two 3D matrices (objects instantiated  from some class that you've defined), the result is the multiplication of the matrices. 	

----------------------------------------------- END EXAMPLE  FRIEND FUNCTION AND OPERATOR OVERLOADING
OUTPUT 
	Calling Peek() to access crit's private data member, m_Name: 
	Poochie
	Sending crit object to cout with the << operator:
	Critter Object - m_Name: Poochie 
/////////////////////////////////////////////////////////////////


>> FRIENDSHIP 
[pag378deitel]
We use friendship to specify that a nonmember function can also access a class's non-public members (a technique that is often used in operator overloading for performance reasons)

>> FRIEND OF A CLASS pag 217 moo book 

>> FUNCTION 
General observation 
- [from pag98deitel] A function that does not, and should not, modify the object on which it's called should be declared "const"
- [from pag203deitel] functions allow you to modularize a program by separating its tasks into self-contained units. 
To promote software reusability, every function should be limited to performing a single, well-defined task, and the name of the function should express that task effectively.
- a function is invoked by a function call, and when te called function completes its task, it either returs a result or simply returns control to the caller. The caller does not know how the function performs its designated tasks. This hiding of implementation details promotes good software engineering. 

>> FUNCTION CALL 
[pag 300 deitel star tag]
le function calls sono quelle righe in cui di solito vedi scritto 
	nomeFunzione();
le parentesi non sono vuote nel caso in cui la funzione richieda dei parametri di input

>> function call operator () / >> ()
[pag470deitel]
il function operator altri non e' che ()
Esempio 
instead of using C++'s double square bracket notation, such as in chess-Board[row][column], you might prefer to overload the function calloperator to enable the notation chessBoard(row, column), where chessBoard is an object of a modified two-dimensional Array class.
///////////////////////////////////////////////////////////////////////////

>> FUNCTION OVERLOADING / FUNCTION OVERLOADED / OVERLOADED FUNCTION
[pag243deitel]
C++ enables several functions of the same name to be defined, as long as they have different signatures. This is called function overloading. The C++ compiler selects the proper fuction to call by examining the number, types and order of the arguments in the call. 
Function overloading is used to create several functions of the same name that perform similar tasks, but on different data type.
Example: many functions in the math library are overloaded for different data types (the C++ standard requires float, double and long double overloaded versions of the math library functions)
- Overloading functions that perform closely related tasks can make programs more readable and understandable
- overloaded functions are distinguished by their signatures. A signature is a combination of a function's name and its parameter types (in order). The compiler encodes each function identifier with the types of its parameters (sometimes referred to as "name mangling" or "name decoration" ) to enable type-safe linkage. Type-safe linkage ensures that the proper function is called and that the types of the arguments conform to the types of the parameters.
- puoi vedere un nice esempio di mangled functions names produced in assembly language by GNU C++ @pag244-245deitel.
	example di mangled functions name (con cui si puo' assicurare il type-safe linkage)
	__Z8federicaciRfRd
e' il mangled name che si produce per la funzione
	int federica( char a, int b, float &c, double &d ) 
__Z8 perche' il nome della funzione federica ha 8 lettere.
	c = character
	i = int
	Rf = represent a float & (i.e. a reference to a float)
	Rd = represent a double & (i.e. a reference to a double)	
altre lettere che puoi trovare nella coda delle mangled functions names:
	Ri = represent a int & (i.e. a reference to an integer)
- Creating overloaded functions with identical parameter lists and different return types is a compilation error.
- function main is not mangled, because it cannot be overloaded.
- the compiler uses only the parameter lists to distinguish between overloaded functions. Such functions need not to have the same number of parameters. Use caution when overloading function with default parameters, because this may cause ambiguity. A function with default arguments omitted might be called identically ot another overloaded function; this is a compilation error.
For example, having a program that contains both a function that explicitly takes no argumets and a function of the same name that contains all default arguments results in a compilation error when an attempts is made to use that function name in a call passing no arguments. The compiler cannot determine which version of the function to choose.

>> FUNCTION PROTOTYPES / >> PROTOTYPE
[pag87deitel]
Function prototypes describe the class's public interface without revealing the class's member-funtion implementations. Cioe' in sostanza come nell'esempio di pag 88 fig3.11 non hanno un body, giusto una declaration that tells the compiler the function's name, its return type and the types of its parameters.
[pag210deitel]
Function prototypes (also called a function declaration) tells the compiler 
- the name of a function
- the type of data it returns
- the number of parameters it expects to receive
- the types of those parameters
- the order in which the parameters of those types are expected.
Use #include proprocessing directives to obtain function prototypes for the C++ Standard library functions. Ex by writing 
	#include <cmath>
[come nell'esempio di pag 165 fig 5.6]
potrai usare sqrt function. in effetti unless you define the function before it is used, devi fornire una function prototype. Since the prototype for sqrt e' contenuto nell'header <cmath> by writing at the beginning of the code #include <cmath>, potrai allora usare direttamente sqrt
Also use #include to obtain headers containing function prototypes written by you or other programmers.
[altre info from 210deitel]
- if a function is defined before it's invoked, then its definition also serves as the function's prototype, so a separate prototype is unnecessary. Ad ogni modo ti consiglio to always provide function prototypes, even though it's possible to omit them when funtions are defined before they're used. Providing the prototypes avoids tying the code to the order in which functions are defined (which can easily change as a program evolves)
- if a function is invoked before it's defined, and that function does not have a function prototytpe, a compilation error occurs.
> Observation from 211deitel
ARGUMENT COERCION : this is an important feature of function prototypes i.e, forcing  arguments to the appropriate types specified by the parameter decalrations.
ARGUMENT PROMOTION : sometimes, argument values that do not correspond precisely to the parameter types in the function prototype can be converted by the compiler to the proper type before the function is called. These conversions occur as specified by C++ promotion rules. The promotion rules indicate the implicit conversions that the compiler can perform between fundamental types. For example an "int" can be converted to a "double" o viceversa a double can converted to an "int" (the fractional part will be truncated). 
- Promotion rules apply also in mixed-type expressions (per esempio un espression in cui molplichi un int con un double). The type of each value in a mixed-type expression is promoted to the "highest" type in the expression (esempio l'int verra' promosso a double se moltiplicato con delle variabili double). See figure 6.6 pag212 deitel trovi la lista degli aritmetic data types from "highest type" to "lowest type".
  


>> FUNCTION PROTOTYPE, CALL, DEFINITI		ON 
bell'esempio chiarificatore a pag206deitel 
[altro bell'esempio pag300 deitel]
- Nota come la function prototype si trovi nell'*.h file (= interface of the class)
- mentre the calling of the function and its definition si trovino nel *.cpp file (= implementation of the class)
Altre osservazioni sul codice delle pagine 206 e 207
nella linea 56 trovi la function call
	maximumGrade = maximum (grade 1, grade2, grade3 );
e a partire dalla linea 60 comincia la function definition 
	int GradeBook::maximum( int x, int y, int z ) const
- nota come there must be one argument in the function call for each parameter (also called  formal parameter) in the function definition.
- nella function definition anche se i parametri hanno lo stesso "type", devi specificarlo davanti a ciascun parametro 
quindi 
	OK -> int GradeBook::maximum( int x, int y, int z ) const
	ERRATO -> int GradeBook::maximum( int x, y, z ) const
- Inoltre la riga 60 della function definition matches the function prototype and indicates that the parameter names are x, y, z. 
- [from pag209deitel] the compiler refers to the function prototype to check that calls to "maximum" contain the correct number and type of arguments and that the types of the arguments are in the correct order. [da qui si comprende la presenza dei due :: quando la funzione viene chiamata il compiler sa dalla linea 60 che il prototipo della funzione lo trova in GradeBook.h (che e' stato tra l'altro incluso nella riga 7 #include "GradeBook.h") e puo' cosi' controllare che il numero di tipo di argument sia coerente a quanto definito dal prototipo della funzione in GradeBook.h]
- in addition the compiler uses the prototype to ensure that the value returned by the function can be used correctly in the expression that called the function (cioe' controlla che nella linea 56 il valore che viene donato a maximumGrade sia cosistente con il type di maximumGrade: nel GradeBook.h, "maximumGrade" e' definito come intero, quindi il compiler controlla che gli sia donato un intero.
If the arguments passed to a function do not match the types specified in the function's prototype, the compiler attempts to convert the arguments to those types.  

>> FUNCTION PROTOTYPE SCOPE / FUNCTION PROTOTYPE SCOPE
the only identifiers with function-prototype scope are those used in the parameter list of a function prototype. As mentioned previously, function prototypes do not require names in the parameter list- only types are required. Names appearing in the parameter list of a function prototype are ignored by the compiler. Identifiers used in a function prototype can be reused elsewhere in the program without ambiguity.   


>> FUNCTION SIGNATURES 
[pag211deitel]
we call the function signature (or simply "signature") the portion of a function prototype that includes the name of the function and the types of its arguments. The function signature does not specify the function's return type. Functions in the same scope must have unique signatures. The scope of a function is the region of a program in which the function is known and accessible.

>> FUNCTION SCOPE 
[211deitel]
The scope of a function is the region of a program in which the function is known and accessible.
Functions in the same scope must have unique signatures. 
[pag228deitel]
Labels (identifiers followed by a colon such as 
	start:
or a "case" label in a "switch" statement) are the only identifiers with function scope. Labels can be used anywhere in the function in which they appear, but cannot be referenced outside the function body.

>> FUNCTION SIGNATURE 
[pag244deitel]
overloaded functions are distinguished by their signatures. A signature is a combination of a function's name and its parameter types (in order).
>> Function-Call Stack
[pag232deitel]
Function Call Stack (sometimes referred to as the program execution stack) supports the function call/return mechanism. 
As each function is called, it may in turn call other functions, which may in turn call other functions. Each function eventually must return control to the function that called it. So we must keep track of the return addresses that each function needs to return control to the function that called it. Each time a function calls another function, an entry is pushed onto the stack. This entry, called a 	
	"stack frame" or 
	"activation record".
If a function makes a call to another function, a stack frame for the new function call is simply pushed onto the call stack. Thus the return address required by the newly called function to return to its caller is noew located at the top of the stack.  
La chiamata di una funzione e il ritorno alla caller function, e' proprio simile ad una pila di piatti. Alla base della pila ci sta il main. Poi il main chiama un altra function, a stack frame or activation record is pushed onto the stack. The activation record contains the return address that the called function needs in order to return to the calling function. E la funzione chiamata puo' chiamare una altra funzione. Piu' una funzione chiama altre funzioni piu' la pila si allunga.
Se lo vedessi dinamicamente il programma somiglia ad una pila di piatti con main alla base che chiama funzioni che chiamano a loro volta altre funzioni, una pila che si alza, s'abbassa, si rialza e cosi' via.
                                                                          functionD
                                                               functionC  functionC    functionC  
                 function2                          functionB  functionB  functionB    functionB   functionB
      function1  function1  function1   functionA   functionA  functionA  functionA    functionA   functionA  functionA 
Main  Main       Main       Main        Main        Main       Main       Main         Main        Main       Main        Main end of Program.
STACK FRAMES and AUTOMATIC VARIABLES
Another important responsability of the stack frames is to reserve the memory for the called function's automatic variables. 
Most functions have automatic variables (like parameters and any local variables the function declares). Automatic variables need to exist while a function is executing. They need to remain active if the function makes calls to other functions. But when a called function return to its caller, the called function's automatic variables need to "go away". 
The called funcion's stack frame is a perfect place to reserve the memory for the called function's automatic variables. That stack frame exists as long as the called function is active. When that function returns (and no longer needs its local automatic variables) its stack frame is popped from the stack, and those local variables are no longer known to the program.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> function objects
[pag726 deitel]
Many standard library algorithms allow you to pass a function pointer into the algorithm to help the alfoirthm perform its task. For example, the binary_search algorithm that we diescced in section 16.3.6 is overloaded with a version that requires as its fourth parameter a function pointer that takes two arugments and returns a bool value. The algorithm uses this function to compres the search key to an element in the collection. The unction return true if the search key and elemnet bein compared are equal: otherwise, the function return false. This enables binary_search to search a collection of elements for which the lement type does not proved an overloaded equality < operator.
Any algorithm that can reveive a function pointer can also receive an object of a class that overloads the function call operator (parenthesis) with a function named operator(), provided that the overloaded operator meets the requirements of the algorithm [in the case of "binary search" it must receive two arguments and return a bool. An object of such a class is known as a function object and can be used syntactically and semantically like a function or function pointer.
- ADVANTAGES of FUNCTION OBJECTS OVER FUNCTION POINTERS 
Function objects provide several advantages over function pointers. The compiler can inline a funcion objects'overloaded operator() to improve performance. Also, since they're objects of classes, function objects can have data members that operator() can use to perform its task. 
- PREDEFINED FUNCTION OBJECTS FO THE STANDARD TEMPLATE LIBRARY
Many predefined function objects can be found in the header <functional>, for example :
	   FUNCTION OBJECT    |  TYPE 
	>> divides< T >       |  arithmetic  
	>> equal_to< T >      |  relational
	>> greater< T >       |  relational
	>> greater_equal< T > |  relational
	>> less< T >          |  relational
	>> less_equal< T >    |  relational
	>> logical_and< T >   |  logical 
	>> logical_not< T >   |  logical 
	>> logical_or< T >    |  logical
	>> minus< T >         |  arithmetic        
	>> modulus< T >       |  arithmetic
	>> negate< T >        |  arithmetic
	>> not_equal_to< T >  |  relational
	>> plus< T >          |  arithmetic  
	>> multiplies< T >    |  arithmetic
EXAMPLE: we use the >> accumulate algorith to calculate the sum of the squares of the elements in an array. 
[/home/dia/Deitel-Code_Examples/ch16/fig16_15/fig16_15.cpp]
This program uses the accumulate numeric algorithm (introduced in fig16.5 pag 703 line 55) to calculate the sum of the squares of the elements in an array. The function accumulate is demonstrated twice, once with a function pointer and once with a function object.
OUTPUT :
	array integers contains:
	1 2 3 4 5 6 7 8 9 10
	
	Sum of squares of elements in integers using binary
	function sumSquares: 385
	
	Sum of squares of elements in integers using binary
	function object of type SumSquaresClass< int >: 385
COMMENTS:
lines 13-16:
	// binary function adds square of its second argument and the
	// running total in its first argument, then returns the sum 
	int sumSquares( int total, int value ) 
	{ 
	   return total + value * value; 
	} // end function sumSquares
define a function sumSquares that squares its second argument value, adds that square and its first argument total and returns the sum.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> modulus / >> % 
[pag 73 jesse]
the modulus operator (%) tells you the remainder after an integer division. Example: the remainder of 21 divided by 4 is 1. 
Finding the modulus can be very useful. For example, you might want to print a statement on every 10th action. Any number whose values is 0 when you modulus 10 with that number is an exact multiple of 10. Thus 1 % 10 is 1, 2 % 10 is 2, and so forth, until 10 % 10 whose result is 0. 11 % 10 is back to 1, and this pattern continues until the next multiple of 10, which is 20, 20 % 10 = 0 again. Quindi usando "%10" e checkando che il modulo sia nullo puoi individuare tutte le actions every 10. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> FUNCTION TEMPLATES 
[pag246deitel]
If the program logic and operations are identical of each data type,overloading can be performed more compactly and convieniently by using function templates. You writes a single function template definition. Given the argument types provided in calls to this function, C++ automatically generates separate "function template specializations" to handle each type of call appropriately. 
  1 // Fig. 6.25: maximum.h
  2 // Function template maximum header.
  3 template < typename T >  // or template< class T >
  4 T maximum( T value1, T value2, T value3 )
  5 {
  6    T maximumValue = value1; // assume value1 is maximum
  7
  8    // determine whether value2 is greater than maximumValue
  9    if ( value2 > maximumValue )
 10       maximumValue = value2;
 11
 12    // determine whether value3 is greater than maximumValue
 13    if ( value3 > maximumValue )
 14       maximumValue = value3;
 15
 16    return maximumValue;
 17 } // end function template maximum
//
- line 3 All function template begin with a template keyword followed by a template parameter list to the function template enclosed in angle brackets <>
- line 6 T is a formal type parameter (ci puoi mettere un nome di tuo piacere) usato come placeholder for fundamental types or user-defined types. 
A function template is defined like any other function, but uses the formal type parameters as placeholders for actual data types.

>> FUNDAMENTAL TYPES (like int, double, char)
Fundamental-type names consist of one or more keywords and therefore must appear in all lowercase letters. here's the C++ fundamental types list:
Integral types:
	bool
	char
	signed char
	unsigned char
	short int 
	unsigned short int
	int
	unsigned int
	long int
	unsigned long int
	long long int
	unsigned long long int
	char16_t
	char32_t
	wchar_t
Floating-point types
	float
	double
	long double
[nota come i fundamental types possano essere composti da una o piu' keyboards sempre scritte in lettere minuscole]	

NB: non confondere "identifier" with fundamental type ex:
	int number1 = 0;
number1 is the identifier. con un identifier puoi usare sia lettere maiuscole che minuscole (C++ is case sentitive), giusto non devi farlo cominciare con un digit. Mentre le keywords che compongono i fundamental type names devono sempre essere scritte in minuscolo. 	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ABSTRACTION 
[pagxii moo book]
Abstraction is selective ignorance = concentrating on the ideas that are relevant to the task at hand, and ignoring everything else. This is the most important idea in modern programming. The key to writing a successful program is knowing which parts of the problem to take into account, and which parts to ignore.
If abstractions are well designed and well chosen, we believe that we can use them even if we don't understand all the details of how they work. We do not need to be aerospace engineers to fly and airplane, nor do we need to understand everything about how C++ works before we can use it.

>> FUNCTIONS [mike programming game pag144]
Before you can call a function you have written, you have to declare it. 
Two ways to declare a function:
A) 
One way to declare a function is to write a function prototype (= code that describes the function)
You write a prototype by listing
- the return value of the function (or void if the function returns no value)
- followed by the name of the function 
- followed by a list of parameters between a set of parenthesis
Example
	void         instruction();  // se tra le parentesi non vi sta nulla significa che la function non ha bisogno di parametri
    |            |
  return value   function name   
Full Example of function prototype from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/instructions.cpp
			// Instructions
			// Demonstrates writing new functions
			
			#include <iostream>
			
			using namespace std;
			
			// function prototype (declaration)  : you need to write the function prototype BEFORE the main() function
			void instructions();  // questa e' una semplice funzione che non prende values in input, e does not return a value
			
			int main()
			{
			    instructions();
			
			    return 0;
			}
			
			// function definition
			void instructions()
			{
			    cout << "Welcome to the most fun you've ever had with text!\n\n";
			    cout << "Here's how to play the game...\n";
			}
-------------------------------------------------
B) second way to declare a function: let the function definition act as its own declaration. TO do that, you simply have to put your function definition before the call to the function. 
HINT: although you don't have to use prototypes, they offer a lot of benefits, not the least of which is making your code clearer.
--------------------------------------------------
>> FUNCTION DEFINITION / >> DEFINE FUNCTION [pag146 mike programming game] / >> FUNCTION HEADER / >> FUNCTION BODY
			// function definition
			void instructions()                                                     // this is the function HEADER
			{                                                                       // this is the function body
			    cout << "Welcome to the most fun you've ever had with text!\n\n";   // this is the function body
			    cout << "Here's how to play the game...\n";                         // this is the function body
			}                                                                       // this is the function body
NOTE: the function header is exactly like the function prototype, except you don't end the line with a semicolon. The function header is made by the return value of the function, the name of the function and the list of parameters between ()
NOTE: the function body is the block within {} curly braces that contains the instructions to be executed when the function is called. 
>> FUNCTION CALL / >> CALL FUNCTION [mike programming game pag146]
You call your own functions the same way you call any other function (by writing the function'sname followed by a pair of parentheses that encloses a valid list of arguments) ex from the above program:
			int main()
			{
			    instructions();   // here we call the function "instruction"
			    return 0;
			}
------------------------------------
When a function finishes, control returns to the calling code. In this case, it means control returns to main(). 
NOTE: [from pag150 mike programming game] A functions ends whenever it hits a return statement. It's perfectly acceptable for a function to have more than one return. This just means that the function has several points at which it can end. 
NOTE: you don't have to return a value with a return statement. You can use "return" by itself in a function that returns no value (one that indicates void as its return type) to end the function. 
>> ABSTRACTION [mike (pence 2016) programming game pag147]
By writing and calling functions you practice what's known as abstraction. Abstraction lets you think about the big picture without worrying about the details. In this program, we can simply use the function "instructions()" without worrying about the details of displaying the text. All we have to do is call the function with one line of code, and it gets the job done. 			
>> RETURN VALUE from function to the calling code. 
You can return a value from a function to send information back to the calling code. As shown in the example below, e' gia' a livello della function propotype prima del main() [see char askYesNo1(); below] che puoi specificare che tipo di value vuoi donare indietro.
[NOTE from pag826 jesse: any function that does not explicitly declare a return type returns "int". You should always declare the return type as a matter of good programming practice]
>> PARAMETER FUNCTION / >> FUNCTION PARAMETER 
As shown in the example below "char askYesNo2(string question);" i parametri che vuoi specificare come input della funzione li devi specificare tra le parentesi (). You don't have to use paraemter names in a prototype. Tipo usare "char askYesNo2(string);" va anche bene. Even though you don't have to use parameter names in prototypes, it's a good idea to do so. It makes your code clearer, and it's worth the minor effort. 
NOTE: con i prototypes specificare il nome del parametro e' facoltativo. MENTRE in the function definition 
	 char askYesNo2(string question)
you must specify parameter names in a function definition. You use a paramenter name inside a function to access the parameter value.
NOTE: the parameter types specified in a function prototype must match the parameter types listed in the function definition. If they don't you'll generate a nasty compile error.
------------------------------------------------------------------------------------------------------------
example :
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		char askYesNo1(); // this function prototype indicates that the function askYesNo1 will return a char value. 
		char askYesNo2(string question); // this function accepts a value into a parameter. specifically it accepts a value of type string.
		
		int main()
		{
		    char answer1 = askYesNo1();  // here we call the function askYesNo1; la variabile answer1 si vedra' assegnato il valore (either "y" or "n" che la funzione dona in ritorno)
		    cout << "Thanks for answering: " << answer1 << "\n\n";
		
		    char answer2 = askYesNo2("Do you wish to save your game?"); // this statement calls askYesNo2() and passes the string literal argument "Do you wish to save your game?"
		    cout << "Thanks for answering: " << answer2 << "\n";
		
		    return 0;
		}
		
		char askYesNo1()
		{
		    char response1;
		    do
		    {
		        cout << "Please enter 'y' or 'n': ";
		        cin >> response1;
		    } while (response1 != 'y' && response1 != 'n');
		
		    return response1;  // Notice that response1 is a char value. It has to be because that's what I promised to return in both the function prototype and function definition. 
		}
		
		char askYesNo2(string question)
		{
		    char response2;
		    do
		    {
		        cout << question << " (y/n): ";  // visto quanto passato da main in questo caso "question" == "Do you wish to save your game?"
		        cin >> response2;
		    } while (response2 != 'y' && response2 != 'n');
		
		    return response2;
		}
-----------------------------------
>> ENCAPSULATION [mike programming game pag152]
Why you need to return the values when using your own functions? Because no variable you create in a function, including its parameters, can be directly accessed outside its function. This is a good thing, and it is called encapsulation. Encapsulation keep independent code truly separate by hiding or encapsulating the details. That's why you use parameters and return values to communicate only the information that needs to be exchanged. Plus you don't have to keep track of variables you create within a function in the rest of your program. As your programs get large, this is a great benefit. 
Encapsulation might sound a lot like abstraction. Abstraction saves you from worrying about the details, while encapsulation hides the details from you.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> FUNCTION observation from pag 112 jesse book / >> FUNCTION SIZE
Although no limit exists to the size of a function in C++, well-designed functions tend to be small. Many programmers advise keeping your functions short enough to fit on a single screen so that you can see the entire function at one time. This a rule of thumb often broken by very good programmers, but it is true that a smaller function is easier to understand and maintain. Each function should carry out a single, easily understood task. If your functions start to getting large, look for places where you can divide them into component tasks.

>> FUNCTION observation from pag 72 moo book 
A function must be declared in every source file that uses it, and defined only once. The delcations and defintions have similar forms. 
	ret-type function-name (parm-decls) ;   // function declaration 
		[inline] ret-type function-name (parm-decls) {  // function definition
	}
Here ret-type is the type that the fucntion returns, parm-decls is a comma separated list of the type for the parameters of the function. Functions must be declared before they are called. Each argument's type must be compatible with the corresponding parameter. A different syntax is necessary to declare or define functions with sufficiently complicated return types. 
Function names may be overloaded: the same function name may define multiple functions so lons as the functions differ in the number or types of the parameters. The implementation can distinguish between a reference and a const reference to the same type.
We can optionally qualify a function definition with "inline", which asks the compiler to expand calls to the function inlne when appropriate (that is to avoid function call overhead by replacing each call to the function by a copy of the function body, modified as necessary). TO do so, the compiler needs to be able to see the function definition, so inlines are usually defined in header files, rather than in source files. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> GGGGGGG

>> GAMING / GAME [mike game programming]
C++ (@2015) is the game industry standard

>> GAME LOOP [mike pag 67]
The game loop is a generalized representation of the flow of events in a game. Although the implementation might be quite different from game to game, the fundamental structure is the same for almost all games across genres.

		    SET UP
		  	  |
        	  |
			  V
 /--->  GET PLAYER INPUT
 |		  	  |
 |       	  |
 |			  V             
 |   UPDATE GAME INTERNALS
 |		  	  |
 |       	  |
 |			  V  
 |      UPDATE DISPLAY
 |		  	  |
 |       	  |
 |			  V  
 \-- NO <- GAME OVER ?
              |
              |
              V
          SHUT DOWN

Here's an explanation of the part of the game loop:
- Setup: this often involves accepting initial settings or loading game assets, such as sound, music and graphics. The player might also be presented with the game backstory and his objectives.
- Getting player input: whether it comes from the keyboard, mouse, or joystick, trackball, or some other device, input from the player is captured
- Updating game internals: the game logic and rules are applied to the game world, taking into account player input. This might take the shape of a physcis system determining the interaction of objects or it might involve calculations of enemy (for some, not form me viva Palpetine!) Dark Sidius, for example.
- Updating the display : in the majority of games, this process is the most taxing on the computer hardware because it often involves drawing graphics. However,this process can be as simple as displaying a line of text.
- Checking whether the game is over. If the game isn't over (the player's character is still alive and the aplyer hasn't quit, for example) control branches back to the getting player input stage. If the game is over, control falls through to the shutting down stage.
- Shutting down: At this point, the game is over. The player is often given some final information, such as his score. The program frees any resources, if necessary, and exits.
-----------------------------------
EXAMPLE Guess my number
///////////////////////
// Guess My Number
// The classic number guessing game

#include <iostream>
#include <cstdlib> // we inclue cstdlib because we plan to generate a random number.
#include <ctime>   // we include ctime because we want to seed the random number generator with the current time

using namespace std;

int main()
{
    srand(static_cast<unsigned int>(time(0)));  //seed random number generator

	int secretNumber = rand() % 100 + 1;  // random number between 1 and 100
	int tries = 0;
	int guess;
    
	cout << "\tWelcome to Guess My Number\n\n";

	do
	{
		cout << "Enter a guess: ";
		cin >> guess;
		++tries;   

		if (guess > secretNumber)
		{
			cout << "Too high!\n\n";
		}
		else if (guess < secretNumber)
		{
			cout << "Too low!\n\n";
		}
		else
		{
			cout << "\nThat's it! You got it in " << tries << " guesses!\n";
		}

	} while (guess != secretNumber);

    return 0; // once the player has guessed the secret number, the loop and game are over. All that's left to do is end the program.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> GETLINE
[pag72deitel]
getline reads characters (including the space characters that separate the words in the input) from the standard input stream object cin (i.e., the keyboard) until the newline character is encountered. The <string> header must be included in the program to use function getline
	#include <string>
	using namespace std;
    ...
	getline( cin, nameNavigatorFlightSchedule );
[trovi esempio a pag71]
rispetto al semplice 
	cin >> nameNavigatorFlightSchedule
che reads characters until the first white-space character is reached.	

>> giustificazione a sinistra / >> giustificazione a destra. / >> justification left / >> justification right
[pag 581 deitel]
Trovi un esempio a pagina 581


>> GLOBAL FUNCTIONS 
global functions are functions, such as main, that are not member of a class. Like a class's member functions, the function prototypes for global fucntions are placed in headers, so that the global functions can be reused in any program that includes the header and that can link to the function's object code. 
[see also pag100 jesse]

>> GLOBAL VARIABLES [pag157 mike game programming]
to declare a global variable, you simply declare the variable outside of any function in your program file.
example 
	using namespace std;
	
	int glob = 10;  // global variable
	
	int main()
	{
	...
	}
Full example in 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/global_reach.cpp
NOTE: 
>> HIDE GLOBAL VARIABLE
then if you want to hide a global variable within a function, you simply decalre a new variable with the same name withing that function
	void hide_global()
	{
	    int glob = 0;  // hide global variable glob
	    cout << "In hide_global() glob is: " << glob << "\n\n";
	}
quando poi sei uscito dallo scope della function, glob continuera' ad assumere il valore originale della global variable.
NOTE:
>> ALTER GLOBAL VARIABLE / >> MODIFY GLOBAL VARIABLE
Just as you can access a global variable from anywhere in your program, you can alter one from anywhere in your program, too.
example from\81@/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/global_reach.cpp
void change_global()
{
    glob = -10;  // change global variable glob
    cout << "In change_global() glob is: " << glob << "\n\n";
}
WARNING: in general global variables make programs confusing because it can be difficult to keep track of their changing values. You should limit your use of global variables as much as possible.
-------------------------------------------------------
>> GLOBAL VARIABLE [further explanations from pag 110 jesse]
Local variables with the same name as global variables do not change the global variables. A local variable with the same name as a global variable hides the global variable however. If a function has a variable with the same name as a global variable, the name refers to the local variable (not the global) when used within the function.  
CAUTION : in C++ global variables are legal, but they are almost never used. Globals are denagerous because they are shared adata, and one function can change a global variable in a way that is invisible to another function. This can and does create bugs that are very difficult to find.
Example
//////////////////////////////////////////////////////
	#include <iostream>
	void myFunction();           // prototype
	  
	int x = 5, y = 7;            // global variables
	int main()
	{
	   using namespace std;
	  
	   cout << "x from main: " << x << endl;
	   cout << "y from main: " << y << endl << endl;
	   myFunction();
	   cout << "Back from myFunction!" << endl << endl;
	   cout << "x from main: " << x << endl;
	   cout << "y from main: " << y << endl;
	   return 0;
	}
	  
	void myFunction()
	{
	   using std::cout;
	 
	   int y = 10;
	  
	   cout << "x from myFunction: " << x << endl;
	   cout << "y from myFunction: " << y << endl << endl;
	}

//////////////////////////////////////////////////////
-------------------------------------------------------
>> GLOBAL CONSTANT [pag161 mike programming game]
Unlike global variables, which can make your programs confusing, global constants (= constants that can be accessed from anywhere in your program) can help make programs clearer. 
You declare a global constant much like you're declaring a global variable, by declaring it outside of ANY function. And because you're declaring a constant, you need to use the "const" keyword.
Example 
	const int MAX_SPACESHIPNUMBER = 10;
NOTE TRAP: just like global variables, you can hide a global constant by declaring a local constant with the same name. However, you should avoid this because it can lead to confusion. 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> GLOBAL NAMESPACE SCOPE 
[228deitel]
an identifier declared outside any funtion or class has global namespace scope. Such an identifier is "known" in all functions from the point at which it's declared until the end of the file. Global variables, function definitions and function prototypes placed outside a function all have global namespace scope. 
Example : see pag 395 deitel 
in fig9.9 puoi vedere come the object "first" di line 10 e' un global object. Visto che the object is defined outside the main() function e si trova al di fuore di qualsiasi altra funzione, il suo scope e' global

>> HHHHHHH

>> H EXTENSION 
by convention include files are given a .h extension
- in linux li puoi visionare comodamente con gedit oppure clic destro sul file e apri con "netbeans"
- a header cannot be used as complete program because it does not contain a "main" function. To test it you must write a separate source code file containing a main function that instantiates and uses objects of the class. 

>> header of a function = return_type FUNCTION_NAME (parameters to that function)
[pag36 jesse]
example 
a function named Sum that receives tow integer values (first and second) and also returns an integer value:
	int Sum (int first, int second)
NOTE: a >> parameter is a declaration of what type of value will be passed in; the actual value passed in when the function is called is referred to as an >> argument. The distinction between these two terms is not critical to your programming C++, so you sholdn't worry if the works get interchanged. 
////////////////////////////////////////////////////////////////////////////

>> HEADERS 
Some advices
- [pag85deitel] use std:: with standard library components in headers. Throughout the header, we use std:: when referring to "string", "cout" and "endl" , headers should never contain "using" directives and "using" declarations 
Detto in parole spicciole: usa std::string, std::cout come nell'esempio fig3.9 pag 84, e non usare la tecnica delle "using" declarations [spiegate a pag55deitel]
- How headers are located [pag86deitel] Notice that the name of the myClassName.h header (in the ccp file containing the main function) is enclosed in quotes "" rather than angle brackes (<>)
	#include "NuclearReactor.h"
Normally, a program's source-code files an user-defined headers are placed in the same directory, When the preprocessor encounters a header name in quotes , it attempts to locate the header in the same directory as the file in which the #include directive appears. If the preprocessor cannot find the header in that directory, it searches for it in the same location(s) as the C++ Standard Library headers. When the proprocessor encounters a header name in angle brackets (e.g. <iostream>), it assumes that the header is part of the C++ Standard Library and does not look in the directory of the program that's being preprocessed.   
In sostanza: to ensure that the preoprocessor can locate headers correctly #include preprocessing directories should place user-defined headers names in quotes (e.g. "VoidLayerMachine.h") and place C++ Standard Library headers names in angle brackets (e.g. <iostream>) 
- Why to hide the class implementation to the client code. When your custom class is defined in a header, the class is reusable. Unfortunately , placing a class definition in a header still reveals the entire implementation of the class to the class's clients. 
Conventional software engineering wisdom says that to use an object of a class, the client code (e.g., function main) needs 
1- to know only what member functions to call, 
2- what arguments to provide to each member function 
3- and what return type to expect from each member function 
The client code does not need to know how those functions are implemented. 
Hiding the class's implementation details makes it easier to change the class's implementation while minimizing, and hopefully eliminating, changes to the client code.
in conclusione: spezza il tuo programma in the cpp file with the main function and the classes in files differenti, in modo che:
A) the class is reusable
B) the clients of the class know what member functions the class provides, how to call them and what return types to expect, and 
C) the clients do not know how the class's member functions are implemented. 
>> NOTA bene da pag 209 mi sembra che quando si parla di FUNCTION HEADER ci si riferisce alla prima linea della definition della funzione all'interno del cpp file e non al *.h header file esempio 
	int GradeBook::maximum( int x, int y, int z ) const
[da pag207 line 60] itiaf verificami in futuro se abbiamo ragione

>> HELPER FUNCTION 
[pag378deitel] 
helper function = a private member function that supports the operation of the class's public member functions, but is not intended for use by clients of the class.

>> HEAPSORT
[pag721 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp
this example demonstrates the standard library algorithms for performing the heapsort sorting algorithm, in which an array of elements is arranged into a data structured called a >> heap. Heapsort is discussed in detail in computer sciences courses called "Data Structures" and "Algorithms". For more information see 
	en.wikipedia/wiki/Heapsort
-------------------------------------------------------------------------------
>> make_heap algorithm 
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
[pag 723 deitel]
 20    make_heap( a.begin(), a.end() ); // create heap from array "a"
line 20 uses the make_heap algorithm to take a sequence of values in the range from a.begin() up to, but not including, a.end() and create a heap that can be used to produce a sorted sequence (per esempio usando sort_heap vedi voce poco piu' sotto). The two iterator arguments must be random-access iterators, so this algorithm will work only with array, vectors and deques. A second version of this algorithm takes as a thid argument a binary predicate function for comparing values.
[nota bene: heap = mucchio, cumulo, ammasso, catasta/ in ambito computeristico indica area used for dynamic memory allocation [fonte dizionario zanichelli]]
>> sort_heap 
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
 24    sort_heap( a.begin(), a.end() ); // sort elements with sort_heap
line 24 uses the sort_heap algorithm to sort a sequence of values in the rage from a.begin() up to, but not including a.end() tha are already arranged in a heap. The two iterator arguments must be random-access iterators. A second version of this algorithm takes as a third argument a binary predicate function for comparing values.
>> push_heap
[pag724 deitel]
[from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
 37    for ( size_t i = 0; i < init.size(); ++i )
 38    {
 39       v.push_back( init[ i ] );
 40       push_heap( v.begin(), v.end() );
 41       cout << "\nv after push_heap(init[" << i << "]): ";
 42       copy( v.cbegin(), v.cend(), output );
 43    } // end for
line 40 uses the push_heap algorithm to add a new value intp a heap. We take one element of array init at a time, append it to the end vector v and perform the push_heap operation. If the appended element is the only element in the vecotr, the vector is already a heap. Otherwise, push_heap rearranges the vector elements into a heap. Each time push_heap is called, it assumes that the last element currently in the vector (i.e. the one that's appended before the push_heap call) is the element being added to the heap and that all other elements in the vector are already arranged as a heap.
[non molto ben chiaro questo heap itiaf]
OUTPUT 
[init e' il container da cui prendiamo gli elementi che andiamo a stivare in "v" la push_heap e' un po' come la gru di un porto, prende gli elementi di init lasciati dai camion porta-container e li pusha nella stiva della nave porta-container.]
	Array init contains: 3 100 52 77 22 31 1 98 13 40	
	v after push_heap(init[0]): 3
	v after push_heap(init[1]): 100 3
	v after push_heap(init[2]): 100 3 52
	v after push_heap(init[3]): 100 77 52 3
	v after push_heap(init[4]): 100 77 52 3 22
	v after push_heap(init[5]): 100 77 52 3 22 31
	v after push_heap(init[6]): 100 77 52 3 22 31 1
	v after push_heap(init[7]): 100 98 52 77 22 31 1 3
	v after push_heap(init[8]): 100 98 52 77 22 31 1 3 13
	v after push_heap(init[9]): 100 98 52 77 40 31 1 3 13 22
-------------------------------------------------------------------------------
>> pop_heap algorithm
 47    // remove elements from heap in sorted order
 48    for ( size_t j = 0; j < v.size(); ++j )
 49    {
 50       cout << "\nv after " << v[ 0 ] << " popped from heap\n";
 51       pop_heap( v.begin(), v.end() - j );
 52       copy( v.cbegin(), v.cend(), output );
 53    } // end for
[pag724 deitel]
Line 51 uses pop_heap to remove the top heap element.  This algorithm assumes that the elements in the range specified by its two random-access iterator arguments are already a heap. Repeatedly removing the top heap element results in a sorted sequence of values.
>> is_heap / >> is_heap_until 
[pag724 deitel]
The is_heap algorithm returns true if the elements in the specified range represent a heap.
-------------------------------------------------------------------------------
FULL OUTPUT EXAMPLE [from /home/dia/Deitel-Code_Examples/ch16/fig16_12/fig16_12.cpp]
	Array a before make_heap:
	3 100 52 77 22 31 1 98 13 40
	Array a after make_heap:
	100 98 52 77 40 31 1 3 13 22
	Array a after sort_heap:
	1 3 13 22 31 40 52 77 98 100
	
	Array init contains: 3 100 52 77 22 31 1 98 13 40
	
	v after push_heap(init[0]): 3
	v after push_heap(init[1]): 100 3
	v after push_heap(init[2]): 100 3 52
	v after push_heap(init[3]): 100 77 52 3
	v after push_heap(init[4]): 100 77 52 3 22
	v after push_heap(init[5]): 100 77 52 3 22 31
	v after push_heap(init[6]): 100 77 52 3 22 31 1
	v after push_heap(init[7]): 100 98 52 77 22 31 1 3
	v after push_heap(init[8]): 100 98 52 77 22 31 1 3 13
	v after push_heap(init[9]): 100 98 52 77 40 31 1 3 13 22
	
	v after 100 popped from heap
	98 77 52 22 40 31 1 3 13 100
	v after 98 popped from heap
	77 40 52 22 13 31 1 3 98 100
	v after 77 popped from heap
	52 40 31 22 13 3 1 77 98 100
	v after 52 popped from heap
	40 22 31 1 13 3 52 77 98 100
	v after 40 popped from heap
	31 22 3 1 13 40 52 77 98 100
	v after 31 popped from heap
	22 13 3 1 31 40 52 77 98 100
	v after 22 popped from heap
	13 1 3 22 31 40 52 77 98 100
	v after 13 popped from heap
	3 1 13 22 31 40 52 77 98 100
	v after 3 popped from heap
	1 3 13 22 31 40 52 77 98 100
	v after 1 popped from heap
	1 3 13 22 31 40 52 77 98 100
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> IIIIIII

>> ignore 
[pag442deitel]
the function ignore discards the specified number of characters in the input stream (one character by default) 

>> ISO [mike pag5] = international organization for standardization 
	- describes how the language should work. 
	- defines a group of files, called the standard library, that contain building block for common programming tasks, such as I/O (= getting input and displaying output).

>> INCREMENT OPERATOR / DECREMENT OPERATOR / INCREMENT AND DECREMENT OPERATORS
[PAG141deitel]
increment operator ++
decrement operator --
we have 4 cases:
1) preincrement    ++a   increment "a" by 1 then use the new value of "a" in the expression in which "a" resides.
2) postincrement   a++   use the current value of "a" in the expression in which "a" resides, then increment "a" by 1.
3) predecrement    --b   decrement "b" by 1 then use the new value of "b" in the expression in which "b" resides.
4) postdecrement   b--   use the current value of "b" in the expression in which "b" resides, then decrement "b" by 1.
nomenclature 
++a chiamato anche prefix increment operator
--b prefix decrement operator
a++ postfix increment operator
b-- postfix decrement operator
Observation : le e linee seguenti sono equivalenti:
	counter = counter +1;
	counter +=1;
	++counter
A) NB: when you increment (++) or decrement (--) an integer variable in a statement by itself, the preincrement and postincrement forms have the same logical effect (cioe' quando la variable si trova da sola ++i oppure i++ hanno lo stesso effetto). E' solo quando a variable appears in the context of a larger expression that preincrementing or postincrementing the variable has different effects.
[cioe' con i++ verra' usata nell'espressione che la contiene il valore della variabile prima dell'incremento.
i++ prima usi i (da sola o all'interno di un espressione) e poi la incrementi 
++i priam incrementi i e poi la usi all'interno dell'espressione che la contiene]
B) ++ e -- have right to left associativity  [see pag143deitel]
ATTENZIONE: ++ e -- sono unary operators. Attempting to use the increment or decrement operator on an expression other than a modifiable variable name ex ++(x+1) is a syntax error.
 
>> type which is the best choice between int unsigned int double ect
- If you need an integer type, you're probably best off using int. That's because int is generally implemented so that it occupies an amount of memory that is most efficienly handled by the computer. 
- If you need to represent integer value greater than the maximum int or values that will never be negative, feel free (U2) to use an unsigned int.
- If you need a floating point number you're probably best off using float, which again is likely to be implemented so that it occupies an amount of memory that is most efficiently handled by the computer.


            
>> I/O type safe / >> type safe / >> type-safe
[pag572 deitel]
C++ offers  type-safe I/O. The << and >> operators are overloaded to accept data items of specific types. If unexpected data is processed, various error bits are set, which the user may test to determine whether an I/O operation suceeded or failed. If operators << and >> have not been overloaded  for a user-defined type and you attempt to input into or output the contents of an object of that user-defined type, the compiler reports an error. 
[pag563 deitel]
C++ uses type-safe I/O. Each I/O operation is executed in a manner sensitive to the data type. If an I/O function has been defined to handle a particular data type, then that member function is called to handle that data type. If there is no match between the type of the actual data and a function for handling that data type, the compiler generates an error. Thus improper data cannot "sneak" through the system.
C++ I/O occurs in >> streams . Streams are sequences of bytes. In input operations, the bytes flow from a device (eg. a keyboard, a disk drive a network connection etc) to main memory. In output operations, bytes flow from main memory to a device (e.g. a display screen, a printer, a disk drive, a network connection etc).
An application associates meaning with bytes. The bytes could represent characters, raw data, graphics images, digital speech, digital video or any other information an application may require. The system I/O mechanism should transfer bytes from devices to memory (and viceversa) consistently and reliably. Such transfers ofter involve some mechanical motion., such as the rotation of a disk or a tape, or the typing of keystrokes at a keyboard. The time these transfers take typically is far greater than the time the processor requires to manipulate data internally. Thus I/O operations require careful planning and tuning to ensure optimal perfomance.
C++ provides both >> low level and >> high level I/O capabilities. Low level I/O capabilities (i.e. >> unformatted I/O) specify that some number of bytes should be transferred device-to-memory  or memory-to-device. In such transfers, the individual byte is the item of interest. Such low-level capabilities provide high-speed, high-volume transfers but are not particularly convinient. [unformatted I/O is not protable across all platforms. Inoltre (from pag572) unformatted input output is performed using the read and write member functions of istream and ostream respectively See voce unformatted I/O for more information]. 
Programmers generally prefer a higher level view of I/O (i.e >> formatted I/O) in which bytes are grouped into meaningful units, such as integers, floating-point numbers, characters, strings and user-defined types. These type-oriented capabilities are satisfactory for most I/O other than high-volume file processing.
>> classic stream vs >> standard stream
In the past, the C++ >> classic stream libraries enabled input and ouptu of chars. Because a char normally occupies one byte, it can represent only a limited set of characters (such as those in the ASCII character). However, many languages use alphabets that contain more chracters then a single-byte char can represent. The ASCII character set does not privode these characters.
>> UNICODE / >> character set unicode 
The >> unicode character set does. Unicode is an extensive international character set that represents the majority of the world's "commercially viable" languages mathematical symbols and much more (for more info see www.unicode.org)
C++ includes the >> standard stream libraries, which enable developers to build systems capable of performing I/O operations with Unicode characters. For this purpose, C++ includes the type 
	>> wchar_t, 
which among the other uses can store Unicode characters.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> invariant // >> loog invariant [pag20 moo book]
detto in parole semplici l'invariant, loop invariant is a property that we assert will be true about a "while" each time it is about to test its conditions. cioe' e' la variabile incrementata all'interno del loop che finche' al di sotto di una certa soglia, permette di mantere a true (invariata) la condizione del ciclo while e di continuare a farlo looppare.

>> iostream library headers >> <iostream>
The C++ iostream libray provides hundreds of I/O capabilities. Several headers contain portions of the library interface. 
Most C++ programs include the <iostream> header, which declares baseic services required for all stream I/O operations.
The <iostream> header defines:
	>> cin  = standard input stream
example ---------------------------------------------------------------------
		// Hezbollah subroutine all rights reserved
		int rocketNumber;
		cout << "\nHow many rocket you need to launch? ";
		cin >> rocketNumber;   // >> extraction operator altri non e' che ">>" estrae il valore dallo standard input (la tastiera e lo inserisce nella variabile)
		cout << "number of rockets to be launched: " << rocketNumber << endl;
-----------------------------------------------------------------------------
	>> cout = standard output stream
	>> cerr = unbuffered standard error stream
	>> clog = buffered standard error stream
Both unformatted and formatted I/O stream are provided.
The >> <iomanip> / >> iomanip header declares services useful for performing formatted I/O with so called parameterized stream manipulators, such as setw and setprecision.
The >> <fstream> / >> fstream  header declares services for file processing. 
[pag565 deitel]
The iostream library provides many tempaltes for handling common I/O operations. For example, we have the following  class templates:
	>> basic_istream  = support stream-input operations
	>> basic_ostream  = support stream-output operations
	>> basic_iostream = supports both stream input and stream output operations  
Each template has a predefined template specialization that enables char I/O. In addition, the iostream library provides a set  of >> typedefs that provide aliases for these template specializations. 
>> typedef
example 	
	typedef unsigned short int ushort; 
this code defines the identifier "ushort" as another name for the type "unsigned short int"
Mike spiega [pag22 mike]:
To define new names for existing types, use typedef followed by the current type, followed by the new name. "typedef" is often used to create shorter names for types with long names. You can use your new type name just like the original type. 
Deitel spiega
The typdef specifier declares synonyms (aliases) for data types. You'll sometimes use typdef to create shorter or more readable type names. For example the statement:
	typdef Card *CardPtr;
defines an additional type name CardPtr as a synonum for type Card *. Creating a name using typedef does not create a data type; it creates only a new type name. 
The typedef istream represents a basic_istream<char> that enables char input.
Similarly the typedef ostream represents a basic_ostream<char> that enables char output.
Also the typedef iostream represents a basic_iostream<char> that enables both char input and output.
>> Stream I/O template hierarchy portion / >> inheritance relationships of stream-I/O templates / >> UML stream I/O inheritance relationships
[pag566 e 567 deitel]
>> standard input device = is usually the keyboard.
////////////////
>> cin [pag 566 deitel] = predefined objecdt cin is an istream instance and is said to be connected to the standard input device, which usually is the keyboard. The stream extraction operator  (>>) as used in the following statement causes a value for integer variable grade (assuming that grade has been declared as an int variable) to be input from cin to memory:
	cin >> grade; // data flows in the direction of the arrows. Vedi anche nostro trick pag 441 deitel
The compiler determines the data type of grade and selects the appropriate overloaded strem extraction operator. Assuming that grade has been declared properly, the stream extraction operator does not require additional type information. The >> operator is overloaded to input data items of fundamental types, strings and pointer values.
>> cout [pag566 deitel]
The predefined object cout is an ostream instance and is said to be "connect to" the >> standard output device, which is usually the display screen. The stream insertion operator <<  as used in the following statament, causes the value of variable grade to be output from memory to the standard output device:
	cout << grade; // data "flows" in the direction of the arrows. Vedi anche nostro trick pag 441 deitel
The compiler determines the data type of grade (assuming grade has been declares properly) and selects the appropriate stream insertion operator. The << operator is overloaded to output data items of fundamental types, strings and pointer values.
>> cerr [pag567 deitel]
The predefined object cerr is an ostream instance and is said to be connecte to the standard error device, normally the screen.
Outputs to object cerr are unbuffered, implying that each stream insertion to cerr causes its ouput to appear immediately (this is appropriate for notifying a user promptly about errors) 
[>> unbuffered meaning = cioe' che compare direttamente su schermo, senza essere confezionato "buffered" in un'area della memoria.]
>> clog [pag 567 deitel]
The predefined object clog is an instance of the ostream class and is said to be "connected to" the standard error device. Outputs to clog are buffered. This means that each insertion to clog could cause its output to be held in a buffer (that is an area in the memory) until the buffer is filled or until the buffer is flushed. Buffering is an I/O performance-enhancement technique discussed in operating systems courses.
>> file processing templates.
	>> ifstream = is a typedef represents a basic_ifstream<char> that enables char input from a file.
	>> ofstream = is a typedef that represents a basic_ofstream<char> that enables char output to a file.
	>> fstream = is a typedef that represents a basic_fstream<char> that enables char input from and output to a file
>> stream ouput 
pag567 deitel
Formatted and unformatted output capabilites are proveded by ostream. Capabilities include output of standard data types with the stream insertion operator (<<); output of characters via the "put" member function; unformatted output via the write member function. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





>> IDE integrated development environment for linux
- NetBeans (from Sun microsystem now Oracle)
- Eclipse (eclipse platform and Java IDE)
- Kdevelop (integrated development environment in ambiente KDE)
- Anjuta (in ambiente gnome)

>> IDENTIFIER 
A valid identifier is a valid sequence of one or more letters, digits or underscore characters (_)
Spaces, punctuation marks or symbols are not ammitted. Only letters, digits, and single underscore characters are valid.
Example 
	int number1 = 0;
number1 is the identifier of the variable, int is the fundamental type of the variable	
Other constraints:
- they have to begin with a letter, in no case they can begin with a digit.
- they cannot match any keyword of the C++ language which are reserved keywords (as break, do, delete, for, goto, if, int, long, new, try, while ect ect)
- remember the C++ is a "case sensitive" language.  That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters. (RESULTS ��Results �� results)  
ex of a valid identifier:  C_127 = 1; 
C_127 is a valid identifier,certainly iiis, C127 is number one in the Vplus plus kingdom, the last refuge of  speedfreaks
NB: lunghezza massima: USE IDENTIFIERS of 31 characters or fewer to ensure portability; in effetti C++ allows identifiers of any length, but your C++ implementation may restrict identifier lengths. 
NB2: choosing meaningful identifiers makes a program self-documenting. Avoid using abbreviation in identifiers, this improves program readability. 
NB3: do not use identifiers that begin with underscore and double underscore, because C++ compilers may use names like that for their own purposes internally. This will prevent the names you choose from being confused with names the compilers choose. 

>> IF CONDITIONAL OPERATOR    [used as mikepag37 said "to branch section of code"]
IN SHORT mike pag3
	if (expression)
		statement;
if expression is true, then statement is executed. Otherwise, statement is skipped and the program branches to the statement after the if suite.
In maniera piu' generale 
	if (expression)   // dopo (expression) non ci va il ;
		{
			statement1;
			statement2;
			...
			statementn;
		}   // dopo } non ci va il ;
///////////////////////////////////////////////////////////////////
NOTE1 [from pag41 mike]: you can interpret any value as true or false. Any non zero value can be interpreted as true, while 0 can be interpreted as false. example 
	int score = 1000;
	if (score)
	{
		cout << "At least you didn't score zero.\n\n";
	}
NOTE2: 
IL SEGUENTE E' SBAGLIATO: 
if (false);
{ 
	cout <<"This is never displayed.\n\n";
}
Mettendo il ; dopo (false); => the if statement sees the false value and skips the next statement (che e' un empty statement) quindi procede con lo statement after if cioe' { cout <<"This is never displayed.\n\n";} che verra' printato su schermo! Non vedrai nessun compiler error! E otterrai un risultato sbagliato!
IN LONG
The conditional operator evaluates an expression returning a value if that expression is true and a different one if the expression is evaluated as false. Its format is: 
	condition ? result1 : result2
If condition is true the expression will return result1, if it is not it will return result2. 
Examples:
	7==5 ? 4 : 3   //return 3, since 7��5
    7==5+2 ? 4 :3  //return 4, since 7==5+2 is true 	5 > 3 ? a : b  //return the value of a 
    a > b ? a : b  //returns whichever is greater
                       a or b 
Example 2:
	int a,b,c;
	a=2;
	b=7;
	c = (a>b) ? a : b;
    cout << c;	
otterrai...
c = 7
----------------------------------------------------------------------
NOTE3: 
che quando si usa if else if le istruzioni vanno racchiuse tra {}  example:

        if (distanceSquare < first)
        {
            second = first;
            centerP2 = centerP1;
            first = distanceSquare;
            centerP1 = mesh.Cf().boundaryField()[patchI][i];
            //Info<< "center P1 is: " << centerP1 << endl;
            //Info<< "center P2 is: " << centerP2 << endl;
            //Info<< "first is: " << first << endl;
            //Info<< "distanceSquare is: " << distanceSquare << endl;
        }
 
        // If distanceSquare is in between first and second
        // then update second
        else if ( (distanceSquare < second) && (distanceSquare != first) )
        {   
            second = distanceSquare;
            centerP2 = mesh.Cf().boundaryField()[patchI][i];
            Info<< "CICCIO" << endl;
            Info<< "center P2 is: " << centerP2 << endl;
        }  
//!!!! 30 minuti che non capivamo perche senza {} dopo else if le istruzioni venivano eseguite comunque!
Se non le racchiudi tra {}, non da nessun errore, la riga che segue immediatamente verra' eseguita o meno a seconda che la condizione dell'else if sia vera o no, mentre tutte le righe che seguono "centerP2..." "Info<<Ciccio.." verranno sempre eseguite, visto che risultato all'esterno del blocco condizionale.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> IF CONDITION compact style 
extract from /home/dia/Deitel-Code_Examples/ch10/fig10_01
   string s1( "happy" );
   string s2( " birthday" );
   string s3;
   // test overloaded equality and relational operators
   cout << "s1 is \"" << s1 << "\"; s2 is \"" << s2
      << "\"; s3 is \"" << s3 << '\"' 
      << "\n\nThe results of comparing s2 and s1:"
      << "\ns2 == s1 yields " << ( s2 == s1 ? "true" : "false" )
      << "\ns2 != s1 yields " << ( s2 != s1 ? "true" : "false" )
      << "\ns2 >  s1 yields " << ( s2 > s1 ? "true" : "false" ) 
      << "\ns2 <  s1 yields " << ( s2 < s1 ? "true" : "false" )
      << "\ns2 >= s1 yields " << ( s2 >= s1 ? "true" : "false" )
      << "\ns2 <= s1 yields " << ( s2 <= s1 ? "true" : "false" );
//////////////////
il precedente estratto dara' in standard output:
	s1 is "happy"; s2 is " birthday"; s3 is ""	
	The results of comparing s2 and s1:
	s2 == s1 yields false
	s2 != s1 yields true
	s2 >  s1 yields false
	s2 <  s1 yields true
	s2 >= s1 yields false
	s2 <= s1 yields true
///////////////////////////////////////////////

>> IF statement IF single statement
nella forma piu' semplice "se condizione soddisfatta fai, se non soddisfatta non far nulla" if puo essere scritto giusto in due linee:
example 
	if ( number1 == number2 )
		cout << number1 << " == " << number2 << endl;
printera la linea solo se i due numeri sono uguali. 
example2
	if (purgeForce >= 7000 )
		cout << "Void Layer machine is flying";
[pag55deitel]
NB: il semicolon si mette solo dopo lo statement e NON dopo le parentesi tonde dell'IF		
placing a semicolon immediately after the right parenthsis after the condition in an if statement is often a logic error (although not a sintax error). The semicolon causes the body of the if statement to be empty, so the if statement performs no action, regardless of whether or not its condition is true. Worse yet, the original body statement of the if statement now becomes a statement in sequence with the if statement and always executes, often causes the program to produce incorrect results. 
Trovi un esempio pratico delle tragiche conseguenze di mettere un ; dopo "if()" a pag83 jesse book 
Se scrivessi 
if (SomeValue < 10);
	SomeValue = 10;
running this code show that SomeValue is always set to 10! The if statement terminates with the semicolon, e come se avessi scritto
if (Some Value < 10) // test
; // do nothing
SomeValue = 10; // assign
To minimize the chances of this problem, you can always write your if statements with braces, even when the body of the if statement is only one line:
if (SomeValue < 10)
{
	SomeValue = 10;
}
////////////////////////////////////////////////////////////////////////////////////////

>> IF ELSE double selection statement
[pag112 deitel] 
pseudo code example
	if antiGravitationalField is greater than or equal to 1000
		print "Levitating"
	else
		print "Not levitating"
in C++ becomes 
	if ( antiGravitationalField >= 1000 )
		cout << "Levitating";
	else
		cout << "Not levitating";
vi e' un'altra maniera piu' concisa per esprimere la precedente, utilizzando il conditional operator ?:
	cout << ( antiGravitationalField >= 1000 ? "Levitating" : "Not levitating");
[vedi anche voce : CONDITIONAL OPERATOR]

>> IF STATEMENT NESTED / >> if nested 
[pag 113]
[spiegato anche a pag87 jesse]
Example in pseudo code:
	if velocity is greater than or equal to 3400
		print "hypersonic speed reached"
	else
		if velocity is greater than or equal to 340
			print "sonic speed reached"
		else
			if velocity is greater than or equal to 100
				print "take-off speed reached"
			else
				print "unable to take off"
in C++ becomes :
	if (speed >= 3400)
		cout << "hypersonic speed reached";
	else
		if (speed >= 340)
			cout << "sonic speed reached";
		else
			if (speed >= 100)
				cout << "take-off speed reached";
			else
				cout << "unable to take-off";
Most programmers write the preceding statement as:
	if (speed >= 3400)
		cout << "hypersonic speed reached";
	else if (speed >= 340)
		cout << "sonic speed reached";
	else if (speed >= 100)
		cout << "take-off speed reached";
	else
		cout << "unable to take-off";
che trovo anche piu' carina ed elegante da leggere. Notare come a differenza del matlab non ci sia un end di conclusione.
NB : [Performance] a nested  if...else statement can perform much faster than a series of single-selection if statements, because of the possibility of early exit after one of the conditions is satisfied.
NB2 : metti all'inizio le condizioni che are more likely to be true  at the beginning of the nested statement. In tal modo la probabilita' che si esca prima aumenta, piu' veloce di cominciare con testare unfrequently occurring cases.
NB3 : C++ compiler always associate an else with the immediately preceding if unless to do otherwise by the placement of braces {} ->> see >> DANGLING-ELSE problem
NB4: [pag115deitel] the if selection statement expects only one statement in its body. Similarly the if and else parts of and if...else statement each expect only one body statement.  To include several statements in the body of an if or in either part of an if..else, enclose the statements in braces ({ and }). A statement contained within a pair of braces is called a block. 
example pratico 
if ( antiGrav >= 1000)
	cout << "Levitating successfully.\n";
else
{
	cout << "Power unsufficient.\n";
	cout << "Realign the Carbon-Carbon layers and exponentiate the orbital energy level 27.\n";
}
//////////////////////////////////////

>> else clause 
[mike pag43]
You can add an else clause to an if statement to provide code that will only be executed if the tested expression is false. Here's the form of an if statement that includes an else clause:
	if (expression)
		statement1;
	else
		statement2;
If expression is true, statement1 is executed. Then the program skips statement2 and executes the statement following the if suite. IF expression is false, statement1 is skipped and statement2 is executed. After statement2 completes, the program executes the statement following the if suite.
Example 
	// Score Rater 2.0
	// Demonstrates an else clause
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		int score;
		cout << "Enter your score: ";
		cin >> score;
	
	    if (score >= 1000)
		{
	        cout << "You scored 1000 or more. Impressive!\n";
		}
		else
		{
			cout << "You scored less than 1000.\n";
		}
	
	    return 0;
	}
/////////////////////////////////////////////////////////////////////////////

>> IF sequence with else clauses pag 46 mike 
if (expression1)
	statement1;
else if (expression2)
	statement2;
...
else if (expressionN)
	statementN;
else
	statementN+1;
Example pratico:
// Score Rater 3.0
// Demonstrates if else-if else suite

#include <iostream>
using namespace std;

int main() 
{
	int score;
	cout << "Enter your score: ";
	cin >> score;

    if (score >= 1000)
	{
        cout << "You scored 1000 or more. Impressive!\n";
	}
	else if (score >= 500)
	{
        cout << "You scored 500 or more. Nice.\n";
	}
	else if (score >= 250)
	{
        cout << "You scored 250 or more. Decent.\n";
	}
	else
	{
		cout << "You scored less than 250. Nothing to brag about.\n";
	}

    return 0;
}




>> #include<iostream> :
tells the preprocessor to include the iostream standard file. This specific file (iostream) includes the declarations fo the basic standard input-output library in C++
[NB iostream sta per input output stream: uno "stream" in C++ is a convenient abstraction to perform input and output operations in sequential media such as the screen or the keyboad. A stream is an object where a program can either insert or extract characters to/from it.]

>> INCREASE DECREASE OPERATOR
increase operator (++) e descrease operator (--)
increase or reduce by one the value stored in a variable, They are equivalent to +=1 and -=1, respectively. Thus:
	c++;
	c+=1;
    c=c+1;
are all equivalent in its functionality: the three of them increase by one the value of c.
NB prefix/suffix: a characteristic of his operator is that it can be used both as a prefix and as a suffix. That means that it can be written either before the variable identifier (++a) or after (a++).In simple expression they both have exactly meaning BUT if used inside an outer expression
- if the increase operat..is used as a prefix (++a) the value is increare BEFORE the result of the outer expression is evalueted
	B=3;
	A=++B;
	// A contains 4, B contains 4
- if the increase operator is used as a suffix (a++) the value store in a e' utilizzato per il calcolo della outer expression, e solo dopo viene incrementato; ex:
	B=3;
	A=B++;
	// A contains 3, B contains 4


>> include / # include <...>  vs # include "userDefinedHeaderFiles" / >> headers
# include <system-header> 
	angle brackets, <>, enclose system headers. System headers may or may not be implemented as files. 
# include "user-defined-header-file-name" 
	user defined header files are included by enclosing the name in quotes. Typically, user defined headers have a suffix of .h

>> INCLUDE GUARD pag 379 380 deitel 
prevent multiple inclusion of header 
	#ifndef NAMEMIO_H
	#define NAMEMIO_H
	...
	#endfi
NOTE[pag380]: by convention the name of the neader is written in UPPERCASE with the period replaced by an underscore in the #ifndef and "define preproecssing directives of a header, quindi al posto di nomemio.h -> NOMEMIO_H
>> HEADER ifndef [osservazione simile from pag 71 moo book]: Header files should be guarded against multiple inclusion by wrapping the file ina an #ifndef GUARD_header_name directive. Headers should avoid declaring names that they do not use. In particular, they should not include using declaration, but instead should prefix standard library names with std:: explicitly.
example :/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/grade.h	
--------------------------------------------------------------------------------------
	#ifndef GUARD_grade_h
	#define GUARD_grade_h
	
	// `grade.h'
	#include <vector>
	#include "Student_info.h"
	
	double grade(double, double, double);
	double grade(double, double, const std::vector<double>&);
	double grade(const Student_info&);
	
	#endif
	

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> INITIALIZATION VARIABLE
1) Way 1
type identifier = initial_value; ex: 
	int a = 7;
2) Way 2
type identifier (initial_value); ex: 
	int a(7);

>> int :stands for integer
size 4 bytes
signed: -2147483648
unsigned 0 till 4294967295
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> INHERITANCE
[pag 483deitel]
in short 
Quando vedi i due punti  :  indica inheritance, example 
	class derivedClassName : public baseClassName
	{}
the keyword public (or protected or private) indica il tipo di inheritance
in long 
When classes share common attributes and behaviours, it's possible to define those attributes and behviours in a common "base" class and "inherit" those capabilities into new class definitions, enabling you to create the new classes with minimal amount of code.
NOMENCLATURA
>> base class = the class from which you inherit [they tend to be more general]
>> derived class = the class that inherits the members from the existing base class [they tend to be more specific].
A derived class represents a more specialized group of objects.
Other programming languages, such as Java and C# refer to the base class as the >> superclass and the derived class as the subclass.
C++ offers tre tipi di inheritance
	>> public inheritance
	>> protected inheritance [see voce protected per maggiori informazioni]
	>> private inheritance
>> public inheritance means that every object of a derived class is also an object of that derived class's base class. Cioe' ogni oggetto derivato e' un anche un oggetto della classe base ma il viceversa non e' vero. 
esempio :
if we have "Vehicle" as a base class and "Airplanes" as a derived class, then all "Airplanes" are "Vehicles", but not all "Vehicles" are "Airplanes", for examle a "Vehicle" could be a "Truck" or a "Boat".
>> inheritance vs composition / >> composition vs inheritance
we distinguish between the >> is-a relationship and the has-a relationship. The is-a relationship represents inheritance. In a is-a relationship, an object of a derived class also can be treated as an object of its base class: for example an Airplane is a Vehicle so any attributes and behaviors of a Vehicle are also attributes and behavior of Airplane. By constrast, the has-a relationship represents composition. In a has-a relationship, an object contains one or more objects of other classes as members. For example an Airplane has many components, has a stick, has a aileron, has a engine etc.
Vedi fig 11.2 pag 484 deitel UML class with five levels of inheritance. Each arrow in the hierarchy represents a is-a relationship. For example, as we follow the arrows in this class hierarchy, we can state "a Student is a Community Member"
_____________________  
Inheritance Examples |
---------------------
Base Class | Derived Class
- Student  | GraduateStudent, UndergraduateStudent
- Shape    | Circle, Triangle, Rectangle, Sphere, Cube
Inheritance relationships form >> class hierarchies. 
Although classes can exist independently, once they're employed in inheritance relationships, they become affiliated with other classes. 
A class becomes 
	- either a base class -> supplying members to other classes 
	- a derived class -> inheriting members from other classes
	- or both
Altre definitioni 
[pag485 deitel]
	>> single inheritance = a class is derived from one base class
	>> multiple inheritance = a derived class inherits simultaneously from two or more (possibly unrelated) classes. 
Usually is discouraged to use multiple inheritance. 
Inoltre si dice 
>> indirect base class = an indirect base class is inherited from two or more levels up the class hierarchy. see fig 11.2 pag 484 : communityMember is a indirect bas class di "Teacher". Starting from the bottom of the diagram, you can follow the arrow upwards and apply the is-a relationship to the topmost base class. For example, an AdministratorTeacher is an Administrato, is a Faculty member, is an Employee and is a CommunityMember.
Example  [pag485deitel]         
     |---------->   Shape  <------------|
     |                                  |
  2D_shape                           3D_shape
  ^       ^                          ^      ^
  |       |                          |      |
circle   triangle                sphere    tetrahedron

Nell'esempio sopra abbiamo 3 livelli di gerarchia. Le frecce rappresentano delle relazione "is-a" , per esempio:
a "Triangle" is a "2D_shape" and is a "Shape", while a sphere is a "3D_shape" and a is a "Shape"
To specify that class 2D_shape is derived from class "Shape" class 2D_shape could begin as follows:
	class 2D_shape : public Shape 
The above is an example of 
>> public inheritance
Public inheritance is the most commonly used from. 
Altre possibilita' sono la private inheritance and the protected inheritance. With all forms of inheritance, "private" members of a base class are not accessible directly from its derived classes, but there private base-class members are still inherited (i.e. they're still considered parts of the derived classes). 
NOTE1: "friend" functions are not inherited
NOTE2: >> inheritance vs composition / >> composition vs inheritance
Inheritance is not appropriate for every class relationship. Sometime is necessary to choose "has-a" relationship instead of a "is-a" relationship. For example given the classes:
- Spaceship
- Engine
- Stellarator
it's improper to say that a Spaceship "is a" Engine or that a Spaceship "is a" Stellarator. However it is appropriate to say that a Spaceship "has-a" Engine and that a Spaceship "has-a" Stellarator.
IMPORTANT  NOTE : 
	INSTEAD of COPY and PASTE, use INHERITANCE
[pag497deitel]
- Copying and pasting code fron one class to another can spread many physical copies of the same code and can spread errors throught a system, creating a code-maintenance nightmare. To avoid duplicating code (and possibly errors), use inheritance, rather than "the copy and paste" approach, in situation where you want one class to "absorb" the data members and member functions of another class.
- With inheritance, the common data members and member functions of all the classes in the hierarchy are declared in a base class. When changes are required for these common features, you need to make the changes only in the base class; derived classes then inherit the changes. Witout inheritance, changes would need to be made to all the source code files that contain a copy of the code in question.
NOTE2:
Quando vedi i due punti  :  indica inheritance, example 
	class derivedClassName : public baseClassName
	{}
the keyword public (or protected or private) indica il tipo di inheritance
A derived class inherits all the members of the base class, except for the constructor (each class provides its own constructors that are specific to the class. Destructor too are not inherited)
- NOTE from pag508
Note in the following extract the syntax used to invoke a redefined base-class member function from a derived class : you need to place the base-class name and the scope resolution operator (::) before the base-class member-function name. This member-function invocation is a good software engineering practice. 
example from Deitel-Code_Examples/ch11/fig11_14_15/BasePlusCommissionEmployee.cpp
	// calculate earnings
	double BasePlusCommissionSpaceShip::tonnaggio() const
	{
	   return getBaseCargoWeight() + CommissionSpaceShip::tonnaggio();
	} // end function earnings
By having BasePlusCommissionSpaceShip's tonnaggio() function invoke CommissionSpaceShip's tonnaggio function to calculate part of a BasePlusCommissionSpaceship object's cargo, we avoid duplicating the code and reduce code maintenance problems.
NOTE: when a base-class member function is redefined in a derived class, the derived-class version often calls the base class verion to do additional work. Failure to use the :: operator prefixed with the name of the base class when referencing the base class's member funtion causes infinite recursion, because the derived-class member function would then call itself.
>> C+11 inheriting base class constructors / >> inheritance base class in C+11
C++11 has the ability to inherit a base class's constructors. You can new do this by explicitly including a "using" declaration of the form
	using BaseClass::BaseClass;  //[>> using declaration tag / >> USING DECLARATION see  also moo book pag27
consiglio importante pag 69 moo book: non usare "using" declaration in *.h files, usale solo negli source files .c. Unlike a header file, a source file has no effect on the programs that use these functions. Hence reliance on using declaration in a source file is purely a local decision.]
anywhere in the derived-class definition.
[see pag 510 deitel for more info]
>> TABLE PUBLIC PROTECTED PRIVATE INHERITANCE / >> TABLE MEMBER ACCESSIBILITY
[see pag 511 deitel]
NOTE: [from pag 512] at the design stage in an object oriented system, the designer often determines that certain classes are closely related. The designer should "factor out" common attributes and behaviours and place these in a base class, then use inheritance to form derived classes.
>> INTERFACE INHERITANCE [pag536deitel]
A derived class can inherit interface and /or implementation from a base class. Each new derived class inherits one or more member functions that were defined in a base class, and the derived class uses the base class definitions.Hierarchies designed for interface inheritance tend to have their functionality lower in the hierarchy cioe': a base class specifies one or more functions that should be defined for each class in the hierarchy (i.e. they have the same prototype), but the individual derived classes provdie their own implementation of the function(s).
INSOMMA e' un po' come una presa elettrica. Le classi derivate utilizzano lo stesso prototipo (la stessa tipologia di presa elettrica). Ma poi come ciascuno sia implementato dentro cambia da classe derivata a classe derivata [come degli elettrodomestici, implementati diversamente all'interno ma hanno poi tutti la stessa presa elettrica (same prototype)].
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TAB data output. Ecco qui un esempio using \t\t in modo da tabulare bene i dati in output. 
[pag 44 jesse book]
#include <iostream>
  
int main()
{
   using std::cout;
  
   cout << "The size of an int is:\t\t"    
      << sizeof(int)    << " bytes.\n";
   cout << "The size of a short int is:\t" 
      << sizeof(short)  << " bytes.\n";
   cout << "The size of a long int is:\t"  
      << sizeof(long)   << " bytes.\n";
   cout << "The size of a char is:\t\t"    
      << sizeof(char)   << " bytes.\n";
   cout << "The size of a float is:\t\t"   
       << sizeof(float)  << " bytes.\n";
   cout << "The size of a double is:\t"    
      << sizeof(double) << " bytes.\n";
   cout << "The size of a bool is:\t"      
      << sizeof(bool)   << " bytes.\n";
  
   return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> protected vs private [pag229 moo book]
Quando a partire da una base class, derivi (via inheritance) una nuova classe, questa nuova classe non puo' accedere ai private members functions della base class. If you want to access them you need to modify the base class, e al posto di "private" devi usare "protected". The protected label gives derived classes access to the protected members of their constituent base-class objects, but keeps these elements inaccessible to users of the classes. 

>> INLINE FUNCTIONS pag122 jesse book
IN SHORT
	non usarle, il piccolo improvement in performance e' trascurabile e talvolta il loro uso puo' in effetti rendere il programma meno efficiente
IN LONG
When you call a function, execution of the program jumps to those instructions and when the function returns, execution jumps back to the next line in the calling function. 
A small performance overhead occurs in jumping in and out of functions. It turns out that some functions are very small, just a line or two of code, and an efficiency might be gained if the program can avoid making these jumps just to execute one or two instructions. 
If a function is declared with the keyword inline, the compiler does not create a real function, it copies the code from the inline function directly into the calling function. No jump is made; it is just as if you had written the statements of the function right into the calling function. 
Note that inline functions can bring a heavy cost. If the function is called 10 times, the inline code is copied into the calling function each of those 10 times. The tiny improvement in speed you might achieve might be more than swamped the increase in size of the executable program, whichmight in fact actually slow the program!
The reality is that today's optimizing compilers can almost certainly do a better job of making this decisiion than you can; and so it is genreally a good iea not to delcare a function inline unless it is only one or at most two statements in length. When in doubt tough, leave inline out.
------------------------------------------------------ INLINE FUNCTION EXAMPLE:
// Listing 5.9 - demonstrates inline functions
#include <iostream>
 
inline int Double(int); // declaration of inline function
  
int main()
{
   int target;
   using std::cout;
   using std::cin;
   using std::endl;
  
   cout << "Enter a number to work with: ";
   cin >> target;
   cout << "\n";
  
   target = Double(target);
   cout << "Target: " << target << endl;
  
   target = Double(target);
   cout << "Target: " << target << endl;
  
   target = Double(target);
   cout << "Target: " << target << endl;
   return 0;
}
  
int Double(int target)
{
   return 2*target;
}
///////////////////////////////////////////////////////////////////////////////////////////////

>> INLINE FUNCTIONS 
pag236deitel
Functions calls involve execution time overhead. 
Placing the  qualifier 
	inline
before a function's return type  in the function definition advises the compiler to generate a copy of the function's body every code in every plave where the function is called to avoid function called. This often makes the program larger. 
The compiler can ignore the "inline" qualifier and generally does so for all but the smallest functions. 
Today's optimizing compilers are so sophisticated that it's best to leave  inlining decisions to the compiler.	
pag383deitel
if a member function is declared in a class's body, the member funtion is implicitly declared inline. Remember that the compiler reserves the right not to inline any function.
Define a member function inside the class definition inlines the member function (if the compiler chooses to do so). This can improve performance.


>> INLINE FUNCTION / >> INLINING FUNCTIONS [pag168 mike programming game]
There's a small performance cost associated with calling a function. Normally this isn't a big deal because the cost is relatively minor. However, for tiny functions (such as one or two lines), it's sometimes possible to speed up program performance by inlining them. By inlining a function, you ask the compiler to make a copy of the function everywhere it's called. As a result, program control doesn't have to jump to a different location each time the function is called.
To mark a function for inlining, simply put "inline" before the function declaration (but not put "inline" before the function declaration; see example below)
By flagging the function with "inline" you ask the compiler to copy the function directly into the calling code. This saves the overhead of making the function call. That is, program control doesn't have to jump to another part of your code. For small functions, this can result in a performance boost. However, inlining is not a silver bullet for performance. In fact, indiscriminate inlining can lead to worse performance because inilining a function creates extra copies of it, which can dramatically increase memory consumption. 
HINT: when you inline a function, you realy make a request to the compiler, which has the ultimate decision on whether to inline the function. If your compiler thinks that inlining won't boost performance, it won't inline the function. 
CALLING INLINE FUNCTION: calling an inlined function is no different than calling a non inlined function.
----------------------------------------------------
FULL EXAMPLE (from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/taking_damage.cpp)
		// Taking Damage
		// Demonstrates function inlining
		
		#include <iostream>
		
		int radiation(int health);   // FUNCTION DECLARATION: in the function declaration you DO NOT use "inline" e' solo nella function definition [vedi sotto il blocco dopo main] che userai l'"inline" keyword 
		
		using namespace std;
		
		int main()
		{
		    int health = 80;
		    cout << "Your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		    
		    health = radiation(health);
		    cout << "After radiation exposure your health is " << health << "\n\n";
		
		    return 0;
		}
		
		inline int radiation(int health)  // FUNCTION DEFINITION : put inline before the function definition.
		{
		    return (health / 2);
		}
--------------------------------------- END FULL EXAMPLE
NOTE: >> PROFILER / >> PERFORMANCE IMPROVEMENT : in the real world although obsessing about performance is a game programmer's favorite hobby, there's a danger in focusing too much on speed. In fact, the approach many developers take is to first get their game programs working well before they tweak for small performance gains. At that point, programmers will "profile" their code by running a utility (>> profiler) that analyzes where the game program spends time. If a programmer sees blottlenecks, he or she might consider hand optimization such as function inlining. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FULL EXAMPLE MAD LIB GAME 
// Mad-Lib
// Creates a story based on user input

#include <iostream>
#include <string>

using namespace std;

string askText(string prompt);
int askNumber(string prompt);
void tellStory(string name, string noun, int number, string bodyPart, string verb);

int main()
{
    cout << "Welcome to Mad Lib.\n\n";
    cout << "Answer the following questions to help create a new story.\n";
    
    string name = askText("Please enter a name: ");
    string noun = askText("Please enter a plural noun: ");
    int number = askNumber("Please enter a number: ");
    string bodyPart = askText("Please enter a body part: ");
    string verb = askText("Please enter a verb: ");
    
    tellStory(name, noun, number, bodyPart, verb);

    return 0;
}

string askText(string prompt)
{
    string text;
    cout << prompt;
    cin >> text;  // TRAP this simple use of "cin" works only with strings that have no white space in them (such as taps or spaces). So when a user is prompted for a name, he can enter "eri" ma "chuck norris" will cause a problem for the program, visto che c'e' uno spazio tra chuch e norris. There are ways to compensate for this, but that really requires a discussion of something called streams, which is beyond the scope of this book. So use "cin" in this way, but just be aware of its limitations.
    return text;
}

int askNumber(string prompt) // >> integer from the user // get integer from the user
{
    int num;
    cout << prompt;
    cin >> num;
    return num;
}

void tellStory(string name, string noun, int number, string bodyPart, string verb)
{
    cout << "\nHere's your story:\n";
    cout << "The famous explorer ";
    cout << name;
    cout << " had nearly given up a life-long quest to find\n";
    cout << "The Lost City of ";
    cout << noun;
    cout << " when one day, the ";
    cout << noun;
    cout << " found the explorer.\n";
    cout << "Surrounded by ";
    cout << number;
    cout << " " << noun;
    cout << ", a tear came to ";
    cout << name << "'s ";
    cout << bodyPart << ".\n";
    cout << "After all this time, the quest was finally over. ";
    cout << "And then, the ";
    cout << noun << "\n";
    cout << "promptly devoured ";
    cout << name << ". ";
    cout << "The moral of the story? Be careful what you ";
    cout << verb;
    cout << " for.";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> INPUT OUTPUT /  binary stream insertion and stream extraction operators 
[pag440deitel]
You can input and output fundamental-type data using the stream extraction operator >> and the stream insertion operator <<. 
The C++ class libraries overload these binary operators for each fundamental type, including pointers and char * strings. You can also overload these operators to perform input and output for your own types. 
See example : /home/dia/Deitel-Code_Examples/ch10/fig10_03_05

>> INPUT from keyboard/ >> get input from the user / >> input from the user
[pag32 and programma di esempio /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/lost_fortune.cpp]
	cout << "Welcome to Lost Fortune\n\n";
	cout << "Please enter the following for your personalized adventure\n";

	cout << "Enter a number: "; 
	cin >> adventurers;

	cout << "Enter a number, smaller than the first: ";
	cin >> killed;

	survivors = adventurers - killed;

	cout << "Enter your last name: ";
	cin >> leader;
IMPORTANT / ATTENTION: this simple use of cin to get a string from the user only works with strings that have NO WHITESPACE (such as tabs or spaces) in them. There are way to compensate for this, but that really requires a discussion of something called streams, which is beyond the scope of the present discussion. So, use cin in this way, but be aware of its limitations.  
>> OUTPUT TO SCREEN example from mike pag 32  /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter01/lost_fortune.cpp
	cout << "\nA brave group of " << adventurers << " set out on a quest ";
	cout << "-- in search of the lost treasure of the Ancient Dwarves. ";
	cout << "The group was led by that legendary rogue, " << leader << ".\n";

	cout << "\nAlong the way, a band of marauding ogres ambushed the party. ";
	cout << "All fought bravely under the command of " << leader;
	cout << ", and the ogres were defeated, but at a cost. ";
	cout << "Of the adventurers, " << killed << " were vanquished, ";
	cout << "leaving just " << survivors << " in the group.\n";

	cout << "\nThe party was about to give up all hope. "; 
	cout << "But while laying the deceased to rest, ";
	cout << "they stumbled upon the buried fortune. ";
	cout << "So the adventurers split " << GOLD_PIECES << " gold pieces.";
	cout << leader << " held on to the extra " << (GOLD_PIECES % survivors);
	cout << " pieces to keep things fair of course.\n";
Nota come si usa il modulus operator % in the expression GOLD_PIECES % survivors. The expression evaluates to the remainder of GOLD_PIECES / survivors , which is the number of gold pieces that would be left after evenly dividing the stash among all of the surviving adventurers.  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> interface of an object = the collection of operations that are possible of an object  
[pag10 moo book]

>> INTERFACE OF A CLASS 
[pag87deitel]
Interfaces define and standardize the ways in which things such as people and systems interact with one another. The interface (come per esempio i bottoni di un iPod) specifies what operations a system permits users to perform but does not specify how the operations are implemented inside the system.
Similarly, the interface of a class describes what services a class's clients can use and how to request those services, but not how the class carries out the services. 
We can specify a class's interface by writing a class definition that lists only the member-function names, return types and parameter types. 
- SEPARATING INTERFACE FROM IMPLEMENTATION / SEPARATION 
Each class definition can contain [like in example pag84 fig3.9] the complete definition of the class's public member functions and the declarations of its private data members. However, IT'S BETTER software engineering to define member functions OUTSIDE the class definition, so that their implementation details can be hidden from the client code. This practice ensures that you do not write client code that depends on the class's implementation details. 
Trovi un esempio nelle pagine 88-90deitel. 3 per lo meno i files necessary per rispettare questo interface/implementation separation approach:
1) un file myClassName.h contenente l'interface della classe; 
2) un file myClassName.cpp contenente l'implementazione della classe;
3) il file mainFunction.cpp dove si istanzia e si utilizza la classe con un #include myClassName.h
Observations 
	->>>>> IL FILE 1) myClassName.h dona la "class definition" containing the functions prototypes that specify the interface of the class. Although parameter names in function prototypes are optional (they're ignored by the compiler) many programmers use these names for documentation purposes. [See voce >> FUNCTION PROTOTYPES or pag87 per rappeler sa definition] . Also the *.h header still specifies the class's private data member as well. 
NB a function prototype is a declation function that tells the compiler the function's name, its return type and the types of its parameters. Solo nel caso del constructor you won't have any return type (constructors cannot return type not even void see pag 81 star tag)
esempi [da pag88deitel]
	explicit GradeBook ( std::string ); 
questo e' un constructor, so no return type e ; obbligatorio
	void setCourseName ( std::string ); 
this function prototype indicates that setCourseName requires a string parameter and does not return a value (its return type is void)
	std::string getCourseName() const;
this function prototype indicates that the function does not requires parameters and return a string.
Insomma these function prototypes are the same as the first lines of the corresponding function definitions in fig 3.9, except that the parameter names (which are optional in prototypes) are not included and each function prototype must end with a semicolon.
->>>>> IL FILE 2) myClassName.cpp contiene le "member-function definitions" representing the implementation of the class. 
- by convention member-function definitions are placed in a source-code file of the same base name (e.g. myClassName) as the class's header but with a .cpp filename extension. 
- Note that the const keyweord msut appear on boch the function prototypes  (fig.3.11 ,lines 13-14) and the function definitions for functions getCourseName and displayMessage (lines 22 and 28)
- each member function name is preceded by the class name and :: which is known as the scope resolution operator. This "ties" each member function to the (now separate) GradeBook class definition, which declares the class's member functions and data members.
- to indicate that the member functions in GradeBook.cpp are part of class GradeBook, we must first include the GradeBook.h header. This allows us to access the class name GradeBook in the GradeBook.ccp file.
When compiling GradeBook.cpp, the compiler uses the information in GradeBook.h to ensure that
	A) the first line of each member function matches its prototype in the GradeBook.h file
	B) each member function knows about the class's data members and other member functions
->>>>> IL FILE 3) main.cpp (client code) : istanziazione e utilizzo della classe by main 
Once compiled, the source files have to linked together, cioe' le chiamate delle member functions all'interno del client code [FILE 3] need to be tied to the implementation of the class's member functions 
- [pag92 deitel] separare un programma in questo modo permette di poter separare il lavoro di development tra piu' persone 
A) da un lato il client code programmer sviluppera' main.cpp 
B) dall'altra il class-implementation programmer sviluppera myClass.cpp
e hanno solo bisogno di definire insieme l'interface della classe. 
The client code programmer is not give myClass.cpp , so the client remains unaware of now myClass.cpp's member functions are implemented. The client code programmer needs to know only myClass's interface to use the class and must be able to link its object code.
Compilers and IDEs typically invoke the linker for you after compiling your code. 


[asdf]

>> JJJJJJJ

>> japanese. [pag14 moo book] 
To hold characters for Japanese we need to use not char bensi' wchar_t: it's a built-in type intended to hold "wide characters", big enough to hold kanji, hira and kana.

>> KKKKKKK

>> KEYWORDS common keywords in C++ 
see fig4.3 pag109deitel

>> LLLLLLLL / >> LLL

>> LONGEST NAME make >> SPACE >> WHITE SPACE making [no no black space and this is not racist please, we are programming here!]
Make white space according to the longest name in a list in modo che la seconda colonna venga bella diritta. 
Ne trovi un bell'esempio in pag65 moo book 
/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> lambda expressions
[pag729 deitel]
C++11 lambda expressions (r >> lambda functions) enable you to define anonymous function objects where they're passed to a function. They're defined locally inside functions and can "capture" (by value or by reference) the local variables of the envlosing function then manipulate these variables in the mabda's body. 
Example : /home/dia/Deitel-Code_Examples/ch16/fig16_16/fig16_16.cpp
OUTPUT 
	2
	4
	6
	8
	sum is 10
COMMENTS
     10    const size_t SIZE = 4; // size of array values
	 11    array< int, SIZE > values = { 1, 2, 3, 4 }; // initialize values
Lines 10 and 11 declare and initialize a small array fo ints named values. 
	 13    // output each element multiplied by two
	 14    for_each( values.cbegin(), values.cend(),
	 15       []( int i ) { cout << i * 2 << endl; } );
Lines 14-15 call the for_each algorithm on the elements of values. The third argument (line 15) to for_each is a lambda expression. Lambdas begin with lambda introducer [], followed by a parameter list and function body. Return types can be inferred automatically if the body is a single statement of the form return expression; otherwise the return type is void by default or you can explicitly use a trailing return type.
	 19    // add each element to sum
	 20    for_each( values.cbegin(), values.cend(),
	 21       [ &sum ]( int i ) { sum += i; } );
Lines 20-21 calculates the sum of the array elements. The lambda introducer [&sum] indicates that this lambda expression captures the local variable sum by reference (note the use of the ampersand), so that the lambda can modify sum's value. Without the ampersand, sum would be captured by value and the local variable outside the lambda expression would not be updated. The for_each algorihm passes each element of values 
to the lambda, which adds the value to the sum. 
	 23    cout << "sum is " << sum << endl; // output sum
Line23 then displays the value to sum. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LARGE PROGRAM the rigth way
[pag202]
the way to develop and maintain a large program is to construct it from small, simple pieces, or components. This technique is called DIVIDE et CONQUER [dividi et impera] 

>> LEFT 
[pag167deitel]
	left
non parameterized stream operator: used to indicate that values should be output left justified.
To restore right justification output with nonparameterized stream manipulator "right"

>> lvalue meaning 
An lvalue is a way of describing the term on the left hand side of an assignment. It is usually an address or variable.
In this declaration and initialization of the int variable a, the lvalue is a.
	int a = 9*7+c;
[source http://cplus.about.com/od/glossar1/g/lvalue.htm]
per una presentazione piu' approfondita see also http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c
[che ti ho salvato in webkaradocs come "understanding-lvalues-and-rvalues-in-c-and-c.html"]
FROM StackOverflow:
ANSWER1
	An lvalue is a value that can be assigned to:
	lvalue = rvalue;
	It's short for "left value" or "lefthand value" and it's basically just the value on the left of the = sign, i.e. the value you assign something to.
	As an example of what is not an lvalue (i.e rvalue only):
	printf("Hello, world!\n") = 100; // WTF?
	That code doesn't work because printf() (a function that returns an int) cannot be an lvalue, only an rvalue.
ANSWER2
	Something that appears on the left hand side of an assignment i.e. something that can be assigned to.
	Note that in C++ a function call may be an lvalue if:
		int & func() {
		   static int a = 0;
		   return a;
   		}
	then:
		func() = 42;     // is legal (and not uncommon)
ANSWER3
It's traditionally the left side of the "=" operator. However, with time, meaning of "lvalue"/"rvalue" changed. C++ added the term of a "non-modifiable lvalue" which is any lvalue that cannot assigned to: arrays and variables that are qualified with "const" are two examples. In C, you cannot assign to any rvalue (see below). Likewise, in C++, you cannot assign to rvalues that are not of some user defined class type.
You can say an "lvalue" is an expression that names an object which persists over time and occupies some location of storage. Whether or not you can assign to that expression is not important for that classification. A reference, in particular, is also an lvalue, because it has a name that persists over time. All the following are lvalues, because they all refer to named objects. Also note that a const does not have any effect on the lvalue-ness.
	int a; lvalue: a;
		   lvalue: ++a;
	int a[2]; lvalue: a;
	int &ra = a; lvalue: ra;
	int *pa = &a; lvalue: *pa;
The term "rvalue" is used for things like literals and enumerator values and for temporaries that do not enjoy the fun of having a long life and are destroyed right away at the end of a full expression. For rvalues, not the aspect of persistence is important, but the value-aspect. Functions in C++ are lvalues, because they are persistent and they have an address, even though they are not objects. I've left them out in the above overview of lvalues, because it's easier to grasp lvalues when first only taking objects into account. All the following are rvalues:
	enum { FOO, BAR }; rvalue: BAR;
	int a[2]; rvalue: (a+1);
	rvalue: 42;
	int a; rvalue: a++; // refering to a temporary
	struct mystruct { }; mystruct f() { return mystruct(); } rvalue: f();
Incidentally, often you have an lvalue, but an operator needs an rvalue. For example the binary builtin "+" operator adds two values. An lvalue expression first and for all specifies a location where a value first has to be read out. So when you add two variables, an "lvalue to rvalue" conversion takes place. The Standard says that the value contained in an lvalue expression is its rvalue result:
		int a = 0, b = 1;
		int c = a + b; // read values out of the lvalues of a and b.
Other operators do not take rvalue, but lvalues. They don't read a value. An example is the address-of operator, &. You cannot take the address of an rvalue expressions. Some rvalues are not even objects: They do not occupy any storage. Examples are again, literals (10, 3.3, ...) and enumerator values.
How is that scary stuff useful?
Well it has several advantages to have the distinction of lvalue and rvalue
    Allowing the compiler to omit taking storage for rvalues and using registers/readonly memory for scalar values
    Flagging expressions as elusive: rvalues will not live long
        Allows efficient copy semantics for the compiler internally and in c++1x also exposed to the programmer (see move semantics and rvalue references): We can steal away resources from rvalues that are going to be destroyed anyway.
    Allows to build rules upon that property
        rvalues are not allowed to be generated from a yet uninitialized objects where an lvalues refers to. But lvalues may refer to uninitialized objects just fine
        rvalues can never be polymorphic. Their static type must also be their dynamic type: Simplifies rules for the typeid operator.
... There is more to it, i feel it ...
[source http://stackoverflow.com/questions/579421/often-used-seldom-defined-terms-lvalue] 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
>> lvalue spieagazione also pag 56 moo book
an lvalue is a value that denotes a nontemporary object. For example
	a variable 
	a reference 
	the result of calling a function that returns a reference 
are lvalue arguments. 
An expression that generates an arithmetic value, such as sum/count is not an lvalue 

>> LIBRARIES BOOST C++ libraries
the boost C++ libraries are free, open-source libraries created by members of the C++  community. Boost provides C++ programmers with useful libraries that work well with the existing C++ standard library. Some of the C++11 Standard Library features were derived from corresponding Boost libraries. 

>> LIBRARY ORDER / >> ORDER LIBRARY during compiling
quando si compile in g++ l'ordine con cui si elencano i files e' importante?
    cd /home/dia/Deitel-Code_Examples/ch10/fig10_09_11
    g++ Array.h Array.cpp fig10_09.cpp -o executable
ci funziona [thanks Ciccio] ma volevamo giusto sapere se l'ordine con cui si scrivono i files e' davvero indifferente.
ANSWER:
from this link [salvato in blackbird]
http://stackoverflow.com/questions/492374/g-in-what-order-should-static-and-dynamic-libraries-be-linked
it seems that as long are they are static libraries the order in which you list them is not important

>> LIFO 
	= Last In First Out
in LIFO data structure the last item pushed (inserted ) on the stack is the first item popped (removed) from the stack. 

>> LINKAGE identifier
[pag226deitel]
An identifier's linkage determines whether it's known only inthe source file where its declared or cress multiple files that are compiled, then linked together. An identifier's storage class specifier helps determine its storage duration and linkage.

>> LINUX WINDOWS same calculation different results / >> Windows Linux same calculation different results 
[stackoverflow.com/questions/16744245/same-calculation-on-linux-and-windows-different-results]
Original code:
	string toFormatFromDecimal(long long t, Format format) {
		int digitCount = ceil(log(t) / log((int) format));
		string hex = "";
		for (int i = 0; i < digitCount; i++) {
			long double cur = (long double)t / (long double)(format);
			long long ganzzahl = (long long) cur;
			long double kommazahl = cur - ganzzahl;
			hex += digits[(long long) (kommazahl * format)];
			t = ganzzahl;
		}
		return string(hex.rbegin(), hex.rend());
	}
SOLUTION 
	string toFormatFromDecimal(long long t, Format format) {
		int digitCount = ceil(log(t) / log((int) format));
		string hex = "";
		for (int i = 0; i < digitCount; i++) {
			hex += digits[(int) (t%format)];
			t = t/format;
		}
		return string(hex.rbegin(), hex.rend());
	}
NOTE1: 	Yes, GCC and Visual Studio C++ have different long double types. On GCC generating code for x86, long double is a 80-bit double-extended IEEE 754 format(*), whereas Visual Studio C++ treats long double like a 64-bit double-precision IEEE 754 format(*).
So (long double)t does not have to be the same number on both platforms, and the division is not the same either. Although you have tagged your question "integer-division", it is a floating-point division between different floating-point types.
(*) almost: it behaves very very much like a 79-bit IEEE 754 type with 15 exponent bits and 63 significand bits would, but it has a slightly wider exponent range since it uses an explicit bit for the leading 1 in the significand.
(**) almost: because the compiler generates instructions that use the historical x87 instructions after having configured the x87 for 53-bit significands, denormal results may be double-rounded
NOTE2: To make the program work the same on both platforms, avoid floating-point completely
/////////////////////////////////////////////////////////////////////////////
See also 
http://stackoverflow.com/questions/1961442/different-math-rounding-behaviour-between-linux-mac-os-x-and-windows
> n addition to the runtime rounding settings that people mentioned, you can control the Visual Studio compiler settings in [rigth click sul nome del progetto li dal solution explorer] Properties > C++ > Code Generation > Floating Point Model. I've seen cases where setting this to "Fast" may cause some bad numerical behavior (e.g. iterative methods fail to converge).
//////////////////////////////////////////////////////////////////////////////

>> LIST INITIALIZER 
[pa139deitel]
The list initializer can be a comma separated list of values that are passed to the object's constructor. Supponi per esempio di creare una classe SpaceShip che rappresenti il nome dell'astronave, anno di creazione e payload in tonnellate. Assuming the class defines a construct that receives a string for the spaceship name, a int for the year of creazione e a double for the tonnellaggio, potremmo inizializzare "SpaceShip" objects as follows:
	SpaceShip spaceship1{ "Falcor", 2592, 37689.5};
	SpaceShip spaceship2{ "Nostromo", 2552, 23689.0};
- for a fundamental type variable invece you place only one value in the list initializer ex
	unsigned int CruisingYearsCounter{ 1 };
usare un initializer ha il vantaggio che se il type e' diverso da quello atteso (esempio inserisci un real number al posto di un integer ottieni un compilation error, e cio' ti puo' aiutare nell'evitare subtle logic errors)
	int x = 12.7 // non ti da nessun errore, giusto un warning e si effettua una narrowing conversion cioe' x diventa = 12
invece usando 
	int x = { 12.7 };
or
	int x{ 12.7 };
ti avverte con un errore di compilazione.
NOTE: ulteriori informazioni from pag392
C+121 now provides a niform initialization syntax called list initializers that can be used to initialize any variable. So instead of the line 11-13 di fig9.6 [riportate qui sotto per migliore convenienza]
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2( 2 ); // hour specified; minute and second defaulted
	   Time t3( 21, 34 ); // hour and minute specified; second defaulted 
	   Time t4( 12, 25, 42 ); // hour, minute and second specified
le possiamo riscrivere usando i list initializers nel modo seguente (cioe' tutto resta uguale a parte le parentesi tonde che diventano graffe) :
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2{ 2 }; // hour specified; minute and second defaulted
	   Time t3{ 21, 34 }; // hour and minute specified; second defaulted 
	   Time t4{ 12, 25, 42 }; // hour, minute and second specified		
o anche 
	int main()
	{
	   Time t1; // all arguments defaulted
	   Time t2 = { 2 }; // hour specified; minute and second defaulted
	   Time t3 = { 21, 34 }; // hour and minute specified; second defaulted 
	   Time t4 = { 12, 25, 42 }; // hour, minute and second specified
The form without the = is preferred. 
//////////////////////////////////////////////////////////////////////////////////

>> list initialization 
>> list character initialization 
[source http://www.cplusplus.com/forum/beginner/138335/]
std::list<const char *> mylist = { "one", "two", "three" };  // Assumes C++11
che usando la lista openFOAM diventa : 
List<const char *> processor0 = {"a", "a", "b", "a", "c", "b"}; // create list of characters for processor0
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ERROR
			ListSortAndDelDuplicate.C:118:2: note: suggested alternative:
			In file included from /usr/include/c++/4.8.2/list:63:0,
						     from ListSortAndDelDuplicate.C:49:
			/usr/include/c++/4.8.2/bits/stl_list.h:438:11: note:   ‘std::list’
				 class list : protected _List_base<_Tp, _Alloc>
					   ^
			ListSortAndDelDuplicate.C:118:8: error: expected primary-expression before ‘char’
			  list< char > listCollector;
					^
			ListSortAndDelDuplicate.C:118:8: error: expected ‘;’ before ‘char’
			make: *** [Make/linux64GccDPInt32Opt/ListSortAndDelDuplicate.o] Error 1
SOLUTION 
se in openFOAM C++ vogliamo utilizzare list al posto di List dobbiamo inserire la linea 
	using namespace std;
A quel punto potremo usare l'istruzione 
	list< char > listCollector;
senza problemi. 

>> LIST sequence container
[pag658deitel]
the list sequence container (from header <list>) allows insertion and deletion operations at ANY location in the container. If most of the insertions and deletions occur at the ends of the container, the "deque " data structure provides a more efficient implementation. 
Class template list is implemented as a >> doubly linked list (every node in the list contains a pointer to the previous node in the list and to the next node in the list). This enables class template list to support >> bidirectional iterators that allow the container to be traversed both forward and backward. 
>> forward list 
[pag 658 deitel]
a partire da C+11 e' disponibile the forward_list sequence container (header <forward_list>), which is implemented as a >> singly linked list (= every node in the list contains a pointer to the next node in the list). This enables class template list to support forward iterators that allow the container to be traversed in the forward direction. Any algorithm that requires input, output or forward iterators can operate on a forward_list.
Class template list provides also the following member functions:
	>> splice -> pag661 deitel
	>> push_front
	>> pop_front -> pag662 deitel
	>> remove   [see also pag 699 deitel]
	>> remove_copy algorithm [see pag 116 moo book]
the remove_copy algorithm does what remove does, but copies its results to an indicated destination.
	>> remove_if 
	>> remove_copy_if [pag 117 moo book]
remove_copy_if operates like remove_copy, except that it uses a predicate as its test, rather than a value.
	>> unique
	>> merge -> pag662 deitel  [vedi anche poco qui sotto esempio]
	>> reverse 
	>> sort -> pag661 deitel
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line29
/////////////
Several of these member functions are list-optimized implementations of the Standard Library alorithms presented in Chapter 16.
Both push_front and pop_front are also supported by forward_list and deque. 
>> CREATE LIST OBJECTS / >> create objects list / >> list object creation / >> list creation 
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line17-18
   list< int > values; // create list of ints  // line 17
   list< int > otherValues; // create list of ints // line 18
lines 17-18 instantiate two list objects capable of storing ints. 
The following line (line 29) uses list member function sort to arrange the elements in the list in ascending order.
	values.sort(); // sort values  // line 29
NOTE: this is different from the sort in the standard library algorithms.
A second version of function sort allows you to supply a binary predicate function that takes two arguments (values in the list), perform a comparison and returns a bool value indicating whether the first argument should come before the second in the sorted contents. This function determines the order in which the lements of the list are sorted. This version could be particularly useful for a list that stores pointers rather than values.
>> SPLICE list member function / >> splice member function / 
[pag 661 deitel]
Line 39 uses list function splice to remove the elements in otherValues and insert them into values before the iterator position specified as the first argument.
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line39
   // remove otherValues elements and insert at end of values
   values.splice( values.cend(), otherValues );
Ci anche due altre varianti della funzione splice, rispettivamente con 3 e con 4 argomenti see pag 61 deitel
Per esempio Function splice with four arguments uses 
- the last two arguments to specify a range of locations that sould be removed from the container in the second argument 
- and placed at the location specified in the first argument.
>> merge member function list / >> list member function merge 
[pag662 deitel]  
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 54
   // remove otherValues elements and insert into values in sorted order
   values.merge( otherValues );   // line 54
line 54 uses list member function merge to remove all elements of "otherValues" and insert them in sorted order into values. Both lists must be sorted in the same order before this operation is performed.
>> list member function pop_front / >> pop_front list member function 
list function pop_front to remove the first element in the list 
	values.pop_front(); // remove element from front
>> pop_back list member function to remove the last element in the list
	values.pop_back(); // remove element from back 
>> unique / >> duplicate element / >> remove duplicate element in a list 
[pag 662 deitel]
function unique remove duplicate elements in the list. 
IMPORTANTE: The list should be in sorted order (so that all duplicates are side by side) before this operation is performed, to guarantee that all duplicates are eliminated.
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 65
   values.sort();  // prima ordiniamo gli elementi della lista 
   values.unique(); // remove duplicate elements  line 65
   cout << "\nAfter unique, values contains: ";
   printList( values );  
///////

>> size / >> lenght of list 
	std::list<const char *> xDuplicates;
	
	xDuplicates = {"c", "a", "a", "c", "a"};
	std::cout << "total number of elements: " << xDuplicates.size();
	std::cout << '\n';

>> duplicate / >> count duplicate
------------------------------------------------ CODE starts
// source http://www.cplusplus.com/forum/beginner/168895/
// to launch g++ -std=c++11 -o countDuplicateCanovaccio.exe countDuplicateCanovaccio.cpp
#include <algorithm>
#include <iostream>
#include <iterator>
#include <utility>
#include <vector>

int main()
{
    std::vector<int> data {1, 1, 1, 3, 3, 3, 3, 8, 8};
    std::vector<int> unique;
    //http://en.cppreference.com/w/cpp/algorithm/unique_copy
    std::unique_copy(data.begin(), data.end(), std::back_inserter(unique));

    std::vector<std::pair<int, int>> frequency;
    for(int i: unique)
        //http://en.cppreference.com/w/cpp/algorithm/count
        frequency.emplace_back(i, std::count(data.begin(), data.end(), i));

    for(const auto& e: frequency)
        std::cout << "Element " << e.first << " encountered " << e.second << " times\n";
}
------------------------------------------------ CODE ends
OUTPUT 
[serena@localhost Documents]$ g++ -std=c++11 -o countDuplicateCanovaccio.exe countDuplicateCanovaccio.cpp 
[serena@localhost Documents]$ ./countDuplicateCanovaccio.exe 
Element 1 encountered 3 times
Element 3 encountered 4 times
Element 8 encountered 2 times
------------------------------------------------------------------------ ALTERNATIVE using "map": 
// to launch g++ -std=c++11 -o countDuplicateCanovaccio.exe countDuplicateCanovaccio.cpp
#include <algorithm>
#include <iostream>
#include <iterator>
#include <utility>
#include <vector>

int main()
{
    std::vector<int> data {1, 1, 1, 3, 3, 3, 3, 8, 8};
    std::vector<int> unique;
    //http://en.cppreference.com/w/cpp/algorithm/unique_copy
    std::unique_copy(data.begin(), data.end(), std::back_inserter(unique));
    
    std::vector<std::pair<int, int>> frequency;
    for(int i: unique)
        //http://en.cppreference.com/w/cpp/algorithm/count
        frequency.emplace_back(i, std::count(data.begin(), data.end(), i));

    for(const auto& e: frequency)
        std::cout << "Element " << e.first << " encountered " << e.second << " times\n";
}
///////////////////////////////////////////////////////////////////////////////////////////////////
>> swap / >> list member function swap
example /home/dia/Deitel-Code_Examples/ch15/fig15_13/Fig15_13.cpp line 70
   // swap elements of values and otherValues
   values.swap( otherValues );
swap is used to exchange the contents of list "values" with contents of list "otherValues"
NOTE: see anche pag 710 deitel o voce "algorithm swap"
///////
>> assign / >> remove / >> list member functions assign and remove
>> remove element from a list
>> replace element in a list within a certain range -> using assign member function see line 77 below
[pag662 deitel]
the line 77 of the following extract uses list function assign to replace the contents of "values" with the contents of "otherValues" in the range specified by the two iterator arguments. 
the line 86 uses list function remove to delete all copies of the value 4 from the list 
   // replace contents of values with elements of otherValues
   values.assign( otherValues.cbegin(), otherValues.cend() );  ///// line 77
   cout << "\nAfter assign, values contains: ";
   printList( values );
   // remove otherValues elements and insert into values in sorted order
   values.merge( otherValues ); 
   cout << "\nAfter merge, values contains: ";
   printList( values ); 
   values.remove( 4 ); // remove all 4s    ///////////////////////// line 86
   cout << "\nAfter remove( 4 ), values contains: ";
   printList( values );
   cout << endl;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LITERAL CONSTANTS
are used to express particular values within the source code of a program. Literal Constants can be divided in Interger Numerals, Floating Point Numerals, Strings and Boolean Values.
NOTE from mike pag35: "Tron Ignition" is a string literal, while "42" and "72" are numerical literal

>> LOCAL VARIABLE 
variables declared in a function definition's body are known as local variables and can be used ONLY from the line of their declaration in the function to the closing right brace } of the block in which they are declared.
- a local variable must be declared before it can be used in a function. A local variable cannot be accessed outside the function in which it's declared. When a function terminates, the value of its local variables are lost (with the exception of the static local variables).
[pag74deitel]

>> LOGICAL OPERATORS mike pag58
Operator      Description      Sample Expression 
!             Logical NOT      !expression 
&&            Logical AND      expression1 && expression2
||            Logical OR       expression1 || expression2
---------------------------------------------------------
NOTE logical operators precedence 
! > && > ||
! has a higher level of precedence than logical AND, &&, which has a higher precedence than logical OR, ||. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> LOGICAL OPERATORS (!, &&, ||)
- The operator ! is the C++ operator to perform the boolean operation NOT, it has only one operand, located at its right, and the only thing that is does is inverse the value of it. ex:
	!(5 == 5) // evalualte to false since (5==5) 
                 is true
    !(6 <= 4) // evaluate to true because (6 <= 4)
                 would be false      
    !true     // evaluate to false
    !false    // evaluate to true
- The logical operator AND: &&
	a     |   b   | a&&b
	true  | true  | true
	true  | false | false
	false | true  | false
	false | false | false
- The logical operator OR:  ||
	a     |   b   | a||b
	true  | true  | true
	true  | false | true
	false | true  | true
	false | false | false
--------------------------------------------------
[from pag180deitel] 
Logical operators are used to form more complex conditions by combining simple conditions
- AND (&&) operator : used to ensure that  two conditions are both true before we choose a certain path of execution.
example 
if ( spaceshipType == intergalactic && Tons >= 12890 )
	++HeavyDutyVesselUnits;
//
- NB1: the right side of a logical AND expression is evaluated only if the left side is true [this is the so called short-circuit evaluation . Similmente il short circuit avviene con || quando la prima condition is true, inutile to evalute the following condition visto che sia che sia vera o falsa the overall expression is true].
- NB2: in expressions using operator &&, make the condition most likely to be false the leftmost condition. In expression using operator || make the condition most likely to be true the leftmost condition. This use of short-circuit evaluation can reduce a program's execution time.
- NB3: [pag181] una condizione del tipo 3 < x < 7 benche' corretta matematicamente non puo' essere utilizzata tale quale in C++ . 
Use (3 < x && x < 7 ) to get the proper evaluation in C++
- NB4: to make the combined condition more readable you can add redundant parenthesis:
	if ( ( spaceshipType == intergalactic )  && ( Tons >= 12890 ) )	
		++HeavyDutyVesselUnits;
- NB4: the && operator has a higher precedence than the || operator. Both operators associate from left to right.
----------------------------------------------------
LOGICAL OPERATOR EXAMPLE 
[pag183deitel]
Code_Examples/ch05/fig05_18/fig05_18.cpp
  3 #include <iostream>
  4 using namespace std;
  5
  6 int main()
  7 {
  8    // create truth table for && (logical AND) operator
  9    cout << boolalpha << "Logical AND (&&)"
 10       << "\nfalse && false: " << ( false && false )
 11       << "\nfalse && true: " << ( false && true )
 12       << "\ntrue && false: " << ( true && false )
 13       << "\ntrue && true: " << ( true && true ) << "\n\n";
 14
 15    // create truth table for || (logical OR) operator
 16    cout << "Logical OR (||)"
 17       << "\nfalse || false: " << ( false || false )
 18       << "\nfalse || true: " << ( false || true )
 19       << "\ntrue || false: " << ( true || false )
 20       << "\ntrue || true: " << ( true || true ) << "\n\n";
 21
 22    // create truth table for ! (logical negation) operator
 23    cout << "Logical NOT (!)"
 24       << "\n!false: " << ( !false )
 25       << "\n!true: " << ( !true ) << endl;
 26 } // end main
//==================================================//

>> LOGICAL OPERATOR example mike pag58
// Designers Network
// Demonstrates logical operators
#include <iostream>
#include <string>
using namespace std;
int main() 
{
	string username;
	string password;
	bool success;

	cout << "\tGame Designer's Network\n";

	do
	{
		cout << "\nUsername: ";
		cin >> username; 

		cout << "Password: ";
		cin >> password; 

		if (username == "S.Meier" && password == "civilization")
		{
			cout << "\nHey, Sid.";
			success = true;
		}

		else if (username == "S.Miyamoto" && password == "mariobros")
		{
			cout << "\nWhat's up, Shigeru?";
			success = true;
		}

		else if (username == "W.Wright" && password == "thesims")
		{
			cout << "\nHow goes it, Will?";
			success = true;
		}

		else if (username == "guest" || password == "guest")
		{
			cout << "\nWelcome, guest.";
			success = true;
		}

		else
		{
			cout << "\nYour login failed.";
			success = false;
		}
	} while (!success);   // while (true) cioe while true == !success cioe' finche not successul is true continua a loopare.

    return 0;
}
//
------------------------------
NOTE: al posto di (username == "guest" || password == "guest") si possono anche introdurre per maggior leggibilita' delle >> redundant parentheses:
	( (username == "guest") || (password == "guest") )
while the extra parentheses don't change the meaning of the expression, they really help the two smaller expressions, joined by the || operator, stand out.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> long double : long double precision floating point number 
size: 8byte 
range: +/-1.7e+308 =(~15 digits)

>> long int (long) = long integer
size 4 bytes (= 32bits visto che 1byte = 8bit)
signed: -2147483648
unsigned long int : 0 till 4294967295
In C++11 is also available 
	unsigned long long int 
(which can be abbreviated as unsigned long long). On some systems enables you to store values in 8 bytes (64bits) which can hold numbers as large as 18,446,744,073,709,551,615 (~ 18 miliardi di miliardi)
[pag251deitel]

>> MMMMMMM

>> main ()
The main function is the point by where ALL C++ programs start their execution, independently of its location within the source code. In un classico programma potrai ad esempio veder scritto 
int main () 
The word main is followed by a pair of parenthesis (). That is because is a function declaration. In C++ what differentiate a function declaration from other types of expressions are these parentheses that follow its name. Optionally, these parenthesis may enclose a list of parameters within them. Right after these parenthesis we can find the body of the main function enclosed in braces {}. What is contained within these braces is what the function does when it is executed. 

>> median search inside a vector [example pag 43-45 moo book]
FULL PROGRAM ------------------------------------------------
	#include <algorithm>
	#include <iomanip>
	#ifndef __GNUC__
	#include <ios>
	#endif
	#include <iostream>
	#include <string>
	#include <vector>
	
	using std::cin;             using std::sort;
	using std::cout;            using std::streamsize;
	using std::endl;            using std::string;
	using std::setprecision;    using std::vector;
	
	int main()
	{
		// ask for and read the student's name
		cout << "Please enter your first name: ";
		string name;
		cin >> name;
		cout << "Hello, " << name << "!" << endl;
	
		// ask for and read the midterm and final grades
		cout << "Please enter your midterm and final exam grades: ";
		double midterm, final;
		cin >> midterm >> final;
	
		// ask for and read the homework grades
		cout << "Enter all your homework grades, "
		        "followed by end-of-file: ";
	
		vector<double> homework;
		double x;
		// invariant: `homework' contains all the homework grades read so far
		while (cin >> x)
			homework.push_back(x);
	
		// check that the student entered some homework grades
	#ifdef _MSC_VER
		typedef std::vector<double>::size_type vec_sz;
	#else
		typedef vector<double>::size_type vec_sz;
	#endif
		vec_sz size = homework.size();
		if (size == 0) {
			cout << endl << "You must enter your grades.  "
			                "Please try again." << endl;	
			return 1;
		}
	
		// sort the grades
		sort(homework.begin(), homework.end());
	
		// compute the median homework grade
		vec_sz mid = size/2;
		double median;
		median = size % 2 == 0 ? (homework[mid] + homework[mid-1]) / 2
		                       : homework[mid];
	
		// compute and write the final grade
		streamsize prec = cout.precision();
		cout << "Your final grade is " << setprecision(3)
		     << 0.2 * midterm + 0.4 * final + 0.4 * median
		     << setprecision(prec) << endl;
	
		return 0;
	}
	

FULL PROGRAM END --------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> median  function to computer
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/median.cc]
[pag53 moo book]
	// source file for the `median' function
	#include <algorithm>    // to get the declaration of `sort'
	#include <stdexcept>    // to get the declaration of `domain_error'
	#include <vector>       // to get the declaration of `vector'
	
	using std::domain_error;   using std::sort;   using std::vector;
	
	#include "median.h"
	
	// compute the median of a `vector<double>'
	// note that calling this function copies the entire argument `vector'
	double median(vector<double> vec)
	{
	#ifdef _MSC_VER
		typedef std::vector<double>::size_type vec_sz;
	#else
		typedef vector<double>::size_type vec_sz;
	#endif
	
		vec_sz size = vec.size();
		if (size == 0)
			throw domain_error("median of an empty vector");  // throw exception
	
		sort(vec.begin(), vec.end());
	
		vec_sz mid = size/2;
	
		return size % 2 == 0 ? (vec[mid] + vec[mid-1]) / 2 : vec[mid];
	}
///////////////////////////////////////////////////////////////////////////////////////////

>> manipulator see pag 4 moo book
example 
	std::endl is a manipulator
The key property of manipulators is that writing a manipulator on a stream manipulates the stream. 
In the case of std::endl the action is to end the current line of output.

>> RANDOM NUMBER mike pag64
In short 
	#include <cstdlib>
	int randomNumber = rand(); // generate random number
NOTE: the rand() function generates a random number between 0 and at least 32767. The exact upper limit depends on your implementation of C++. The upper limit is stored in the constant RAND_MAX, which is defined in cstdlib. So if you want to know the maximum random number rand() can generate, just send RAND_MAX to cout.
--------------------------------------------------------------------------
EXAMPLE:
--------
// Die Roller
// Demonstrates generating random numbers

#include <iostream>
#include <cstdlib>  // this file contiene (among other things) functions that deal with generating random numbers. Because we included the file we are then free to call the functions it contains, includeing the function rand(), which is what we do in main()
#include <ctime>

using namespace std;

int main()
{
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time

	int randomNumber = rand(); // generate random number. In questo caso tra le parentesi tonde non vi e' alcun argument visto che rand non ha bisogno di alcun input per generare un numero random
	cout << " il massimo valore che puo' assumere random number nella tua implementazione C++ e' " << RAND_MAX << endl;
	int die = (randomNumber % 6) + 1; // get a number between 1 and 6
	cout << "You rolled a " << die << endl;

    return 0;
}
----------------------
OUTPUT:
C:\Users\alsdia\Documents\MikeCppCodeExamples\Tron\Debug>tron.exe
 il massimo valore che puo' assumere random number nella tua implementazione C++ e' 32767
You rolled a 2
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> SEED RANDOM NUMBER GENERATOR / >> seeding random number / >> srand [mike pag66]
IN SHORT
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
IN LONG 
Computers generate pseudorandom numbers (not truly random numbers) based on a formula. One way to think about this is to imagine that the computer reads from a huge book of predetermined numbers. By reading from this book, the computer can appear to produce a sequence of random numbers. 
But there's a problem: the computer always starts reading the book from the beginning. Because of this the computer will always produce the same series of random numbers in a program. In games, this ins't something we would want.
A solution to this problem is to tell the computer to start reding from some arbitrary place in the book when a game program begins. This process is called seeding the random number generator. Game programmers give the random number generator a number , called a seed, to determine the starting place in this sequence of pesudorandom numbers.
(sembra che sia proprio cio' che bisognerebbe introdurre nel codice di shuffle/random play dell'ipod) 
example:
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
the previous line seeds the random number generator. It seeds the random number generator based on the current date and time, which is perfect since the current date and time will be different for each run of the program.
In term of the actual code, the srand() function seed the random number generator (you just have to pass it an unsigned int as a seed). What gets passed to the function here is the return value of time(0), a number based on the current system date and time. 
[ah bene >> cast : nota come nella frase seguente mike usi cast in maniera chiara cast = convertire, "casting a value from one type to another" significa "convertire una variabile da un tipo ad un altro, per esempio convertire un signed integer into an unsigned integer.]
The code static_cast<unsigned int> just converts (or casts) this value to an unsigned int.
If you want to generate a series of random numbers that are different each time the program is run, your program should execute this line once before making calls to rand().
Example 
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
	int randomNumber = rand(); // generate random number
>> SHUFFLE [pag127 and 128 mike]
standard library algorithms can work also with containers defined outside of the STL. These containers only have to meet certain requirements. For example, even though string objects are not part of the STL, you can use appropriate STL algorithms on them.
example of >> shuffle the characters in a word:
	string word="High Scores";
	random_shuffle(word.begin(), word.end());
the preceding code randomly shuffles the characters in "word".  As you can see, string objects have both begin() and end() member functions, which return iterators to the first character and one past the last character, respectively. That's part of the reason why STL algorithms work with strings (because they are designed to)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> RANDOM NUMBER WITHIN RANGE [mike pag 67 ]
puoi usare il modulus operator 
	(numeroRandom % maxRangeDesiderato) + 1; // donera' un numero tra 1 e maxRangeDesiderato
del resto ogni numero diviso by maxRangeDesiderato, donera' un remainder between 0 and maxRangeDesiderato.
example:
	srand(static_cast<unsigned int>(time(0)));  // seed random number generator based on current time
	int randomNumber = rand(); // generate random number
	int die = (randomNumber % 6) + 1; // get a number between 1 and 6
	cout << "You rolled a " << die << endl;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> math algorithms / >> mathematical algorithms / >> algorithm mathematical
[pag702 deitel]
please refer to /home/dia/Deitel-Code_Examples/ch16/fig16_05/fig16_05.cpp 
Nel sopra citato programma trovi utili funzioni:
>> random_shuffle algorithm 
	random_shuffle( a1.begin(), a1.end() );
la precedente linea uses the random_shuffle algorithm to reorder randomly the elements in the range a1.begin() up to but not including a1.end().
Note: thie version of random_shuffle uses rand for randominzation and produces the same results each time you run the program unless you seed the random-number generator with srand.
>> count 
puoi usare questo algorithm per individuare quante volte un certo elemento e' presente all'interno di un vettore. 
esempio:
	int result = count( a2.cbegin(), a2.cend(), 8 );
la precedente linea uses the count algorithm to count the elements with the value 8 in the range a2.cbegin() up to, but not including a2.cend(). This algoirthm requires its two iterator arguments to be at least input iterators.
>> count_if : per individuare quanti elementi all'interno di un vettore sono piu' grandi di un certo valore. Example: trovare tutti gli elementi che sono piu' grandi di 9
	 result = count_if( a2.cbegin(), a2.cend(), greater9 );
>> min_element : per individuare l'elemento piu' piccolo all'interno di un vettore 
   cout << "\n\nMinimum element in a2 is: "
      << *( min_element( a2.cbegin(), a2.cend() ) );
NOTE: error-prevention: it's a good practice to check that the range specified in a call to min_element is not empty and that the return value is not the "past the end" iterator.
>> max_element [pag 705 dietel]: algorithm utilizzato per individuare l'elemento piu' grande all'interno di un vettore.
   cout << "\nMaximum element in a2 is: "
      << *( max_element( a2.cbegin(), a2.cend() ) );
>> minmax_element  [algorithm disponibile a partire da C++11]
with this algorithm you can locate both the smallest and largest elements in un vettore.
If there are duplicate smallest or largest elements, the iterators are located at the first smallest and last largest values.
   auto minAndMax = minmax_element( a2.cbegin(), a2.cend() );
   cout << "\nThe minimum and maximum elements in a2 are "
      << *minAndMax.first << " and " << *minAndMax.second
      << ", respectively";
>> accumulate  [utile per esempio mi pare per calcolare la >> media / >> average nel senso che se sei il numero di elementi bastera' dividere il risultato ottenuto da accumulate per il numero di elementi]
   // calculate sum of elements in a1
   cout << "\n\nThe total of the elements in a1 is: "
      << accumulate( a1.cbegin(), a1.cend(), 0 );
La linea precedente uses the accumulate algorithm (the template of which is in header <numeric>) to sum the values in the range from a1.cbegin() up to, but not including a1.cend().
>> for_each algorithm
[pag706 deitel] 
from /home/dia/Deitel-Code_Examples/ch16/fig16_05/fig16_05.cpp
   // output square of every element in a1
   cout << "\n\nThe square of every integer in a1 is:\n";
   for_each( a1.cbegin(), a1.cend(), outputSquare ); 
La precedente linea 59 uses the for_each algorithm to apply a general function to every element in the range from a1.cbegin() up to, but not including a1.cend().
>> transform algorithm
[pag706 deitel]
 63    // calculate cube of each element in a1; place results in cubes
 64    transform( a1.cbegin(), a1.cend(), cubes.begin(), calculateCube );
 65    cout << "\n\nThe cube of every integer in a1 is:\n";
 66    copy( cubes.cbegin(), cubes.cend(), output );
 67    cout << endl;
line 63 uses the transform algorithm to apply a general function to every element in the range from a1.cbegin() up to, but not including a1.cend().  
-----------------------------------------------------------------------
eccoti l'output offerto dal programma [compilato on visual studio 2013]
////////////// OUTPUT
	a1 before random_shuffle: 1 2 3 4 5 6 7 8 9 10
	a1 after random_shuffle: 9 2 10 3 1 6 8 4 5 7
	
	a2 contains: 100 2 8 1 50 3 8 8 9 10
	Number of elements matching 8: 3
	Number of elements greater than 9: 3
	
	Minimum element in a2 is: 1
	Maximum element in a2 is: 100
	The minimum and maximum elements in a2 are 1 and 100, respectively
	
	The total of the elements in a1 is: 55
	
	The square of every integer in a1 is:
	81 4 100 9 1 36 64 16 25 49
	
	The cube of every integer in a1 is:
	729 8 1000 27 1 216 512 64 125 343
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MEMBER FUNCTIONS 
NOTES from pag383deitel: only the simplest and most stable memeber functions (i.e. whose implmentations are unlikely to change) should be defined in the class header. 
Member functions vs Global Functions (also called Free functions)
Usually members function calls are more concise than conventional function calls in procedural programming. Cioe' per esempio una funzione procedurale in matlab ti richiede per esempio di listare tutti i parametri di input che dovra' processore
	nomeFunzioneProcedurale(param1, param2, ... paramN)
rendendo la chiamata lunga, tediosa e con il rischio di dimenticare qualche parametro. 
Invece con un approccio object oriented la chiamata di una funzione si puo' spesso ridurre a member functions that take no arguments, tipo:
	nomeMemberfunction()  [see esempio pratico pag381deitel]
A) Using an object-oriented programming approach often simplifies function calls by reducing the number of parameters. This benefit derives from the fact that encapsulating data members and meber functions within a class, gives the member functions the right to access the data members
-----------------------\
| CLASS                 |
------------------------| 
| data members  <-----\ | 
|                     | | member functions can access data members that are encapsulated in the same class
| member functions ---/ |
\----------------------/
B) Member functions are usually shorter than functions in non-object-oriented programs, because the data stored in data members have ideally been validated by a constructor or by member functions that store new data. Because the data is already in the object, the member-function calls often have no arguments or fewer than function calls in non-object-oriented languages. Thus, the calls, the function definitions and the function prototypes are shorters.This improves many aspects of program development
B) The fact that membe function calls generally take either no arguments or substantially fewer arguments than conventional function calls in non-object-oriented languages reduces the likelihood of passing the wrong arguments, the wrong types of arguments or the wrong number of arguments. 
////////////////////////////////////////////////////////////////////////////////////////////////////////

>> member functions vs non member functions / >> non member function vs member function
pag466 deitel

>> MEMBER FUNCTION const non-const member function combination / >> COMBINATION MEMBER FUNCTION ON CONST OBJECT
[pag403 deitel]
fig9.16 shows various member-function call combination on objects example 
- non-const member function on a non-const object OK 
- const member function on a non-const object OK 
- const member function on a const object  OK 
- non-const member function on a const object DAME!!!! non si puo' modificare un constant object.
NOTE1: calling a non constant member function on a constant object generates a compilation error. 
NOTE2: a constructor must be anon-const member function, but it can still be used to initialize a const object
NOTE3: invoking a non-const member function from the constructor call as part of the initialization of a const object is allowed.
NOTE4 [pag404 comet star tag]: a call of a non constant member function on a constant object non e' ammesso neppure nel caso in cui la member function doesn't modify the object. The function must explicitly be declare constant. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MEMBER INITIALIZERS
[pag404deitel]
An class's constructor can pass arguments to member-object constructors via member initializers. 
NOTE: data members are constructed in the order in which they're declared in the class definition (not in the order they're listed in the constructor's member initializer list) and before their enclosing class objects (sometimes called >> host objects) are constructed.

>> MEMBER ACCESS LEVELS [pag249 mike game programming]
Like functions you should treat objects as encapsulated entities. This means that, in general, you should avoid directly altering or accessing an object's data members. Instead, you should call an object's member functions, allowing the object to maintain its own data members and ensure their integrity. Fortunately, you can enforce data member restrictions when you define a class by setting member access levels.
--------------------------------------------------------------------------------- START FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/private_critter.cpp]
	//Private Critter
	//Demonstrates setting member access levels
	
	#include <iostream>
	
	using namespace std;
// declaring a class for critters that restricts direct access to an object's data member for its hunger level	
	class Critter
	{
	public:            // begin public section
	    Critter(int hunger = 0);
// the member function GetHunger allows access to the data member 
	    int GetHunger() const; 
// the member function SetHunger allows changes to the data member
	    void SetHunger(int hunger);
	    
	private:           // begin private section
	    int m_Hunger;   // the access of the hunger level is restricted
	};
	
	Critter::Critter(int hunger): 
	    m_Hunger(hunger)
	{
	    cout << "A new critter has been born!" << endl;
	}
	
// >> ACCESSOR MEMBER FUNCTION DEFINITION [pag252 mike game programming]. An accessor member function allows indirect accesss to a data member. Because m_Hunger is private, we wrote an accessor member function, GetHunger(), to return the value of the data member. 
	int Critter::GetHunger() const
	{
	    return m_Hunger;
	}
	
	void Critter::SetHunger(int hunger)
	{
	    if (hunger < 0)
		{
	        cout << "You can't set a critter's hunger to a negative number.\n\n";
		}
// when the program attempts to change the critter's hunger level to an illegal value, we catch the illegal value and do not make the change.
	    else
		{
	        m_Hunger = hunger;
		}
	}
	
	int main()
	{
	    Critter crit(5);  
	    //cout << crit.m_Hunger; -- illegal, m_Hunger is private!
	    cout << "Calling GetHunger(): " << crit.GetHunger() << "\n\n";
	   
	    cout << "Calling SetHunger() with -1.\n";
	    crit.SetHunger(-1);
	    
	    cout << "Calling SetHunger() with 9.\n";    
	    crit.SetHunger(9);
// usiamo l'accessor member function "GetHunger" to access the private data member m_Hunger
	    cout << "Calling GetHunger(): " << crit.GetHunger() << "\n\n";
	    
	    return 0;
	}
// >> ACCESSOR MEMBER FUNCTION: what's the point of all this hassle?!
// At this point, you might be wondering why you'd go to the trouble of making a data member private only to grant full access to it through accessor functions. The answer is that you don't generally grant full access. For example in the SetHunger accessor member function, first we check to make sure that the value passed to the member function is greater than zero. If it's not, it's an illegal value, and we display a message leaving the data member unchanged. If the value is greater than zero. then we make the change. This way, SetHunter() protects the integrity of m_Hunger, ensuring that it can't be set to a negative number. Just as we've done here, most game programmers begin their accessor member function names with Get or Set. 
--------------------------------------------------------------------------------- END FULL EXAMPLE
OUTPUT PROGRAM:
	A new critter has been born!
	Calling GetHunger(): 5
	
	Calling SetHunger() with -1.
	You can't set a critter's hunger to a negative number.
	
	Calling SetHunger() with 9.
	Calling GetHunger(): 9
---------------------------------------------------------------------------------
>> PUBLIC AND >> PRIVATE ACCESS LEVELS [pag251 mike game programming]
Every class data member and member function has an access level, which determines where in your program you can access it. In the program right above we start a public session. [>> PUBLIC MEANING] By using "public:" I'm saying that any data member or member function that follows (until another access level specifier) will be public. This means that any part of the program can access them.
		class Critter
		{
		public:            // begin public section
		    Critter(int hunger = 0);
	// the member function GetHunger allows access to the data member 
		    int GetHunger() const; 
// NOTE: because we have declared these member functions within a public section, it means that any part of our code can call any member function through a Critter object.
	// the member function SetHunger allows changes to the data member
		    void SetHunger(int hunger);
// we now specify a private section [>> PRIVATE MEANING] By using "private:" we're saying that any data member or member function that follows (until another access level specifier) will be private. This means that only code in the Critter class (i.e. the current class we are writing in) can directly access it   
		private:           // begin private section
		    int m_Hunger;   // the access of the hunger level is restricted
		};
-------------------------------
NOTE: you can repeat access modifiers. So if you want, you could have a private section, followed by a public section, followed by another private section in a class. 
NOTE2: member access is private by default. Until you specify an access modifier, any class members you declare will be private.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> CONSTANT MEMBER FUNCTION [pag253 mike game programming]
Constant member function can't modify a data member of its calls or call a non constant member function of its class. It protects you from accidentally altering a data member in the member function. 
You can declare a constant member function by putting the keyword const at the end of the function header. 
	int GetHunger() const;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PRIVATE vs PUBLIC / >> PUBLIC vs PRIVATE / >> PUBLIC versus PRIVATE 
[pag144 jesse]
The private and public keywords are used with member of a class
	where member of a class can be 
		- data members 
		- member methods (chiamate anche "functions")
All members of a class are private, by default. 
To make this a bit clearer, consider this example of class declaration :
	class Cat
	{
		unsigned int itsAge;
		unsigned int itsWeight;
		void Meow();
	};
In this declaration, itsAge, itsWeight, and Meow() are all private because all members of a class are private by default. Unless you specify otherwise, they are private. If you create a program and try to write the following within main (for example):

	int main()
	{
		Cat Boots;
		Boots.itsAge = 5;  // error! can't access private data!

The compiler flags this as an erro. In effect, by leaving theses members as private, you've said to the compiler "I'll access itsAge, itsWeight, and Meow() only from within member functions of the Cat class". Yet, here you've accessed the itsAge member variable of the Boots object from outside a Cat method. Just becuase Boots is an object of class Cat, that doesn't mean that you can access the parts of Boots that are private (even though they are visible in the declaration).
This is source of endless confusion to new C++ programmers. I can almost hear you yelling "Hey! I just said Boots is a Cat. Why can'T Boots access his own age?" The answer is that Boots can, but you can't. Boots, in his won methods, can access all his parts (public and private). Even though you've created a Cat, that doesn't mean that you can see or change the parts of it that are private. 
The way to use Cat so that you can access the data members is to make some of the members public:
	class Cat
	{
	  public:
		unsigned int itsAge;
		unsigned int itsWeight;
		void Meow();
	};
In this declaration itsAge, itsWeight, and Meow() are all public. Boots.itsAge = 5; from the previous example will compile without problems. 
NOTE: the keyword public applies to all members in the declaration until they key-word private is encountered and vice-versa. This lets you easily declare sections of your class as public or private.
Il seguente esempio shows the declaration of a Cat class with public member variables:
-------------------------------------------------------------------------------------
// Demonstrates declaration of a class and
// definition of an object of the class,
  
#include <iostream>   
  
class Cat               // declare the Cat class
{
  public:               // members which follow are public
    int itsAge;         // member variable
    int itsWeight;      // member variable
};         // note the semicolon
  
int main()
{
   Cat Frisky; // Frisky is defined as an instance of a "Cat", that is as a "Cat" object
   Frisky.itsAge = 5;    // assign to the member variable
   std::cout << "Frisky is a cat who is " ;
   std::cout << Frisky.itsAge << " years old.\n";
   return 0;
}

-------------------------------------------------------------------------------------
MAKING MEMBER DATA PRIVATE. WHY? WHAT'S THE POINT? [see pag147 jesse to discover the advantages]
As a general rule of design, you should keep the data members of a class private. Of couse, if you make all of the data members private, you might wonder how you access information about the class. For example, if itsAge is private, how would you be ale to set or get a Cat object's age?
[>> accessor / >> accessors / >> accessor methods] [pag147 jesse]
To access private data in a class, you must create public functions known as accessor methods. Use these methods to set and get the private member variables. These accessor methods are the member function that other parts of your program call to get and set your private member variables. 
A public accessor method is a class member function used either to read (get) the value of a private class member variable or to set its value. 
Why bother with this extra level of indirect access? Why add extra functions when it is simpler and easier to use the data directly? Why work through accessor functions?
The answer to these question os that accessor functions enable you to separate the details of how the dat is sotred from how it is used. By using accessor functions, you can later change how the data is stored without having to rewrite any of the other functions in your programs that use the data. 
If a function that need to know a Cat's age accesses itsAge directly, that function would need to be rewritten if you, as the author of the Cat class, decided to change how that data is stored. By having the function call GetAge(), your Cat class can easily return the right value no matter how you arrive at the age. The calling function doesn't need to know whether you are storing it as an unsigned  integer or a long, or whether you are computing it as needed. 
This technique makes your program eaiser to maintain. It gives your code a longer life because design changes don't make your program obsolete.
In addition, accessor functions can include additional logic, for instance, if a Cat's age is unlikely to be more than 100, or its weight is unlikely to be 1000. These values should probably not be allowed. An accessor function can enforce this types of restrictions as well as do other tasks. 
The following listing shows the Cat class modified to include private member data and public accessor methods. Note, this is not a listing that can be run if it ic compiled.
  1 // Cat class declaration
  2 // Data members are private, public accessor methods
  3 // mediate setting and getting the values of the private data
  4 
  5 class Cat
  6 {
  7   public:      // this is the access control keyword used to declare the following methods as public
  8     // public accessors
  9     unsigned int GetAge();                 // public method 1  - accessor method to get the age
 10     void SetAge(unsigned int Age);         // public method 2  - accessor method to set the age
 11 
 12     unsigned int GetWeight();              // public method 3  - accessor method to get the weight
 13     void SetWeight(unsigned int Weight);   // public method 4  - accessor method to set the weight
 14 
        // the above accessors methods (or you can also called them "accessor functions") set the member variables and return their values. 

 15     // public member functions
 16     void Meow();                           // public method 5  - this is NOT an accessor function, since it does not get or set a member variable. It performs another service for the class, printing the word "Meow"
 17 
 18     // private member data
 19   private:
 20     unsigned int  itsAge;                  // declaration of member variable itsAge
 21     unsigned int  itsWeight;               // declaration of member variable itsWeight
 22 };
-------------------------------------------------------------------------------------------------------------
 Declaring methods or data private enables the compiler to find programming mistakes before they become bugs. Any programmer worth his consulting fees can find a way around privacy if he wants to. Stroustrup said "The C++ access control mechanisms provide protection against accident, not againt fraud."
-------------------------------------------------------------------------------------------------------------
>> SUMMARY terminologia >> class vs >> object vs >> class member data (>> member data) vs >> class method / >> class function. 
The class keyword 
Syntax for the class keyword is as follows

	class class_name 
	{
		// access control keyword here
		// class variables and methods declared here 
	};

You use the class keyword to declare new types. 
A class is a collection of
	1) class member data (= variables of various types, including other classes)
	2) class function (also called class methods). These are functions used to manipulate tha data in the class and to perform other services for the class. 

You define >> objects of the new type in much the same way in which you define any variable. State the type (class) and then the varible name (the object). You access the class members and functions by using the dot (.) operator. 

You use >> access control keyword to declare sections of the class as public or private. The default for access control is private. Each keyword changes the access control from that point on to the end of the class or until the next access control keyword. Class declaration end with a closing brace and a semicolon. 
---------------------------------------------------------------------
Example 1
---------
class Cat
{
	public: // usi la access control keyword "public" in modo da definire i seguenti data and methods/functions as public
		unsigned int Age;      // class member data Age
		unsigned int Weight;   // class member data Weight
		void Meow();           // class function Meow
};  // qui termina la definizione della classe  

Cat Frisky;     // definisci l'oggetto Frisky, il cui type e' la classe Cat
Frisky.Age = 8; // accedi alla class member data Age using the . operator e gli assegni il valore 8
Frisky.Weight = 18;
Frisky.Meow();  // accedi alla class function Meow() using the . operator Non c'e' bisogno di somministrare alcun parametro alla funzione Meow visto che e' giusto una funzione che printa il verso del gatto. 
-----------------------------------------------------------------------

Example 2 
---------
class Flyer
{
	public :     					// the next five are public
		void Start();
		void Accelerate();
		void Brake();
		void SetYear(int year);
		int GetYear();
	
	private:     					// the rest is private
		int Year;
		Char Model [255];
};               					// end of class declaration 

Flyer OldFaithful;    				// make an instance of the flyer
int bought;							// local variable of type int
OldFaithful.SetYear(84);			// assign 84 to the year
bought = OldFaithful.GetYear();		// set bought to 84
OldFaithful.Start();				// call the start method

-------------------------------------------------------------------
in conclusione 
DO
	DO use public accessor methods. 
	DO access private member variables from within class member functions. 
DON'T
	DON'T declare member variables public
	DON'T try to use private member variables from outside the class.
Detto ancora in parole piu' spicciole: le funzioni son PUBBLICHE ma cio' i dati su cui operano sono PRIVATE. Una classe ben costruita e' insomma come un ufficio di amministrazione pubblica che funzioni a dovere. I funzionari son pubblici, qualunque cittadino puo' venire a richiedere i suoi servizi, ma i dati su cui il funzionario opera son privati e il cittadino non puo' pretendere di avere un accesso diretto a tali dati. 

NOTE: >> member function vs method / >> method vs member function: the terms memberfunction and method can be used interchangeably.

--------------------------------------------------------------------
>> CLASS IMPLEMENTATION / >> IMPLEMENTATION OF A CLASS [pag150 jesse]
Each accessor function (= that provides a public interface to the private member data of the class) along with any other class methods that you declare, must have an implementation. The implementation is called the function >> definition.
[>> definition of a function = implementazione della funzione]
a function definition assume la seguente struttura 
// return type that will come from the function | name of the class | two colons | name of the function | function's parameters   
   void                                           Cat                 ::           SetAge                 (int Age)
-------------------------------------------------------------------------------------------------------------------------------
Example listing 6.3 [/home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/List0603.cpp]
  1 // Demonstrates declaration of a class and
  2 // definition of class methods,
  3 #include <iostream>         // for cout
  4 
  5 class Cat                   // begin declaration of the class
  6 {
  7   public:                   // begin public section
  8     int GetAge();           // accessor function
  9     void SetAge (int age);  // accessor function
 10     void Meow();            // general function
 11   private:                  // begin private section
 12     int itsAge;             // member variable
 13 };
 14 // definition of the member function GetAge()
 15 // GetAge, Public accessor function 
 16 // returns value of itsAge member
 17 int Cat::GetAge()       // NOTE: "Cat::" e' la sintassi richiesta per indicare al compiler that the GetAge() function you are defining here is the one that you declared in the Cat class. 
 18 {
 19    return itsAge;
 20 }
 21 
 22 // definition of SetAge, public
 23 // accessor function
 24 // sets itsAge member
 25 void Cat::SetAge(int age)
 26 {
 27    // set member variable itsAge to
 28    // value passed in by parameter age
 29    itsAge = age;
 30 }
 31 
 32 // definition of Meow method
 33 // returns: void
 34 // parameters: None
 35 // action: Prints "meow" to screen
 36 void Cat::Meow()
 37 {
 38    std::cout << "Meow.\n";
 39 }
 40 
 41 // create a cat, set its age, have it
 42 // meow, tell us its age, then meow again.
 43 int main()
 44 {
 45    Cat Frisky;
 46    Frisky.SetAge(5);   // note that the method is called by using the object name "Frisky" followed by the member operator "." and the method name "SetAge"
 47    Frisky.Meow();
 48    std::cout << "Frisky is a cat who is " ;
 49    std::cout << Frisky.GetAge() << " years old.\n";
 50    Frisky.Meow();
 51    return 0;
 52 }
-------------------------------------------------------------------------------------------------------------
>> CONSTRUCTORS / >> DESTRUCTORS [pag153 jesse]
IN SHORT
	CONSTRUCTORS = is a special member function used to initialize the member data of a class
	DESTRUCTORS = clean up after your object and free any resources or memory that might have allocated
IN LONG 
Two ways exist to define an integer variable. You can define the variable and then assign a value to it later in the program. For example 
	int Weight;     // define a variable 
	...				// other code here
	Weight = 7;		// assign it a value
Or you can define the integer and immediately initialize it. For example:
	int Weight = 7;		// define and initialize to 7
Initialization combines the definition of the variable with its initial assignment. Nothing stops you from changing that value later. Initialization ensures that your variable is never without a meaningful value. 
How do you initialize the member data of a class? You can initialize the member data of a class using a special member function called a constructor. The constructor can take parameters as needed, but it cannot have a return value (not even "void"). The constructor is a class method with the same name as the class itself.
Whenever you declare a constructor, you'll also want to declare a destructor. Just as constructors create and initialize objects of your class, destructors clean up after your object and free any resources or memory that you might have allocated (either in the constructor, or throughout the lifespan of the object). A destructor always has the name of the class, preceded by a tilde(~). Destructors take no arguments and have no return value. If you were to declare a destructor for the Cat class, its declaration would look like the following:
	~Cat();
>> ~ = meaning -> quando lo vedi signica che ti trovi davanti a un destructor used to clean up after your object and free any resources or memory that you might have allocated
[Ciccio detto in parole semplici: Constructor is a tool to avoid having data members not inizialized, quindi ti evita che i tuoi data members che ti accingi ad utilizzare portino con se' garbage senza significato. Vedi il team di Constructor e Deconstructor un po come il team di pulizia dello Shinkansen. Prima che salgano i nuovi passeggeri settano tutto a posto, portano via cartacce, rimuovono i morti d'infarto, se ricevono il parametro d'input dal manager mettono nella VIP carrozza una rosa per lady D. Il destructor e' il team che interviene una volta terminato il viaggio, non hanno bisogno di parametri di input, la loro funzione giusto lasciare lo shinkasen tutto bello vuoto e pulito.]
-------------------------------------------------------------------------------------------------------------
>>DEFAULT CONSTRUCTOR and DESTRUCTOR [pag153 jesse]
Many types of constructors are available; some take arguments, others do not. The one that takes no arguments is called the default constructor. There is only one destructor. Like the default constructor, it takes no arguments. 
It turns out that if you don't create a constructor or a destructor, the compiler provides one for you. The constructor that is provided by the compiler is the default constructor. 
The default constructor and destructor created by the compiler don't have arguments. In addition they don't appear to do anything! If you want them to do something, you must create your own default constructor or destructor. 
Using the Default Constructor 
Quando nel programma sopra avevamo scritto 
	Cat Frisky; // che crea un nuovo oggetto chiamato Frisky della classe Cat
this is interpreted as a call to the default constructor. It provides no parameters and it leaves off the parentheses.
As a matter of form, it is always recommended that you define a constructor, and set the member varaibles to appropriate defaults, to ensure that the object will always behave correctly. Also as a matter of form, if you decalre a constructor, be certain to declare a destructor, even if your destructor does nothing. Although it is true that the default destructor would work correctly, it doesn't hurt to declare your own. It makes your code clearer. 
In the following listing we rewrite the Cat class to use a non default constructor to inizialize the Cat object, setting its age to whiatever initial age you provide, and it demonstrates where the destructor is called.
------------------------------------------------------------------------------- [/home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/List0604.cpp]
1 // Demonstrates declaration of  constructors and
  2 // destructor for the Cat class
  3 // Programmer created default constructor
  4 #include <iostream>        // for cout
  5 
  6 class Cat                  // begin declaration of the class
  7 {
  8   public:                  // begin public section
  9     Cat(int initialAge);   // constructor that takes an integer. 
 10     ~Cat();                // destructor (it takes no parameters)
 11     int GetAge();          // accessor function
 12     void SetAge(int age);  // accessor function
 13     void Meow();
 14   private:                 // begin private section
 15     int itsAge;            // member variable
 16 };
 17 
 18 // constructor of Cat, note how the class name precedes the constructor name. Since it is a constructor there is no return value. 
 19 Cat::Cat(int initialAge)     // da linea 19 a 22 trovi l'implementazione del constructor. 
 20 {
 21    itsAge = initialAge;
 22 }
 23 
 24 Cat::~Cat()                 // destructor, takes no action
 25 {                           // note no return time or parameters are included. Do not forget to precede ~Cat by the class name Cat:: 
 26 }
 27 
 28 // GetAge, Public accessor function
 29 // returns value of itsAge member
 30 int Cat::GetAge()
 31 {
 32    return itsAge;
 33 }
 34 
 35 // Definition of SetAge, public
 36 // accessor function
 37 void Cat::SetAge(int age)
 38 {
 39    // set member variable itsAge to
 40    // value passed in by parameter age
41    itsAge = age;
 42 }
 43 
 44 // definition of Meow method
 45 // returns: void
 46 // parameters: None
 47 // action: Prints "meow" to screen
 48 void Cat::Meow()
 49 {
 50    std::cout << "Meow.\n";
 51 }
 52 
 53 // create a cat, set its age, have it
 54 // meow, tell us its age, then meow again.
 55 int main()
 56 {
 57    Cat Frisky(5);
 58    Frisky.Meow();
 59    std::cout << "Frisky is a cat who is " ;
 60    std::cout << Frisky.GetAge() << " years old.\n";
 61    Frisky.Meow();
 62    Frisky.SetAge(7);
 63    std::cout << "Now Frisky is " ;
 64    std::cout << Frisky.GetAge() << " years old.\n";
 65    return 0;
 66 }
 67  
----------------------------------------------------------- 
SUMMARY 
DO
	- do use constructors to initialize your objects
	- do add a destructor if you add a constructor 
DON'T
	- don't give constructor or destructors a return value 
	- don't give destructor parameters. 
-------------------------------------------------------------------------------------------------------------
>> CONST MEMBER FUNCTIONS / >> constant member functions [pag157 jesse]
IN SHORT
una constant member function e' una funzione che non cambia nessuno dei data members within the same class e la si dichiara facendo precedere la keyword const prima del ;
	void SomeFunction() const;
IN LONG
If you declare a class method const, you are promising that the method won't change the value of any of the members of the class. 
To declare a class method constant, put the keyword const after the parentheses enclosing any parameters, but before the semicolon ending the method declaration. For example 
	void SomeFunction() const;
This declares a constant member method called SomeFunction() that takes no arguments and return void. You know this will not change any of the data members within the same class because it has been declared const. 
Accessor functions that only get values are often declared as constant functions by using the constant modifier. For example the accessor function we saw above GetAge() simply return the current value of the member variable itsAge. Therefore, you can declare it in this way: 
	int GetAge() const;
If you declare a function to be const, and the implementation of that function changes the object by changing the value of ANY of its members, the compiler flags it as an error. For example if you wrote GetAge() in such a way that it kept count of the number of times that the Cat was asked its age, it would generate a compiler error. This is because you would be changing the Cat object when the method was called. 
It is good programming practice to declare as many methods to be const as possible. Each time you do, you enable the compiler to catch your errors instead of letting your errors become bugs that will show up when your program is running. 
-------------------------------------------------------------------------------------------------
[from pag 158 jesse]
>> CLIENTS are the parts of the program that create and use objects of your class. You can think of the public interface to your class (the class declaration) as a contract with these clients. The contract tells how your class will behave. 
NOTE1 [from pag 160 jesse]: if you provide any constructor, the compiler will not provide one at all. Thus, if you create a constructor that takes a parameter, you then have no default constructor unless you write your own. 
>> compiler errors vs >> run-time errors / >> runtime errors
Compiler errors are infuriating and are the bane of a programmer's existence.
But compile errors (that is errors found while you are compiling) are far better than runtime errors (= errors found while you are executing the program)/ This is because compile time errors can be found much more reliably. It is possible to run a program many times without going down every possible code path. Thus, a runtime error can hide for quite a while. Compile-time errors are found every time you compile. Thus they are easier to identify and fix. It si the goal of quality programming to ensure that the code has no runtime bugs. One tried and true technique to accomplish this is to use the compiler to catch your mistakes early in the development process. 
-------------------------------------------------------------------------------------------------
>> WHERE CLASS DECLARATION and METHOD DEFINITIONS / >> LOCATION of CLASS DECLARATION AND METHOD DEFINITIONS [pag161]
Each function that you declare for your class must have a definition. 
The definition is also called the >> function implementation (>> definition of a function = function implementation)
Like other functions, the definition of a class method has a function header and a function body. 
The definition must be in a file that the compiler can find. Most C++ compilers want that file to end with .c or .cpp. 
You are free the declaration in this file as well [cioe' puoi mettere la DECLARAtion nello stesso file .c in cui e' presente la DEFINItion della funzione], but that is not good programming practice. The convention that most programmers adopt is to put the declaration into what is called a header file, usually with the same name but ending in .h or .hp or hpp. 


          ***.h  ----> declaration della funzione/metodo

		  ***.c  ----> definition  della funzione/metodo 

For example, you put the declaration of the Cat class into a file named Cat.h and you put the definition of the class methods into a file called Cat.c. You then attach the header file to the .c file by putting the following code at the top of the Cat.c:

	#include "Cat.h"

This tells the compiler to read Cat.h into the file, the same as if you had typed in its contents at this point. 
Why bother separting the contents of your .h file and your .c files?
1) because you might very well end up including the .h file into more than one .c file
2) because most of the time, clients of your class don't care about the implementation specifics. Reading the header file tells them everything they need to know.
NOTE: many compilers assume that files ending with .c are C programs, and that C++ program files end with .cpp. 
You can use any extension, but .cpp minimizes confusion. 
NOTE: 
	>> DECLARATION of a CLASS = INTERFACE of a CLASS [pag162 jesse]
The declaration of a class tells the compiler what the class is, what data it holds, and what functions it has. The declaration of the class is called its interface because it tells the user now to interact with the class. The interface is usually stored in an .hpp or .h file, which is referred as the header file.
while
	>> DEFINITION of a function = IMPLEMENTATION of a class method.  
The function definition tells the compiler how the function works. The function definition is called the implementation of the class method, and it is kept in a cpp file. The implementation details of the class are of concern only to the author of the class. Clients of the class (that is the parts of the program that use that class) don't need to know and don't care how the functions are implemented. 
------------------------------------------------------
>> INLINE IMPLEMENTATION [pag162 jesse]
Just as you can ask the compiler to make a regular function inline, you can make class methods inline. THe keyword inline appears before the return type. The inline implementation of the GetWeight() function, for example looks like this:

	inline int Cat::GetWeight()
	{
		return itsWeight; // return the Weight data member
	}

You can also put the definition of a function into the declaration of the class, which automatically makes the function inline. For example 

	class Cat
	{
		public:
			int GetWeight() { return itsWeight; } // inline 
			void SetWeight (int aWeight);
	};
----------------------------------------------------------------
>> HAS-A RELATIONSHIP MEANING >> HAS A RELATIONSHIP MEANING [pag165 jesse]
It not uncommon to build up a complex class by declaring simpler classes and including them in the declaration of the more complicated classes. FOr example, you might declare a navigator class, a motor class, a levitator class, and so forth and them combine them into an hoverboard class. This declares a has-a relationship. An hoverboard as a motor, it has a navigator and it has a levitator. 
pag 165 trovi example >> rectangle class: since is composed by 4 lines defined by points, it shows how to declare first a "Point" class, that holds the coordinates of each points, and then use it to define the rectangle.
Example:
---------------------------------------- HEADER 
// from /home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/
	// Begin Rectangle.hpp
	#include <iostream>
	class Point     // holds x,y coordinates
	{
	  // no constructor, use default
	  public:
	    void SetX(int x) { itsX = x; }   // member variable itsX
	    void SetY(int y) { itsY = y; }   // member variable itxY   : these variables holds the values of the coordinates.
	    int GetX()const { return itsX;}
	    int GetY()const { return itsY;}
	  private:
	    int itsX;
	    int itsY;
	};    // end of Point class declaration
	  
	class  Rectangle
	{
	  public:
	    Rectangle (int top, int left, int bottom, int right);
	    ~Rectangle () {}
	  
	    int GetTop() const { return itsTop; }
	    int GetLeft() const { return itsLeft; }
	    int GetBottom() const { return itsBottom; }
	    int GetRight() const { return itsRight; }
	  
	    Point  GetUpperLeft() const { return itsUpperLeft; }
	    Point  GetLowerLeft() const { return itsLowerLeft; }
	    Point  GetUpperRight() const { return itsUpperRight; }
	    Point  GetLowerRight() const { return itsLowerRight; }
	  
	    void SetUpperLeft(Point Location)  {itsUpperLeft = Location;}
	    void SetLowerLeft(Point Location)  {itsLowerLeft = Location;}
	    void SetUpperRight(Point Location)  {itsUpperRight = Location;}
	    void SetLowerRight(Point Location)  {itsLowerRight = Location;}
	  
	    void SetTop(int top) { itsTop = top; }
	    void SetLeft (int left) { itsLeft = left; }
	    void SetBottom (int bottom) { itsBottom = bottom; }
	    void SetRight (int right) { itsRight = right; }
	  
	    int GetArea() const;
	  
	  private:
	    Point  itsUpperLeft;
	    Point  itsUpperRight;
	    Point  itsLowerLeft;
	    Point  itsLowerRight;
	    int    itsTop;
	    int    itsLeft;
	    int    itsBottom;
	    int    itsRight;
	};
	// end Rectangle.hpp
---------------------------------------- MAIN PROGRAM
// from /home/dia/sourceCode-SAMS-Jesse-5th-edition/Day06/
	// Begin Rect.cpp
	#include "Rectangle.hpp"
	Rectangle::Rectangle(int top, int left, int bottom, int right)
	{
	   itsTop = top;
	   itsLeft = left;
	   itsBottom = bottom;
	   itsRight = right;
	  
	   itsUpperLeft.SetX(left);
	   itsUpperLeft.SetY(top);
	  
	   itsUpperRight.SetX(right);
	   itsUpperRight.SetY(top);
	  
	   itsLowerLeft.SetX(left);
	   itsLowerLeft.SetY(bottom);
	
	   itsLowerRight.SetX(right);
	   itsLowerRight.SetY(bottom);
	}
	  
	// compute area of the rectangle by finding cornerssides,
	// establish width and height and then multiply
	int Rectangle::GetArea() const
	{
	   int Width = itsRight-itsLeft;
	   int Height = itsTop - itsBottom;
	   return (Width * Height);
	}
	  
	int main()
	{
	   //initialize a local Rectangle variable
	   Rectangle MyRectangle (100, 20, 50, 80 );
	 
	   int Area = MyRectangle.GetArea();
	   
	   std::cout << "Area: " << Area << "\n";
	   std::cout << "Upper Left X Coordinate: ";
	   std::cout << MyRectangle.GetUpperLeft().GetX();
	   return 0;
	}
-------------------------------------------------------------------------------------------------------------
SUMMARY CLASSES / >> class summary [pag170 jesse]
A class can have >> data members which are variables of various types, including other classes. A class can also include member functions (also known as methods). You use these >> member functions to manipulate the >> member data and to perform other services
Class members, both data and functions, can be public or private. Public members are accessible to any part of your program. Private members are accessible only to the member functions of the class. Members of a class are private by default. 
It is good programming practice to isolate the interface, or >> declaration (= interface of a class) of the class in a header file. You usually do this in a file with an .hpp extension and then use it in your code files (.cpp) using an include statement. The implementation of the class methods is written in a file with a .cpp extension.
>> constructors vs >> destructors.
Class constructors can be used to initialize object data members. Class destructors are executed when an object is destroyed and are often used to free memory and other resources that might be allocated by methods of the class.
-------------------------------------------------------------------------------------------------------------
>> CLASS OBJECT size [pag171]
A class object's size in memory is determined by the sum of the sizes of its member variables. Class methods take up just a small amount of memory, which is used to store information on the location of the method (a pointer).
>> struct vs >> class why to use >> structures? [pag172 jesse]
Is there ever a reason to use a structure in C++ program?
Many c++ programmers reserve the struct keyword for classes that have no functions. This is a throwback to the old C structures, which could not have functions. Frankly it is confusing and poor programming practice. Today's methodless structure might need methods tomorrow. Then you'll be forced either to change the type to class or to break your rule and end up with a structure with methods. If you need to call a legacy C function that requires a particular struct, then you would have the only good reason to use one. 
>> INSTANTIATION  what is this?
Instantiation is simply a fancy word for the process of creating an object from a class. A specific object defined as being of the type of a class is a single instance of a class.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> CONSTANT declaration example 
example of declaration of pi greco and initialization of a variable using the declared constant
	const float PI = 3.14159;
	float myPi = PI;
[from pag 825 jesse]

>> MEMORY LOCATION 
- placing a new value into a memory location is said to be a destructive operation 
(perche' when a value is placed in a memory location, the value overwrites the previous value in that location)
- when a value is read out of a memory location, the operation is non destructive (i valori delle variabili contenute nelle memory location in cui si legge, sono ancora presenti anche una volta effettuata la lettura)
[pag49deitel]

>> MICROSOFT VISUAL STUDIO EXPRESS error expired license / >> VISUAL STUDIO LICENSE ERROR
SOLUTION 
Setta la data a ex 2012 e l'errore scompare. Ci capitava con microsoft visual studio 2013. Settando la data ad un anno prima partiva senza problemi su Orion I

>> min / >> max / >> minmax / >> minmax_element
[pag724 tailless] 
example /home/dia/Deitel-Code_Examples/ch16/fig16_13/fig16_13.cpp
OUTPUT de programma:
	The minimum of 12 and 7 is: 7
	The maximum of 12 and 7 is: 12
	The minimum of 'G' and 'Z' is: G
	The maximum of 'G' and 'Z' is: Z
	
	The minimum of 12 and 7 is: 7
	The maximum of 12 and 7 is: 12
	
	Array items contains: 3 100 52 77 22 31 1 98 13 40
	The minimum element in items is: 1
	The maximum element in items is: 100
-----------------------------------------------------
>> min and >> max determine the minimum and the maximum of two elements, respectively.
--------------------
>> initializer_list parameters. // >> minimum of a vector / >> maximum of a vector // >> min algorithm / >> max algorithm
[pag 725 deitel]
C++11 and upp includes overloaded versions of the algorithms min and max each receive an initializer_list parameter and return the smallest or largest item in the list initializer that's passed as an argument. For example the following statement returns 7:
	int minimum = min( {10, 7, 14, 21, 17 } );
---------------------
>> minmax algorithm 
[pag725 deitel]
minmax algorithm receives two items and returns a pair in which the smaller item is stored in first and the larger item is stored in second. A second version of this algorithm takes a third argument a binary predicate function ofr comparing values.
   auto result1 = minmax( 12, 7 );
   cout << "\n\nThe minimum of 12 and 7 is: " << result1.first 
      << "\nThe maximum of 12 and 7 is: " << result1.second;
--------------------
>> minmax_element algorithm
[pag 726 deitel]
minmax_element algorithm receives two input iterators representing a range of elements and returns a pair of iterators in which first points to the smallest element in the range and second points to the largest.
example from  example /home/dia/Deitel-Code_Examples/ch16/fig16_13/fig16_13.cpp
   auto result2 = minmax_element( items.cbegin(), items.cend() );
   cout << "\nThe minimum element in items is: " << *result2.first
      << "\nThe maximum element in items is: " << *result2.second  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> MODULO   %
Modulo is the operation that gives the remainder of a division of two values. For example
, if we write:
	a = 11 % 3; 
the variable a will contain the value 2 since 11/3 = 3 resto 2 (3*3+2 = 11)

>> MULTIDIMENSIONAL ARRAYS / >> ARRAYS MULTIDIMENSIONAL / >> ARRAYS 2D / 2-D arrays / two-dimensional arrays / 2d arrays
[pag304deitel]
We can use arrays with two dimensions to represent tables of values consisting of information arranged in rows and columns. 
To identify a particular table elements, we must specify two subscripts
	- the first identifies the element's row
	- the second identifies the element's column
in general, an array with m rows and n columns is called an m-by-n array
Every element in a 2-D array is identified by an element name of the form
	a[i][j]
where a is the name of the array, and i and j are the subscripts that uniquely identify each element in a. 
Common programming error:
referencing a 2-d array element as a[x,y] is an error. Actually a[x,y] is treated as a[y] because C++ evaluates the expression x,y (containing a comma operator) simply as y (the last of the comma-operated expression) 
EXAMPLE see pag305
	const size_t rows = 2;
	const size_t columns = 3;
	void printArray( const array< array< int, columns >, rows> & );
Spegazione Dialin
Se lo riscriviamo in una maniera piu' matematica e sostituendo i valori di "rows" and "column"
	array [ array(int,3), 2] => crea una matrice 3*2
Quindi quando gli assegneremo le 6 componenti
	array< array< int, columns >, rows > array1 = { 1, 2, 3, 4, 5, 6 };
che nel nostro linguaggio semplificato diventa array [ array(int,3), 2] = {1 2 3 4 5 6}
significa che i primi tre elementi 1 2 3 verranno stored on the first row, and the last 3 on the second row.
//from nostra spiegazione con i colori a pag305
Qualora al posto di 6 elementi nella stringa ci fossero solo 5 initializers, allora il sesto elemento sara' inizializzato a zero. 
Any elements that do not have an explicit initializer are initialized to zero. 
NOTE: la scrittura un poco astrusa 
	array< array< int, columns >, rows >
la puoi anche leggere nel modo seguente, prendi la solita definizione di un array:
	array< typeElement, n >
Ora la particolarita' e' che typeElement e' a sua volta un array di m elements interi cioe' un array< int, m > 
Quindi assemblando il tutto:
	array< array< int, m >, n >
Poniamo ora n = 2 e m = 3. E ripetiamo il ragionamento 
	array< typeElement, 2 >
Abbiamo un array immaginalo a forma di pila con 2 elementi uno sopra l'altro e quando apri la box typeElement scopri che 
	typeElement = array< int, 3 >
Cioe' ciascuno dei due piani della pila ha 3 elementi
Quindi assemblando il tutto  
	array< array< int, 3 >, 2 >
avremmo una matrice 3*2
- FOR STATEMENT for 2-D arrays
[pag306deitel]
We use a nested loop in which the outer loop iterates through the rows and the inner loop iterates through the columns of a given row.
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
	{
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			cout << a[ row ][ column ] << ' ';
		cout << endl;
	} // end outer for 
[see example pratico pag305]
EXAMPLES 2d arrays examples
- EXAMPLE1
[pag306deitel]
Settare a zero tutti gli elementi della seconda riga di una matrice 3x4
	for ( size_t column = 0; column < 4; ++ column )
		a [ 2 ][ column ] = 0;
The preceding for statement is equivalent to the following assignement statements:
	a[ 2 ][ 0 ] = 0;
	a[ 2 ][ 1 ] = 0;
	a[ 2 ][ 2 ] = 0;
	a[ 2 ][ 3 ] = 0;
- EXAMPLE2
[pag306deitel]
Sommare tutti gli elementi di un 2D array (insomma di un tensore 2 o la nostra tradizionale matrice)
	total = 0;
	for ( size_t row = 0; row < a.size(); ++row )  // iterations through the rows
		for ( size_t column = 0; column < a[ row ].size(); ++column )  // iterations through the columns
			total += a[ row ][ column ];
usando il C++11 "auto" keyword il precedente nested loop puo' essere riscritto come 
	total = 0;
	for ( auto row : a ) // for each row
		for ( auto column : row ) // for each column in row 
			total += column;
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MULTIDIMENSIONAL ARRAYS [pag97 mike]
EXAMPLE:
/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter03/tic-tac-toe_board.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////
// Tic-Tac-Toe Board
// Demonstrates multidimensional arrays

#include <iostream>

using namespace std;

int main()
{
    const int ROWS = 3;
    const int COLUMNS = 3;
	// >> 2D ARRAY initialization example / >> multidimensional array example [from pag99 mike] 
    char board[ROWS][COLUMNS] = { {'O', 'X', 'O'},
                                  {' ', 'X', 'X'},
                                  {'X', 'O', 'O'} };  // in questo esempio oltre alla dichiarazione viene anche inizializzato
	/*
	it is possible to simply declare a multidimensional  array without initializing it. For example:
		char chessBoard[8][8];
	The preceding code declares an 8x8, 2dimensional character array, chessBoard. By the way multidimensional arrays aren't required to have the same size of each dimesnion. The following is a perfectly valid declaration for a game map represented by individual characters :
		char map[12][20];

	*/ 

    cout << "Here's the tic-tac-toe board:\n";
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << board[i][j];
		}

        cout << endl;
    }

    cout << "\n'X' moves to the empty location.\n\n";
    board[1][0] = 'X';  // this is an example of how to >> index individual element of a multidimensional array
	// the previous code assigns the character X to the element at board[1][0] (which was ' '). 

    cout << "Now the tic-tac-toe board is:\n";
    for (int i = 0; i < ROWS; ++i)
    {
        for (int j = 0; j < COLUMNS; ++j)
		{
            cout << board[i][j];
		}

        cout << endl;
    }

    cout << "\n'X' wins!";

    return 0;
}

//////////////////////////////////////
OUTPUT:
	Here's the tic-tac-toe board:
	OXO
	 XX
	XOO
	
	'X' moves to the empty location.
	
	Now the tic-tac-toe board is:
	OXO
	XXX
	XOO
	
	'X' wins!
////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> JUMBLE PROGRAM
-----------------------------------------------
// Word Jumble
// The classic word jumble game where the player can ask for a hint

#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>

using namespace std;

int main()
{
	enum fields { WORD, HINT, NUM_FIELDS };
	const int NUM_WORDS = 5;
	const string WORDS[NUM_WORDS][NUM_FIELDS] =
	{
		{ "wall", "Do you feel you're banging your head against something?" },
		{ "glasses", "These might help you see the answer." },
		{ "labored", "Going slowly, is it?" },
		{ "persistent", "Keep at it." },
		{ "jumble", "It's what the game is all about." }
	};

	srand(static_cast<unsigned int>(time(0)));
	int choice = (rand() % NUM_WORDS);
	string theWord = WORDS[choice][WORD];  // word to guess
	string theHint = WORDS[choice][HINT];  // hint for word

	string jumble = theWord;  // jumbled version of word
	int length = jumble.size();
	for (int i = 0; i<length; ++i)
	{
		int index1 = (rand() % length);
		int index2 = (rand() % length);
		char temp = jumble[index1];
		jumble[index1] = jumble[index2];
		jumble[index2] = temp;
	}

	cout << "\t\t\tWelcome to Word Jumble!\n\n";
	cout << "Unscramble the letters to make a word.\n";
	cout << "Enter 'hint' for a hint.\n";
	cout << "Enter 'quit' to quit the game.\n\n";
	cout << "The jumble is: " << jumble;

	string guess;
	cout << "\n\nYour guess: ";
	cin >> guess;

	while ((guess != theWord) && (guess != "quit"))
	{
		if (guess == "hint")
		{
			cout << theHint;
		}
		else
		{
			cout << "Sorry, that's not it.";
		}

		cout << "\n\nYour guess: ";
		cin >> guess;
	}

	if (guess == theWord)
	{
		cout << "\nThat's it!  You guessed it!\n";
	}

	cout << "\nThanks for playing.\n";

	return 0;
}
////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> MULTIPLE INHERITANCE / >> INHERITANCE MULTIPLE [pag950 deitel]
In C++, a class may be derived from more than one base class: this technique is known as multiple inheritance, in which a derived class inherits the members of two or more base classes. This powerful capability encourages interesting forms of software reuse but can cause a variety of ambiguity problems. Multiple inheritance is a difficult conept that sould be used only by experienced programmers. In fact, some of the problems associated with multiple inheritance are so subtle that newer programming languages, such as Java and C# do not enable a class to derive from more than one base class.
Great care is required in the design of a system to use multiple inheritance properly; it should not be used when single inheritance and/or composition will do the job.
A common problem with multiple inheritance is that each of the base classes might contain data members or member functions that have the same name. This can lead to ambiguity problems when you attempt to compile. 
Altri concetti e gergo:
>> diamond inheritance [pag955deitel]
>> virtual base class inheritance [pag957 deitel]
////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> multiple value return from function [pag56 moo book]
There is no direct way to return more than one value from a function. One indirect way to do so is to give the function a parameter that is a reference to an object in which it is to palce one of its results. This strategy is common for functions that read input:
EXAMPLE /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main1.cc
// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}
////////////////////////////////////////////////////////////////////////

>> INHERITANCE [mike game programming pag307]
Inheritance is especially useful when you wnat to create a more specialized version of an existing class because you can add data members and members functions to the new class to extend it. 
One of the many advantages of inherintance is that you can reuse classes you've already written. This reusability produces benefits that include:
1) LESS WORK: there's no need to redefine functionality you already have. 
2) FEWER ERROR: once you've got a bug free class, you can reuse it without errors.
3) CLEANER CODE: because the functionality of base classes exists only once in a program, you don't have to wade through the same code repeatedly, which makes programs easier to understand and modify. 
Most related game entities cry out for inheritance. Whether it's the series of enemies that a player faces, squadrons of military vehicles that a player commands, or an inventory of weapons that a player wields, you can use inheritance to define these groups of game entities in terms of each other, which results in faster and easier programming.
Example pag309 Simple Boss Program
>> DERIVE CLASS example extracted from the program below
	class Boss : public Enemy
where
	Boss   = name of the derived class or >> subclass
	:      = put a colon after the name of the derived class
	public = this is the access modifier, in questo esempio e' "public"  [le altre opzioni sono "protected" and "private"]
	Enemy  = name of the base class or >> superclass 
NOTE from pag 315 mike game programming 
		>> public = members are accessible to all code in a program [pag315 mike game programming]
		>> protected = members are accessible only in their own class and certain derived classes, depending upon the access level used in inheritance.
		>> private = members are only accessible in their own class, which means they are not directly accessible in any derived class.
Using public derivation means that 
	- public members in the base class become public members in the derived class, 
	- protected members in the base class become protected  members in the derived class
	- private members in the base class are inaccessible in the derived class.
		note: even if base data members are private, you can still use them indirectly through base class member functions.
Quando usi inheritance e crei una class derivata, e' come se copiassi e pastassi the code from the superclass into the definition of the derived class.
>> DERIVED CLASS INSTANTIATING / >> INSTANTIATING DERIVED CLASS 
	Boss boss1;   // see program below
when a Boss oject is instantiated, the default Enemy constructor is automatically called and the object gets an m_Damage data member with a value of 10 (just like any Enemy object would). Then, the Boss constructor is called and finishes off the object by giving it an m_DamageMultiplier data member with a value of 3. The reverse happens when a Boss object is destroyed at the end of the program. First the Boss class destructor is called for the object, and then the Enemy class destructor is called. 
------------------------------------------------------------
	//Simple Boss
	//Demonstrates inheritance
	
	#include <iostream>
	using namespace std;
	
	class Enemy    // we define this class Enemy for lowly enemies. From this class we will derived the class Boss
	{
	public:
	    int m_Damage;
	
	    Enemy();  
	    void Attack() const;
	};
	
	Enemy::Enemy(): 
	    m_Damage(10)
	{}    
	
	void Enemy::Attack() const
	{ 
	    cout << "Attack inflicts " << m_Damage << " damage points!\n";
	}  
	
	class Boss : public Enemy         // we derive from "Enemy" class this "Boss" class
	{                                 // Bass is based on Enemy. In fact, Enemy is called
	public:                           // base class (or superclass) and Boss the derived class
	    int m_DamageMultiplier;       // or subclass. This means that Boss inherits Enemy's data members
	                                  // and member functions, subject to access control. 
	    Boss();  
	    void SpecialAttack() const;
	
	};
	
	Boss::Boss(): 
	    m_DamageMultiplier(3)
	{}  
	
	void Boss::SpecialAttack() const
	{
	    cout << "Special Attack inflicts " << (m_DamageMultiplier * m_Damage); // note that the member function SpecialAttack uses data member m_Damage declared in Enemy. That's perfectly fine. Boss inherits m_Damage from Enemy and, in this example, the data member works like any other data member in the Boss class
	    cout << " damage points!\n";
	}
	
	int main()
	{ 
	    cout << "Creating an enemy.\n";
	    Enemy enemy1;
	    enemy1.Attack();
	
	    cout << "\nCreating a boss.\n";
	    Boss boss1;
	    boss1.Attack();  // [pag312 mike game programming] qui usiamo the inherited member function "Attack" 
// essendo boss1 un oggetto della classe derivata Boss, esso eredita la member function "Attack" della superclass Enemy
	    boss1.SpecialAttack(); 
	
	    return 0;
	} 
------------------------------------------------------------
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> DERIVE TYPE OBJECT CREATION [pag231 moo book]
Here's how the implementation creates objects of derived type. 
As with any class type, the implementation begins by allocating space for the object. Next it runs the appropriate constructor to initialize the object.
The fact that the object is of a derived type adds an extra step. Derived objects are constructed by:
- allocating space for the entire object (base class members as well as derived members)
- calling the base-class constructor to initialize the base-class part(s) of the objects
- initializing the members of the derived class as directed by the constructor initializer
- executing the body of the derived class constructor, if any.
>> GET VALUE WITHOUT KNOWING THE OBJECT'S TYPE/ >> VALUE retrieval without knowing the object's type [pag234 moo book]
pag 234 mooo book : virtual function a che serve in parole semplici: we want the system to run the right function based on the actual type of the objects passed to the function, which is known only at run time. To support this kind of run time selection, C++ provides virtual functions.
>> DYNAMIC BINDING vs >> STATIC BINDING [pag235 moo book]
This run time selection fo the virtual function to execute is relevant only when the function is called through a reference or a pointer. If we call a virtual function on behalf of an object (as opposed to through a reference or pointer), then we know the exact type of the object at compile time.
[...] The distinction between dynamic binding and static binding is essential to understand how C++ support OOP (object orienting programming). The phrase dynamic binding captures the notion that functions may be bound at run time, as opposed to static bindings that happen at compile time.
- If we call a virtual function on behalf on an OBJECT, that call is STATICALLY bound, that is, it is bound at compile time, because there is no possibility that the object will have a different type during execution than it does during compilation. 
- In constrast, if we call a virtual function through a POINTER or REFERENCE, then the function is DYNAMICALLY bound, that is, bound at run time. At run time, the version of the virtual function to use will depend on the type of the object to which the reference or pointer is bound.
The fact that we can use a derived type where a pointer or reference to the base is expected is an example of a key concept in OOP called polymorphism. This word, from the greek polymorphos = of many forms, in a programming context, it refers to the ability of one type to stand in for many types. C++ supports polymorphism through the dynamic binding properties of virtual functions. When we call a virtual through a pointer or reference, we make a polymorphic call. The type of the reference (or pointer) is fixed, but the type of the object to which it refers (or points) can be the type of the reference (or pointer) or any type derived from it. Thus, we can potentially call one of many functions through a single type. 
One fine note about virtual functions. These functions must be defined, regardless of whether the program calls them. Nonvirtual functions may be declared but not defined, as long as the program does not call them. Many compilers generate mysterious error messages for calsses that fail to define one or more virtual functions. 
[>> UNDEFINED ERROR message] If your program evokes a message from the compiler that you do not understand, and that message says that something is undefined, you should verify that you have defined all of your virtual functions. You are likely to find that the error goes away when you do so.
>> VIRTUAL DESTRUCTORS [pag242 moo book]
so that the destructor that will be run will depend on the type of object we are pointing to.  
>> HANDLE CLASS [pag243 moo book]
>> STATIC MEMBER FUNCTION [pag244 moo book] Static member functions differ from ordinary member functions in that they do not operate on an object of the class type. Unlike other member functions, they are associated with the class, not with a particular object.
>> INHERITANCE [pag250 moo book]
Inheritance allows us to model classes that are similar to one another with exceptions:
	class base {
	public:
		// common interface 
	protected:
		// implementation members accessible to derived classes
	private:
		// implementation accessible to only the base class
	};
	
	// public interface of base is part of the interface for derived
	class derived: public base { ... };
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> NNNNNNN

>> NAMESPACES / >> NAME SPACES [pag943deitel]
A program may include many identifiers defined in different scopes. Sometimes a variable of one scope will "overlap" (i.e. collide) with a variable of the same name in a different scope, possibly creating a naming conflict. Such overlapping can occur at many levels. Identifier overlapping occurs frequently in third party libraries that happen to use the same names for global identifiers (such as functions). This can cause compilation errors.
	C++ solves this problem with namespaces. Each namespace define a scope in which identifiers and variables are placed. To use an namespace member, either the member's name must be qualified with the namespace name and the scope resolution operator (::), as in 
	MyNameSpace::member
or a "using" directive must appear before the name is used in the program. Typically, such "using" statements are placed at the beginning of the file in which members of the namespace are used. For example, placing the following using directive at the beginning of a source code file
	using namespace MyNameSpace;
specifies that members of namespace MyNameSpace can be used in the file without preceding each member with MyNameSpace and the scope resolution operator (::). [cioe' detto in parole spicciole se scrivi all'inizio del programma using namespace NomeSpace, allora tutte le funzioni/members che appartengono a NomeSpace possono essere utilizzate direttamente all'interno del programma, se invece non scrivessi tale riga, allora dovrai precedere ciascun membro da NomeSpace::nomeDellaFunzioneDiNomeSpaceCheVuoiUtilizzare]
A using directive of the form 
	using std::cout;
brings one name into the scope where the directive appears. A using directive of the form 
	using namespace std;
brings all the names from the specified namespace (std) into the scope where the directive appears.
ERROR prevention: precede a member with its namespace name and the scope resolution operator (::) if the possibility exists of a naming conflict.
NOTE1: not all namespaces are guaranteed to be unique. Two third-party vendors might inadvertently use the same identifiers for their namespace names.
NOTE2: placing main ina namespace is a compilation error.
NOTE3: USING DIRECTIVES SHOULD NOT BE PLACED IN HEADERS namespaces are particularly ueful in large scale applications that use many class libraries. In such cases, there's a higher likelihood of naming conflicts. When working on such projects there should never be a suing directive in an header. Having one brings the corresponding names into any file that includes the header. This could result in name collisions and subtle, hard to find errors. Instead, use only fully qualified names in headers (for example std::cout or std::string)
>> ALIASES for namespace Names
namespaces can be aliased. For example the statement
	namespace CPPHTP = CPlusPlusHowToProgram;
creates the namespace alias CPPHTP for CPlusPlusHowToProgram.
---------------------------------------------------------------------------------------------
OPERATOR KEYWORDS [pag946 deitel]
The C++ standard providesoperator keywords that can be used in place of several C++ operators. You can use operator keywords if you have keyboards that do not support certain characters such as !, &, ^, ~, | etc. 
OPERATOR   OPERATOR KEYWORD    DESCRIPTION 
&&         and                 logical AND
||         or                  logical OR
!          not                 logical NOT
!=         not_eq              inequality
&          bitand              bitwise AND
|          bitor               bitwise inclusive OR
^          xor                 bitwise exclusive OR
~          compl               bitwise complement
&=         and_eq              bitwise AND assignment 
|=         or_eq               bitwise inclusive OR assignment
^=         xor_eq              bitwise exclusive OR assignment  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> NAMESPACES [pag637 jesse]
CREATING AND USING NAMESPACES 
Namespaces can be used to help you organize your classes. More importantly namespaces help programmers avoid name clashes when using more than one library. In this lesson you will learn
	- how functions and classes are resolved by name 
	- how to create a namespace 
	- how to use a namespace
	- how to use the standard namespace std
Name conflicts have been a source of aggravation to both C and C++ developers. A name clash happens when a duplicate name with matching scope is found in two parts of your program. The most common occurrence can be found in diffrent library packages. For example, a container class library will almost certainly declare and implement a List class.
It is not surprise to find a List class also being used in a windowing library. 
Suppose you want to maintain a list of windows for your application. 
Further assume that you are using the List class found in the container class library. You declare an instance of the window library's "List" to hold your windows, and you discover that the member functions you want to call are not available. 
The compiler has matched your List declaration to the "List" container in the Standard Library, but what you really wanted is the "List" found in the vendor-specific window library. 
Namespaces are used to reduce the chance of name conflicts. Namespaces are similar in some ways to classes, and the syntax is very similar. 
Items declared within the namespace are owned by the namespace. All items within a namespace have public visibility. Namespaces can be nested within other namespaces. Functions can be defined within the body of the namespace or defined outside the body of the namespace. If a function is defined outside the body of the namespace, it must be qualified by the namespace's name or the calling program must have imported the namespace into its global namespace.
------------------------------------------------------------------------------------
>> RESOLVING FUNCTIONS AND CLASSES BY NAME [pag638 jesse]
As the compiler parses source code and builds a list of function and variable names, it also checks for name conflicts. Those conflicts that it can't resolve are left for the linker to resolve. 
The compiler cannot check for name clashes across object files or other translation units; that is the purpose of the linker. Thus the compiler does not even offer a warning in those cases. 
It is not uncommon for the linker to fail with the message: 
	"identifier" multiply defined 
where "identifier" is some named type. 
You see this LINKER message if you have defined the same name with the same scope in DIFFERENT  translation units. 
You get a COMPILER error if you redefine a name WITHIN a single file having the same scope. Listing 18.1a and Listing 18.1b are an example when compiled and linked together, that produces an error message by the linker. 
------------------------------------------------------ Listing 18.1a
// file first.cpp
int integerValue = 0 ;
int main( ) {
    int integerValue = 0 ;
    // . . .
    return 0 ;
} ;
------------------------------------------------------ Listing 18.1b
// file second.cpp
int integerValue = 0 ;
// end of second.cpp
-------------------------------------------------------  
OUTPUT 
[1036 List1801] >> g++ -o program.exe first.cpp second.cpp 
/tmp/cceGOBdd.o:(.bss+0x0): multiple definition of `integerValue'
/tmp/cc4lvVtP.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
-----------------------------------------------
NOTE: if these names were in a different scope, the compiler and linker would not complain about the duplication. It is also possible to receive a warning from the compiler concerning ">> identifier hiding". The compiler should warn, in first.cpp in Listing 18.1a, that integerValue in main() is hiding the global variable with the same name. 
To use the integerValue declared outside main(), you must explicitly scope the variable to global scope. Consider this example in Listing 18.2a and 18.2b which assigns the value 10 to the integerValue outside main() and not to the integerValue declared within main().
------------------------------------------------------------------------------------ Listing 18.1b
// file first.cpp
int integerValue = 0 ;
int main( )
{
    int integerValue = 0 ;
    ::integerValue = 10 ; //assign to global "integerValue"
	// note the use of the scope operator "::" indicating that the integerValue being referred to is global, not local.
    // . . .
    return 0 ;
} ;
------------------------------------------------------------------------------------ Listing 18.2b
// file second.cpp
int integerValue = 0 ;
// end of second.cpp
------------------------------------------------------------------------------------ 
OUTPUT [anche questo nella nostra machine non linka]
[1041 List1802] >> g++ -o program.exe first.cpp second.cpp 
/tmp/ccL8MMGY.o:(.bss+0x0): multiple definition of `integerValue'
/tmp/cccxqYz2.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
------------------------------------------------
Del resto come scritto a pagina 640: the problem with the two global integers defined outside of any functions is that they have the same name and visibility and thus cause a linker error. 
-----------------------------------------------------------------------------------------------------------------------------------------------
>> VARIABLES VISIBILITY / >> VISIBILITY VARIABLES / >> SCOPE VARIABLES [pag640]
The term visibility is used to designate the scope of a defined object, whether it is a variable, a class or a function. Although this was covered on Lesson 5 "Organizing into Functions" it is worth covering again here breifly. As an example: 
1) a variable declared and defined outside any function has "file" or "global" scope. The visibility of this variable is from the point of its definition through the end of the file (cioe' la variabile e' visibile dalla riga della sua definition fino alla fine del file).
2) a variable having a  "block" or "local" scope is found within a block structure. The most common examples are variables defined within functions. The following 18.3 listing shows the scope of variables: 
------------------------------------------------------------------------------------------------------------  Listing 18.3 start
// Listing 18.3
int globalScopeInt  = 5 ;  // questa variabile e' definita outside of any function, quindi is visible within the functions f() and main(). 
void f( ) 
{
    int localScopeInt = 10 ;  // this variable has a local scope, meaning that is visible only within the block defining it. Cioe' in questo caso visibile solo all'interno del blocco della funzione f().
// this means that the main() function cannot access f()'s localScopeInt. When the f() function returns, localScopeInt  goes out of scope. 
}
int main( )
{
    int localScopeInt = 15 ;  // here another variable definition also named localScopeInt. La sua visibilita' e' limitata all'interno del main block, per cui main's localScopeInt does not conflict with f()'s localScopeInt. 
    {
        int anotherLocal = 20 ;
        int localScopeInt = 30 ; // also this variable have block scope. As soon as the closing brace is reached in the following line, this variable lose its visibility
    } // qui la variabile "localScopeInt = 30" perde la sua visibilita', cio' che vedi e' solo la variable che avevi definito prima del blocco, "localScopeInt = 15". Any changes made to the localScopeInt defined within the braces  does not affect teh contects of the outer localScopeInt. 
    return 0 ;
}
------------------------------------------------------------------------------------------------------------  Listing 18.3 ends
>> LINKAGE [pag641 jesse]
Names can have internal and external linkage. These two terms refer to the use or availability of a name across  multiple translation units or within a single translation unit. 
Any name having internal linkage can only be referred to within the translation unit in which it is defined. For example, a variable defined to have internal linkage can be shared by functions within the same translation unit. 
Names having external linkage are available to other translation units. Listings 18.4a and 18.4b demonstrate internal and external linkage. 
------------------------------------------------------------------------------------------------------------  Listing 18.4a starts
// file: first.cpp
int externalInt = 5 ;  // this variable has external linkage. Although it is defined in first.cpp, second.cpp can also access it. 
const int j = 10 ;  // this variable is constant, which, by default, have internal linkage
int main()
{
    return 0 ;
}
------------------------------------------------------------------------------------------------------------  Listing 18.4a ends
------------------------------------------------------------------------------------------------------------  Listing 18.4b starts
// file: second.cpp
extern int externalInt ;
int anExternalInt = 10 ;
const int j = 10 ;  // this variable is constant, which, by default, have internal linkage
------------------------------------------------------------------------------------------------------------  Listing 18.4b ends
COMPILING 
[1047 List1804] >> g++ -o myprog.exe first.cpp second.cpp   # compiled with no errors.
[1048 List1804] >> ls
first.cpp  myprog.exe  second.cpp
-----------------------------------------------------------------------------------------------------------
You can override the constant default by providing  an explicit declaration, as shown in Listing 18.5a and 18.5b: 
------------------------------------------------------------------------------------------------------------  Listing 18.5a 
// file: first.cpp
extern const int j = 10 ;
------------------------------------------------------------------------------------------------------------  Listing 18.5b 
// file: second.cpp
extern const int j ;
#include <iostream>
int main()
{
    std::cout << "j is " << j << std::endl ; // note that cout is called with the namespace designation of std. When built, this example displays  "j is 10" 
    return 0 ;
}
---------------------------------------------------------------------------------------------------------------
OUTPUT :
[1052 Day18] >> cd List1805
[1053 List1805] >> ls
first.cpp  second.cpp
[1054 List1805] >> g++ -o myprog.exe first.cpp second.cpp 
[1055 List1805] >> ./myprog.exe 
j is 10
-----------------------------------------------------------------------------------------------------------------
>> STATIC GLOBAL VARIABLES [pag 642 jesse] -> in short don't use them 
The standards committee has deprecated the use of static global variables. Static global variables are declared as follows:
	static int staticInt = 10;
	int main()
	{
		//....
	}
The use of static to limit the scope of external variables is no longer recommended and might become illegal in the future [like nexus 8 replicants]. You should now use namespaces instead of static.
DO
	- DO use namespaces instead of static 
DON'T
	- DON'T apply the static keyword to a variable defined at file scope. 
---------------------------------------------------------------------------------------------------------------------
>> NAMESPACE CREATION [pag643 jesse]
The syntax for a namespace declaration is similar to the syntax for a struct or class declaration: First apply the keyword namespace followed by an optional namespace name, and then an opening curly brace. The namespace is concluded with a closing brace but no terminating semicolon. 
For example 
	namespace Window 
	{
		void move( int x, int y) ;
		class List 
		{
			//...
		}
	}
---------------
The name Window uniquely identifies the namespace. You can have many occurences of a named namespace. These multiple occurrences can occur within a single file or across multiple translation units. When this occurs, the separate instances are merged together by the compiler into a single namespace. The C++ Standard Library namespace, std, is a prime example of this feature. This makes sense because the Standard library is a logical grouping of functionality, but it is too large and complex to be kept in a single file. 
The main concept behind namespaces is to group related items into a specified (named) area. The following listing 18.6a and 18.6b provide a brief example of a namespace that spans multiple header files. 
----------------------------------------------------------------------------------------------- Listing 18.6a
// header1.h
namespace Window 
{
    void move( int x, int y) ;
}
----------------------------------------------------------------------------------------------- Listing 18.6b
// header2.h
namespace Window  
{
    void resize( int x, int y ) ;
}
-----------------------------------------------------------------------------------------------
As you can see, the Window namespace is spread across both header files. The compiler treats both the move() function and the resize() function as part of the Window namespace.
>> DECLARING and DEFINING TYPES / >> NAMESPACE DECLARATIONS [pag644 jesse]
You can declare and define types and functions within namespaces. Of course, this is a design and maintenance issue. Good design dictates that you should separate interface from implementation. 
You should follow this principle not only with classes but also with namespaces.
>> DEFINING FUNCTIONS OUTSIDE a NAMESPACE / >> NAMESPACE FUNCTION DEFINITION [pag645 jesse]
You should define namespace functions outside the namespace body. Doing so illustrates a clear separation of the declaration of the function and its definition (and also keeps the namespace body uncluttered). Separating the function definition from the namespace also enables you to put the namespace and its embodied declaration within a header file; the definitions can be placed into an implementation file. The Listing 18.7a and 18.7b illustrate this separation: 
----------------------------------------------------------------------------------------------- Listing 18.7a Declaring a Header in a Namespace 
// file header.h
namespace Window {
    void move( int x, int y) ;
    // other declarations ...
}
----------------------------------------------------------------------------------------------- Listing 18.7b Declaring the Implementation in the Source File
// file impl.cpp
void Window::move( int x, int y )
{
    // code to move the window
} 
-----------------------------------------------------------------------------------------------------
>> NEW MEMBERS ADD / >> ADD NEW MEMBERS [pag645 jesse]
New member can be added to a namespace only within the namespace's body. You cannot define new members using >> qualifier syntax (= per qualifier syntax intende, come scritto nell'esempio seguente di far precedere il new member da "nomeOfTheNamespace::"). The most you can expect from this style of definition is a complaint from your compiler. The following example demonstrates this error: 
	namespace Window
	{   
		// lot of declarations 
	}
	// ... some code
	int Window::newIntegerInNamespace ; // sorry, can't do this. 
The preceding line of code is illegal. Your conforming compiler issues a diagnostic reflecting the error. To correct the error or to avoid it altogheter, move the declaration within the namespace body (cioe' all'interno delle parentesi graffe di Window{} ).
When you add new members, you do not want to include access  modifiers, such as public or private. All members encased within a namespace are public. The following code does not compile because you cannot specify private:]
	namespace Window
	{
		private:
			void move ( int x, int y ); 
	}
----------------------------------------------------------------------------------------------------------
>> NAMESPACE NESTING / >> NESTING NAMESPACE / >> NEST NAMESPACE [pag646 jesse]
A namespace can be nested within another namespace. The reason they can be nested is because the definition of a namespace is also a declaration. As with any other namespace, you must qualify a name using the enclosing namespace. If you have nested namespaces, you must qualify each namespace in turn. For example, the following  shows a named namespace nested within another named namespace.
	namespace Window
	{
		namespace Pane
		{
			void size( int x, int y );
		}
	}
To access the function size() outside of the Window namespace, you must qualify the function with both enclosing namespace names. In this case, you need to use the following line to access size:
	Window::Pane::size (10,20);
----------------------------------------------------------------------------------------------------------
>> NAMESPACE usage / >> using namespace / >> namespace example [pag646 jesse]
Let's take a look at an example of using a namespace and the associated use of the scope resolution operator. In the example, all types and functions for use within the namespace Window are declared. After everything required is defined, any member functions that were declared are defined. These member functions are defined outside of the name-space; the names are explicitly identified using the scope resolution operator. The listing 18.8 (CPlusPlusPlayGround/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day18/List1808.cpp) illustrates using a namespace.
------------------------------------------------------------------------------------------------------------------------------------------------ Listing 18.8 starts
#include <iostream>
// Using a Namespace
namespace Window
{
    const int MAX_X = 30 ;
    const int MAX_Y = 40 ;
    class Pane     // note that the class Pane is nested inside the namespace Window. This is why in the rest of the program outside namespace Window block, we have to qualify the name "Pane" with the "Window::" qualifier.
    {
        public:
            Pane() ;
            ~Pane() ;
            void size( int x, int y ) ;
            void move( int x, int y ) ;
            void show( ) ;
        private:
            static int count ;
            int x ;
            int y ;
    };
} 
  
int Window::Pane::count = 0 ;
Window::Pane::Pane() : x(0), y(0) { }
Window::Pane::~Pane() { }
  
void Window::Pane::size( int x, int y )
{
    if( x < Window::MAX_X  &&  x > 0 )   // note that MAX_X and MAX_Y are fully qualified (qualified cioe' sono preceduti dal nome del namespace "Window::"). This is because Pane is in scope; otherwise, the compiler issues an error diagnostic. This also holds true for the function Pane::move()
        Pane::x = x ; 
    if( y < Window::MAX_Y  &&  y > 0 )
        Pane::y = y ;
}
void Window::Pane::move( int x, int y )
{
    if( x < Window::MAX_X  &&  x > 0 )
        Pane::x = x ; // also interesting is the qualification of Pane::x inside the function definition. Why is this needed? Well, if the function Pane::move() were written like just using "x = x;" instead of "Pane::x = x;", you would have problem. Can you spot the issue? You probably won't get much of an answer from your compiler. Some don't issue any kind of diagnostic message at all. The source of the problem is the function's arguments. Arguments x and y hide the private x and y instance variables declared within class Pane. Effectively, the statement "x = x;" assigns x to itself.
    if( y < Window::MAX_Y  &&  y > 0 )
        Pane::y = y ;
}
void Window::Pane::show( )
{
    std::cout << "x " << Pane::x ;
    std::cout << " y " << Pane::y << std::endl ;
}
  
int main( )
{
    Window::Pane pane ;
  
    pane.move( 20, 20 ) ;
    pane.show( ) ;
 
    return 0 ;
}

------------------------------------------------------------------------------------------------------------------------------------------------ Listing 18.8 ends

>> USING keyword [648 jessy book]
The "using" keyword is used for both the 
	- using directive 
and the 
	- using declaration 
The syntax of the using keyword determines whether the context is a directive or a declaration. 
------------------------------------------------
>> USING DIRECTIVE [648 jesse]
The using directive effectively exposes all names declared in a namespace to be in the current scope. You can refer to the names without qualifying them with their respective namespace name.
The following example shows the "using" directive : 
	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	[...]
	Window::value1 = 10; // se non usiamo "using namespace" bisogna far precedere la variabile dal qualifier.
	
	using namespace Window; // se invece usiamo the using directive 
	value2 = 30 ; // allora possiamo direttamente scrivere il nome della variabile, no more need to write Window::value2 = 30;  

The "using" directive can be used at any level of scope. This enables you to use the directive within block scope; when that block goes out of scope, so do all the names within the namespace. The following example shows this behaviour: 

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	// ...
	void f()
	{
		{
			using namespace Window;
			value2 = 30; // here it is OK you can use the directive within the block scope.
		}
		value2 = 20; // error!! qui non va piu' bene, perche' sei al di fuori dello scope (= al di fuori delle {} dove hai scritto using namespace) quindi dovresti usare il qualifier Window::value2
	}

Variable names declared within a local scope hide any namespace names introduced in that scope. This behaviour is similar to how a local variable hides a global variable. Even if you introduce a names space after a local variable, that local variable hides the namespace name. Consider the following example : 

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	// ...
	void f()
	{
		int value2 = 10;
		using namespace Window; // anche se scrivi using namespace Window dopo aver inizializzato value2 a "10"
		std::cout << value2 << std::endl ; // il valore printato per value 2 sara' still 10, e non il 40 from the namespace
	}

The output of this function is 10, not 40. The value2 in namespace Window is hidden by the value2 in f(). If you need to use a name within a namespace, you must qualify the name with the namespace name. An ambiguity can arise using a name that is both globally defined and defined within a namespace. The ambiguity surfaces only if the name is used, not just when a namespace is introduced. This is demonstrated with the following code fragment : 

	namespace Window
	{
		int value1 = 20;
	}
	// ...
	using namespace Window; 
	int value1 = 10;
	void f()
	{
		value1 = 10;  // se vuoi evitare errore dovresti commentare questa linea.
	}

The ambiguity occurs within function f(). The directive effectively brings Window::value1 into the global namespace; because a value1 is already globally defined, the use of value1 in f() is an error. Note that if teh line of code in f() were removed, no error would exist.	

>> USING DECLARATION [pag650 jesse]
The using declaration is similar to the "using" directive except that the declaration provides a finer level control. More specifically, the using declaration is used to declare a specific name (from a namespace) to be in the current scope. You can then refer to the specified object by its name only. The following example demonstrates the use of the using declaration : 

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;	
		int value3 = 60;	
	}
	//...
	using Window::value2; // bring value2 into current scope (solo value2 viene portata nel current scope but not value1 and value3)
	Window::value1 = 10; // value1 must be qualified 
	value2 = 30;
	Window::value3 = 10; // value3 must be qualified

The using declaration adds the specified name to the current scope. The declaration does not affect the other names within the namespace. In the previous example, value2 is referenced without qualification, but value1 and value3  require qualification. The using declaration provides more control over namespace names that you bring into scope. This is in contrast with the directive that brings all names in a namespace into scope. 
After a name is brought into a scope, it is visible until the end of that scope. This behaviour is the same as any other declaration. A "using" declaration can be used in the global namespace or within any local scope. 
NOTE: it is an error to introduce a duplicate name into a local scope in which a namespace name has been declared. The reverse is also true. The following example shows this:

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	// ...
	void f()
	{
		int value2 = 10;
		using Window::value2 ; // multiple declaration 
		std::cout << value2 << std::endl ; 
	}

The line  "using Window::value2 ;" in f() produces a compiler error because the name value2 is already defined. The same error occurs if the using declaration is introduced before the definition of the local value 2
cioe' also this is wrong: 
	void f()
	{
		using Window::value2 ; 
		int value2 = 10; // multiple declaration 
		std::cout << value2 << std::endl ; 
	}

Any name introduced at local scope with a using declaration hides any name outside that scope. Consider the following code snippet: 

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	int value2 = 10; // mi sembra questa sia la linea a cui si riferisce la frase "value2 defined in the global namespace" nel senso che qui dichiari la variabile al di fuori di qualsiasi blocco o funzione quindi diventa global.
	// ...
	void f()
	{
		using Window::value2 ; // yet se poi scrivi questa using declaration all'interno di questo blocco, qui verra utilizzato il valore 40, e il valore 10 del global namespace restera' nascosto. 
		std::cout << value2 << std::endl ; 
	}
------------------------------------------------------------------------------------------ TESTING with Operational code by Ciccio 
// Operational code 
#include <iostream>

	namespace Window
	{
		int value1 = 20;
		int value2 = 40;		
	}
	int value2 = 10; // mi sembra questa sia la linea a cui si riferisce la frase "value2 defined in the global namespace" nel senso che qui dichiari la variabile al di fuori di qualsiasi blocco o funzione quindi diventa global.
	// ...
	void f()
	{
		using Window::value2 ; // yet se poi scrivi questa using declaration all'interno di questo blocco, qui verra utilizzato il valore 40, e il valore 10 del global namespace restera' nascosto. 
		std::cout << value2 << std::endl ; 
	}
  
	int main( )
	{
		f();
		return 0;
	}
---------------------------------------------------------------------- OUTPUT : 
[1063 Day18] >> g++ -o CodeTestPag651.exe List18CiccioTestingLineOfCodeFromPag651.cpp 
[1063 Day18] >> ./CodeTestPag651.exe 
40 # OK ottieni 40 in output proprio come dedotto dal nostro ragionamento. 
------------------------------------------------------------------------------------------- OBSERVATION about >> using directive vs >> using declaration 
As mentioned before, a using declaration gives you finer control over the names introduced from a namespace. A using directive brings all names from a namespace into the current scope. It is preferable to use a declaration over a directive because a directive effectively defeats the purpose of the namespace mechanism. 
A DECLARATION is more definitive because you are explicitly identifying the names you want to introduce into a scope. A using declaration does not pollute the global namespace, as is the case with a using directive (unless, of course, you declare all names found in the namespace). Name hiding, global namespace pollution, and ambiguity all are reduced to a more manageable level by using the using declaration. 
------------------------------------------------------------------------------------------- 
>> ALIAS / >> NAMESPACE ALIAS [pag 652 jesse]
A namespace alias is designed to provide another name for a named namespace. An alias provides a shorthand term for you to use to refer to a namespace. This is especially true if a namesapce name is very long; creating an alias can help cut down on lengthy, repetitive typing. Consider the following code: 

	namespace the_software_company
	{
		int value;
		// ...
	}
	the_software_company::value = 10;   // qui si deve stare a typare tutta una lungo namespace
	...
	namespace TSC = the_software_company;  // e' piu' comodo creare un alias corto tipo TSC = The Software Company
	TSC::value = 20 ;  // in tal modo nelle righe seguenti bastera typare "TSC" al posto di "the_software_company" , piu' veloce e meno probabilita' di mistypes. 
A drawback, of course, it that you alias might collide with an existing name. If this is the case, the compiler catches the conflict and you can resolve it by renaming the alias. 
----------------------------------------------------------------------------------------------
>> UNNAMED NAMESPACE / >> namespace unnamed [pag652 jesse]
An unnamed namespace is simply a namespace that does not have a name. A common use of unnamed saces is to shield global data from potential name clashes between objects files and oter translation units. Every translation unit has a unique, unnamed namespace. All names defined within the unnamed namespace (within each translation unit) can be referred to without explicit quantification. Listing 18.9a and 18.9b are examples of two unnamed namespaces found in two separate files. 
-------------------------------------------------------------------- Listing 18.9a
// file: one.cpp
namespace   // di solito la keyword namespace viene seguita dal "nome" del namespace, ma in questo caso non vi e' alcun nome visto che e' per l'appunto un unnamed namespace. 
{
    int value ;
    char p(zchar *p ) ;
    //. . .
}
-------------------------------------------------------------------- Listing 18.9b
// file: two.cpp
namespace  // qui si dichiara un second unnamed space
{
    int value ;
    char p( char *p ) ;
    //. . .
}
int main( )
{
    char c = p( char * ptr ) ;
}
--------------------------------------------------------------------- 
In the case in which these two listings are compiled into the same executable, each of the names, "value" and function p(), is distinct to its respective file. To refer to a (unnamed namespace) name within a translation unit, use the name without qualification. This usage is demonstrated in the previous example with the call to function p() within each file. 
This use implies a "using" directive for objects referred to from an unnamed namespace. Because of this, you cannot access members of an unnamed namespace in another translation unit. 
The behaviour of an unnamed namespace is the same as a static object having external linkage. Consider this example :
	static int value = 10;
Remember that this use of the static keyword is deprecated by the standards committee. Namespaces now exist to replace code as this static declaration. Another way to think of unnamed namespaces is that they are global variables with internal linkage.
-----------------------------------------------------------------------
>> STANDARD NAMESPACE >> STD [pag654 jesse]
The best example of namespaces is found in the C++ Standard library. The standard library is completely encased within the namespace "std". All functions, classes, objects, and templates are declared within the namespace std. 
You have seen the code such as the following : 
	#include <iostream>
	using namespace std;
Now, you know that when you use the "using" directive in this manner that it is pulling everything  in from the named namespace. 
Going forward, you should consider it bad form to employ the using directory when using the Standard Library. Why? Because doing so pollutes the global namespace of your applications with all the names found in the header. Keep in mind that all header files use the namespace feature, so if you include multiple standard header files and specify the "using" directive, then everything declared in the headers is in the global namespace. 
You might be noting that most of the example in this book violate this rule; this action is not an intent to advocate violating the rule, but it is used for brevity of the examples. Instead of using directive (like "using namespace std;") you should use the using declaration (like "using std::cin" cioe' specificando con precisione quali sono gli item di cui hai bisogno) as shown in the following listing 18.10 : 
---------------------------------------------------------------------- Listing 18.10 starts
#include <iostream>
using std::cin ;  // declaring the three items from the namespace std
using std::cout ;
using std::endl ;
int main( )
{
    int value = 0 ;
    cout << "So, how many eggs did you say you wanted?" << endl ;
    cin >> value ;
    cout << value << " eggs, sunny-side up!" << endl ;
    return( 0 ) ;
}
---------------------------------------------------------------------- Listing 18.10 ends
OUTPUT 
[1065 Day18] >> g++ -o List1810.exe List1810.cpp 
[1066 Day18] >> ./List1810.exe 
So, how many eggs did you say you wanted?
7
7 eggs, sunny-side up!
-----------------------------------------------------------------------
As an alternative you could fully qualify the names that you use, as shown in the following Listing 18.11: 
---------------------------------------------------------------------- Listing 18.11 starts
#include <iostream>
int main( )
{
    int value = 0 ;
    std::cout << "How many eggs did you want?" << std::endl ; // here we qualify namespace items inle. Ma e' barboso ripetere std:: tutte le volte
    std::cin >> value ;
    std::cout << value << " eggs, sunny-side up!" << std::endl ;
    return( 0 ) ;
}
---------------------------------------------------------------------- Listing 18.11 ends
Qualifying namespace items inline might be appropriate for shorter programs but can become quite cumbersome for any significant amount of code. Imagine having to prefix std:: for every name you use that is found in the Standard Library!
--------------------------------------------------------------------------------------------
SUMMARY 
Creating a namespace is very similar to a class definition. A couple of differences are worth noting. First, a semicolon does not follow a namespace's closing brace. Second, a namespace is open, whereas a class is closed. This means that you can continue to define the namespace in other files or in separate sections of a file. 
Anything that can be declared, can be inserted into a namespace. If you are designing classes for reusable library, you should be using the namespace feature. Functions declared within a namespace should be defined outside of that namespace's body. This promotes a separation of interface from implementation and also keeps the namespace from becoming cluttered. 
The using directive is used to expose all names in a namespace into the current scope. This effectively fills the global namespace with all names found in the named namespace. It is generally bad practice to use the using directive, especially with respect to the Standard Library. Use using declaration instead. 
A using declaration is used to expose a specific namespace item into the current scope. This allows you to refer to the object by its name only. 
A namespace alias is similar in nature to a typedef. A namespace alias enables you to create another name for a named namespace. This can be quite useful when you are using a namespace with a long name or nested namespaces. 
Every file can contain  an unnamed namespace. An unnamed namespace, as its name implies, is a namespace without a name. An unnamed namespace allows you to use the names within the namespace without qualification. It keeps the namespace names local to the translation unit. Unnamed namespaces are the same as declaring a global variable with the static keyword.
-----------------------------------------------------------------------------------------------------------------------------------------------
Q&A
	Q Do I have to use namespaces?
A No, you can write simple programs and ignore namespaces altogether. But itis recommended that you do use namespaces. 
	Q Is C++ the only language that uses namespaces?
A No. Other languages also use namespaces to help organize and separate values. This inlcudse languages such as Visual Basic 7 (.NET), C#, and more. Other languages have similar concepts. For example, Java has packages.
	Q What are the unnamed namespaces? Why do I need unnamed namespaces?
A Unnamed namespaces are namespaces without names. They are used to wrap a collection of declarations against possible name clashes. Names in an unnamed namespace cannot be used outside of the translation unit where the namespace is declared.
QUIZ 
- How do you access the function MyFunc() if it is in the Inner namespace within the Outer namespace?
answer:
	Outer::Inner::MyFunc();
- Can I use names defined in a namespace without using the "using" keyword?
	Yes you can use names defined in a namespace by prefixing them with the namespace qualifier. 
- What are the major differences between normal and unnamed namespaces?
	Names in a normal namespace can be used outside of the translation unit where the namespace is declared. Names in an unnammed namespace can only be used withing the translation unit where the namepace is declared. 
- What are the two forms of statements with the using keyword? What are the differences between those two forms?
	The using keword can be used for the using directoves and the usig declarations. A using directive allows all names in a namespace to be used as if they are normal names. A using declaration, on the other hand, enables the program to use an individual name from a namespace without qualifying it with the namespace qualifier. 
- What are the unnamed namespaces? Why do we need unnamed namespaces?
	Unnamed namespaces are namespaces without names. They are used to wrap a collection of declarations against possible name classes. Names in a unnamed namespace cannot be used outside of the translation unit where teh namespace is declared.
- What is the standard namespace? 
The standard namespace std is defined by the C++ standard library. It includes declarations of all names in the Standard Library. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LINK and COMPILE / >> COMPILE e >> LINK  
[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html]
A few commonly-used GCC compiler options are:

$ g++ -Wall -g -o Hello.exe Hello.cpp

    -o: specifies the output executable filename.
    -Wall: prints "all" Warning messages.
    -g: generates additional symbolic debuggging information for use with gdb debugger.

Compile and Link Separately

The above command compile the source file into object file and link with other object files and system libraries into executable in one step. You may separate compile and link in two steps as follows:

// Compile-only with -c option
> g++ -c -Wall -g Hello.cpp
// Link object file(s) into an executable
> g++ -g -o Hello.exe Hello.o

The options are:

    -c: Compile into object file "Hello.o". By default, the object file has the same name as the source file with extension of ".o" (there is no need to specify -o option). No linking with other object files or libraries.
    Linking is performed when the input file are object files ".o" (instead of source file ".cpp" or ".c"). GCC uses a separate linker program (called ld.exe) to perform the linking.

Compile and Link Multiple Source Files

Suppose that your program has two source files: file1.cpp, file2.cpp. You could compile all of them in a single command:

> g++ -o myprog.exe file1.cpp file2.cpp 

However, we usually compile each of the source files separately into object file, and link them together in the later stage. In this case, changes in one file does not require re-compilation of the other files.

> g++ -c file1.cpp
> g++ -c file2.cpp
> g++ -o myprog.exe file1.o file2.o
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> NESTING [pag42 mike]
When you write one if statement inside another, it's called nesting.
example
	int score = 1000;
    if (score >= 500)
    {
        cout << "You scored 500 or more. Nice.\n\n";

        if (score >= 1000)
		{
            cout << "You scored 1000 or more. Impressive!\n";
		}
    }
//
NOTE: you can nest as many levels as you want. However, if you nest code tto deeply, it gets hard to read. In general, you should try to limit your nesting to a few levels at most.
/////////////////////////////////////////////////////////////


>> NEWLINE
To have a new line
- Way 1
	cout << "First Line" << endl << "End Line";
- Way 2
o inserisci tra le due linee:
	cout<<"\n";
- NB: to get a blank line in your output, just place two newline characters back to back. 
ex
		std::cout << "Welcome\nto\n\nC++!\n";
donera'
	Welcome
	to
	
	C++!
--------------------------------------------	

>> NEW LINE ogni 5 di output numeri printati vai a capo 
see examnple pag215
      // if counter is divisible by 5, start a new line of output
      if ( counter % 5 == 0 )
         cout << endl;

>> noexcept  -> see pag 751 deitel 

>> nullptr 
[pag 463deitel]
if after deleting dynamically allocated memory, the pointer will continue to exist in memory, set the pointer's value to nullptr to indicate that the pointer no longer points to memory in the free store. By setting the pointer to nullptr, the program loses access to that free-store space, which could be reallocated for a different purpose.If you do not set the pointer to "nullptr", your code could inadvertently access the reallocated memory, causing subtle, nonrepeatable logic errors. 

>> NUMBER PRECISION 
[pag127deitel]
the number of digits to the right of the decimal point

>> NUMBER SYSTEMS [pag973 deitel]
When we write an integer such as 127 in a C++ program, the number is written in the decimal (base 10) number system. Internally computers use the binary (base 2) number systems. The binary number system has only two digits, 0 and 1. Binary numbers tends to be much longer than their decimal equivalent. Programmers who work in assembly languages, and in high level languges like C++ that enable them to reach donw to the machine level, find ti cumbersome to work with binary numbers. So two other number systems [the octal number system (base8) and the hexadecimal number system (base 16)] are popular, primarily because they make it convenient to abbreviate binary numbers.
NOTE: the hexadecimal number system requires 16 digits: visto che abbiamo solo 0 1 2 3 4 5 6 7 8 9 (10 digits provenienti dalla notazione araba), per le restanti 6 si usano the letters from A to F. Thus in hexadecimal we can have numbers like 876 consisting solely of decimal like digits, numbers like 8A55F consisting of digits and letters, and numbers like FFE consisting solely of letters.
Each of these number systems uses >> positional notation: each potition in which a digit is written has a different >> positional value. For example in the decimal number 937 (the 9 the 3 and the 7 are referred to as symbol values), we say that the 7 is written in the ones position, the 3 is written in the tens position and the 9 is written in the hundreds position. Note that each of these position is a power of the base (base 10) and that these powers begin at 0 and increase by 1 as we move left in the number. 
>> HEXADECIMAL / >> OCTAL / >> BINARY NUMBERS CONVERSION -> pag977 deitel
>> negative binary numbers / >> two's complement notation pag980deitel

>> nontype parameters [pag773 deitel]
>> default type argument / >> default argument [pag773 deitel]
 function templates [pag774]
function templates and overloading are intimately related. When overloaded functions perform identical operations on different type of data, they can be expressed more compactly and conveniently using function templates.
You can then write function calls with different types of arguments and let the compiler generate separate function template specializations to handle each function call appropriately.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> OOOOOOO

>> OBJECT mike explains pag82 mike
Most modern programming languages let you work with sorfware objects (often just called objects) that combine data and functions. 
	- A data element of an object is called a >> data member, while 
	- a fnction of an object is called a >> member function. 
As a concret example, think about an alien spacecraft. An alien spacecraft object might be of a new type called Spacecraftk defined by a game programmer, and might have a data member for its energy level and an member function to fire its weapons. In practice, an object energy level might be stored in its data member energy as an int, and its ability to fire its weapons might be defined in a member function called fireWeapons()

                    /------------------\
					|    Spacecraft    |
                    --------------------
                    |   energy: int    |    <-- data member
                    --------------------
                    |   fireWeapons()  |    <-- member function
                    \------------------/

The cool thing about objects is that you don't need to know the implementation details to use them, just as you don't need to know how to build an airplane to drive one. You only have to know the object's data member and member functions (just as you only need to know where a aircraft's cloche, gas, afterburner button, thrust reverse, brake pedal are located)
You can store objects in variables, just like with built-in types. Therefore, you could store an alien spacecraft object in a variable of the Spacecraft type. You can access data member and member functions using the member selection operator (.), by placing the operator after the variable name of the object. So if you want your alien spacecraft, ship, to fire its weapons only if its energy level is greater than 10, you could write:
	// ship is an object of Spacecraft type
	if (ship.energy > 10)  // si accede al data member "energy"
	{	
		ship.fireWeapons() // si accede alla member function "fireWeapons"
	} 
ship.energy accesses the object's "energy" data member, while ship.fireWeapons() calls the object's fireWeapons() member function.
EXAMPLE: un esempio di object che usi spesso e' una stringa. A "string" is actually an object, and it provides its own set of member functions that allow you to do a range of things with the string object (everything from simply getting its length to performing complex character substitutions). In addition, strings are defined so that they work intuitively with a few of the operators you already know.
---------------- Example from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter03/string_tester.cpp
// String Tester
// Demonstrates string objects

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string word1 = "Game";
    string word2("Over");
    string word3(3, '!');   // questo produce la stringa "!!!"   [>> repeat character in string]

    string phrase = word1 + " " + word2 + word3;  // si concatenano le stringhe usando +. This is possible because the + operator has been overloaded. [>> OVERLOADING mike explaines pag 87 and pag 165 game programming ] Operator overloading redefines a familiar operator so it works differently when used in a new, previously undefined context. In this case, I use the + operator not to add numbers but to join string objects. We are able to do this only because the string type specifically overloads the + operator and defines it so the operator means string object concatenation when used with strings. [mmm raffinato l'approccio!, in effetti si puo' usare + in questo modo perche' all'interno della classe string si ridefinisce il "+" in modo che quando si trovi tra stringa agisca in modo da concatenare le stringe]
    cout << "The phrase is: " << phrase << "\n\n";

    cout << "The phrase has " << phrase.size() << " characters in it.\n\n";   // qui utilizziamo la member function "size" of the string object "phrase" through the member selection operator (the . dot). Every character counts, including spaces.
	// NOTE: the string objects also have a member function >> length(), which just like size() returns the number of characters in the string object.  [confermato anche da pag107 mike : both length() and size() return the same value, so you can use either.]

    cout << "The character at position 0 is: " << phrase[0] << "\n\n";  // this is an example of >> indexing a string object. A string object stores a sequence of char values. You can access any individual char value by providing an index number with the subscripting operator ([]). Do not forget that indexing begins at position 0. Remember, a string object with n characters in it can be indexed from position 0 to position n-1.

    cout << "Changing the character at position 0.\n";
    phrase[0] = 'L';  // not only can you access characters in a string object with the subscripting operator, but you can also reassign them [>> reassign character]
    cout << "The phrase is now: " << phrase << "\n\n";
// >> Iteration through string objects / >> iteration through string objects 
	for (unsigned int i = 0; i < phrase.size(); ++i) // loop through string objects ; note that we made the loop variable i an unsigned int because the value returned by size() is an unsigned integral type.
	{
        cout << "Character at position " << i << " is: " << phrase[i] << endl;
	}
// IN THE REAL WORLD dei loop come quello precedente are often used in games. Iterating through a sequence is a powerful and often used technique in games. You might for example, iterate through hundreds of individual units in a strategy game, updating their status and order. Or you might iterate through the list of vertices of a 3D model to apply some geometric transformation. 
    cout << "\nThe sequence 'Over' begins at location ";                                                     012345 
    cout << phrase.find("Over") << endl;    // donera' in output "5" visto che si comincia a contare da zero GAME OVER
// the find() member function searches the calling string object for the string supplied as an argument. The member function returns the position number of the first occurrence where the string object for which you are searching begins in the calling string object.
    if (phrase.find("eggplant") == string::npos)  // visto che eggplant non compare all'interno della stringa, find() returns a special constant defined in the file string, which we access with string::npos. As a result, the screen displays the message "eggplant' is not in the phrase.
	{
        cout << "'eggplant' is not in the phrase.\n\n";
	} // >> string::npos represents the largest possible size of a string object, so it is greater than any possible valid position number in a string object. Informally, it means "a position number that can't exist". It's the perfect return value to indicate that one string couldn't be found in another.
// >> when using find(), you can supply an optional arugment that specifiess a character number for the program to start looking for the substring. The following line will start looking for the string literal "eggplant" beginning at position 5 in the string object phrase. 
    phrase.erase(4, 5); // >> erase() string member function removes a specified substring from a string object. One way to call the member function is to specify the beginning position and the length of the substring. phrase.erase(4, 5) removes the five character substring starting at position 4.
    cout << "The phrase is now: " << phrase << endl; 

    phrase.erase(4); // another way to call erase() is to supply just the beginning position of the substring. This removes all of the characters starting at that position number to the end of the string object.
    cout << "The phrase is now: " << phrase << endl;

    phrase.erase(); // >> this erase every character in "phrase". As a result phrase becomes the empty string, which is equal to "". [>> empty string. Puoi >> delete every character in a string usando nomeString.erase()]
    cout << "The phrase is now: " << phrase << endl;
// >> empty string detection / >> detect empty string
    if (phrase.empty()) // the empty() member function returns a bool value, true if the string object is empty and false otherwise. 
	{ // visto che phrase una volta eseguita l'istruzione phrase.erase() e' diventata an empty string, il seguente messaggio viene printato su screen.
        cout << "\nThe phrase is no more.\n";
	}

	return 0;
}
///----------------------------------------------- OUTPUT

Character at position 0 is: L
Character at position 1 is: a
Character at position 2 is: m
Character at position 3 is: e
Character at position 4 is:
Character at position 5 is: O
Character at position 6 is: v
Character at position 7 is: e
Character at position 8 is: r
Character at position 9 is: !
Character at position 10 is: !
Character at position 11 is: !

The sequence 'Over' begins at location 5
'eggplant' is not in the phrase.

The phrase is now: Lame!!!
The phrase is now: Lame
The phrase is now:

The phrase is no more.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> Object-oriented programming / object oriented programming / >> OOP
Simple instructive example at pag68deitel
Typically the programs you develop will consist of function main and some classes, each containing data members and members functions. 
[pag67deitel]
example
#include <iostream>
using namespace std;
// GradeBook class definition
class GradeBook
{
public:
   // function that displays a welcome message to the GradeBook user
   void displayMessage() const  // questa e' la member function della GradeBook class
   {
      cout << "Welcome to the Grade Book!" << endl;
   } // end function displayMessage
}; // end class GradeBook
// function main begins program execution // la funzione main e' scritta in fondo poiche' affinche' possa creare a GradeBook object, dobbiamo prima dire al compiler what member functions and data members belong to the class.
int main()
{
   GradeBook myGradeBook; // create a GradeBook object named myGradeBook
   myGradeBook.displayMessage(); // call object's displayMessage function
} // end main
//------------------------------------
Observations: 
- by convention the name of a user-defined class begins with a capital letter (class GradeBook)
- for readability each subsequent word in the class name begins with a capital letter (improves readability)[cioe' esattamente nei nomi in openFOAM : pimpleFoam, rhoSimpleFoam, ogni volta che nel nome entra una nuova parola non si mette l'underscore, giusto si usa la capital letter: this capitalization style was widely used in the Pascal programming language; per questo this capitalization style is often referred as Pascal case, or camel case, visto che le lettere maiuscole che di tanto in tanto compaiono assomigliano a gobbe di cammello.]
- the class definition terminates with a semicolon.
- every class's body is enclosed in a pair of left and right braces {}
- the function main is always called automatically when you execute a program. Most functions do not get called automatically. You must call a member function explicitly to tell it to perform its task
- public keyword, is an access specifier. Access specifiers are always followed by a colon (:)
- the member function appears after the public access specifier: to indicate that the function is "available to the public" = can be called by other function in the program (like main) and by member functions of other classes (if there are any). Oltre a public ci sono anche gli "protected" and "private" access specifiers.
- when you define a function, you must specify a return type to indicate the type of the value returned by the function when it completes the task. In the example above, the return type void indicates that the function will not return any data to its calling function.
- by convention our function names use the camel case style with a lowercase first letter. The parenthesis after the member function name indicate that this is a function. An empty set of parenthesis indicates that this member function does not require additional data to perform its task. 
- la forma del tipo 
	void nomeFunction() const 
is commonly referred as a function header. Quando come nell'esempio sopra la funzione e' dichiarata const, si comunica al compiler che la function should not modify the object on which it's called. 
- every function's body is delimited by left and right braces {}
- typically you cannot call a member function of a class until you create an object of that class. nell'esempio sopra we create an object of class GradeBook called myGradeBook
	int main()
	{
		GradeBook myGradeBook;
the variable type is GradeBook, in maniera similare al type int. Solo che int is a fundamental type built in C++, while GradeBook is a user-defined type. So we need to tell the compiler what GradeBook is by including the class definition.
- each class you create becomes a new type that can be used to create objects. You can define new classes as needed; this is one reason why C++ is known as an extensible programming language.
- we call the member function using the dot operator:
    GradeBook myGradeBook; // create a GradeBook object named myGradeBook
	myGradeBook.displayMessage(); // call object's displayMessage function
"myGradeBook." indicates that main should use the GradeBook object created in the previous line.	
[pag69deitel]
- ARGUMENT and parameters [Argument vs parameter]: a member function can require one or more parameters that represent additional data it needs to perform its task. A function call supplies values -called ARGUMENTS- for each of the function's PARAMETERS. --> per comprendere meglio il ruolo di argument e parameter see fig 3.3 pag 71deitel
diciamo in parole semplici: argument e' cio che si passa per esempio in fase di call di una funzione, mentre parameter lo ritrovi tra le parentesi () nella definizione della funzione, per definire gli input di cui la funzione ha bisogno per funzionare.												
[pag71deitel]
- ATTRIBUTES, DATA MEMBERS and MEMBER FUNCTIONS 
a class normally consists of one or more member functions that manipulate the attributes that belong to a particular oject of the class. Attributes are represented as variables in a class definition. Such variables are called data members and are declared inside a class definition but outside the bodies of the class's member-function definition (see example pag75deitel). Each object of a class maintains its own attributes in memory. These attributes exist throughtout the life of the object. If you create more than one object (a partire dalla stessa classe) each will have its own data member, and these can contain different values.
Cioe' detto in parole spicciole: ogni classe ha degli attributi, che vengono rappresentati attraverso dei data members. Ogni volta che istanzi un oggetto a partire da una classe l'oggetto avra' il proprio data members con il suo specifico valore.
[pag74deitel]
////////////////////////////////////////////////////////////////////////////////////

>> Object-oriented programming / object oriented programming / >> OOP / >> object oriented analysis and design [pag329 jesse book]
It is easy to become focused on the syntax of C++ and to lose sight of how and why you use these techniques to build programs. 
Today you will learn: 
- how to use object oriented analysis to understand the problem you are trying to solve
- how to use object oriented design to create a robust extensible and reliable solution 
- how to use the unified modeling language (UML) to document your analysis and design
BUILDING MODELS 
If complexity is to be managed, a model of the universe must be created. The goal of the model is to create a meaninful abstraction of the real world. 
Such an abstraction should be simpler than the real world but should also accurately reflect the real world so that the model can be used to predict the behaviour of things in the real world.
Object oriented software design is about building good models. It consists of two significant pieces: a modelling language and a process. 
>> MODELLING LANGUAGE / >> MODELING LANGUAGE : [pag 330 jesse] The modelling language is the least important aspect of object oriented analysis and design; unfortunately, it tends to get most attention. In the >> UML = unified modelling language, classes are drawn as rectangles and inheritance is drawn as a line with an arrowhead. Interestingly, the arrowhead points from the more specialized class to the more general class. 90 percent of the time you use only a small subset of the UML notation, and that subset is easily learned.
>> PROCESS in software design. [pag 331 jesse book]
The process of object oriented analysis and design is much more complex and important than the modelling language. So, of coarse, it is ironic that you hear much less about it. 
That is because the debate about modelling languages is pretty much settled; as an industry, it has been decided that UML is the primary standard to be used. The debate about process, however, ranges on. 
A method is a modelling language and a process. Method is often incorrectly referred to as "methodology". But "methodology" is the study of methods. 
A methodologist is someone who develops or studies one or more methods. Typically, methodologists develop and publish their own methods. Three of the leading methodologists and teir methods are Grady Booch, who developed the Booch Method, Ivar Jacobson who developed obeject-oriented software engineering, and James Rumbaugh, who developed Objct Modelling Technology (>> OMT). Together, these three men have created what is now called the Rational Unified Process, a method and a commercial product from Rational Software, inc. All three men have been emplyed at IBM's Rational Software division, where  they have affectionately been known as the Three Amigos. 
Today's lesson loosely follows their process rather than slavishly adhering to academic theory, it is much more important to ship a product than to adhere to a method. 
The process of software design can be iterative. In that case, as software is developed, you can go through the entire process repeatedly as you strive to enhance your understanding of the requirements. The design directs the implementation, but the details uncovered during implementation feed back into the design. In this approach, you should not try to develop any sizable project in a single orderly straight line; rather you should iterate over pieces of the project, constantly improving your design and refining your implementation. 
>> WATERFALL DEVELOPMENT  vs >> ITERATIVE DEVELOPMENT [pag332 jesse]
In waterfall development the output  from one stage becomes the input to the next. Just like you can't easily go up a waterfall, with this  method of development there is no going back to previous stages. 
       
        top of the water fall
		------------------------------
                     ANALYSIS           |______________       
                                                           DESIGN         |_____________________
                                                                                           IMPLEMENTATION      |_______________
                                                                                                                                              TEST            |____ bottom of the waterfall

In a waterfall development process, the requirements are detailed, and the clients sigh off ("yes that's what I want"); the requirements are then passed on to the designer, set in stone. The designer creates the design and passes it off to the programmer who implements the design. The programmer, in turn hands the code to a Quality Assurance person who tests the code and then releases it to the customer. Great in theory, however, this is potentially disastrous in practice.
>> ITERATIVE DEVELOPMENT : when you have a good start on the requirements, you begin the design, knowing full well that the questions that arise during design might cause modifications back in the requirements. As you work on design, you can also begin prototyping  and then implementing the product. The issues that arise in development feed back into design and might even influenc your understanding of the requirements. Most important, you design and implement only pieces of the full product, iterating over the design and implementation phases repeatedly.       
Although the steps of the process are repeated iteratively, it is nearly impossibleto describe them in a such a cyclical manner. Therefore, the following list describes them in sequence. 
The following are the steps of the iterative development process:
	- STEP1: CONCEPTUALIZATION
	Conceptualization is the "vision thing". It is the single sentence that describes the great idea
	- STEP2: ANALYSIS
	Analysis is the process of understanding the requirements
	- STEP3: DESIGN
	Design is the process of creating the model of your classes, from which you will generate your code. 
	- STEP4: IMPLEMENTATION 
	Implementation is writing it in code (for example in C++)
	- STEP5: TESTING 
	Testing is making sure that you did it right 
	- STEP6: ROLLOUT 
	Rollout is getting it to your customers. 
Endless controversies exist about what happens in each stage. Here's the secret: it does not matter. The essential steps are the saem in just about every object-oriented process: find out what you need to build, design a solution, and implement that design. The goal is to produce code that meets the stated requirements, and that is reliable, extensible and maintanable. Most important the goal is to produce high quality code on time and on budget. 
-----------------------------------------------------------------------------
STEP1 the conceptualization phase: starting with The Vision. 
All great software starts with a vision. One individual has an insight into a product he thinks would be good to build. 
The very first phase of object-oriented analysis and design is to capture this vision in a single  sentence (or at most a short paragraph) [per esempio il nostro "3D hyperlink scientifi paper visualizer" perche' girare le pagine e ritrovare i rimandi di equazioni e immagini quando si studia un scientific paper sucks, meglio implementare un programma che a partire dal pdf ti faccia poppare l'equazione o immagine right in front of your eyes one you click on the link referenced]. Even if the vision statement comes out of  a committee in the marketing deparment, one person should be designated as the "visionary" . It is his job to be the keeper of the sacred light. As you progress the requirements will evolve. But the visionary must keep an eye on the essential idea, to ensure that whatever is produced reflects the core vision with high fidelity. If you lose sight of the vision, your product is doomed.
STEP2: Analysis phase, gathering requirements 
Some companies confuse the vision statement with the requirements. A strong vision is necessary, but it is not sufficient. To move on to design, you must understand how the product will be used and how it must perform. The goal of the analysis phase is to articulate and capture these requirements. The outcome of the analysis phase is the production of a requirement document. The first section in the requirement document is the use-case analysis. 
>> USE CASES 
The driving force in analysis, design, and implementation is the use cases. A use case is nothing more than a high-level description  of how the product will be used. Use cases drive not only the analysis, but they also drive the design, they help you determine the classes, and they are especially important in testing the product. 
Creating a robust and comprehensive set of use cases might be the single most important task in analysis. It is here that you depend most heavily on your domain experts (those experts having the most information about the business requirements you are trying to capture).
Use cases pay little attention to the details of the user interface, and they pay no attention to the internals of the system you are building. Rather, they should be focused on the interactions that need to occur and those people and systems (called actors) that will need to be working together to produce the desired results.
To summarize, the following are some definitions : 
- >> use case = a description of how the software will be used 
- >> domain experts = people with expertise in the domain (area) of business for which you are creating the product.
- >> actor = any person or system that interacts with the system you are developing. 
A use case is a description of the interaction between an actor and the system itself. For purposes of use-case analysis, the system is treated as a black box. An actor sends a message to the system, and something happens: information is returned, the state of the system is changed, the spaceship changes direction, whatever. 
IDENTIFYING THE ACTORS
It is important to note that not all actors are people. Systems that interact with the system you are building are also actors. 
Essential characteristics of actors are as follows: 
	- they are external to the system
	- they interact with the system
Getting started is often the hardest part of use case analysis. Often, the bst way to get going is with a brainstorming session. Simply write down the list of people and systems that will interact with your new system. Remember that people really means roles, one person can have more than one role. For example if you are building an automated teller machine, the list of roles would include:
- the customer
- the bank personnel 
- a back office system 
- the person who fills the ATM with money and supplies.        
No need exists to go beyond the obvious list at first. Generating even three or four actors might be enough to get you started on generating use cases. Each of these actors interacts with the system in different ways. You need to capture these interactions in the use cases. 
-------------------------------------------------------------------------------------------------
>> DOMAIN MODEL [pag339 jesse book]
After you have a first cut at your use cases, the requirements document can be fleshed out with a detailed domain model. The domain model is a document that captures all you know about the domain (the field of business you are working in). As part of your domain model, you create domain objects that describe all the objects mentioned in your use cases. For example in the ATM example we would have these objects: customer, bank personnel, back-office systems, checking account, savings account, and so forth. 
For each of these domain objects, you need to capture essential data, such as the name of the object (for example, customer, account, and so on), whether the object is an actor, the object's principal attributes and behaviour. It is important to realize that what is being described here is not the class that will be used in the design (even though there will probably be similar classes used in the design), but rather classes of objects in the requirements domain. This is documentation of what the requirements will demand of the system, not documentation of how the system will meet those requirements. 
You can diagram the relationship among the objects in the domain of the ATM example using UML (with the same diagramming conventions that will be used later to describe the relationships among classes in the design). This is one of the great strengths of the UML: you can use the similar representations at every stage of the project. For example you can capture that checking accounts and savings accounts are both specializations of the more general concept of bank account by using the UML convections for classes and generalization relationships. 
The UML is a rich modelling language, and you can capture any number of relationships. The principal relationships captured in analysis, however, are as follows: 
- generalization (or specialization)
- containment 
- association 
>> GENERALIZATION : generalization is often equated with inheritance, but a sharp and meaningful distinction exists between the two. Generalization describes the relationship; inheritance is the programming implementation of generalization. Inheritance is how generalization is manifested in the code. The other side of the generalization coin is specialization. A cat is a specialized form of animal; animal is a generalized concept that unifies cat and rabbits. 
Specialization implies that the derived object is a subtype of the base object. During domain analysis, you should seek to capture these relationships as they exist in the real world. 
>> CONTAINEMENT : often one object is compsed of many subobjects. For example a car is composed of a steering wheel, tires, doors, radio and so forth. A checking account is composed of a balance, a transaction history, a customer ID, and so on. The checking account has these items; containment models the "has a" relationship (cioe' la relazione "containment" modella la "has a " relationship). The UML illustrates the containment  relationship by drawing a line with a diamond from the containing object to the contained object. 
>> ASSOCIATION : the third relationship commonly captures in the domain analysis is a simple association. An association suggests that two objects interact in some way, without being terribly precise about what that way actually might be. This definition will become more precise in the design stage, but for analysis it is only being suggested that Object A and Object B interact, but neither contains the other or neither is a specialization of the other. This association is shown in the UML with a simple straight line between the objects. 
-----------------------------------------------------
>> SCENARIOS / Establishing scenarios 
Each use case can be broken into a series of scenarioes. A scenario is a description of a specific set of circumstances that distinguish among the various elements of the use case. Each scenario explores a variation on the original use case. Often these variations are exception conditions (for example if you take the use case "customer withdrawas money from his account" a possible scenario would be "not enough money in account" scenario, or "not enough money in the machine" scenario and so on). Not every possible scenario must be explored, rather you are looking for those scenarios that tease out requirements of the system or details of the interaction with the actor.
Establishing guidelines 
As part of your method, you need to create guidelines for documenting each scenario. You capture these guidelines in your requirements document. Typically you need to ensure that each scenario includes the following : 
- preconditions = what must be true for the scenario to begin 
- triggers = what even causes the scenario to begin 
- what actions the actors take 
- what results or changes are caused by the system
- what feedback the actors receive
- whether repeating activities occur, and what causes them to conclude 
- a description of the logical flow of the scenario 
- what causes the scenario to end 
- postconditions = what must be true when the scenario is complete 
>> USE CASE DIAGRAM [pag 345 jesse] Con questi diagrammi puoi visualizzare the interaction betwen the actor and the system. You can write the interaction among use cases. Only two interactions are possible: 
	<<uses>>
	<<extends>>
The <<uses>>  stereotype indicates that one use case is a superset of another. For example, it isn't possible to withdraw cash without first logging in. 
The <<extends>> use case was intended to indicate conditional relationships and something akin to inheritance. 
>> INTERACTION DIAGRAMS  [pag 346 jesse] 
>> PACKAGES [pag347 jesse] Because you generate many use cases for any problem of significant complexity, the UML enables you to group your use cases in packages. A package is like a directory or a folder it is a collection of omdelling objects (classes, actors and so forth). To manage the complexity of use cases, you can create packages aggregated by whatever characteristics make sense for your problem. Thus you can aggregate your use cases by account type, by credit or debit, by customer type ot whatever characteristics make sense to you. More important, a single use case can appear in different packages, allowing you great flexibility. 
>> APPLICATION ANALYSIS [pag347 jesse] In addition to creating use cases, the requirements document must capture your customer's assumptions, and any constraints or requirements concerning hardware and operating systems, security, performance and so forth. These requirements are your particular customer's prerequisites (= those things that you would normally determine during design and implementation but that your client has decided for you). For example the client has a standing investment in a particular operating system or hardware platform. The client's business plan depends on your software running on the existing system, and you must capture these requiements early and design accordingly.
>> SYSTEM ANALYSIS [pag347 jesse] Some software is written to stand alone, interacting only with the end user. Ofter, however you will be called on to interface to an existing system. System analysis is the process of collecting all the details of the systems with which you will interact. These and related questions must be answered in the analysis phase, before you begin to design your new system. In addition you need to try to capture the constraints and limitations implicit in interacting with the other systems. Will they slow down the responsiveness of your system? Will they put high demands on your new system, consuming resources and computing time? 
>> BUDGET and >> TIMELINE [pag347 jesse]
After you understand what your system must do and how it must behave, it is time to take a first stab  at creating a time and budget document . There are a couple guidlines to keep in mind: 
1) if you are given a range, the outer number is probably optimistic 
2) Liberty's Law states that everything takes longer than you expect (even if you take into account Liberty's Law). 
Given these realities, it is imperative that you prioritize your work so that the most important tasks are done first. You should not expect to have time to finish, it is that simple. It is important that when you run out  of time, what you have works and is adequate for the first release. If you are building  a bridge and run out of time, if you didn't get a chance to put in the bicycle path, that is too bad; but you can still open the bridge and start collecting tolls. If you run out of time and you're only halfway across the river, that is not as good. 
An essential thing to know about planning documents is that they are generally wrong. This early in the process, it is virtually impossible to offer a reliable estimate of the duration of the project. After you have the requirements, you can get a good handle on how long the design will take, a fair estimate of how long the implementation will take, and a reasonable guessstimate of the testing time. Then you must allow yourself at least 20 to 25 percent "wiggle room" which you can tighten as you move forward through the iterations and learn more. 
NOTE : the inclusion of "wiggle room" in your planning is not an excuse to avoid planning documents. It is merely a warning not to rely on them too much early on. As the project goes forward, you'll stregthen your understanding of how the system works, and your estimates will become increasingly precise.
>> VISUALIZATION [pag 349 jesse] The final piece of the requirements document is the visualization. The visualization is a fancy name for the diagrams, pictures, screen shots, prototypes, and any other visual representations created to help you think through and design the graphical user interface of your product. 
>> ARTIFACTS / >> DELIVERABLES [pag 349 jesse] : at the end of each pahse of analysis and design, you will create a series of documents (often called artifacts or deliverables)                          
ARTIFACT                                                      DESCRIPTION 
use-case report                                             document detailing the use cases, scenarios, steoreotypes, pre/postconditions, visualizations
domain analysis                                             document and diagrams describing the relationships among  the domain objects
analysis collaboration diagrams                    collaboration diagrams describing interatcions among objects in the problem domain. 
analysis activity diagrams                              acitivity diagrams describing interactions among objects in the problem domain 
system analysis                                              report and diagrams describing low level and hard ware systems on which the project will be built
application analysis document                       report describing the customer's requirements specific to this particular project 
operational constraints report                      report describing performance characteristics and constraints imposed by this client 
cost and planning document                          report indicating projected scheduling, milestones and costs. 
--------------------------------------------------------------------------------------------------------------------------------
>> DESIGN PHASE [pag 350 jesse]
Analysis focuses on understanding the problem domain, whereas the next step of the processes, design, focuses on creating the solution. Design is the process of transofrming your understanding of the requirements into a model that can be implemented in software. The result of this process is the production of a design document.
A design document can be divided into two sections: class design and archictectural mechanisms. 
The class design section in turn is divided into static design (which details the various classes and their relationships and characteristics) and dynamic design (which details how the classes interact).  The Architectural mechanisms section of the design document provides details about how you will implement object persistence, concurrency, a distributed object system, and so forth. 
--------------------------
What are the classes?
 As a C++ programmer, you are now used to creating classes. Formal design methods require you to separate the concept of the C++ class from the concept of the deisgn class, although they are intimately related. The C++ class you write in code is the implementation of the class you designed. There is a one to one relationship: each class in your design correspond to a class in your code, but don't confuse one for the other. It is certainly possible to implement your design classes in another language, and the syntax of the class definitions might be changed. 
You capture the design model's classes in UML diagrams, and you capture the implementation's C++ classes in code that can be compiled. The distinction is meaninful, yet subtle. 
In any case, the biggest stumbling block for many novices is finding the initial set of classes and understanding what makes a well designed class. One simplsitic technique suggests writing out the use-case scenarios and then creating a class for every noun. 
Considering the following use-case scenario: 
CUSTOMER chooses to withdraw CASH from CHECKING. Sufficient cash is in the ACCOUNT, sufficient cash and RECEIPTS are in the ATM, and the NETWORK is up and running. The ATM asks the customer to indicate the AMOUNT for the WITHDRAWAL, and the customer asks for $300, a legal amount to withdraw at this time. The MACHINE dispenses $300 and prints a receipt, and the customer takes the MONEY and the receipt. 
You might pull out from this scenario the following classes:
	Customer 
	Cash
	Checking 
	Account
	Receipts 
	ATM
	Network
	Amount 
	Withdrawal 
	Machine 
	Money
You might then aggregate the synonyms to create this list, and then create classes for each of these nouns:
	Customer 
	Cash (money, amount, withdrawal)
	Checking 
	Account 
	Receipts 
	ATM (machine)
	Network
----------------------------------------------
In the preceding sections we begin transforming objects from the domain analysis into objects in the design. That is a fine first step. Often many of the objects in the domain have >> surrogates in the design. An object is called a surrogate to distinguish between the actual physical receipt dispensed by an ATM and the object in your design that is merely an intellectual abstraction implemented in code.     
You will likely find that most of the domain objects have a representation in the design, that is a one to one correspondence exists between the domain object and the design object. Other times, however a single domain object is represented in the design by an entire series of design objects. And at times, a series of domain  objects might be represented by a single design object. 
NOTE : often each actor has a class. A good staring place is with the interface between your new system and any existing systems, this should be encapsulated in an interface class. However, be careful when  considering databases and other external storage media. It is generally better to make it a responsibility of each class to mange its own "persistence", that is how it is stored and retrieved between user sessions. Those design classes, of coarse, can use common classes for accessing files or databases, but most commonly, the operating system or the database vendor provides these to you. 
These interface classes allow you to encapsulate your system's interactions with the other system, and thus, shield your code  from changes in the other system. Interface classes allow you to change your own design, or to accommodate changes in the design of other systems, without breaking the rest of the code. As long as the two systems continue to support the agreed on interface, they can change independently of one another.
>> DATA MANIPULATION  : similarly you might need to create classes for data manipulation. If you have to transform data from one form into another format you might want to encapsulate these transformations behind a special class. Any time you must manipulate data into a specified format, you encapsulate the protocol behind a data manipulation class.
>> DEVICES [pag 354 jesse book] If your system interacts with or manipulates devices (such as printers, cameras, modems, scanners, and so forth) the specifics of the device protocol ought to be encapsulated in a class. Again, by creating a class for the interface to the device, you can plug in new devices with new protocols  and not break any of the rest of your code; just create a new interface class that supports the same interface (or a derived interface) and off you go. 
>> STATIC MODEL BUILDING [pag354 jesse] When you have establihed your preliminary set of classes, it is time to begin modelling their relationships and interactions. For purposes of clarity, the static model is explained first, and then the dynamic model. In the actual design process, you will move freely between the static and dynamic models, filling in details of both, and in fact adding new classes and sketching them in as you learn from each. 
The static model focuses on three areas of concern:
- responsabilities 
- attributes 
- relationships
The most important of these (and the one to focus on first) is the set of responsabilities for each class. The most important guiding principle is this: EACH CLASS SHOULD BE RESPONSIBLE FOR ONE THING. 
That is not to say that eachclass has only one method. Faaar from it! Many classes will have dozens of methods. But all these methods must be coherent and cohesive; that is they must all relate to one another and contribute to the class's capability to accomplish a single area of responsability. 
In a well designed system, each object is an instance of a well defined and well understood class that is responsible for one area of concern. Classes typically delegate extraneous responsabilities to other, related classes. By creating classes that have only a single area of concern, you promote the creation of highly maintanable code. 
To get a handle on the responsibilities of your classes, you might find it beneficial to begin your design work with the use of CRC cards. 
Using >> CRC Cards [pag 354 jesse]
CRC stand for Class, Responsibility and Collaboration. CRC is nothing more than a 4x6 index card (~ un piccolo e semplice foglietto di carta). This simple low tech device enables you to work with other people in understanding the primary responsibilities of your initial set of classes. You assemble a stack of blank 4x6 cards  and meet around a conference table for a series of CRC card sessions. 
How to conduct a CRC session : for a large project or component, each CRC session should be attended, ideally by a group of three to six people; any more becomes unwieldy. You should have a facilitator whose job is to keep the session on track and to help the participants capture what they learn. At least one senior software architect should be present, ideally someone with significant experience in object-oriented analysis and design. In addition you need to include at least one or two "domain experts" who understand the system requirements and who can provide expert advice in how things ought to work. 
The most essential ingredient in CRC session is the conpicucous absence of managers. This is a creative free wheeling session that must be unencumbered by the need to impress one's boss. The goal here is to explore, to take risks, to tease out the responibility of the classes, and to understand how they might interact with one another. 
You begin the CRC session by assembling your group around a conference table, with a small stack of cards. At the top of each CRC card, you write the name of a single class. Draw a line down the center of the card and write "Responsibilities" on the left and "Collaborations" on the right. Begin by filling out cards for the most important classes you' ve identified. For each card, write a one sentence or two sentence definition on  the back. 
The point of the CRC session is to idenfity the responsibilities of each class. Pay little attention to the attributes, capturing only the most essential and obvious attributes as you go. The important work is to identify the responsibilities. If, in fulfilling a responsibility, the class must delegate work to another class, you capture that information under "collaborations".
As you progress, keep an eye on your list of responsabilities. If you run out of room on your 4x6 card, it might make sense to wonder whether you're asking this class to do too much. Remember, each class should be responsible for one general area of work, and the various responsibilities listed should be cohesive  and coherent that is they should work together to accomplish the overall responsibility of the class. 
At this point, you do not want to focus on relationships, nor do you want to worry about the class interface or which methods will be public and which  will be private. The focus is ONLY on understanding WHAT EACH CLASS DOES. 
LIMITATIONS  of CRC cards: although CRC cards can be a powerful tool for getting started with design, they have inherent limitations. The first problem is that they do not scale well. In a very complex project, you can be overwhelmed with CRC cards; just keeping track of them all can be difficult. 
CRC cards also don't capture the interrelationship among classes. CRC cards are good at start, but you need to move the classes into UML if you are to build a robust and complete model of your disegn. Although the transition into the UML is not terribly difficult, it is a one way street. After you move your classes into UML diagrams, there is no turning back; you set aside the CRC cards and don't come back to them. It is simply too difficult to keep the two modes syncronized with one another. 
>> CRC UML transformation : Each CRC card can be translated directly into a class modeled with the UML. Responsabilities are translated into class methods, and whatever attributes you have captured are added as well. The class definition from the back of the card is put into the class documentation. 
>> RELATIONSHIPS among classes / >> CLASS RELATIONSHIPS [pag358 jesse] 
After the classes are in  the UML, you can begin to turn your attention to the relationship among the various classes. The principal relationships you'll model are the following : 
	- generalization
	- association 
	- aggregation 
	- composition 
The generalization relationship is implemented in C++ through public inheritance. You examined the generalization relationship in the analysis phase, but now turn you attention to the objects in your design rather than to just the objects in the domain. Your efforts should now be to "factor out" common functionalities in related classes into base classes that can encapsulate the shared responsabilities.
When you factor out common functionalities, you move that functionality out of the specialized classes and up into the more general class. Thus if you notice that both your checking and your savings account need methods for transferring money in and out, you'll move the TransferFunds() method up into the account base class. The more you factor out of the derived classes, the more polymorphic your design will be. 
One of the capabilities available in C++ is multiple inheritance. Multiple inheritance allows a class to inherit from more than one base class, bringing in the members and methods of two or more classes. Experience has shown that you should use multiple inheritance judiciously because it can complicate both your design and the implementation. Many problem initially solved with multiple inheritance are today solved using aggregation. That said, multiple inheritance is a powerful tool, and your design might require that a single class specializes the behaviour of two or more other classes. 
>> MULTIPLE INHERITANCE vs >> CONTAINMENT  / >> INHERITANCE vs >> CONTAINMENT  [pag 358 jesse]
Is an object the sum of its parts? Does it make sense to model a Car object as a specialization of "SteeringWheel", "Door", "Tire" ? NO, it does not make sense it would be a false inheritance. It is important to come back to the fundamentals:  public inheritance should always model generalization. The common expression for this is that inheritance should model a "is a" relationships. To say the The car "is a" door is wrong. We should say the car "has a" door. If you want to model the "has a" relationship, you do so with aggregation. As shown at pag 359, the aggregation is represented with a white diamond (scritto next to the class that is owner of the various parts). The diamond in the diagram is not filled in because this relationship is being modelled as an aggregation, not as a composition. Composition implies control for the lifetime of the object. Although the car "has" tires and door, the tires and door can exist before they are part of the car and can continue to exist after they are no longer part of the car. 
At pag360 trovi invece un esempio of >> composition with the >> black diamond / >> filled diamond: this model says that the body is not only an aggregation of a head, two arms and two legs but that these objects (hands, arms, legs) are created when the body is created and disappear when the body disappears. That is, they have no independent existence; the body is composed of these things and their lifetimes are intertwined. 
>> DISCRIMINATORS AND >> POWERTYPES [pag360 jesse]  
Powertypes enable you to create a variety of logical types without using inheritance. You can thus manage a large and complex set of types without the combinatorial explosion you might encounter with inheritance. 
Typically you implement the powertype in C++ with pointers. 
Keep in mind that the practice of creating new types in this way at runtime can reduce the benefits of C++ strong typing, in which the compiler can enforce the correctness of interclass relationships. Therefore use it carefully. 
NOTE: powertypes enable you to create new types (not just instances) at run-time. Because each logical type is differentiated only by the attributes of the associated powertype, these attributes can be parameters to the powertype's constructor. This means that you can, at runtime, create new types of objects on the fly.
-----------------------------------------------------------------------------------------------------------------
>> DYNAMIC MODEL / >> SEQUENCE DIAGRAM [pag363 jesse book]
In addition to modelling the realtionshps among the classes, it is critical to model how they interact. 
>> COLLABORATION DIAGRAM [pag364 jesse book.]
Interaction diagrams come in 2 flavours. Sequence diagrams and collaboration diagrams. The sequence diagram emphasizes the sequence of events over time; the collaboration diagram emphasizes the "timeless" interactions among the classes. 
>> STATE TRANSITION DIAGRAMS [pag 364 jesse book]
As you come to understand the interactions among the objects, you also have to understand the various possible states of each individual object. You can model the transitions among the various states in a state diagram (or state transition diagram). 
Next steps: implementation, testing and rollout. 
Don't forget that carefully testing your classes in isolation and together is key to determining that you have successfully implemented the design. 
------------------------------
Q&A from pag 368 jesse book
In what way is object oriented analysis and design fundamentally different from othe approaches?
Prior to the development of these object oriented techniques, analysist and programmers tended to think of programs as groups of functions that acted on data. Object oriented programming focuses on the integrated data and functionality as discrete units that have both knowledge (data) and capabilities (functions). 
Procedural programs, on the other hand, focus on functions and how they act on data. It has been said that Pascal and C programs are collection of procedures, and C++ program are collections of classes. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> OOP / >> Object Oriented Programming [mike programming game pag 241]
In OOP you define different types of objects with relationships to each other that allow the objects to interact. 
One of the key characteristics of OOP is the ability to make your own types from which you can create objects.
C++ lets you represent game entities as software objects, complete with member functions and data members. These objects work just like "string" and "vector" objects. But to use a new kind of object (say, an alien spacecraft) you must first define a type for it.
In the Simple Critter Program (example below) we define a brand new type called "Critter" for creating virtual pet objects. The program uses this new type to create two Critter objects. Then, it gives each cirtter a hunger level. Finally, each critter offers a greeting and announces its hunger level to the world. 
>> CLASS = code that groups data members and member function (p243 mike game programming). From a class, you create individual objects that have their own copies of each data member and access to all of the member functions. A class is like a blueprint. Just as a blueprint deines the structure of a building, a class defines the structure of an object. 
NOTE: to define a class, start with the keyword "class", followed by the class name. By convention, class names begin with an uppercase letter. You surround the class body with curly braces and end it with a semicolon. 
--------------------------------------------------------- START EXAMPLE
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/simple_critter.cpp]
		//Simple Critter
		//Demonstrates creating a new type
		
		#include <iostream>
		
		using namespace std;
[>> CLASS = code that groups data members and member function (p243 mike game programming) here follows a simple example]		
		class Critter            // class definition -- defines a new type, Critter
		{
		public:
		    int m_Hunger;        // data member NOTE convention: notice that we prefix the data "M"ember name with m_, convention to make data "M"ember instantly recognizable.
		    void Greet();        // member function prototype; NOTE: by convention member function names begin with an uppercase letter. 
		};
		
// you can define member functions outside of a class definition
		void Critter::Greet()    // member function definition
		{
		    cout << "Hi. I'm a critter. My hunger level is " << m_Hunger << ".\n";
		}
// >> MEMBER FUNCTION note [nmike pag244 mike programming]: the definition of a member function looks like any other function definition, except for the prefix "Critter::" to the function name. When you define a member function outside of its class, you need to qualify it with the class name and scope resolution operator so the compiler knows that the definition belongs to the class.
		
		int main()
		{
		    Critter crit1;   // INSTANTIATION OBJECTS
		    Critter crit2;
// when you create an object (come nelle due righe precedenti) you instantiate it from a class. In fact specific objects are called >> instances of the class [pag245 mike programming game].
		    // >> data member access [pag245 mike game programming]: you can access an available data member of an object using the member selection operator "." 
		    crit1.m_Hunger = 9;  //assigns "9" to crit1's data member m_Hunger
		    cout << "crit1's hunger level is " << crit1.m_Hunger << ".\n";
		
		    crit2.m_Hunger = 3;
		    cout << "crit2's hunger level is " << crit2.m_Hunger << ".\n\n";
		    
		    crit1.Greet(); 
		    crit2.Greet();
		
		    return 0;
		}
------------------------------------------------------------------ END EXAMPLE
  
////////////////////////////////////////////////////////////////////////////////////

>> OOP SUMMARY OBSERVATION from mike game programming pag 265
- Object oriented programming  is a way of thinking about programming in which you define different types of objects with relationships that interact with each other. 
- You can create a new type by defining a class
- A class is a blueprint for an object
- In a class you can declare data members and member functions. 
- When you define a member function outside of a class definition, you need to quailify it wit the class name and scope resolution operator (::)
	i.e. type nomeClass::nomeMemberFunction(input_parameters)
- You can access data members and member functions of objects through the member selection operator (.)
- Every class has a constructor (a special member function that's automatically called every time a new object is instantied). Constructors are often used to initialize data members 
- You can set member access levels in a class by using the keywords public, private, and protected. 
- A public member can be accessed by any part of your code through an object.
- A private member can be accessed only by a member function of that class.
- A static data member exists for the entire class.
- A static member function exists for the entire class.
- Some game programmers prefix private data member names with m_ and static data members names with s_ so that they're instantly recognizable
PAG267 mike programming: >>struct
What is a structure? A structure is very similar to a class. The only real difference is that the default access level for structures is public (al contrario delle classi in cui il default access level is private). You define a structure by using the keyword "struc". 
Why does C++ have both structures and classes? So that C++ retains backward compatibility with C.
Some game programmers use strutures to group only data together, without functions (because that's how C structures work). But it's probably best to avoid structures whenever possible and use classes instead. 
////////////////////////////////////////////////////////////////////////////////////


>> object size 
[pag385deitel]
People new to object-oriented programming often suppose that objects must be quite large because they contain data member and member functions. Logically this is true (you may think of objects as containing data and functions) but PHYSICALLY however this is not TRUE.
>> PERFORMANCE and object size
Objects contain only data, so objects are much smaller than if they also contained member functions. The compiler creates one copy (only) of the member functions separate from all objects of the class. All objects of the class share this one copy. Each object, of course, needs its own copy of the class's data, because the data can vary among the objects. The function code is nonmodifiable and, hence, can be shared among all objects of one class.

>> object's scope / >> object scope
[pag394deitel]
the block in which that object is defined

>> object serialization 
[pag628 deitel]
When object data members are output to a disk file, we lose the object's type information. We store only the values of the object's attributes, not type information, on the disk. If the program that reads this data knows the object type to which the data corresponds, the program can read the data into an object of that type as we did in your random access files examples (ex Fig14_14.cpp e compagnia pagine 620-628)
An interesting problem occurs when we store objects of different types in the same file. How can we distinguish them (or their collections of data members) as we read them into a program? The problem is that objects typically do not have type fields.
One approach used by several programming languages is called object serialization. A so called >> serialized object is an object represented as a sequence of bytes that includes the object's data as well as information about the object's type and the types of data stored in the object.
 After a serialized object has been written to a file, it can be read form the file and deserialized (taht is the type information and bytes that represent the object and its data can be used to recreate the object in memory).
C++ does not provide a built-in serialization mechanism; however there are third party and open source C++ libraries that support object serialization. The open source Boost C++ libraries (www.boost.org) provide support for serializing objects in text, binary and extensible markup language (XML) formats. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> output  of char * Variables
[pag568]
C++ determines data type automatically (an improvement over C) but this feature sometimes gets in the way. For example, supose we want to print the address stored in a char * pointer. The << operator has been overloaded to output a char * as null-terminated C-style string. To output the address, you can cast the char * to a void * (this can be done to any pointer variable).   

>> overloading pag 118 jesse
C++ enables you to create more than one function with the same name. This is called function overloading. The functions must differ in their parameter list with a different type of parameter, a different number of parameters or both. Here's an example:
	int myFunction (int, int);
	int myFunction (long, long);
	int myFunction (long);
NOTE: two functions with the same name and parameter list, but different return types, generate a compiler error. To chnage the return type, you must also change the signature
Function overloading is also called function polymorphism ( poly = many, morph = form => function of many forms)
Function polymorphis refers to the capability to overload a function with more than one meaning. By changing the number or type of the parameters, you can give two or more functions the same function name, and the right one will be called automatically by matching the parameters used. 
Suppose you write a function that doubles whatever input you give it. You would like to be able to pass in an "int", a long a float or a double. Senza function overloading saresti obbligato a creare 4 funzioni diverse
	int Double(int);
	long DoubleLong(long);
	float DoubleFloat(float);
	double DoubleDouble(double);
with function overloading, it is sufficient to declare:
	int Double(int);
	long Double(long);
	float Double(float);
	double Double(double);
This is easier to read and easier to use.
--------------------------------------------------------------------------------------------------------------
// Listing 5.8 - demonstrates
// function polymorphism
  
#include <iostream>
  
// prototypes of the functions 
int Double(int);
long Double(long);
float Double(float);
double Double(double);
  
using namespace std;

int main()
{
   int      myInt = 6500;
   long     myLong = 65000;
   float    myFloat = 6.5F;
   double   myDouble = 6.5e20;
  
   int      doubledInt;
   long     doubledLong;
   float    doubledFloat;
   double   doubledDouble;
  
   cout << "myInt: " << myInt << "\n";
   cout << "myLong: " << myLong << "\n";
   cout << "myFloat: " << myFloat << "\n";
   cout << "myDouble: " << myDouble << "\n";
  
   doubledInt = Double(myInt);
   doubledLong = Double(myLong);
   doubledFloat = Double(myFloat);
   doubledDouble = Double(myDouble);
  
   cout << "doubledInt: " << doubledInt << "\n";
   cout << "doubledLong: " << doubledLong << "\n";
   cout << "doubledFloat: " << doubledFloat << "\n";
   cout << "doubledDouble: " << doubledDouble << "\n";
  
   return 0;
}
  
// definition of the functions.
int Double(int original)
{
   cout << "In Double(int)\n";
   return 2 * original;
}
  
long Double(long original)
{
   cout << "In Double(long)\n";
   return 2 * original;
}
  
float Double(float original)
{
   cout << "In Double(float)\n";
   return 2 * original;
}
  
double Double(double original)
{
   cout << "In Double(double)\n";
   return 2 * original;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> operator overloading / >> overloading operator
[pag434 deitel]
Examples
- one example of an overloaded operator built into C++ is << 
in effetti << is used both as the stream insertion operator and as the bitwise left-shift operator.
Similarly, >> also is overloaded: it's used both as the stream extraction operator and the bitwise right-shift operator. 
Both of these operators are overloaded in the C++ standard library.
The overloads are built into the base C++ language itself. For example, C++ overloads the addition operator (+) and the subtraction operator (-) to perform differently, depending on their context in integer, floating point and pointer arithmetic with data of fundamental types.
You can overload most operators to be used with class objects (the compiler generates the appropriate code based on the types of the operands). 
NOTES [from pag 438 deitel]
You can use operators with your own user-defined types. Although C++ does not allow new operator to be created, it does allow most exisiting operator to be overloaded so that , when they're used with objects, they have meaning appropriate to those objects. 
Operator overloading is not automatic, you must write operato-voerloadin functions to perform the desired operations. An operator is overloaded by writing a non-static member function definition or non-member function definition as you normally would, except that the function name starts with the keyword "operator" followed by the symbol for the operator being overloaded. 
For example, the function name "operator+" would be used to overload the addition operator (+) for used with objects of a particular class. When operators are overloaded as member functions, they must be non-static, because they must be called on an object of the class and operate on that object. 
To use an operator on an objet of a class, you must define overloaded operator functions for that class, with three exceptions:
1) the assignment operator (=) may be used with most classes to perform memberwise assignment of the data members (each data member is assigned from the assignment's "source" object (on the right) to the "target" object (on the left). Memberwise assignment is dangerous for classes with pointer members, so we'll explicitly overload the assignment operator for such cases)
2) the address (&) operator returns a pointer to the object; thi operator also can be overloaded.
3) the comma operator evaluates  the expression to its left then the expression to its right, and returns the value of the latter  expression. This operation also can be overloaded. 
>> OPERATORS THAT CANNOT BE OBERLOADED
	. 
	.*(pointer to member)
	::
	?:
>> OPERATOR OVERLOADING RULES AND RESTRICTIONS
[pag439deitel]
- The precedence of an operator cannot be changed by overloading. However, parenthesis can e used to force the order of evaluation of overloaded operators in an expression. 
- the associativity of an operator cannot be changed by overloading: if an operator normally associates from left ot right, then so do all of its overloaded versions.
- you cannot change the "arity" [ tag >> arity] of an operator (tha is , the number of operands an operator takes), overloaded unary operators remain unary operators; overloaded binary operators remain binary operators. Operators &, *, + and - all have both unary and binary version; theses unary and binary veresion can be separately overloaded.  
- you cannot create new operators; only existing operators can be overloaded.
- related operators like + and += must be overloaded separately. 
- when overloading (), [], -> or any of the assignment operator, the operator overloading function must be declared as a class member. For all other overloadable operators, the operator overloading functions can be member functions or non-member functions. 
ADVICE : overload operators for class types so they work as closely as possible to the way built-in operators work on fundamental types. 

>> OVERLOADING UNARY OPERATORS
[pag444deitel]
	bool operator!() const;
>> overloaded operators as non-member functions
	bool operator!( const String & );
//////////////////////////////////////////////////////

>> OVERLOADING BINARY OPERATORS.
[pag 439 deitel] 
A binary operator can be overloaded as a 
1) non-static member function with one parameter or as a 
2) non-member fuction with two parameters
ESEMPI
1) Example binary overloaded operators as member functions [pag440deitel]
	class String
	{
	public:
		bool operator<(const String & ) const;
		...
	}; // end class string
2) binary overloaded operators as non-member functions example [pag440 deitel]
	bool operator<( const String &, const String & );
////////////////////////////////////////////////////////////////////////////////////////


>> OVERLOAD ++ / >> OVERLOAD -- / >> OVERLOAD UNARY PREFIX / >> OVERLOAD UNARY POSTFIX
[pag 445 deitel]
NOTE from pag451 
Overloading the postfix increment operator is trickier. For example if int variable x has the value 7, the statement 
	cout << x++ << endl;
outputs the original value of variable x.

>> OVERLOADING FUNCTIONS [pag165 mike game programming]
Suppose you want to write a function that performs a 3D transofmration ona set of vertices that are represented as floats, but you want the function to work with ints as well. Instead of writing 2 separate functions with 2 different names, you could function overloading so that a single function could handle the different parameter lists. This way, you could call one function adn pass vertices as either floats or ints.
In the full example below we use a single function that 's been overloaded to work with an argument of two different types: int and string. 
TO CREATE AN OVERLOADED FUNCTION, YOU SIMPLY NEED TO WRITE MULTIPLE FUNCTION DEFINITIONS WITH THE SAME NAME OF DIFFERENT PARAMETERS LISTS.
extract example from the FULL EXAMPLE below:
		int triple(int number); // this first function prototype takes an int argument and returns an int
		string triple(string text); // this second function prototype takes a string object and returns a string object.
Seguiranno le corrispondenti function definitions come mostrato nel FULL EXAMPLE qui sotto.
FULL EXAMPLE 
[from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/triple.cpp]
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int triple(int number);
		string triple(string text);
		
		int main()
		{
		    cout << "Tripling 5: " << triple(5) << "\n\n";
		    cout << "Tripling 'gamer': " << triple("gamer");
		
		    return 0;
		}
		
		int triple(int number)
		{
		    return (number * 3);
		}
		
		string triple(string text)
		{
		    return (text + text + text);
		}
---------------------------------------------------------
overloading functions TRAP [pag167 mike game programming]: to implement function overloading, you need to write mupltiple definitions for the same function with different parameter lists. That's because if you write two functions definitions in which only the return type is different, you'll generate a compile error. For example you cannot have both of the following proptotypes in a program:
	int Score(int);
	float Score(int); 
>> OVERLOADED FUNCTION CALL / >> CALL OVERLOADED FUNCTION [pag167 mike game programming]
You can call an overloaded function the same way you call any other function, by using its name with a set of valid arguments. But with overloaded functions, the compiler (based on the argument values) determines which definition to invoke.
For exemple in the FULL EXAMPLE above :
    cout << "Tripling 5: " << triple(5) << "\n\n";
since we call triple() giving an "int" as a argument, the compiler knows to invoke the definition that takes an "int". As a result the function returns the int 15. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
>> OVERRIDE keyword 
pag528deitel

>> OVERRIDE member functions [pag319 mike game programming]
Any inherited base class member function that you expect to be overrideen in a derived class should be declared as virtual, using the keyword virtual. When you declare a member function virtual, you provide a way for overridden version of the member function to work as expected with pointers and references to objects. 
Although you can override non-virtual member functions, this can lead to behaviour you might not expect. A good rule of thumb is to declare any base class member function to be overridden as virtual. 
NOTE: the keyword "virtual" is not used in the definition of the member function, only in its declaration. 
TRAP: don't confuse override with overload. When you override a member function, you provide a new definition of it in a derived class. When you overload a function, you create multiple versions of it with different signatures.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> OR OPERATOR   || 
see LOGICAL OPERATORS

>> ORDER of evaluation of operands 
[pag254]
Most programmers simply assume that the operands are evaluated left to right. C++ does not specify the order in which the operands of most operators are to be evaluated. 
C++ specifies the order of evaluation of the operands of only four operators 
	&&
	||
	,
	?:
the first three (&& || , ) are binary operators whose two operands are guaranteed to be evaluated from left to right.
The last operator ?: is the only ternary operator
- its leftmost operand is always evaluated first
- if it evaluates true, the middle operand evaluates next and the last operand is ignored
- if the leftmost operand evaluates to false, the third operand evaluates next and the middle operand is ignored.
MEMENTO: writing programs that depend on the order of evaluation of the operands of operators other than &&, || ?: and the comman (,) operator can lead to logic errors.

>> out of range exception 
[pag458 deitel]
capita quando il subscript all'interno dell'operatore [] si trova al di fuori del range dell'array
tipo avessi un array "carrier" di 7 elementi e effettuassi un 
	carrier[17] = 1000;
ti verrebbe fuori una out of range exception

>> OVERLOADING CONSTRUCTOR 
[pag392deitel]
A class constructor and member functions can also be overloaded. Overloaded constructors typically allow objects to be initialized with different types and/or numbers of arguments. To overload a constructor, provide in the class definition a prototype for each version of the constructor, and provide a separate constructor definition for each overloaded version.
see esempio pag 392deitel 

>> PPPPPPP

>> PASS-BY-VALUE vs PASS-BY-REFERENCE
[pag237deitel]
- Pass by value: when a value is passed  by value a copy the argument value is made and passed to the called function.
Changes to the copy do not affect the original variable's value in the caller. 
One disadvantage is that, if a large data item is being passed, copying that data can take a considerable amount of execution time and memory space.
- Pass by reference: the caller gives the called function the ability to access the caller's data directly and to modify the data
Pass-by-reference is good for performance reasons, because it can eliminate the pass-by-value overhead of copying large amount of data.
BUT : pass by reference can weaken security; the called function can corrupt the caller's data.
 
>> parameter list [pag101 jesse] = is the list of values that you sent into a function. 
For example 
	int myFunction(int someValue, float someFloat);
in questo caso la parameter list is 2 variables :
	int someValue
	float someFloat
>> declaration vs definition of a function [pag101 jesse]
The declaration tells the compiler the name, return type, and parameters of the function. A declaration of a function is called >> prototype
The definition tells the compiler how the function works.
------------------------------------------------------------ altra rispiegazione a pag169 jesse
>> definition vs declaration 
A declaration introduces a name of something but does not allocate memory. A definition allocates memory. 
With a few exceptions, all declarations are also definitions. The most important exceptions are the declaration of a global function (a prototype) and the declaration of a class (usually in a header file).
------------------------------------------------------------------------------------------------

>> prototype [pag102 jesse]
The function prototype is a statement which means it ends  with a semicolon. It consists of the function's return type and signature. A function >> signature is its name and parameter list
example 
 	 unsigned short int   FindArea     (int  length,     int  width)         ; 
 //	 return type          name          type parameter1  type parameter2     do not forget the semicolon!
Note: when you write a function prototype you can also just write the types of the parameters and omit their names, example 
	long Area (int, int);
this would be perfectly legal, but it is not a good idea, since adding parameter names makes your prototype clearer.
If your function does not actually return a value, you declare its return type to be "void", as shown here
	void printNumber(int myNumber);
this declares a function called printNumber that has one integer parameter. Because void is used, nothing is returned.
>> DEFINE FUNCTION [pag103 jesse]
The definition of a function consists of the function header and its body. 
The header is like the function prototype except that the parameters must be named, and no terminating semicolon is used. 
The body of the function is a set of statements enclosed in {}
	int Area (int length, int width)
	{
		//statement 
		return   (length * width);
    //  keyword  return value  
	}
IN SHORT : the only required difference between prototype and definition of a function is that the function prototype  ends with a semicolon and has no body.
---------------------------------------------------------------------------------------------------
// Full example of function delcaration and the definition and use of that function
	// Listing 5.1 - demonstrates the use of function prototypes
	  
	#include <iostream>
	int Area(int length, int width); //function prototype
	  
	int main()
	{
	   using std::cout;
	   using std::cin;
	  
	   int lengthOfYard;
	   int widthOfYard;
	   int areaOfYard;
	  
	   cout << "\nHow wide is your yard? ";
	   cin >> widthOfYard;
	   cout << "\nHow long is your yard? ";
	   cin >> lengthOfYard;
	  
	   areaOfYard= Area(lengthOfYard, widthOfYard);
	  
	   cout << "\nYour yard is ";
	   cout << areaOfYard;
	   cout << " square feet\n\n";
	   return 0;
	}
	  
	int Area(int len, int wid) // definition of the function 
	{    // nota come non sia richiesto usare lo stesso nome dei parametri usati nel prototype qui usiamo "len" e "wid"
         // anche se a pag105 consiglia as a good programming practise to use the same parameters names 
		 //  int Area(int length, int width)   would be clearer when re-reading the program
	   return len * wid;
	}
//////////////////////////////////////////////////////////

>> PREDICATE FUNCTION [pag107 mike]: A predicate function is a function that returns either true or false. The string object member function empty() is an example of a predicate function. 

>> palindromes search example pag 105 moo book 
Palindromes are words that are spelled the same way front to back as back to front. For example "civic", "eye", "level", "rotor" are palindromes.
Ecco a compact solution to determine if a word is a palindrome:
	bool is_palindrome(const string& s)
	{	
		return equal(s.begin(), s.end(), s.rbegin());
	}
dove rbegin return an iterator, but this time it is an iterator that starts with the last element in the container and marches backward through the container. And the ">> equal" function compares two sequences to determine whether they contain equal values. The first two iterators passed to "equal" specify the first sequence. The third argument is the starting point for the second sequence. Because we pass s.rbegin() as the starting point for the second sequence, the effect of this call is to compare values from the back of s to values in the front. The "equal" function will compare the first character with the last. Then it will compare the second with the next to last, and so on. In tal modo checkare se la parola sia un palindrome o no.
--------------------------------------------------------------
>> URL FIND / >> FIND URL example pag105 moo book
A URL is a sequence of character of the form 
	protocol-name://resource-name
Our function will take a string argument and will look for instances of "://" in that string. Each time we find such an instance, we'll look for the protocol-name that precedes it, and the resource-name that follows it.
Because we want our function to find all the URLs in its input, we'll want it to return a vector<string>, with one element for each URL. The function executes by moving the iterator b through the string, looking for the character :// that might be a part of a URL. If we find these characters, it looks backward to find the protocol-name, and it looks forward to find the resource-name. 
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/urls.cc]
	vector<string> find_urls(const string& s)
	{
		vector<string> ret;
		typedef string::const_iterator iter;
		iter b = s.begin(), e = s.end();
	
		// look through the entire input
		while (b != e) {
	
			// look for one or more letters followed by `://'
			b = url_beg(b, e);
	
			// if we found it
			if (b != e) {
				// get the rest of the URL
				iter after = url_end(b, e);
	
				// remember the URL
				ret.push_back(string(b, after));
	
				// advance `b' and check for more URLs on this line
				b = after;
			}
		}
		return ret;
	}
///////////////////////////////////////////////////////////////////////////////////////

>> padding / >> fill / >> setfill
[pag582 deitel]
- fill member function specifies the fill character to be used with justified fields; spaces are used for padding by default. The setfill manipulator also sets the padding character. 
NOTE: padding character = il carattere di riempimento che viene usato per riempire gli spazi che non siano occupati da delle cifre. [di default i padding character sono degli spazi bianchi ma come mostrato a pag583 deitel puoi settare dei caratteri di riempimento diversi.]


>> PAUSE
Is there a decent wait function in C++?
SOLUTION (THE CHOSEN ONE)
you can require the user to hit enter before closing the program... something like this works.
	#include <iostream>
	int main()
	{
	  std::cout << "Hello, World\n";
	  std::cin.ignore();      // OTTIMO QUESTO METODO FUNZIONA A MERAVIGLIA
	  return 0;
	}
The cin reads in user input, and the .ignore() function of cin tells the program to just ignore the input. The program will continue once the user hits enter.
[http://stackoverflow.com/questions/902261/is-there-a-decent-wait-function-in-c]
SOLUTION2
If you want to write portable C++ code, then I'd suggest using cin.get().
system("PAUSE") works on Windows, since it requires the execution of a console command named "PAUSE". 
[http://stackoverflow.com/questions/24776262/pause-console-in-c-program]
SOLUTION3
    sleep(unsigned int)
The value has to be a positive integer in millisecond. That means that if you want your programme wait for 2 second, enter 2000.
Here's an example :
	#include <iostream>     //for using cout
	#include <stdlib.h>     //for using the function sleep
	using namespace std;    //for using cout
	int main(void)         
	{
	   cout << "test" << endl;
	   sleep(5000);         //make the programme waiting for 5 secondes
	   cout << "test" << endl;
	   sleep(2000);         // wait for 2 secondes before closing
	   return 0;
	}
If you wait too long, that probably means the parameter is in second. So change it like that :
	sleep(5);
For those who get error message or problem using sleep try to replace it by _sleep or Sleep especially on Code::Bloks.
And if you still getting probleme, try to add of one this library on the biggining of the code.
	#include <stdio.h>
	#include <time.h>
	#include <unistd.h>
	#include <dos.h>
	#include <windows.h>
[http://stackoverflow.com/questions/902261/is-there-a-decent-wait-function-in-c]
////////////////////////////////////////////////////////////

>> PERFORMANCE 
- a small performance improvement for code that executes many times in a loop result in substantial overall performance improvement. 
[pag118deitel]

>> POINTERS [pag222 jesse]
A pointer is a variable that holds a memory address. That's it. If you understand this simple sentence, then you know the core of whoat there is to know about pointers.
NOTE: the ability to use pointers and manipulate memory at a low level is one of the facotrs that makes C++ the language of choice for embedded and real-time applications.
------------------------------------
>> MEMORY [pag222 jesse]
To understand pointers, you must know a little about computer memory. Computer memory is divided into sequentially numbered memory locations. Each variable is located at a unique location in memory, known as its address. 
[
Carina la figura 8.1 di pag 222 where you can see that 
	- each location is 1 byte (cioe' 8 bit)
	- supponi di voler mettere in memoria una variabile unsigned long integer che occupi 32 bit
	- allora avrai bisogno di 32/8 = 4 byte
	- per esempio se assegni alla variable l'address 102, allora anche i 3 seguenti indirizzi di memoria (103, 104, 105) verranno occupati in modo da disporre in totale di 32 bit.
]
-----------------------------------
>> MEMORY ADDRESS how to get memory address of a variable
Getting a variable's memory address [pag222 jesse]
You can use the >> address-of operator (&), which returns the address of an object in memory.
EXAMPLE:
	// Listing 8.1 Demonstrates address of operator
	// and addresses of local variables
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	   unsigned short shortVar=5;
	   unsigned long  longVar=65535;
	   long sVar = -65535;
	
	   cout << "shortVar:\t" << shortVar;
	   cout << "\tAddress of shortVar:\t";
	   cout <<  &shortVar  << endl;  // the address-of operator is simply placed on the front of the variable name in order to have the address returned.
	
	   cout << "longVar:\t"  << longVar;
	   cout  << "\tAddress of longVar:\t" ;
	   cout <<  &longVar  << endl;
	
	   cout << "sVar:\t\t"     << sVar;
	   cout << "\tAddress of sVar:\t" ;
	   cout <<  &sVar     << endl;
	
	   return 0;
	}
--------------------------------------------------------------------------------
NOTE: When you declare a variable, the compiler determines how much memory to allow based on the variable type. The compiler takes care of allocating memory and automatically assign an address for it. For an long integer that is typically four bytes, for example, an address to four bytes of memory is used.
--------------------------------------------------------------------------------
>> POINTER [pag224 jesse] / >> STORE VARIABLE'S ADDRESS IN A POINTER
Every variable has an address. Even without knowing the specific address, you can store a variable's address in a pointer. Suppose, for example that howOld is an integer. To declare a pointer called pAge to hold its address, you write
	int *pAge = 0;
This declares pAge to be a pointer to an int. That is, pAge is declared to hold the address of an integer. 
Note that pAge is a variable. When you declare an integer variable (type int) the compiler sets aside enough memory to hold an integer. When you declare a pointer variable such as pAge, the compiler sets aside enough memory to hold an address (on most computers four bytes). A pointer, and thus pAge, is just a different type of variable. 
>> POINTER NAMING CONVENTION  [pag224 jesse]
Because pointers are just another variable, you can use any name that is legal or other variables. The same naming rules and suggestions apply. Many programmers follow the convention of naming all pointers with an initial p, as in pAge and pNumber.
In the example 
	int *pAge = 0;
pAge is initialized to 0. A pointer whose value is zero is called the >> null pointer. All pointers when they are created, should be initialized to something. If you don't know what you want to assign to the pointer, assign 0. A pointer that is not initialized is called a >> wild pointer because you have no idea what it is pointing to, and it could be pointing to anything! Wild pointers are very dangerous.
PRACTICE SAFE COMPUTING: INITIALIZE ALL OF YOUR POINTERS!!!!
For a pointer to hold an address, the address must be assigne to it. For the previous example, you must specifically assign the address of "howOld" to pAge, as shown in the following example 
	unsigned short int howOld = 50;    // make a variable 
	unsigned short int * pAge =  0;    // make a pointer
	pAge = &howOld;                    // put howOld's address in pAge
You could have accomplish this with one fewer step as in:
	unsigned short int howOld = 50;    		// make a variable 
	unsigned short int * pAge = &howOld;    // make pointer to howOld
--------------------------------------------------------------------------------
>> GETTING THE VALUE FROM A VARIABLE / >> INDIRECTION [pag225 jesse]
Using "pAge" you can actually determine the value of howOld, which in this case is 50. Accessing the value stored in a variable by using a pointer is called >> indirection because you are indirectly accessing the variable by means of the pointer. For example, you can use indirection with the pAge pointer to access the value of howOld. 
Indirection means accessing the value at the address heold by a pointer. The pointer provides an indirect way to get the value held at the address. 
NOTE : with a normal variable, the type tells the compiler how much memory is needed to hold the value. With a pointer, the type does not do this; all pointers are the same size, usually 4 bytes on a machine with a 32 bit processor and eight byptes on a machine with a 64 bit processor. 
The type just tells the compiler how much memory is needed for the object at the address, which the pointer holds!
In the declaration  
	unsigned short int * pAge =  0;    // make a pointer
pAge is declared to be a pointer to an unsigned short integer. This tells the compiler that the pointer (which needs four bytes to hold and address) will hold the address of an object of type unsigned short int, which itself requires two bytes. [come vedi ci possono anche essere casi come questo in cui il puntatore occupa piu' spazio in memoria della cosa a cui punta.]	
--------------------------------------------------------------------------------------------------
>> DEREFERENCE OPERATOR / >> INDIRECTION OPERATOR * / >> [pag226 jesse book] 
IN SHORT 
	DEREFERENCE = get the value at the address pointed by the pointer
IN LONG
The indirection operator (*) is also called the dereference operator. When a pointer is dereferenced, the value at the address stored by the pointer is retrieved. 
	nomeVariabile = *nomePointer;
significa: take the value stored at the address in nomePointer and assign it to nomeVariabile. In this way a pointer provides an indirect access to the value of the variable whose address it stores [indirect access cioe' indirect rispetto al modo diretto di assegnare un valore a nomeVariabile]
NOTE: if you didn't include the indirection operator
	nomeVariabile = nomePointer;
you would be attempting to assign the value in nomePointer, a memory address to nomeVariabile. Your compiler would most likely give you a warning that you are making a mistake. 
NOTE2: different uses of the Asterisk. The asterisk (*) is used in two distinct ways with pointer: as part of the pointer declaration and also as the dereference operator. 
When you declare a pointer, the * is part of the declaration and it follows the type of the object pointed to. 
Example:
	// make a pointer to an unsigned short
	unsigned short * pAge = 0
When the pointer is dereferenced, the dereference (or indirection) operator indicates that the value at the memory location stored in the pointer is to be accessed, rather than the address itself.
	// assign 5 to the value at pAge
	*pAge = 5
--------------------------------------------------------------------------------
>> POINTER vs >> ADDRESSES vs >> VARIABLES [pag227 jesse book]
It is important to distinguish between a pointer, the address that the pointer holds and the value at the address held by the pointer. This is the source of much of the confusion about pointers. 
Consider the following code fragment [dal vangelo apocrifo di San Puntato]
	int theAgnusDei = 3;
	int * pPointerReMagio = &theAgnusDei;
theAgnusDei is declared to be an integer variable initialized with the holy value of 3. pPointerReMagio is declared to be a pointer to an integer; it is initialized with the address of the variable "theAgnusDei". pPointerReMagio is the pointer. The address that pPointerReMagio holds is the address of "theAgnusDei". The value at the address that pPointerReMagio holds is 3. 
Quindi supponi che theAgnusDei is stored at the address location 303. Then il valore stored by pPointerReMagio is 303.
---------------------------------------------------------------------------------
>> MANIPULATING DATA by USING POINTERS [pag 228 jesse book]
In addition to using the indirection operator to see what data is stored at a location pointed to by a variable, you can also manipulate that data. After the pointer is assigned the address, you can use that pointer to access the data in the variable being pointed to. 
In the following listing/program, you see how the address of a local variable is assigned to a pointer and how the pointer can be used along with the indirection operator to manipulate the values in that variable. 
------------------------------------------------------------------------------
// Listing 8.2 Using pointers
	#include <iostream>
	
	typedef unsigned short int USHORT;
	
	int main()
	{
	
	   using namespace std;
	
	   USHORT myAge;         // a variable
	   USHORT * pAge = 0;    // a pointer
	
	   myAge = 5;
	
	   cout << "myAge: " << myAge << endl;
	   pAge = &myAge;     // assign address of myAge to pAge
	   cout << "*pAge: " << *pAge << endl << endl;
	
	   cout << "Setting *pAge = 7... " << endl;
	   *pAge = 7;         // sets myAge to 7
	
	   cout << "*pAge: " << *pAge << endl;
	   cout << "myAge: " << myAge << endl << endl;
	
	   cout << "Setting myAge = 9 " << endl;
	   myAge = 9;
	
	   cout << "myAge: " << myAge << endl; // obtaining the value of myAge directly
	   cout << "*pAge: " << *pAge << endl; // obtaining the value of myAge indirectly by deferencing pAge
	 
	   return 0;
	}
--------------------------------------------------------------------------------
OUTPUT
	myAge: 5
	*pAge: 5
	
	Setting *pAge = 7...
	*pAge: 7
	myAge: 7
	
	Setting myAge = 9
	myAge: 9
	*pAge: 9
--------------------------------------------------------------------------------
>> ADDRESS EXAMINATION [pag229] / >> EXAMINE ADDRESS
Pointers enable you to manipulate addresses without ever knowing their real value. When you assign the adress of a variable to a pointer, it really has the address of that varaible as its value. Let's check it with the following program.
--------------------------------------------------------------------------------
	// Listing 8.3 
	// What is stored in a pointer.
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	
	   unsigned short int myAge = 5, yourAge = 10;
	
	    // a pointer
	   unsigned short int * pAge = &myAge; 
	
	   cout << "myAge:\t" << myAge    <<  "\t\tyourAge:\t" << yourAge << endl;
	
	   cout << "&myAge:\t" << &myAge      << "\t&yourAge:\t" << &yourAge << endl;
	
	   cout << "pAge:\t" << pAge << endl;
	   cout << "*pAge:\t" << *pAge << endl;
	
	   
	   cout << "\nReassigning: pAge = &yourAge...\n\n";
	   pAge = &yourAge;       // reassign the pointer
	
	   cout << "myAge:\t" << myAge <<  
	      "\t\tyourAge:\t" << yourAge << endl;
	
	   cout << "&myAge:\t" << &myAge 
	      << "\t&yourAge:\t" << &yourAge << endl;
	
	   cout << "pAge:\t" << pAge << endl;
	   cout << "*pAge:\t" << *pAge << endl;
	   
	   cout << "\n&pAge:\t" << &pAge << endl;
	
	   return 0;
	}
-------------------------------------------------------------------------------
OUTPUT 
	myAge:  5               yourAge:        10
	&myAge: 0x22fe3e        &yourAge:       0x22fe3c  // <- cout << "&myAge:\t" << &myAge      << "\t&yourAge:\t" << &yourAge << endl;
	pAge:   0x22fe3e // from "cout << "pAge:\t" << pAge << endl;" <--- showing the address the pointer is pointing to
	*pAge:  5        // from "cout << "*pAge:\t" << *pAge << endl;"  <----------- we are "DEFERENCING": at the address the pointer is pointing to the value is 5
	
	Reassigning: pAge = &yourAge...
	
	myAge:  5               yourAge:        10
	&myAge: 0x22fe3e        &yourAge:       0x22fe3c
	pAge:   0x22fe3c
	*pAge:  10
	
	&pAge:  0x22fe30   // from "cout << "\n&pAge:\t" << &pAge << endl;" <----- getting the address of the pointer itself
	
	Process exited after 0.009192 seconds with return value 0 
--------------------------------------------------------------------------------
Riassumendo 
DO use the indirection operator (*) to access the data stored at the address in a pointer 
DO initialize all pointers either to a valid address or to null (0)
DON'T confuse the address in a pointer with the value at that address.
>> POINTER DECLARATION [pag231 jesse]
To declare a pointer, write the type of the variable or object whose address will be stored in the pointer, followed by the pointer operator (*) and the name of the pointer. For example :
	unsigned short int * pPointer = 0;
To assign or initialize a pointer, prepend the name of the variable whose address is being assigned with the address-of operator (&). For example 
	unsigned short int theVariable = 5;
	unsigned short int * pPointer = &theVariable;
To deference a pointer, prepend the pointer name with the dereference operator (*). For example 
	unsigned short int int theValue = *pPointer
--------------------------------------------------------------------------------
>> POINTERS? WHY? Perche' complicarsi la vita in tal modo. Ecco la risposta [from 232 jesse]
So far, you've seen step y step details of assigned a variable's address to a pointer. In practice, though, you would never do this. After all, why bother with a pointer when you already have a variable with access to that value? The only reason for this kind of pointer manipulation of an automatic variable is to demonstrate how pointers work. Now that you are comfortable with the syntax of pointers, you can put them to good use. Pointers are used most often for three tasks:
	1)  managing data of the free store 
	2) 	accessing class member data and functions 
	3)  passing variables by reference to functions
First will will focus on 1) and 2) (day 8) learning to manage data on the free store and accessing class member data and functions. On day 9 (pag256 jesse) we will learn about passing variables using pointers, which is called passing by reference.
>> STACK and >> FREE STORE >> HEAP [pag232 jesse]
IN SHORT
The heap (also called free store) is the remaining available memory that you get from = total memory available - (registers + code space + stack + global namespace)
NOTE: heap memory = free store memory, son due termini che stanno ad indicare la stessa cosa.
IN LONG
Let's recall the five areas of memory mentioned on day 5
	1) global namespace -> global variables are in the global namespace  
	2) registers -> the registers are used for internal housekeeping, such as keeping track of the top of the stack and the instruction pointer
	3) code space -> Code is in code space
	4) the stack -> Local variables are on the stack, along with function parameters. 
	5) the free store -> all of the remaining memory is given to the free store, which is often referred as the heap.
Local variables don't persist; when a function returns, its local variables are destroyed. 
This is good, because it means the programmer doesn't have to do anything to manage this memory space, but is bad because it makes it hard for functions to create objects for use by other objects or functions without generating the extra overhead of copying objects from stack to return value to destination object in the caller. 
Global variables solve that problem at the cost of providing unrestricted access to those variables through-out the program, which leads to the creation of code that is difficult to understand and maintain. Putting data in the free store can solve both of thses problems if that data is managed properly. 
You can think of the free store as a massive section in which thousands of sequentially numbered cubbyholes lie waiting for your data. You can't label these cubbyholes though, as you can with the stack. You musk ask for the address of the cubbyhole that you reserve and then stash (= metter da parte) that address away in a pointer.  
One way to think about this is with an analogy. A firedn gives you a free toll number for "Hoverbike mail order". You go home and program your telephone with that number, and then you throw away the piece of paper with the number on it. If you push the button, a telephone rings somewhere, and Hoverbike mail order answers. You don't remember the nmber, and you don'tknow where the other telelphone is located, but the button gives you access to Hoverbike Mail Order. Hoverbike Mail Order is your data on teh free store. You don't know where it is, but you know how to get to it. You access it by using its address (in this case the telephone number). You don't have to know that number, you just have to put it into a pointer (the button). The pointer gives you access to your data without bothering you with the details. 
The stack is cleaned automatically when a function returns. All the local variables go out of scope, and they are removed from the stack. On the contrary the free store is not cleaned until your program ends, and it is YOUR RESPONSABILITY to free any memory that you've reserved when you are done with it. This is where destructors are absolutely critical, because they provide a place where any heap memory allocated in a class can be reclaimed.  
The advantage to the free store is that the memory you reserve remains avaialable until you explicitly state you are done with it by freeing it. If you reserve memory on the free store while in a function, the memory is still available when the function returns. 
The disadvantage of the free store is also that the memory you reserve remains available until you explicitly state you are done with it by freeing it. If you neglect to free that memory, it can build up over time and cause the system to crash. 
The advantage of accessing memory in this way, rather than using global variables, is that only functions with access to the pointer (which has the appropriate address) have access to the data. This requires the object containing the pointer to the data, or the pointer ifself, to be explicitly passed to any function making changes, thus reducing the chances that a function can change the data without that change being traceable.   
>> NEW keyword / >> ALLOCATE SPACE WITH THE NEW KEYWORD [pag234 jesse]
You allocate memory on the free store in C++ by using the new keyword. new is followed by the type of the object that you want to allocate, so that the compiler knows how much memory is required.
Therefore
	new unsigned short int 
allocates two bytes in the free store, and 
	new long 
allocates four, assuming your system uses a two-byte unsigned short int and a four-byte long. 
The return value from "new" is a memory address. Because you now know that memory addresses area stored in pointers, it should be no surprise to you that the return value from "new" should be assigned to a pointer. To create an unsigned short on the free store, you might write 
	unsigned short int * pPointer;
	pPointer = new unsigned short int;
you can of course do this all on one line by initializing  the pointer at the same time you declare it:
	unsigned shot int * pPointer = new unsigned short int;
In either case, pPointer now points to an unsigned short int on the free store. You can use this like any other pointer to a variable and assign a value into that area of memory by writing:
	*pPointer = 72;
This means : "Assign the value 72 to the area on the free store to which pPointer points."
NOTE: if new cannot create memory on the free store (memory is after all a limited resource), it throws an exception.
--------------------------------------------------------------------------------------------------------
>> DELETE KEYBOARD for putting memory back / >> memory retrieve / [pag235 jesse]
When you are finished with an area of memory, you must free it back to the system. You do this by calling delete on the pointer. delete returns the memory to the free store. 
It is critical to remember that memory allocated with "new" is not freed automatically. If a pointer varaible is pointing to memory on the free store and the pointer goes out of scope, the memory is not automatically returned to the free store. Rather, it is considered allocated and because the pointer is no longer available, you can no longer access the memory. This happens, for instance, if a pointer is a local variable. When the function in which that pointer is declared returns, that pointer goes out of scope and is lost. The memory allocated with new is not freed, instead it becomes unavailable. 
This situation is called a >> memory leak. It's called a memory leak because that memory can't be recovered until the program ends. It is as though the memory has leaked out of your computer. 
To prevent memory leaks, you should restore any memory you allocate back to the free store. You do this by using the keyword delete. For example 
	delete pPointer;
When you delete the pointer, you are really freein up the memory whose address is stored in the pointer. You are saying "Return to the free store the memory that this pointer points to". The pointer is still a pointer and it can be reassigned. 
The following listing 8.4 demonstrates allocating a variable on the heap, using that variable and deleting it.
	// Listing 8.4
	// Allocating and deleting a pointer
	#include <iostream>
	int main()
	{
	   using namespace std;
	   int localVariable = 5;
	   int * pLocal= &localVariable;  // declaring the pointer pLocal and initializing it with the address of the local variable.
	   int * pHeap = new int;
	   *pHeap = 7;
	   cout << "localVariable: " << localVariable << endl;
	   cout << "*pLocal: " << *pLocal << endl;
	   cout << "*pHeap: " << *pHeap << endl;
	   delete pHeap;
	   pHeap = new int;
	   *pHeap = 9;
	   cout << "*pHeap: " << *pHeap << endl;
	   delete pHeap;
	   return 0;
	}
--------------------------------------------------------------------------------------------------------------
NOTE1: Most commonly you will allocate items from the heap in a constructor, and deallocate them in the destructor. In other cases, you will initialize pinters in the constructor, allocate memory for those pointers as the object is used, and in the destructor, test the pointers for null and deallocate them if they are not null. 
CAUTION: when you call "delete" on a pointer the memory it points to is freed. Calling "delete" on that pointer, set it to zero (null). Calling delete on a null pointer is guaranteed to be safe, for example: 
Animal *pWolf = new Animal; // allocate memory
delete pWolf; // frees the memory
pWolf = 0; // sets pointer to null 
//...
delete pWolf; // harmless.
NOTE2: [from pag 237 jesse] Memory leaks are one of the most serious issues and complaints about pointers. You can for example create inadvertently a memory leak by reassigning your pointer before deleting the memory to which it points. Consider this code fragment:
	unsigned short int * pPointer = new unsigned short int; // creating a pointer and assigning an area of free store
	*pPointer = 72; // storing the value 72 in that area of memory
	pPointer = new unsigned short int; // reassigns pPointer to another area of memory  
	*pPointer = 84; // placing 84 in that new area of memory
The original area (in which the value 72 is now held) is unavailable because the pointer to that area of memory has been reassigned. No way exists to access that original area of memory, nor is there any way to free it before the program ends. 
The code should have been written like this:
	unsigned short int * pPointer = new unsigned short int; // creating a pointer and assigning an area of free store
	*pPointer = 72; // storing the value 72 in that area of memory
	delete pPointer; // the memory originally pointed to by pPointer is deleted, and thus freed. 
	pPointer = new unsigned short int; // reassigns pPointer to another area of memory  
	*pPointer = 84; // placing 84 in that new area of memory
QUINDI regola d'oro: FOR EVERY TIME IN YOUR PROGRAM THAT YOU CALL new, THERE SHOULD BE A CALL TO delete. It is important to keep track of which pointer owns an area of memory and to ensure taht the memory is returned to the free store when you are done with it.	
--------------------------------------------------------------------------------------------------------
[the following section di pag.238-239 jesse presentano la tecnica che sta al cuore di tutta la programmazione in OpenFOAM, si' mi sembra proprio di ritrovare quelle sintassi che per tanto tempo sembravano nebulose e non chiare. Molte delle volte che vedi "*" e "~" stanno creando e distruggendo oggetti nello free store. Creazione e distruzione per tenere la memoria sotto controllo. (tag >> EQUATION BRIDGE / >> BRIDGE EQUATIONS)]
>> OBJECTS CREATION ON THE FREE STORE / >> CREATION OBJECT ON THE FREE STORE / >> CREATING OBJECTS ON THE FREE STORE [pag 238 jesse]
Just as you can create apointer to an integer, you can create a pointer o any data type, including classes. If you have declared an oject of type Cat, you can declare a pointer to that class and instantiate a Cat object on the free store, just as you can make one on the stack. The syntax is the same as for integers:
	Cat *pCat = new Cat;
This calls the default constructor (the constructor that takes no parameters). The constructor is called whenever an object is created (on the stack or on the free store). Be aware, however, that you are not limited to use only the default constructor when creating an object with new (any constructor can be used).
>> DELETE OBJECT FROM THE FREE STORE / >> OBJECT DELETION FROM THE FREE STORE / DELETING OBJECT FROM FREE STORE [pag238 jesse]
When you call delete on a pointer to an object on the free store, that object's destructor is called before the memory is released. This gives your classes a chance to clean up (generally deallocating heap allocated memory) just as it does for objects destroyed on  the stack.
Here's a listing that illustrates how to create and delete objects on the free store: 
// Listing 8.5 - Creating objects on the free store
// using new and delete
  
#include <iostream>

using namespace std;

class SimpleCat   //--------------------- declaration of class SimpleCat
{
  public:
     SimpleCat(); // declaration of the constructor 
     ~SimpleCat(); // declaration of the destructor
  private:
     int itsAge;
}; //------------------------------------- end declaration of class SimpleCat
  
SimpleCat::SimpleCat()  //--------------------- definition of the constructor
{
   cout << "Constructor called. " << endl;
   itsAge = 1;
}
  
SimpleCat::~SimpleCat() //--------------------- definition of the destructor
{
   cout << "Destructor called. " << endl;
}
 
int main()
{
   cout << "SimpleCat Frisky... " << endl;
   SimpleCat Frisky;
   cout << "SimpleCat *pRags = new SimpleCat..." << endl;
   SimpleCat * pRags = new SimpleCat;
   cout << "delete pRags... " << endl;
   delete pRags;
   cout << "Exiting, watch Frisky go... " << endl;
   return 0;
}
---------------------------------------------------------------------------------------
>> ACCESSING DATA MEMBERS / >> DATA MEMBERS ACCESS / >> -> meaning [pag239 jesse] /
[qui un'altra pagina importante per openfoam esegesi: perche' nei programmi si trovano tanti "->"? che significa? in short, quando vedi un "->" significa che si vuole accedere a dei data members allocati nella free store memory]
As seen in chapter day 6 Data members and functions can be accessed by using the dot (.) operator. This works for objects created locally.
Accessing the member of a nobject when using a pointer is a little more complex 
To access the Cat object on the free store, you must dereference the pointer and call the dot operator on the object pointed to by the pointer. It is worth repeating this. You must first dereference the pointer [= get the value at the address pointed by the pointer]. You then use the dereferenced value (= the value being pointed to) along with the dot operator to access the members of the object.
Therefore to access the GetAge member function of an object pointed to by pRags, you write:

	(*pRags).GetAge();

As you can see, parenthesis are used to ensure that pRags is dereferenced firt (before GetAge() is accessed). Remember, parentheses have a higher precedence than other operators. 
Because this is cumbersome, C++ provides a shorthand operator for indirect access: the ">> class member access" operator "->". C++ treats "->" as a single symbol. 
NOTE: Because the class member access operator (->) can also be used for indirect accesss to members of an object (through a pointer), it can also be referred to as an indirection operator. Some people also refer to it as the points-to operator because that is what it does.
----------------------------------------------------
CICCIO SPIEGA: accedere un data member via puntatori
                  ______________________
                  |                     |
    --------------|->   Cat object      |
        pRags     |_____________________|

1) dereference pRags
	*pRags == ottieni il valore contenuto all'interno dell'indirizzo verso cui punta pRags, cioe' ottieni l'oggetto Cat
2) ora che hai ottenuto l'oggetto Cat gli puoi applicare le sue member functions 
Riassumendo quando lavori con oggetti creati in locale puoi usare 
	nomeOggetto.nomeFunzione 
tipo
	Cat.GetAge
Quando lavori con oggetti che non sono in locale e a cui vi devi accedere con dei puntatori devi usare
	(*pRags).GetAge         
Ora visto che rieffettuare tutte le volte il ragionamento *pRags e' una deference che equivale a Cat a qui posso applicare il metodo GetAge viene piu' semplice usare the class member access operator "->"
[insomma tutti gli * ~ -> che si vedono in OpenFOAM sono legati alla distruzione accesso modificazione di oggetti e data storati nel free store memory.]
-----------------------------------------------------
/ >> class member access operator example [pag240 jesse]
// Listing 8.6 - Accessing data members of objects on the heap
// using the -> operator

#include <iostream>

class SimpleCat
{
  public:
    SimpleCat() {itsAge = 2; }   // default constructor set the itsAge (member data) of the object to 2
    ~SimpleCat() {}
    int GetAge() const { return itsAge; }
    void SetAge(int age) { itsAge = age; }
 private:
    int itsAge;
};
 
int main()
{
   using namespace std;
   SimpleCat * Frisky = new SimpleCat; // a simpleCat object that is pointed to by the pointer Frisky is instantiated (created) on the free store
   cout << "Frisky is " << Frisky->GetAge() << " years old " << endl;
   Frisky->SetAge(5); // Frisky is a pointer, the indirection operator is used to access the member data and functions.
   cout << "Frisky is " << Frisky->GetAge() << " years old " << endl;
   delete Frisky;
   return 0;
}
--------------------------------------------------------------------------------------------------------
[pag241 jesse book]
>> MEMBER DATA creation on the free store / >> DATA MEMBER CREATION ON THE FREE STORE / >> POINTERS AS DATA MEMBERS [pag241 jesse]
IN addition to creating objecdts on the free store, you can also create data members within an object on the free store. One or more of the data members of a class can be a pointer to an object on the free store. Using what you have already learned, you can allocate memory on the free store for these pointers to use. The memory can be allocated in the class constructor or in one of the class' methods. When you are done using the member you can (and should) delete it in one of the methods or in the destructor as the following listing illustrates: 
	// Listing 8.7 - Pointers as data members
	// accessed with -> operator
	 
	#include <iostream>
	
	class SimpleCat
	{
	  public:
	    SimpleCat();
	    ~SimpleCat();
	    int GetAge() const { return *itsAge; }
	    void SetAge(int age) { *itsAge = age; }
	
	    int GetWeight() const { return *itsWeight; }
	    void setWeight (int weight) { *itsWeight = weight; }
	
	  private:              // here are the 2 member variables of the SimpleCat class
	    int * itsAge;       // both are pointers to integers
	    int * itsWeight;
	};
	
	SimpleCat::SimpleCat()
	{
	   itsAge = new int(2);       // here a pseudo constructor is called on the new integer
	   itsWeight = new int(5);    // passing in the value for the integer. This creates an integer on the heap
	}                             // and initializes its value.
	
	SimpleCat::~SimpleCat()       // here's the destructor that cleans up the allocated memory.
	{                             // Because this is the destructor, there is no point in assigning these pointers to null because
	   delete itsAge;             // they will no longer be accessible. This is one of the safe places to break the rule that 
	   delete itsWeight;          // deleted pointers should be assigned to null, although following the rule doesn't hurt.
	}
	
	int main()
	{
	   using namespace std;
	   SimpleCat *Frisky = new SimpleCat;
	   cout << "Frisky is " << Frisky->GetAge()    // the calling function [in this case main()] is unaware that itsAge and itsWeight are 
	             << " years old " << endl;         // pointers to memory on the free store. main() continues to call GetAge() and SetAge()
	   Frisky->SetAge(5);                          // and the details of the memory management are hidden in the implementation 
	   cout << "Frisky is " << Frisky->GetAge()    // of the class as they should be
	             << " years old " << endl;
	   delete Frisky;      // when Frisky is deleted, its destructor is called. The destructor deletes each of its member pointers.
	   return 0;           // If these, in turn, point to objects of other user defined classes, their destrucotrs are called as well
	}
--------------------------------------------
NOTE: Tue use of pointers as was done in the listing above would be pretty silly in a real program unless a godd reason existed for the Cat object to hold its members by reference. In this case, there is no good reason to use pointers to access itsAge and itsWeight, but in other cases, this can make a lot of sense. 
This brings up the obvious question. What are you trying to accomplish by using pointers as references to variables instead of just using variables? Understand, too, that you must start with design. If what you've designed is an object that refers to another object, but the second object might come into existence before the first object and continue after the first object is gone, then the first object must contain the second by reference. 
For example, the first object might be a window and the second object might be a document. The window needs access to the document, but it does not control the lifetime of the document. Thus, the window needs to hold the document by reference. This is implemented in C++ by using pointers or references. 
--------------------------------------------------------------------------------------------------------
>> THIS POINTER pag 243 jesse
IN SHORT this is pointer and stores the memory address of an object, it's a pointer to the object that holds the function.
You don't have to worry about creating or deleting the this pointer, the compiler takes care of it [Take car of her?! Mia Wallace] 
IN LONG
Every class member function has a hidden parameter: the "this" pointer. "this" points to "this" individual object. Therefore, in each call to GetAge() or SetAge(), each function get "this" for its object as a hidden parameter. 
It is possible to use the pointer to this explicitly  as the following listing illustrates: 
-------------------------------------------------------------------------------------------
	// Listing 8.8
	// Using the this pointer
	
	#include <iostream>
	
	class Rectangle
	{
	  public:
	    Rectangle();
	    ~Rectangle();
	    void SetLength(int length)           // SetLength() and GetLenght() accessor functions both explicitly
	      { this->itsLength = length; }      // use the "this" pointer to access the member variables of the Rectangle object 
	    int GetLength() const 
	      { return this->itsLength; }
	
	    void SetWidth(int width)             // SetWidth() and GetWidth() accessor function do not use the this pointers explicitly
	      { itsWidth = width; }              // questo tipo di sintassi e' piu' semplice da capire rispetto ad usare 
	    int GetWidth() const                 // "this" esplicitamente. E ti dona esattamente lo stesso comportamento di quando  
	      { return itsWidth; }               // usi this esplicitamente
	                                         // If that were all there was to "this", there would be little point in bothering 
	  private:                               // you with it. "this" however is a pointer and stores the memory address of an 
	    int itsLength;                       // object. As such, it can be a powerful tool. 
	    int itsWidth;
	};
	
	Rectangle::Rectangle()
	{
	   itsWidth = 5;
	   itsLength = 10;
	}
	Rectangle::~Rectangle()
	{}
	
	int main()
	{
	   using namespace std;
	   Rectangle theRect;
	   cout << "theRect is " << theRect.GetLength() 
	      << " feet long." << endl;
	   cout << "theRect is " << theRect.GetWidth() 
	      << " feet wide." << endl;
	   theRect.SetLength(20);
	   theRect.SetWidth(10);
	   cout << "theRect is " << theRect.GetLength()
	      << " feet long." << endl;
	   cout << "theRect is " << theRect.GetWidth()
	      << " feet wide. " << endl;
	   return 0;
	}
--------------------------------------------------------------------------------------------------------
>> STRAY >> WILD >> DANGLING POINTERS [pag245 jesse]
A stray pointer (also called a wild or dangling pointer) is created when you call delete on a pointer (thereby freeing the memory that it points to) and then you don't set it to null. If you then try to use that pointer again without reassigning it, the result is unpredictable and, if you are lucky, your program will crash. 
If is as though the HoverBike Mail Order company moved moved away, but you still pressed the programmed button on your phone. It is possible that nothing terrible happens (a telephone rings in a deserted warehouse). On the other hands perhaps the telephone number has been reassigned to a munitions factory, and your call detonates an explosive and blows up your whole city!
In short 
	BE CAREFUL NOT TO USE A POINTER AFTER YOU HAVE CALLED delete ON IT.
The pointer still points to the old area of memory, but the compiler is free to put other data there; using the pointer without reallocating new memory for it can cause your program to crash. Worse, your program might preceed merrily on its way and crash several minutes later. This is called a time bomb, and it is no fun. To be safe, after you delete a pointer, set it to null (0). This disarms the pointer (Come direbbe Clink Eastwood, una volta che colpisci al cuore riposa la pistola nella fondella. Inutile continuare a tenere la mano sul calcio della pistola che se no ti ritrovi con Marvin shot in the face. And it's no fun. There's no Mister Wolf and honda Acura coming to rescue you in the real world out there)
>> stomping on a pointer meaning -> pag 247 jesse book : "When the value 20 was assigned to the location that pInt previously pointed to, it wrote over the value pointed to by pLong. This is called stomping on a pointer. [cioe' i valore nella casella di memoria a cui un pointer punta, viene parzialmente o totalmente sovrascritto dall'assegnazione a un dandling pointer, che precedentemente si vedeva assegnata la stessa casella di memoria. vedi esempio pratico pag 248 jesse book]
>> stry pointer vs >> null pointer [pag248 jesse book]
When you delete a pointer, you tell the compiler to free the memory, but the pointer itself continues to exist. It is now a stray pointer. When you then write myPtr = 0; you change it from being a stray pointer to being a null pointer.
Normally if you delete a pointer and then delete it again, your program is undefined. That is, anything can happen (if you are lucky, the program will crash). If you delete a null pointer, nothing happens; it is safe. 
Using a stray or a null pointer (for example writing myPtr = 5;) is illegal, and it might crash. If the pointer is null, it WILL crash, another benefit of null over stray. Predictable crashes are preferred because they are easier to debug.
--------------------------------------------------------------------------------------------------------
>> CONSTANT POINTERS / >> CONST POINTERS [pag248 jesse book]
You can use the keyword const for pointers before the tyep, after the type, or in both places. For example, all the following are legal declarations: 
	1) variabile costante, pointer mutabile [scettico: puo' puntare a cose diverse, ma dovunque punti la variabile e' sempre la stessa: perplessita' verso il mondo.] 
	const int * pOne; // pOne is a pointer to a constant integer. The value that is pointed to can't be changed
	2) variabile mutabile, pointer costante  [cattolico: si punta sempre alla bibbia ma il suo significato varia]
	int * const pTwo; // pTwo is a constant pointer to an integer. The integer can be changed, but pTwo can't be point to anything else.
	3) variablile costante, pointer constante [ebreo ortodosso: si punta sempre alla bibbia e la si prende alla lettera]
	const int * const pThree; // pThree is a constant pointer to a constant integer. The value that is pointed to can't be changed, and pThree can't be changed to point to anything else.
The trick to keeping this straight is to look to the right of the keyword "const" to find out what is being declared constant. [= diviene costante cio' che segue la parola constant]. 
1) If the type is to the right of the keyword, it is the value that is constant. 
	const int * p1; // the int pointed to is constant
1) If the variable is to the right of the keyword "const", it is the pointer variable itself that is constant. 
	int * const p2; // p2 is constant, it can't point to anything else. 
Ciccio: detto in maniera semplice. Se "const" viene prima dell'asterico (e quindi prima del type) e' la variable a essere constante 
Se "const" viene dopo l'* (e quindi dopo il segno di dichiarazione del pointer) e' the pointer itself that is constant.
--------------------------------------------------------------------------------------------------------
const Pointers and const Member functions [pag249 jesse book]
On day 6, you learned that you can apply the keyword "const" to a member function. 
When a function is declared const, the compiler flags as an error any attempt to change data in the object from within that function. 
If you declare a pointer to a const object, the only methods that you can call with that pointer are const methods. [cioe' a constant object dev'essere chiamato solo con dei metodi/funzioni costanti, cioe' suppongo del tipo giusto una funzione che legge l'oggetto e lo printa su schermo ma non lo modifica.]
Example 
	// Listing 8.10 - Using pointers with const methods
	
	#include <iostream>
	using namespace std;
	
	class Rectangle
	{
	   public:
	     Rectangle();
	     ~Rectangle();
	     void SetLength(int length) { itsLength = length; }
	     int GetLength() const { return itsLength; }
	     void SetWidth(int width) { itsWidth = width; }
	     int GetWidth() const { return itsWidth; }
	 
	   private:
	     int itsLength;
	     int itsWidth;
	};
	 
	Rectangle::Rectangle()
	{
	    itsWidth = 5;
	    itsLength = 10;
	}
	 
	Rectangle::~Rectangle()
	{}
	 
	int main()
	{
	    Rectangle* pRect =  new Rectangle;   // declaring a pointer "pRect" that points to a "Rectangle" object
	    const Rectangle * pConstRect = new Rectangle;
	    Rectangle * const pConstPtr = new Rectangle;
	 
	    cout << "pRect width: " << pRect->GetWidth() 
	       << " feet"  << endl;
	    cout << "pConstRect width: " << pConstRect->GetWidth() 
	       << " feet" << endl;
	    cout << "pConstPtr width: " << pConstPtr->GetWidth() 
	       << " feet" << endl;
	 
	    pRect->SetWidth(10);
	    // pConstRect->SetWidth(10);  // this line is commeted out because it would be not legal to set the width when pConstRect was declared to point to a constant Rectangle. Therefore, it cannot legally call a nonconst member function. 
	    pConstPtr->SetWidth(10); // here it is OK. "pConstPtr" is declared to be a constant pointers to a rectangle. In other words, the pointer is constant and cannot point to anything else, but the rectangle is not constant, so methods such as GetWidth() and SetWidth() can be used. 
	 
	    cout << "pRect width: " << pRect->GetWidth() 
	       << " feet\n";
	    cout << "pConstRect width: " << pConstRect->GetWidth() 
	       << " feet\n";
	    cout << "pConstPtr width: " << pConstPtr->GetWidth() 
	       << " feet\n";
	    return 0;
	}
--------------------------------------------------------------------- NOTE from pag 251 jesse book 
Using a const "this" pointer
When you declare an object to be const, you are in effect decalrin that the object's ths pointer is a pointer to a const object. A const this pointer can be used only with const member functions.
DO 
	1) DO protect objects passed by reference with const if they should not be changed. 
	2) DO set pointers to null rather than leaving them unitiliazed or dandling
DON'T
	1) DON'T use a pointer that has been deleted 
	2) DON'T delete pointers more than once.  
---------------------------------------------------------------------
SUMMARY POINTERS
Pointers provide a powerful way to access data by indirection. Every variable has an address, which can be obtained using the address-of operator (&). The address can be stored in a pointer. Pointers are declared by writing the type of object that they point to, followed by the indirection operator (*) and the name of the pointer. Pointers should be initialized to point to an object or to null (0). You access the value at the address stored in a pointer by using the indirection operator (*).
You can declare const pointers which can't be reassigned to point to other objects, and pointers to const objects, which can't be used to change the objects to which they point. [questo garantisce accesso in sicurezza]
To create new objects on the free store, you use the new keyword and assign the address that is returned to a pointer. You free that memery by calling the delete keyword on the pointer. delete frees the memory, but it doesn't destroy the pointer. Therefore, you mus reassign the pointer after its memory has been freed.
----------------------------------------------------------------------
>> ESERCIZI 
Carino l'esercizietto di pag.834 in tre righe ti spiega bene *, & e puntatori. >> pointer simple example ciccio's way
int * pOne;  // declares a pointer to an integer 
int vTwo;    // declares an integer variable. 
int * pThree = &vTwo;  // declares a pointer to an integer and initializes it with the address of the integer variable vTwo 
////////////////////////////////////////////////////////////////////////////////////////////////////////

>> F11 error in windows / >> RUN error in DEVC++ windows 7
I compile and run the program by pressing F11 in DEVC++ IDE, ma la finestra non si apriva e ci usciva un errore (vedevamo comparire il makeFile.win). 
SOLUTION 
Era perche' non avevamo chiuso la console window del programma precedente. E avevamo poi giusto copiato il nuovo programma nello stesso cpp file mantenendo lo stesso nome. Una volta chiusa la finestra dos e rilanciato F11 tutto ha funzionato senza problemi.

>> POINTERS / >> *
[pag335deitel]
Pointers keep track of where data and functions are stored in memory.
[memo trick : il puntatore viene preceduto dal simbolo * perche' come un puntatore laser emette * luce, che usa per puntare/illuminare un determinato indirizzo.]
in short
	int *countPtr, count;
is the declaration of a pointer "countPtr" that points at the int variable "count". [nota come l'"int" si riferisca al type della variable a cui il pointer punta e non al pointer stesso.]
example 2
	double *xPtr, *yPtr;
indicates that both xPtr and yPtr are pointers to double values. When a variable appears in a declaration, it's not an operator; rather it indicates that the variable being declared is a pointer. Pointers can be declared to point objects of any data type.
[pag336deitel]
- Common programming error: each pointer must be declared with the * prefixed to the name (with or without spaces in between). Assuming that the * used to declare a pointer distributes to all names in a declaration's comma-separated list of variables can lead to errors.
- Good programming practice: including the letter Ptr in a pointer variable name makes it clear that the variable is a pointer and that it must be handled accordingly.
- Error prevention: initialize all pointer to prevent pointing to unknown or uninitialized areas of memory. Pointer should be initialized to
	nullptr 
or an address of the corresponding type either when they've declared or in an assignement.
>> NULL POINTER : a pointer with the value nullptr "points to nothing" and is known as a null pointer.   
- Pointers variables contain memory addresses as their values. Normally, a variable directly contains a specific value. A pointer contains the memory address of that variable that, in turn, contains a specific value. 
In this sense, a variable name directly references a value, and a pointer indirectly references a value. Referencing a value through a pointer is called INDIRECTION 
- Diagrams typically represent a pointer as an arrow from the variable that contains an address to the variable located at that address in memory. 
- Pointers like any other variables, must be declared before they can be used. For example, for a pointer "countPtr" that points at the variable "count" (come nella figura 8.1pag336deitel) the declaration :
	int *countPtr, count;
declares the variable countPtr to be of type int * (cioe' e' un pointer che punta a un int value) and is read right to left cioe' "countPtr is a pointer to int."
RESS OPERATOR (&)
[pag 337deitel] the address operator & is a unary operator that obtains the memory address of its operand. For  example:
	int y = 5;           // declare variable y
	int *yPtr = nullptr; // declare pointer variable yPtr
	yPtr = &y;           // assign address of y to yPtr
----------------------------------------------------------------------------------------------------------------------
>> POINTERS TO CLASS MEMBERS ( .* AND ->* )/ >> ->* / >> .* [pag948 deitel]
C++ provides the .* and ->* operators for accessing class members via pointers. This is a rarely used capability, primarily for advanced C++ programmers. 
EXAMPLE:
	// Fig. 23.6: fig23_06.cpp
	// Demonstrating operators .* and ->*.
	#include <iostream>
	using namespace std;
	
	// class Test definition
	class Test
	{
	public:
	   void func()
	   {
	      cout << "In func\n";
	   } // end function func
	
	   int value; // public data member
	}; // end class Test
	
	void arrowStar( Test * ); // prototype
	void dotStar( Test * ); // prototype
	
	int main()
	{
	   Test test;
	   test.value = 8; // assign value 8
	   arrowStar( &test ); // pass address to arrowStar
	   dotStar( &test ); // pass address to dotStar
	} // end main
	
	// access member function of Test object using ->*
	void arrowStar( Test *testPtr )
	{
	   void ( Test::*memberPtr )() = &Test::func; // declare function pointer
	   ( testPtr->*memberPtr )(); // invoke function indirectly
	} // end arrowStar
	
	// access members of Test object data member using .*
	void dotStar( Test *testPtr2 )
	{
	   int Test::*vPtr = &Test::value; // declare pointer
	   cout << ( *testPtr2 ).*vPtr << endl; // access value
	} // end dotStar
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTERS [pag211 mike game programming]
The essence of a pointer is quite simple: A POINTER IS A VARIABLE THAT CAN CONTAIN A MEMORY ADDRESS.
Pointers give you the ability to work directly and efficiently with computer memory.
Computer memory is a lot like a neighborhood, but instead of houses in which people store their stuff, you have memory locaions where you can store data. Just like a neighborhood where houses sit side by side, labeled with addresses, chunks of computer memory sit side by side, labeled with addresses. In a computer, you can use a pointer with a memory address in it to get to a particular memory location (and to the stuff stored inside it).
Example /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/pointing.cpp
In questo programma we create a variable for a score and then creates a pointer to store the address of the variable.
il seguente programma dimostra che 
	- you can change the value of a variable directly, and the pointer will reflect the change.
	- you can change the value of a variable through a pointer. 
	- you can change a pointer to point to another variable entirely
	- pointers can work just as easily with objects.
-------------------------------------------------- FULL EXAMPLE pointing.cpp
		// Pointing
		// Demonstrates using pointers
		
		#include <iostream>
		#include <string>
		
		using namespace std;
		
		int main()
		{
		    int* pAPointer;    //declare a pointer
            // NOTE: because pointers work in such a unique way, programmers often prefix pointer variable names with the letter "p" to remind them that the variable is indeed a pointer.
			// NOTE2: just like an iterator, a pointer is declared to point to a specific type of value. pAPointer is a pointer to in, which means that it can point to an int value. pAPointer can't point to a float or a char, for example. pAPointer can only store the address of an int. 
		    
		    int* pScore = 0;   //declare and initialize a pointer
		        
		    int score = 1000;
		    pScore = &score;   //assign pointer pScore address of a variable score
		
		    cout << "Assigning &score to pScore\n";
		    cout << "&score is: " << &score << "\n";     //address of score variable ()
		    cout << "pScore is: " << pScore << "\n";     //address stored in pointer  (printi il puntatore quindi l'indirizzo che punta alla variabile)
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n"; //value pointed to by pointer 
		   
		    cout << "Adding 500 to score\n";
		    score += 500;  // ora score = 1500
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";  // *pScore means "the object to which pScore points."
            // anche la linea precedente dona in output 1500
		
		    cout << "Adding 500 to *pScore\n";
		    *pScore += 500;  // aggiungi 500 to the value to which pScore points, quindi score diventa 1500 + 500 = 2000
            // con la linea precedente modifichiamo il valore contenuto nell'indirizzo a cui pScore punta e non pScore stesso. Se per esempio effettuassimo pScore +=500; sarebbe sbagliato perche' cambieremmo l'indirezzo a cui punta pScore, a new address that might contain anything. And this could lead to disastrous results. It would be a disaster. Donald Trump approves this message.
		    cout << "score is: " << score << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";
		
		    cout << "Assigning &newScore to pScore\n";    
		    int newScore = 5000;
		    pScore = &newScore;  // reassigning pointers
		    cout << "&newScore is: " << &newScore << "\n";
		    cout << "pScore is: " << pScore << "\n";     
		    cout << "newScore is: " << newScore << "\n";
		    cout << "*pScore is: " << *pScore << "\n\n";  
		    
		    cout << "Assigning &str to pStr\n";
		    string str = "score";
		    string* pStr = &str;   //pointer to string object
		    cout << "str is: " << str << "\n";
		    cout << "*pStr is: " << *pStr << "\n";
		    cout << "pStr).size() is: " << pStr).size() << "\n";
		    cout << "pStr->size() is: " << pStr->size() << "\n";  
		  
		    return 0;
		}

--------------------------------------------------- FULL EXAMPLE pointing.cpp end
OUTPUT PROGRAM 
	Assigning &score to pScore
	&score is: 0x7fff6fc5c098
	pScore is: 0x7fff6fc5c098
	score is: 1000
	*pScore is: 1000
	
	Adding 500 to score
	score is: 1500
	*pScore is: 1500
	
	Adding 500 to *pScore
	score is: 2000
	*pScore is: 2000
	
	Assigning &newScore to pScore
	&newScore is: 0x7fff6fc5c09c
	pScore is: 0x7fff6fc5c09c
	newScore is: 5000
	*pScore is: 5000
	
	Assigning &str to pStr
	str is: score
	*pStr is: score
	pStr).size() is: 5
	pStr->size() is: 5
---------------------------------------------------
NOTE: because pointers work in such a unique way, programmers often prefix pointer variable names with the letter "p" to remind them that the variable is indeed a pointer.
NOTE2: >> declare pointer: when you declare a pointer, you can put whitespace on either side of asterisk. So
	int* pAPointer;
or
	int *pAPointer;
or 
	int int * pAPointer; 
all declare a pointer named pAPointer.
[quindi "char *argv[]" che di tanto in tanto si trova nei programmi openFOAM char *argv[]
altro non e' che un pointer di type char]
TRAP: when you declare a pointer, yhe asterisk only applies to the single variable name that immediately follows it. So the following statement declares pScore as a pointer to int and score as an int. 
	int* pScore, score;
score is not a pointer! It's a variable of type int. One way to make this clearer is to play with the whitespace and rewrite the statement as 
	int *pScore, score;
However, the clearest way to declare a pointer is to declare it in its own statement, as in the following lines.
	int* pScore;
	int score;
NOTE3: >> initialize Pointers / >> pointer initialize  : as with other variables you can initialize a pointer in the same statement you declare it. That's what we do next with the following line, which assigns 0 to pScore:
	int* pScore = 0; // declare and initialize a pointer
Assigning 0 to a pointer has a special meaning. Loosely translated, it means "Point to nothing". Programmers call a pointer with the value of zero a null pointer. You should always initialize a pointer with some value when you declare it, even if that value is zero. 
HINT: many programmer assign NULL to a pointer instead of 0 to make the pointer a null pointer. NULL is a constant defined in multiple library files, including iostream. 
NOTE4: >> assign address to pointer / >> pointer assign [pag215 mike game programming] A way to get address into the pointers is to get the memory address of an existing variable and assign it to a pointer. That's what we do in the following line, which gets the address of the variable score and assigns it to a pScore 
	pScore = &score; // assign pointer address of a variable score.
We get the address of score by preceding the variable name with &, the address of operator. 
NOTE5: & is a symbol used also as "reference operator". However, in this context, the & symbol gets the address of an object.
As a result the preceding line of code, pScore contains the address of score. It's as if pScore knows exactly where score is located in the computer's memory. This means you can use pScore to get to score and manipulate the value stored in score. 

            pScore                               score
      -----------------                    |-----------------|
      |               |                    |                 |
      |            ----------------------->|      1000       |
      |               |                    |                 |
      -----------------                    \-----------------/ 

The pointer pScore points to score, which stores the value 1000
NOTE6 pag 216 
>> DEREFENCING POINTERS [pag216 mike programming] termine sibillino per giusto dire "ottenere il valore puntato dal pointer", ottenere il contenuto dell'indirizzo a cui si punta, REFERENCING -> riferirsi = puntare a DEREFERENCING -> deriferire = ottenere il valore dell'indirizzo a cui si punta
    cout << "*pScore is: " << *pScore << "\n\n"; //value pointed to by pointer
*pScore means "the object to which pScore points."
NOTE7: DON'T\81@DEREFERENCE A NULL POINTER BECAUSE IT COULD LEAD TO DISASTROUS RESULTS [del resto un nullpointer non si sa bene cosa sia il contenuto a cui punta, metti che sia un goblin, o peggio ancora un gremlins, altro che electric dreams. You end up with electric nightmares!] 
NOTE8: >> pointer reassigning / >> reassign pointer [mike pag 217 game programming]
	pScore = &newScore;  // reassigning pointers
Unlike references, pointers can point to different objects at different times during the life of a program. Reassigning a pointer works like reassigning any other variable. In the following line we reassign pScore with the following line:
	pScore = &newScore; // pScore now points to newScore
TRAP : don't change the value to which a pointer points when you want to change the pointer itself. For  example, if we want to change pScore to point to newScore, then the following line would be a big mistake.
	*pScore = newScore;
This code simply changes the value to which pScore currently points; it doesn't change pScore itself. 
>> POINTERS TO OBJECTS [mike game programming pag217]
    cout << "Assigning &str to pStr\n";
    string str = "score";
    string* pStr = &str;   //pointer to string object, meaning that pStr can store the address of any string object.
    cout << "pStr).size() is: " << pStr).size() << "\n";
where pStr).size() says "Take the result of dereferencing pStr and call that object's size() member function". Because pStr refers to the string object equal to "score", the code returns 5. 
HINT: whenever you dereference a pointer to access a data member or member function, surround the dereferenced pointer with a pair of parentheses. This ensures that the dot operator will be applied to the object to which the pointer points.
NOTE : una maniera piu' readable e del tutto equivalente a pStr).size() e' pStr->size(). It's a more readable way to access object members. [>> -> = easy way to access object members pag 218 mike programming game]
----------------------------------------------------------------------------------------------------------
>> POINTER CONSTANT / >> CONSTANT POINTER [pag219 mike programming game] int* const pScore = &score;
You can use the keyword const to restrict the way a pointer works. These restrictions can act as a safeguards and can make your programming intentions clearer.
Pointers can point to different object at different times in a program. However, by using the const keyword  when you declare and initialize a pointer, you can restrict the pointer so it can only point to the object to which it was initialized to point. A pointer like this is called a constant pointer. Another way to say this is to say that the address stored in a constant pointer can never change: it's constant. You create a constant pointer by putting const right before the name of the pointer when you declare it. Here's an example of creating a constant pointer:
	int score = 100;
	int* const pScore = &score; // a >> constant pointer example
The preceding code creates a constant pointer, pScore, which score to score. Like all constants, you must initialize a constant pointer when you first declare it. For example writing "int* const pScore;" is more ILLEGAL than mexican pleople entering through the Trump wall or Crooked Hillary bribes business.
Also "pScore = &anotherScore;" is illegal since pScore can't point to a different object. 
Although you can't change pScore itself, you can use pScore to cahnge the value to which it points. The following line is completely legal:
	*pScore = 500;
It's perfectly fine to use a constant pointer to change the value to which it points. Remember, the restriction on a constant pointer is that its value, the address that the pointer stores can't change, the address a cui punta non puo' cambiare ma chi ci vive in quell'indirizzo puo' cambiare. Il const pointer mi sembra un po come il padrone di una casa in affitto. Il locatario puo' cambiare, ma il padrone lui resta puntato sempre allo stesso indirizzo da cui riceve l'affitto.
NOTE: the way a constant pointer works should remind you of something: a reference. Like a reference, a constant pointer can refer only to the object to which it was initialized to refer. 
Although you can use a constant pointer instead of a reference in your programs, you should stick with references when possible. References have a cleaner syntax than pointers and can make code easier to read. 
>> POINTER TO CONSTANT [pag220 mike game programming] const int* pNumber; // a pointer to a constant  {{da non confondersi con constant pointer vedi sopra "int* const pScore = &score;"}}
By using a the const keyword when you declare a pointer, you can restrict a pointer so it can't be used to change the value to which it points. A pointer like this is called pointer to a constant. Example 
	const int* pNumber;
The preceding code declares a pointer to a constant, pNumber. You declare a pointer to a constant by putting const right before the type of value to which the pointer will pointer. You assign an address to a pointer to a constant as you did before:
	int lives = 3;
	pNumber = &lives;
However, you can't use the pointer to change the value to which it points. The following line is illegal:
	*pNumber -= 1; // illegal: can't use pointer to constant to change value that pointer points to
Although you can't use a pointer to a constant to change the value to which it points, the pointer itself can change. This means that a pointer to a constant point to different objects in a program. The following code is perfectly legal.
	const int MAX_THRUST = 500;
	pNumber = &MAX_THRUST; // point itself can change.
>> CONSTANT POINTER TO A CONSTANT [pag221 mike programming] (in realta' poco usati perche' sono del tutto equivalenti a delle "constant reference", le quali presentano il vantaggio di offrire a cleaner syntax and a more readable code)
A constant pointer to a constant combines the restrictions of a constant pointer and a pointer to a constant. This means that a constant pointer to a constant can only point to the object to which it was inialized to point. In addition, it can't be used to change the value of the object to which it points. 
	const int* const pBONUS = &BONUS; // >> constant pointer to constant
The preceding code creates a constant pointer to a constant named pBONUS that points to the constant BONUS. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTER PITFALLS [pag254 moo book]
A pointer is a promitive, low level data structure. Programming with pointers is notoriously error prone. Many of the problems with pointers arise because pointers are independent of the objects to which they point, leading to pitfalls:
- copying a pointer does not copy the corresping object, leading to surprises if two pointers inadvertently point to the same object.
- destroying a pointer does not destroy its object, leading to memory leaks
- deleting an object without destroying a pointer to it leads to a dangling pointer, which causes undefined behaviour if the program uses the pointer.
- creating a pointer without initializing it leaves the pointer unbound, which also causes undefined behaviour if the program uses it.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PASSING POINTERS / >> POINTER PASS [pag222 mike programming game]
NOTE [pag224 mike programming] why we pass pointers? perche' si vedono functions' headers like "void goodSwap(int* const pX, int* const pY)" con strani asterischi? E' PERCHE' SI VUOLE DONARE ALLA FUNZIONE ACCESS TO VARIABLES. Vedi l'esempio qui sotto:
	1) in the main() function 
		goodSwap(&myScore, &yourScore); // as input we use the addresses of myScore and your score. WHEN YOU PASS AN OBJECT TO A POINTER YOU NEED TO SEND THE ADDRESS OF THE OBJECT
	2) in the function header
		void goodSwap(int* const pX, int* const pY)    // in the function's header pX and pY are constant pointers and will each accept the memory address we set in the main function. 
----------------------------------------------------------------- 
You can give function access to variables by passing references. But it's also possible to accomplish this using pointers. When you pass a pointer, you pass only the address of an object. This can be quite efficient, especially if you're working with objects that occupy large chunks of memory. Passing a pointer is like e-mailing a friend the URL of a website instead trying to send him the entire website.
-----------------------------------------------------------------
Even though references are the preferred way to pass arguments because of their cleaner syntax, you still might need to pass objects through pointers. For example, suppose you're using a graphics engine that returns a pointer to a 3D object. If you want another function to use this object, you'll probably want to pass the pointer to the object for efficiency. Therefore, it's important to know how to pass pointers as well as references.
NOTE: you can also pass a constant pointer to a constant. This works much like passing a constant reference, which is done to efficiently pass an object that you don't need to change.
[example from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/swap_pointer_ver.cpp]
----------------------------------------------------------------- FULL EXAMPLE
		// Swap Pointer
		// Demonstrates passing constant pointers to alter argument variables
		
		#include <iostream>
		
		using namespace std;
		
		void badSwap(int x, int y);
		void goodSwap(int* const pX, int* const pY);
		
		int main()
		{
		    int myScore = 150;
		    int yourScore = 1000;
		    cout << "Original values\n";
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		    
		    cout << "Calling badSwap()\n";
		    badSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		        
		    cout << "Calling goodSwap()\n";
		    goodSwap(&myScore, &yourScore); // we pass the addresses of myScore and yourScore when we call goodSwap() with the following line. WHEN YOU PASS AN OBJECT TO A POINTER YOU NEED TO SEND THE ADDRESS OF THE OBJECT
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n";
		
		    return 0;
		}
		
		void badSwap(int x, int y)
		{
		    int temp = x;
		    x = y;
		    y = temp;
		}
		
		void goodSwap(int* const pX, int* const pY)    // in this function's header pX and pY are constant pointers and will each accept a memory address. We made the parameters constant pointers because, although we plan to change the values they point to, We don't plan to change the pointers themselves. [i proprietari (pointers) puntano sempre alle stesse case in affitto, cambi giusto i locatari che vi vivono dentro] 
		{
		    //store value pointed to by pX in temp
		    int temp = *pX;
		    //store value pointed to by pY in address pointed to by pX
		    *pX = *pY;
		    //store value originally pointed to by pX in address pointed to by pY       
		    *pY = temp;      
		}
----------------------------------------------------------------- FULL EXAMPLE END
/////////////////////////////////////////////////////////////////////////////////////

>> low level data structures >> pointers and arrays [pag 169 moo book]
We can store data either in varialables or containers, such as vector, that come from the standard library. The reason for this strategy is that the standard library facilities are usually more flexible and easier to use than the facilities that are part of the core language. 
	Once you know how to use the library, the logical next step is to understand how it works. The key to this undersatnding turns out to involve core language programming tools and techniques that come in handy in other contexts as well. We use the term low level to refer to theses ideas because they underlie the standard library and because they correspond closely to the way typical computer hardware works. For these reasons, they tend to be harder to use, and are more dangerous, but they sometimes can be more efficient. Because no library can solve all problems, many C++ programs wind up using low level techniques from time to time. For example we can use arryas and pointers and combine with "new" expressions and "delete" expressions to allow a form of dynamic memory allocation that programmers can control more directly than they can control the automatic memory management offered by library classes such as vector and list.
An >> array is a kind of container, similar to a vector but less powerful. A pointer is a kind of random access iterator that is essential for accessing elements of arrays, and has other uses as well.
Pointers and arrays are among the most promitive data strutures in C and C++. They are virtually inseparable from one another, in the sense that it is impossible to do anything useful with an array without using pointers, and pointers become much more useful in the presence of arrays.
>> POINTER [pag170 moo book]
A pointer is a value that represents the address of an object. Every distinct object has a unique address, which denotes the part of the computer memory that contains the object. If you can access an object, you can obtain its address, and viceversa. 
For example if 
	x is an object
then
	&x is the address of that object, 
and if 
	p is the address of an object 
then 
	*p is the object itself.
The & and &x is an address operator, and is distinct from the use of & to define reference types (pag54 moo book). 
The * is a dereference operator, which works analogously to the way * works when applied to any other iterator (pag81 moo book).
If p contains the address of x, we also say that p is a pointer that points to x. It is common to represent such a astate of affairs with a diagram such as :

               p                                    x
      -----------------                    |-----------------|
      |               |                    |                 |
      |            ----------------------->|                 |
      |               |                    |                 |
      -----------------                    \-----------------/ 

As with other built-in types, a local variable that is a pointer has no meaningful value until we give it one. Programmers frequently use the value 0 to initialize pointers, because converting 0 to a pointer yields a value that is guaranteed to be distinct from a pointer to any object. Moreover, the constant 0 is the only interger value that can be converted to a pointer type. The resulting value, often called a null pointer, is often useful in comparisons.
As with all C++ values, pointers have types. Suppose that x is an object of type int, defined as;

	int x;

and we want to define p to have a type that will allow p to contain the address of x. We do so by saying that the type of p is "pointer to int" which we say implicitly by defining *p to have type int:
	
	int *p;    // *p has type int

Here *p is a >> declarator, which is the part of a definition that defines a single variable. 
Even though the * and the p are part of a single declarator, most C++ programmers write this definition as 
	
	int* p;    // p has type int*

to emphasize the notion that p has a particular type (i.e. int*). These two usages are equivalent because spaces around the * are neutral. However , the latter usage conceals a pitfall that is so important that it deserves special attention:

	int* p, q;

defines p as an object of type "pointer to int" and q as an object of type int. This example is easier to understand if we view it this way:

	int *p, q;  // *p and q have type int

or for that matter this way 

	int (*p), q;   (*p) and q have type int

Still better, we can make our intentions crystal clear by writing

	int* p;   // *p has type int
	int q;    // q has type int

We now know enough to write a simple program that uses pointers:

	int main()
	{
		int x = 5;

		// p points to x 
		int* p = &x;    // dove & e' l'address operator. Questa linea significa: assegn al pointer p (di type int*) l'address della variabile x
		cout << "x = " << x << endl;

		// change the value of x through p
		*p = 6;   // *p = cio' a cui p punta, cioe' il contenuto della memoria allocata alla variable x, cioe' "*p = 6" same as "x = 6"
		cout << "x = " << x << endl;
		return 0;
	}

CICCIO TRICK &x ti da l'indirizzo, and & this is the END. la mafia arriva *p con la torcia * e ti scompiglia tutti i valori che hai in casa.

The output of this program will be 

	x = 5
	x = 6

Nel programma sopra, immediately after we have defined p, the state of our variable is 5. After the first output to screen, the next statement changes the value of x to 6 by executing *p = 6. Remember, once p contains the address of x, *p and x are two different ways of referring to the same object. Thus the x is 6 when the second output expression is executed.
------------------------------------------------------------------------------------- ti ricopio l'esempio sopra in maniera piu' compatta senza commenti
#include <iostream>
using std::cout;
using std::endl;
int main()
{
	int x = 5;

	// `p' points to `x'
	int* p = &x;
	cout << "x = " << x << endl;

	// change the value of `x' through `p'
	*p = 6;
	cout << "x = " << x << endl;
	return 0;
}
------------------------------------------------------------------------------------------
>> POINTERS TO FUNCTIONS [pag172 moo book]
Functions are not objects, and there is no way to copy or assign them. In particular there is no way for a program to create or modify a function (only the compiler can do that). All that a program can ever do with a function is call it or take its address. 
	Nevertheless, we can call a function with another function as an argument [like pag 112-113 moo book]. What happens is that the compiler quietly translates such calls so as to use pointers to functions instead of using functions directly.
Pointers to functions behave similarly to any other pointers. Once you have dereferenced such pointer, however, all you can do with the resulting function is call it (or take the function's address yet again).
[CICCIO SPIEGA in parole semplici: 

	>> DEREFERENCE = ottenere il valore a cui il pointer punta 

Quindi se il puntatore punta a una funzione, deferenziando ottieni la funzione stessa: e con essa potrai effettuare solo due operazioni: chiamarla o ottenerne l'indirizzo.
]
We might write 
	int (*fp)(int);
to say that if we dereference "fp", and call it with an int argument, the result has type int. By implication, "fp" is a pointer to a function that takes an int argument and returns an int result. 
Because all that you can do with a function is to take its address or call it, any use of a function that is not a call is assumed to be taking its address, even without an explicit &. Similarly, you can call a pointer to a function without dereferencing the pointer explicitly. 
So for example if we have a function whose type matches "fp" (nel senso che prende per input un intero e dona in output un intero) as 
	int next(int n)	
	{
		return n+1;
	}
then we can make fp point to "next" by writing either of the following two statements:
	// these two statements are equivalent
	fp = &next;
	fp = next;
Similarly if we have an int variable named i, we can use fp to call "next", and thereby increment i, by writing either:
	// these two statements are equivalent
	i = (*fp)(i);
	i = fp(i);
Finally, if we write a function that looks like it takes another function as a parameter, the compiler quietly translates the parameter to be a pointer to a function instead. So for example, in the write_analysis pag 113 moo book the paraemeter that we wrote as 
	double analysis(const vector<Student_info>&)
could be equivalently have been written as 
	double (*analysis)(const vector<Student_info>&) 
-----------------------------------------------------------------------------------------------------
>> ARRAYS [pag174 moo book]
An array is a kind of container that is part of the core language rather than part of the standard library. Every array contains a sequence of one or more objects of the same type. The number of elements in the array MUST BE KNOWN at compile time, which requirement implies that arrays cannot grow or shrink dynamically the way library containers do. 
Osservazioni: 
- al posto di "size_type" si usa "size_t" to deal with the size of an array. ["size_type" e' una member functions che non e' disponibile per gli arrays, i quali non essendo class types, have no members, fanno parte del core language, non della standard library]
- se dovessi definire un punto usando i container della library potresti convenientemente scrivere:
	double coords[3];
oppure in maniera piu' hard core language potresti scrivere
	const size_t NDim = 3;
	double coords[NDim];
Using NDim instead of 3 distinguishes the 3 that represents the number of dimensions from a 3 that represents, say, the number of sides of a triangle.
No matter ow we define an array, there is always a fundamental relationship between arrays and pointers: whenever we use the name of an array as a value, that name represents a pointer to the initial element of the array. 
[detto in altre parole : >> POINTER TO THE INITIAL ELEMENT OF AN ARRAY = name of the array]
We have defined coords as an array, so using coords as a value gives us the address of the array's initial element. As with any other pointer, we can dereference it with the * operator to get the object to which it points, so that executing
	*coords = 1.5;
sets the initial element of coords to 1.5
------------------------------------------------------------------------------------------------------
>> POINTER ARITHMETIC [pag175 moo book]
Riprendiamo l'esempio sopra:
	const size_t NDim = 3;
	double coords[NDim];
coords ha quindi 3 elementi. The initial element of coords has number 0, we see that coords + 1 is the address of element number 1 of the coords array (i.e. the element after the initial one), and coords + 2 is the address of the element number 2, which is also the last one because we defined coords to have three elements. 
Del resto a pointer is a kind of iterator, more specifically a random access iterator. If p points to the mth element of an array, then p + n points to the (m + n)th element of the array and (p - n) points to the (m-n)th element assuming of course these elements exist.
E anche qualora l'element non esistesse il pointer resta valido anche se non si sa bene a cosa punti. 
Riprendendo l'esempio coords con i sui tre elementi, coords+3 represents the address of where element number 3 would be in the coords array if the element existed, but the element doesn't exist. Nevertheless coords+3 is a valid pointer, even though it doesn't point to an element. 
[pag175moo book]
If p and q are pointers to elements of the same array, then p-q is an integer that represents the distance in elements between p and q. More precisely, p-q is defined so that (p-q)+q is equal to p. Because p-q might be negative, it has a signed integer type. Whether that type is int or long depends of the implementation, so the library provides a synonym, named ptrdiff_t, to represent the appropriate type. Like size_t, the ptrdiff_t type is defined in the <cdtddef> header
-----------------------------------------------------------------------------------------------------
>> INDEXING [pag175 moo book]
Pointers are random-access iterators for arrays. Therefore, like all random-access iterators, they support indexing. Specifically, if p points to the mth element of an array, p[n] is the m+n th element of the array, not the address of the element, but the ELEMENT ITSELF.
Remember that the name of array is the address of the initial element of the array. This fact, together with the definition of p[n], implies that if a is an array, a[n] is the nth element of an array. More formally, if p is a pointer and n is an integer, then p[n] is equivalent to *(p+n).
-----------------------------------------------------------------------------------------------------
>> ARRAY INITIALIZATION [pag176 moo book]
There is a convenient syntax for giving an initial value to each element of an array. 
Moreover, using this syntax often lets us avoid having to state the size of the array explicitly.
For example, if we were writing a program that deals with deals with dates, we might like to know how many days are in each month. One way to do so would be the following:
	const int month_lengths[] = {
		31, 28, 31, 30, 31, 30,
		31, 31, 30, 31, 30, 31
	};
Here, we have given an initial value to each element that corresponds to the length of a month, with January being month 0 and December being month 11. Now, we can use month_length[i] to refer to the length of month i. 
Note that we did not say explicitly how many elements the month_lengths array has. Because we initialized it explicitly, the compiler will count elements for us, a task to which it is much better suited than we.
>> STRING LITERAL REVISITED [pag176 moo book]
We have finally learned enough to understand the true meaning of string literals. A string literal is really an array of const char with one more element than the number of characters in the literal. The extra character is a null character (i.e.,  '\0') that the compiler automatically appends to the rest of the characters. In other workds if we define 
	const char hello[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
then the variable "hello" has exactly the same meaning as the string liberal "Hello", except, of course, that the variable and the literal are two distinct objectds and therefore, have different addresses. 
The reason that the compiler inserts the null character is to allow the programmer to locate the end of the literal given only the address of its initial character. The null character acts as an end marker, so that the programmer can know where the string ends.
There is a library function in <cstring> called strlen, which tells us how many characters are in a string literal or the other null-terminated array of characters, not counting the null at the end. 
IN CONCLUSION : a string literal is just a conveninent way of writing the address of the initial character of a null-terminated sequence of characters. 
>> INITIALIZING ARRAYS OF CHARACTERS POINTERS [pag177 moo book]
As we have seen in the example 
	const int month_lengths[] = {
		31, 28, 31, 30, 31, 30,
		31, 31, 30, 31, 30, 31
	};
we can initialize the elements of an array by giving a seqeunce of appropriate values, enclosed in curly braces, as an initializer. And we know that a string literal is just a conveninent way of writing the address of the initial character of a null-terminated sequence of characters. 
By combining these two facts, we can initialize an array of characters pointers by giving a sequence of string literals. 
>> NUMERIC LETTER CONVERSION / >> LETTER NUMERIC CONVERSION /  NUMBER LETTER / >> NUMBER LETTER CONVERSION [pag177 moo]
Supponi di voler effettuare una conversione del tipo:
If the grade is at least 97  94  90  ect ... 70 60 0 
then the letter grade is A+  A   A-  ect ... C- D  F
Here is a program that does the conversion:
[/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/letter_grade.cc]
	#include <cstddef>
	#include <string>
	
	using std::string;
	
	string letter_grade(double grade)
	{
		// range posts for numeric grades
		static const double numbers[] = {
			97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
		};
	
		// names for the letter grades
		static const char* const letters[] = {
			"A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
		};
	
		// compute the number of grades given the size of the array
		// and the size of a single element
		static const size_t ngrades = sizeof(numbers)/sizeof(*numbers);
	
		// given a numeric grade, find and return the associated letter grade
		for (size_t i = 0; i < ngrades; ++i) {
			if (grade >= numbers[i])
				return letters[i];
		}
	
		return \?\?";
	}
-----------------------------------------------------------------------------------------------------
>> ARGUMENTS to "main" / >> pass argument to main / >> main arguments pass [pag179 moo book]
example /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/write_args.cc
----------------------------------------------------------------
#include <iostream>

using std::cout;
using std::endl;

int main(int argc, char** argv)
{
	// if there are command-line arguments, write them
	if (argc > 1) {
		cout << argv[1];               // write the first argument

		// write each remaining argument with a space before it
		for (int i = 2; i != argc; ++i)
			cout << " " << argv[i];    // `argv[i]' is a `char*'
	}
	cout << endl;
	return 0;
}
------------------------------------------------------------------
If we compile this program and put the resulting executable in a file called "say", then by asking the system to execute
	say Hello, world
we will cause our program to write
	Hello, world
In this case argc will be 3, and the three elements of argv will be pointers to the initial characters of arrays initialized with "say", "Hello," and "world" respectively. We can visualize the value of argv this way


       argv      
         ------>|______|--> s | a | y | \0  
                |______|--> H | e | l | l | o | , | \0
                |______|--> w | o | r | l | d | \0
 
vedi figura completa pag 180 non ho tempo di farti tutto l'art ascii
///////////////////////////////////////////////////////////////////////////////////////////////////// 

>> CONVENTIONS
some useful links :
- http://www.stroustrup.com/bs_faq2.html (saved in blackbird webkara doc as Stroustrup_Cpp_Style_and_Technique FAQ.html)
- https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md (saved in blackbird webkaraDoc as "CppCoreGuidelines_CppCoreGuidelines")
- http://geosoft.no/development/cppstyle.html (saved in blackbird webkate doc as CppProgrammingStyleGuidelines_byGeoSoft.html)
>> MEANING VARIABLE FOLLOWED BY & / >> & after variable name meaning
Nel OF source code trovavamo : "const word&" Questo e' diverso dal & che precede un nome. Quindi non si tratta di donare l'address, vero?
Si ha ragione, eccoti una risposta da StackOverFlow:
ANSWER
MyType& represents a /reference/, a completely different beast to pointers. If your function prototype were
func(MyType);
you would be working with a copy of the argument inside the function. With
func(MyType&);
you are working with the object itself (i.e., same object both in the calling and called scope). It is, for this case, like working with a pointer but using the same "dot" syntax as for objects.
Of course, this is a shallow and simplistic explanation. For me fulling grasping the deep zens below pointers, references, and the rest of the horde took years.
[source https://stackoverflow.com/questions/3350626/whats-the-meaning-of-and-when-applied-to-variable-names]
See also https://stackoverflow.com/questions/20864574/ampersand-at-the-end-of-variable-etc

>> -> meaning

ANSWER1) a->b means (*a).b.
If a is a pointer, a->b is the member b of which a points to.
a can also be a pointer like object (like a vector<bool>'s stub) override the operators.
ANSWER2) It's to access a member function or member variable of an object through a pointer, as opposed to a regular variable or reference.
For example: with a regular variable or reference, you use the . operator to access member functions or member variables.
std::string s = "abc";
std::cout << s.length() << std::endl;
But if you're working with a pointer, you need to use the -> operator:
std::string* s = new std::string("abc");
std::cout << s->length() << std::endl;
It can also be overloaded to perform a specific function for a certain object type. Smart pointers like shared_ptr and unique_ptr, as well as STL container iterators, overload this operator to mimic native pointer semantics.
For example:
std::map<int, int>::iterator it = mymap.begin(), end = mymap.end();
for (; it != end; ++it)
    std::cout << it->first << std::endl;
ANSWER3) see the summary in https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Member_and_pointer_operators
[>> Operators in C and C++ : ti ho salvato la pagina in blackbird webkaradocs -> OperatorsInCandCpp-Wikipedia.html]

>> _ following name / >> undescore following name meaning:
Private class variables should have underscore suffix.
class SomeClass {
  private:
    int length_;
}
Apart from its name and its type, the scope of a variable is its most important feature. Indicating class scope by using underscore makes it easy to distinguish class variables from local scratch variables. This is important because class variables are considered to have higher significance than method variables, and should be treated with special care by the programmer.
A side effect of the underscore naming convention is that it nicely resolves the problem of finding reasonable variable names for setter methods and constructors:
  void setDepth (int depth)
  {
    depth_ = depth;
  }
An issue is whether the underscore should be added as a prefix or as a suffix. Both practices are commonly used, but the latter is recommended because it seem to best preserve the readability of the name.
It should be noted that scope identification in variables has been a controversial issue for quite some time. It seems, though, that this practice now is gaining acceptance and that it is becoming more and more common as a convention in the professional development community.
[source http://geosoft.no/development/cppstyle.html]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> return 0 meaning [pag3 moo book]
example 
	// a small C++ program
	#include <iostream>
	
	int main()
	{
		std::cout << "Hello, world!" << std::endl;
		return 0;   // lo zero viene assegnato all' "int" di main a segno che il programma e' stato eseguito con successo.
	}
NOTE: a program may have more than one return statement. If the definition of a function promises that the function returns a value of a particular type, then every return statement in the function must return a value of an appropriate type.
------------------------------------------------------------------------------------
>> FILE READ / >> FILE WRITE [pag180 moo book]
>> ERROR STREAM / >> STANDARD ERROR STREAM [pag180 moo book]
To notify the user abbout error conditions and to make such comments easy to distinguish from ordinary output, the C++ library defines a standard error stream, in addition to the standard input and output streams. This stream is often merged with the standard output, but most systems provide a way to separate them.
A pag180 trovi spiegazione di parole chiave tipo 
	->> clog	[pag180 moo book]: is intended for logging purposes. It has the same buffering properties as "cout". It saves characters and writes them when the system decides that it is appropriate to do so
	->> cerr	[pag180 moo book]: cerr stream, on the other hand always writes its output immediately.
This strategy guarantees that the output will become visible as sson as possible, but it imposes what might be a substantial overhead. Therefore, to write an urgent complaint, you should use cerr; to produce a running commentary about what the program is doing, you should use clog.
Altre parole chiave descritte
	->> ifstream vs >> istream [pag181 moo book]
	->> ofstream vs >> otream [pag181 moo book]
>> input files and >> output files / >> read file / >> write file [pag181 moo book]
Example of program that copies a file named "in" into a file named "out" :
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/copyfile.cc]
	#include <fstream>
	#include <string>
	
	using std::endl;
	using std::getline;
	using std::ifstream;
	using std::ofstream;
	using std::string;
	
	int main()
	{
		ifstream infile("in");
		ofstream outfile("out");
	
		string s;
	
		while (getline(infile, s))
			outfile << s << endl;
		return 0;
	}
-------------------------------------------------------------------------------------
Example 2 pag182 moo book (>> concatenate files): program that produces, on its standard output, a copy of the contents of all the files whose names are given as arguments to main
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter10/concat_files.cc]
-------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>

using std::cerr;
using std::cout;
using std::endl;
using std::getline;
using std::ifstream;
using std::string;

int main(int argc, char **argv)
{
	int fail_count = 0;
	// for each file in the input list
	for (int i = 1; i < argc; ++i) {
		ifstream in(argv[i]);

		// if it exists, write its contents, otherwise generate an error message
		if (in) {
			string s;
			while (getline(in, s))
				cout << s << endl;
		} else {
			cerr << "cannot open file " << argv[i] << endl;
			++fail_count;
		}
	}
	return fail_count;
}
-------------------------------------------------------------------------------------
For each arugment given to main, the program creates an ifstream object to read the file by that name. If the object appears false when used as a condition, that means that the file does not exist, or that it cannot be read for some reason. Accordingly, the program complains on cerr, and keeps a count of how many failures it had. If the program created the ifstream object successfully, it reads the file, one line at a time, into "s", and writes the contents of each line on the standard output. 
When the program returns control to the system, it passes back the number of files that it was able unable to read. As usual, a return value of zero indicates success, which in this case will indicate that we were able to read all the files.
-------------------------------------------------------------------------------------
>> MEMORY MANAGEMENT [pag182 moo book] / >> MEMORY MANAGEMENT TYPES / >> ALLOCATION / >> DEALLOCATION of an Object
There are two distinct kinds of memory management
The first kind is called >> automatic memory management and is associated with local variables. A local variable occupies memory that the system allocates when it encounters the variable's definition during execution. [ecco perche' non dichiarare una variabile preliminarmente crea errore. bisogna fare bene i preparativi, mettere in posizione le pentole prima di metterci dentro gli ingredienti, se no finisci con un immangiabile frittomisto. Matlab probabilmente riesce ad effettuare operazione senza inizializzazione di variabili, perche' ha un controllo if interno: se l'utente ordina di versare farina e sotto non c'e' ancora una pentola, metti la pentola automaticamente] The system automatically deallocates that memory at the end of the block that contains the definition. 
Once a variable has been deallocated, any pointers to it becomes invalid. It is the programmer's reponsability to avoid using such invalid pointers. For example:

	// this function deliberately yields an invalid pointer
	// it is intended as a negative example don't do this
	int* invalid_pointer()
	{
		int x;
		return &x;   // instant disaaaaaster!!! sad!  MakeAmGreAg!!!
	} 
This program returns the address of the local variable x. Unfortunately, when the function returns, doing so ends execution of the block that contains the definition of x, which deallocates x. The pointer that &x created is now invalid, but the function tries to return it anyway. What happens at this point is anybody's guess. 
If we want to return the address of a variable such as x, one way to do so is to use the other kind of memory management, by asking for x to be statically allocated. [>> static allocation example pag183 moo book]
	// this function is completely legitimate
	int* pointer_to_static()
	{
		static int x;
		return &x;   
	}  
By saying that x is static, we are saying that we want to allocate it once, and only once, at some point before the first time that pointer_to_static is ever called, and that we do not want to deallocate it as long as our program runs. 
However, static allocation has the potential disadvantage that every call to pointer_to_static will return a pointer to the same object! Suppose we want to define a fucntion such that each time we call it, we get a pointer to a brand new object, which stays around until we decide that we no longer want it. To do so, we use >> dynamic allocation [pag183 moo book], which we request by using the new and delete keywords. 
>> ALLOCATE OBJECT If T is a type of an object, "new T" is an expression that allocates an object of type T, which is default initialized, and yields a pointer to this (unnamed) newly allocated object. It is possible to give a specific value to use when initializing the object by executing new T(args)  [cioe' new T(parametroDiInput1, parametroDiInput2, ...parametroDiInputN)]. The object stays around until the program either ends or executes "delete p" (whichever happens first), where "p" is (a copy of) the pointer returned by "new". In order to delete a pointer, the pointer must poin to an object that was allocated by "new", or be equal to zero. Deleting a zero pointer has no effect. 
As an example 
[>> pointer spiegato da dio! conciso e chiaro leggi linee seguenti (from pag183 moo book)]
	int* p = new int(42);
will 
	1) allocate an unnamed new object of type "int", 
	2) initialize the object to 42,  
	3) and cause  "p" to point to that object
We can affect the value of the object by executing statements such as 
	++*p;   // *p is now 43
after which the object has the value 43. When we're done with the object, we can execute 
	delete p;
after which the space occupied by *p is freed and p becomes an invalid pointer, with a value that we can no longer use until we have assigned a new value to it.
As another example, we might write a function that allocates an int object, initializes it, and returns a pointer to it:
[pag184 moo book]
	int* pointer_to_dynamic()
	{
		return new int(0);
	}
which imposes on its caller the responsibility of freeing the object at an appropriate time. [ah ecco perche' in OF abbiamo bisogno di deallocare la memoria, se non si fa nulla, l'oggetto resta li' fino alla fine del programma, occupando inutilmente memoria anche quando non se ne ha piu' bisogno.] 
-------------------------------
>> deallocate entire array / >> deallocate array [pag184 moo book]
	delete[] p;
the [] are necessary to tell the system to deallocate an entire array , rather than a single element.
/////////////////////////////////////////////////////////////////////////////////////


>> RETURN [pag114 jesse]
When inside a function the "return" keyword is encountered, the expression folowing return is returned as the value of the function. Program execution returns immediately to the calling function, and any statements following the return are not executed. 
To return a value from a function write the keyword "return" followed by the value you want to return 
example 
	return 5; // returns 5
	return (x > 5); // returns "true" if x > 5 e "false" is x < 5 (does not return the value of x itself)
	return (MyFunction()); // qui farai ritornare al programma chiamante il valore donato da MyFunction()
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> int main() vs >> void main()  [pag116 jesse]
Both works, but it is adviced to use
	int main()
because 
1) only int main() is ANSI compliant, so only int main() is guaranteed to continue working in future
2) int main() returns a value to the operating system. When your program completes, that value can be captures by, for example, batch programs.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTER RETURN / >> RETURN POINTERS [pag226 mike game programming]
Prima dell'arrivo delle references, l'unica maniera che i programmatori avevano per returning objects efficiently from functions era di utilizzare dei puntatori. E sebbene usare references provides a cleaner syntax than using pointers, you might still need to return objects through pointers.
The following program demonstrates returning pointers. Through returned pointers, the program displays and even alters the values of a vector that holds a here's inventory.
COMMENTI SUI PASSI SALIENTI DEL PROGRAMMA SOTTOSTANTE
	- NOTE: 	string* ptrToElement(vector<string>* const pVec, int i)  // about the header of the function ptrToElement. 
	This function will return a pointer to a string object (and not a string object itself). To specify that a function returns a pointer to an object of a particular type, put an asterisk after the type name of the return type. 
	- NOTE: 
FULL EXAMPLE from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/inventory_pointer.cpp
--------------------------------------------------------------------- FULL EXAMPLE 
	// Inventory Pointer
	// Demonstrates returning a pointer
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	//returns a pointer to a string element
	string* ptrToElement(vector<string>* const pVec, int i);
	
	int main()
	{
	    vector<string> inventory;
	    inventory.push_back("sword");  // sword's position is 0
	    inventory.push_back("armor");
	    inventory.push_back("shield");
	    //displays string object that the returned pointer points to
	    cout << "Sending the object pointed to by returned pointer to cout:\n";       
	    cout << *(ptrToElement(&inventory, 0)) << "\n\n";  // >> RETURNED POINTER TO DISPLAY A VALUE / >> POINTER RETURN EXAMPLE
        	// NOTE: the preceding line calls prtToElement(), which returns a pointer to inventory[0]. 
			// ptrToElement() doesn't return a copy of one of the elements of inventory; it returns a pointer to one of them. 
			// the line then sends the string object pointed to by the pointer to cout. 

	    //assigns one pointer to another -- inexpensive assignment
	    cout << "Assigning the returned pointer to another pointer.\n";  // >> POINTER ASSIGN / >> assigning returned pointer to pointer 
	    string* pStr = ptrToElement(&inventory, 1);
			// the call to prtToElement() returns a pointer to inventory[1]. The statements assigns that pointer to pStr. 
            // quindi il puntatore pStr punta all'object 1 ("armor")
                  
                   inventory
                   ------------------------------------------------
                   |    "sword"   |   "armor"    |    "shield"    | 
                   ----------------------^-------------------------
                                         |
                                         |
                                 pStr    |
                                --------------------
                                |                  |
                                --------------------

			// This is an efficient assignment because assigning a pointer to a pointer does not involve copying the string object. 

	    cout << "Sending the object pointed to by new pointer to cout:\n";
	    cout << *pStr << "\n\n";
	    
	    //copies a string object -- expensive assignment
	    cout << "Assigning object pointed to by pointer to a string object.\n";   // >> ASSIGNING TO A VARIABLE THE VALUE POINTED TO BY A RETURNED POINTER
	    string str = *(ptrToElement(&inventory, 2));
			// the call to ptrToElement() returns a pointer to inventory[2]. 
			// However, the preceding statement doesn't assign this pointer to str (it can't because str is a string object).
			// Instead the computer quietly makes a copy of the string object to which the pointer points and assigns that object to str.
            // quindi str is a new string object, totally independent from inventory.  
	    
        cout << "Sending the new string object to cout:\n";
	    cout << str << "\n\n";
	    
	    //altering the string object through a returned pointer
	    cout << "Altering an object through a returned pointer.\n"; // >> POINTER ALTERS OBJECT
	    *pStr = "Healing Potion";
  			// >> spiegazione linea precedente: because pStr points to the element in position 1 of "inventory", 
			// this code changes inventory[1] so that it's "Healing Potion"
 			// NOTE: if you want to protect an object pointed to by a returned pointer,
			// make sure to restrict the pointer. Return either a pointer to a constant or a constant pointer to a constant.

	    cout << "Sending the altered object to cout:\n";
	    cout << inventory[1] << endl;
	
		int x; cin >> x;
	    
	    return 0;
	}
	
	string* ptrToElement(vector<string>* const pVec, int i) // we specify in the function header that we are returning a pointer.
	{
	    //returns address of the string in position i of vector that pVec points to
	    return &((*pVec)[i]);  >> ESEGESI POINTERS: quando ti trovi davanti a una complex expression a little cryptic, EVALUATE IT LIKE THE COMPUTER DOES, that is BY STARTING WITH THE INNERMOST PART
	// nella parte piu' interna trovi scritto *pVec : questo come spiegato a pagina 216 mike programming significa deferenziare un puntatore. *nomePuntatore = the object to which the object points 
	// [ apro parentesi: da non confondersi con il type* nomePuntatore che trovi tra i parametri di input della funzione. Li si tratta di dichiarare il puntatore e si segue la struttura spiegata a pag 214 mike game programming: vector<string>* == puntatore che punta a dei vettori stringa, quindi segui il nome
	// chiudo parentesi]
	// (*pVec)[i] in questo caso il puntatore punta all'elemento di un vettore, ecco perche' rispetto a pag.216 si aggiunge la complicazione dell'[i], ma alla fine della storia si comprende che (*pVec)[i] significa elemento in position i del vettore a cui il puntatore sta puntanto. E' UN ELEMENTO, non l'indirizzo.
	// aggiungi il guscio intorno &((*pVec)[i]) applicando the address of operator (&) ot the (*pVec)[i] it becomes the address of the element in position i of the vector pointed to by pVec. OK compreso!!!!
	// NOTE perche' *pVec sia circondato dalle parentesi () mi sembra sia legato al motivo spiegato a pag218 mike programming 
	// >> (*nomePuntatore).memberFunction : whenever you dereference a pointer to access a data member function, surround the dereferenced pointer with a pair of parentheses. This ensures that the dot operator will be applied to the object to which the pointer points. 
	} 
--------------------------------------------------------------------- END FULL EXAMPLE 
OUTPUT PROGRAM
	Sending the object pointed to by returned pointer to cout:
	sword
	
	Assigning the returned pointer to another pointer.
	Sending the object pointed to by new pointer to cout:
	armor
	
	Assigning object pointed to by pointer to a string object.
	Sending the new string object to cout:
	shield
	
	Altering an object through a returned pointer.
	Sending the altered object to cout:
	Healing Potion
FINE OUTPUT PROGRAM
-------------------------------------------------
NOTE :TRAP [from pag228 mike programming game] Although returning a pointer can be an efficient way to send information back to a calling function, you have to be careful not to return a pointer that points to an out-of-scope object [>> out of scope object example error]. For example the following function returns a pointer that, if used, could crash the program
	string* badPointer()
	{
		string local = "This string will cease to exist once the function ends.";
		string* pLocal = &local; // assegni al puntatore pLocal l'address della string local, la quale sparira' una volta che funzione ripassa il controllo a main(), quindi la variabile a cui il puntatore pLocal resta indefinita, visto che local non esiste piu', potrebbe esserci dentro di tutto, possibili risultati catastrofici!
		return pLocal;
	} 
NOTE: >> POINTERS vs >> ARRAYS relationship [pag231 mike programming game]
Pointers have an intimate relationship with arrays. In fact, an array name is really a constant pointer to the first element of the array. Because the elements of an array are stored in a contiguous block of memory, you can use the array name as a pointer for random access to elements. Cioe' :
	arrayName[i] e' del tutto equivalente a *(arrayName + 1)
Here's follow a practical example of the concept: [search >> UBIK per saltare al cuore dell'esemplificazione]
>> ARRAY NAME used as a CONSTANT POINTER [pag233 mike game programming]
[/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter07/array_passer.cpp]
---------------------------------------------------
	//Array Passer
	//Demonstrates relationship between pointers and arrays
	
	#include <iostream>
	
	using namespace std;
	
	void increase(int* const array, const int NUM_ELEMENTS);
	void display(const int* const array, const int NUM_ELEMENTS);
	
	int main()
	{
	    cout << "Creating an array of high scores.\n\n";
	    const int NUM_SCORES = 3;
	    int highScores[NUM_SCORES] = {5000, 3500, 2700};
	    
	    cout << "Displaying scores using array name as a constant pointer.\n";
	    cout << *highScores << endl; // >> UBIK because an array name is a costant pointer to the first element of the array, you can deference the name to get at the first element.
		// >> RANDOM ACCESS ARRAY ELEMENTS [pag233 mike programming]. Come illustrato nel comando seguente
		// You can randomly access array elements using an array name as a pointer through simple addition. All you have to do is add the position number of the element you want to access to the pointer before you deference it. 
	    cout << *(highScores + 1) << endl;  // this line allows to access the score at position 1
		// NOTE: *(highScores + 1) e' del tutto equivalente a highScore[1]. Both return the element in position 1 of highScores (cioe' 3500).
	    cout << *(highScores + 2) << "\n\n"; // in this line we access the score at position 2 in highScores with the following line, which displays 2700. In general you can write arrayName[i] as *(arrayName + 1) where arrayName is the name of an array.
	    
		// >> ARRAY PASS / >> ARRAY RETURN [pag234 mike game programming]
		// Because an array name is a constant pointer, you can use it to efficiently pass an array to a function.  
	    cout << "Increasing scores by passing array as a constant pointer.\n\n";
	    increase(highScores, NUM_SCORES); // this line passes to increase() a constant pointer to the first element of the array and the number of elements in the array [NOTE: when you pass an array to a function, it's usually a good idea to pass also the number of elements in the array so the function can use this to avoid attempting to access an element that doesn't exist.]. As you can see below from the function header of increase(), the array name is accepted as a constant pointer.
	    
	    cout << "Displaying scores by passing array as a constant pointer to a constant.\n";
	    display(highScores, NUM_SCORES);
	   
	    return 0;
	}
	
	void increase(int* const array, const int NUM_ELEMENTS) // the array name is accepted as a constant pointer.
	{
	    for (int i = 0; i < NUM_ELEMENTS; ++i)
		{
	        array[i] += 500; // the function body adds 500 to each score.
		}
	}
	
	void display(const int* const array, const int NUM_ELEMENTS) // also the function display() accepts highScore as a pointer.
	// note that this function accepts the array as a constant pointer to a constant, in this way, we keep it safe from changes. Since all we want to do is to display each element, it's the perfect way to go.
	{
	    for (int i = 0; i < NUM_ELEMENTS; ++i)
		{
	        cout << array[i] << endl;
		}
	}
	

---------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////


>> PREPROCESSOR / >> PREPROCESSING pag986 deitel
Preprocessing occurs before a program is compiled. Some possible actions are inclusion of other files in the file begin compiled, definition of symbolic constants and macros, conditional compilation of program code and conditional execution of preprocessing directives. All prprocessing directives begin with #, and only whitespace characters may appear before a preprocessing directive on a line. Proprocessing directives are not C++ statements, so they do not end in a semicolon (;). Preprocessin directives are processed fully before compilation begins. 
The two forms of the #include directive are 
	#include <filename>  // used for standard library header files 
	#include "filename"  // used to include programmer defined header files 
The difference between these is the location the proprocessor searches for the file to be included. If the filename is enclosed in angle brackets (< >) - used for standard library header files - the preprocessor searches for the specified file in an implementation dependent manner,normally thorugh predesignated directories. If the file name is enclosed in quotes, the preprocessor searches first in the same directory as the file being compiled, then in the same implementation dependent manner as for a file name encolsed in angle brackets. This method is normally used to include programmer defined header files. 
The #include directive is used to include standard header files such as <iostream> and <iomanip>. The #include directive is also used with programs consisting of several source files that are to be compiled together. A header file containing declarations and definitions common to the separate program files is often created and included in the file. Example of such declarations and definitions are classes, structures, unions, enumerations, function prototypes, constants and stream objects.  
------------------------------------------------------------------------
>> # define Preprocessing directive / >> symbolic constants [pag987 deitel]
The #define preprocessing directive creates symbolic constants -constants represented as symbols -and macros- operations defined as symbols. The #define  preprocessing directive format is 
	#define identifier replacement-text
When this line appears in a file, all subsequent occurrences (except those inside a string) or identifier in that file will be replaced by replacement text before the program is compiled. For example :
	#define PI 3.14
replaces all sbusequent occurrences of the symbolic constant PI with the numeric constant 3.14159. Symbolic constant enable you to create a name for a constant and use the name throughout the program. Later, if the constant needs to be modified throughout the program, it can be modified once in the #define  proprocessing directive and when the program is recompiled, all cocurrences of the constant in the program will be modified. 
NOTE1, IMPORTANT!: non mettere l'uguale tra il nome della symbolic constant e il valore numerico.
	#define PI 3.14     OK
	#define PI = 3.14   DAME   <= questo introdurrebbe many subtle logic and syntax errors
in effetti everything to the right of the symbolic constant name replaces the symbolic constant. For example #define PI = 3.14159 cuases the preprocessor to replace every occurrence of PI with = 3.14159 (come vedi anche l'uguale viene incluso).
NOTE2: note that const variables in C++ are preferred over symbolic constants. Constant  variables have a specific data type and are visible by name to a debugger. Once a symbolic constant is replaced with its replacement text, only the replacement text is visible to a debugger. A disadvantage of const variables is that they might require a memory location of their data type size (symbolic constant do not require any additional memory)
-------------------------------------------------------------------------------
#define Preprocessing Directive : Macros [pag987 deitel] / >> macro
This section is included for the benefit of C++ programmers who will need to work with C legacy code. In C++ macros can often be replaced by templates and inline functions. A macro is an operation defined in a #define prprocessing directive. As with symbolic constants the macro identifier is replaced with the replacement text before the program is compiled. Macros may be defined with or withour arguments. A macro without arguments is processed like a symbolic constant. In a macro with arguments the arguments are substituted in the replacement text, then the macro is expanded.
Example 
Consider the following macro definition with one argument for the area of a circle :
	#define CIRCLE_AREA ( x ) ( PI * ( x ) * ( x ) )
(nel discorso che segue si suppone inoltre che si sia precedentemente gia' definito #define PI 3.14 ) Wherever CIRCLE_AREA ( y ) appears in the file, the value of y is substituted for x in the replacement text, the symbolic constant PI is replaced by its value (defined previously) and the macro is expanded in the program. For example the statement:
	area = CIRCLE_AREA ( 4 );
is expanded to 
	area = ( 3.14 * ( 4 ) * ( 4 ) );
because the expression consists only of constants, at compile time the value of the expression can be evaluated, and the result is assigned to area at runtime. The parentheses around each x in te replacement text and around the entire expression force the proper order of evaluation when the macro argument is an expression. For example, the statement 
	area = CIRCLE_AREA ( c + 2 );
is expanded to
	area = ( 3.14 * ( c + 2 ) ( c + 2 ) );
which evaluates correctly, because the parentheses force the proper order of evaluation. 
NOTE1: forgetting to enclose macro arguments in parenthesis in the replacement text is an error
NOTE2: If the replacement text for a macro or symbolic constant is longer than the remainder of the line, a backslash (\) must be placed at the end of each line of the macro (except the last line), indicating that the replacement text continues on the next line.
NOTE3: (>> discard symbolic constant and macro) Symbolic constants and macros can be discarded using the #undef preprocessing directive. Directive #undef "undefines" a symbolic constant or macro name. The scope of a symbolic constant or macro is from its definition until it is either undefined with #undef or the end of the file is reached. Once undefined, a name can be redefined with #define. 
----------------------------------------------------------------------------------------------------------------------
>> CONDITIONAL COMPILATION / >> COMPILE CONDITIONALLY [pag989 deitel]
Conditional compilation enables you to control the execution of preprocessing directives and the compilation of program code. Each of the conditional proprocessing directives evaluates a constant integer expression that will determine whether the code will be compiled.
The conditional prprocessor construct is much like the if selection structure. Consdier the following proprocessor code:
	#ifndef NULL
		#define NULL 0
	#endif
which determines whether the symbolic constant NULL is already defined. The expression #ifndef NULL includes the code up to #endif if NULL is not defined, and skips the code if NULL is defined. Every #if construct ends with #endif.  Directives #ifdef and #ifndef are shorthand for #if  define(name) and #if !defined(name). 
>> Directive definition Ciccio spiega:
nota come la parola ">> directive" indicante il # seguito da una parola chiave in italiano lo possiamo tradurre con diretiva, istruzione, in effetti con # si da una direttiva, tipo quando si scrive #include si dona la direttiva di includere per esempio una library (ex #include <iostream>  = direttiva di includere la standard library iostream), cosi' come #ifnodef NULL dona la direttiva di includere il codice qualora NULL non sia definito.
A multiple part conditional preprocessor construct may be tested using the #elif (the equivalent of else if in an if structure) and the #else (the equivalent of else in an if structure) directives
>> DIRECTIVE ulteriori spiegazioni in Mike pag 7 : For example the line 
	#include <iostream>
is a preprocessor directive visto che comincia con una #. The preprocessor runs before the compiler does its thing and substitutes text based on various directives. In this case, the line involves the #include directive, which tells the proprocessor to include the contents of another file. Weinclude the file iostream which is part of the standard library because it contains code to help us display output. We surround the filename with <> to tell the compiler to find the file where it keeps all the files that came with the compiler. A file that you include in your programs like this is called a header file. 
>> DEBUG TIPS 
>> TIP USEFUL TIP during program development. / >> COMMENT OUT LARGE PORTION OF CODE [pag990deitel]
During program development, programmers often find it helpful to "comment out" large portions of code to prevent it from being compiled. If the code contains C style comments, /* and */ cannot be used to accomplish this task, because the first */ encountered would terminate the comment. Instead, you can use the following preprocessor construct: 
	#if 0
		code prevented from compiling
	#endif
To enable the code to be compiled, simply replace the value 0 in the preceding construct with the value 1.
>> DEBUG TIP 2 / >> show variable value
Conditional compilation is commonly used as a debugging aid. Output statements are often used to print variable values and to confirm the flow control. These output statements can be enclosed in conditional preprocessing directives so that the statements are compiled only until the debugging process is completed. For example:
	#ifdef DEBUG
		cerr << "Variable x = " << x << endl;
	#endif
causes the cerr statement to be compiled in the program if the symbolic constant DEBUG has been defined before directive #ifdef DEBUG. This symbolic constant is normally set by a command line compiler or by settings in the IDE (e.g. visual studio) and not by an explit #define definition. When debugging is completed, the #define directive is removed from the source file, and the output statements inserted for debugging purposes are ignored from compilation. In larger programs, it might be desirable to define several different symbolic constants that control the conditional compilation in separate sections of the source file. 
--------------------------------------------------------------------------------------------------------------------------------------
>> #error and #pragma preprocessing directives [pag990 deitel]
The #error directive 
	#error tokens
prints an implementation dependent message including the tokens specified in the directive. The tokens are sequences of characters separated by spaces. For example
	#error 1 - Out of range error
contains 6 tokens. In one popular C++ compiler, for example, when a #error directive is processed, the tokens in the directive are displayed as an error message, preprocessing stops and the program does not compile. 
The #pragma directive
	#pragma tokens 
causes an implementation defined action. A pragma not recognized by the implementation is ignored. A particular C++ compiler, for example, might recognize pragmas that enable you to take advantage of that compiler's specific capabilities. 
----------------------------------------------------------------------------------------------
>> # and >> ## operators [pag991 deitel]
The # and ## preprocessor operators are avaiblable in C++ and ANSI/ISO C. The # operator causes a replacement text token to be converted to a string surrounded by quotes. Consider the following macro definition:
	#define HELLO( x ) cout << "Hello, " #x << endl;
When HELLO(John) appears in a program file, it is expanded to
	cout << "Hello, " "John" << endl;
The string "John" replaces #x in the replacement text. Strings separated by white space are concatenated during preprocessing, so the above statement is equivalent to
	cout << "Hello, John" << endl;
Note that the # operator must be used in a macro with arguments, because the operand of # refers to an argument of the macro.
The ## operator concatenates two tokens. Consider the following macro definition:
	cout << "Hello, John" << endl;
	#define TOKENCONCAT ( x, y ) x ## y
When TOKENCONCAT appears in the program, its arguments are concatenated and used to replace the macro. For example, TOKENCONCAT(O, K) is replaced by OK in the program. The ## operator must have two operands.
----------------------------------------------------------------------------------------------
>> PREDEFINED SYMBOLIC CONSTANTS [pag991]
There are six predefined symbolic constants. The identifiers for each of these begin and (except for __cpluscplus) end with two underscores. These identifiers and preprocessor operator defined cannot be used in #define or #undef directives. 
	__LINE__      the line number of the current source code line (an integer constant)
	__FILE__      the presumed name of the source file (a string)
	__DATE__      the date the source file is compiled (a strong of the form "Mmm dd yyyy" such as "Aug 19 2120")
	__STDC__      indicates whether the program conforms to the ANSI/ISO C standard. (If not it put it into JAIL). Scherzi a parte: contains value 1 if there is full conformance and is undefined otherwise.
	__TIME__      the time the source file is compiled (a string literal of teh form "hh:mm:ss").
	__cplusplus   contains the value 199711L (the date the ISO C++ standard was approved) if the file is being compiled by a C++ compiler, undefined otherwise. Allows a file to be set up to be compiled as either C or C++
------------------------------------------------------------------------------------------------
>> ASSERTIONS [pag992 deitel] / >> DEGUB TOOLS (iteresting !! )The assert macro (defined in the <cassert> header file) tests the value of an expression. If the value of the expression is 0 (false) then assert prints an error message and calls function abort (of the general utility library <cstdlib>) to terminate program execution. This is a useful debugging tool for testing whether a variable has a correct value. For example suppose variable x should never be larger than 10 in a program. An assertion may be used to test the value of x and print an error message if the value of x is incorrect. The statement would be;	
	assert (x <= 10); 
If x is greater than 10 when the preceding statement is encountered in a program, an error message containing the line number and file name is printed, an the program terminates. You may then concentrate on this area of the code to find the error. If the symbolic contanst NDEBUG is defined, subseqeunt assertions will be ignored. Thus when assertions are no longer needed (i.e. when debugging is complete) we insert the line 
	#define NDEBUG
in the program file rathe rthan deleting each assertion manually. 
Most C++ compilers now include expetion handling. C++ programmers prefer using exceptions rather than assertions. But assertions are still valuable for C++ programmers who work with C legacy code.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POINTERS BUILT-IN ARRAYS relationship
[pag355deitel]
Built-in arrays and pointers are intimately related in C++ and may be used almost interchangeably. 
Example
	int b [ 5 ]; // create 5-element int array b; b is a const pointer
	int *bPtr;   // create int pointer bPtr, which isn't a const pointer
we can set bPtr to the address of the first element in the built-in array b with statement:
	bPtr = b; // assign address of built-in array b to bPtr
Nota come l'indirizzo b del built-in array coincide con quello del primo elemento dell'array.
Quindi la precedente istruzione is equivalent to assigning the address of the first element as follows:
	bPtr = &b[ 0 ]; // also assigns address of built-in array b to bPtr
Pointer/Offset notation >> OFFSET NOTATION 
[pag356deitel]
Built-in array element b[3] can be alternatively be referenced with the pointer expression
	*( bPtr + 3 )
The 3 in the preceding expression is the offset to the pointer.
When the pointer points to the beginning of a built-in array, the offsett indicates which built-in array element should be referenced, and the offset value is identical to the subscript. Parenthesis are necessary, because the precedence of * is higher than that of +
Just as the built-in array element can be referenced with a pointer expression, the address
	&b[ 3 ]
can be written with the pointer expression
	bPtr + 3 

>> POINTER/SUBSCRIPT NOTATION 
[pag356deitel] 
Pointers can be subscripted exactly as built-in arrays can. For example, the expression
	bPtr[ 1 ]
refers to b[1]; this expression uses pointer/subscript notation
GOOD PROGRAMMING PRACTICE: for clarity, use built-in array notation instead of pointer notation when manipulating built-in arrays.


>> POINTERS EXPRESSIONS and >> POINTERS ARITHMETIC
[pag352deitel]
Pointer arithmetic is appropriate only for pointers that point to built-in array elements.
Let's assume that int v[5] has been declared and that its first element is at memory location 3000
see fig8.15 deitel o lo schemi stilizzato qui sotto
3000  3004 3008 3012 3016
  |     |    |    |    |
  v[0]  v[1] v[2] v[3] v[4]
variable vPtr can be initialized to point to v with either of the following statements:
POINTER VARIABLE INITIALIZATION:
	int *vPtr = &v[ 0 ];
	int *vPtr = v; // istruzione equivalente alla precedente visto che a built-in array's name evaluates to the address of its zeroth element)
> ADDING INTEGERS TO POINTERS
supponiamo che il nostro vPtr punta all'address 3000, indirizzo dell'elemento v[0]. v nel nostro esempio e' un built-in array di 5 int elements, ciascuno dei quali con un size di 4bytes. Allora se
	vPtr += 2;
would produce 3000 + 2 * 4 = 3008 assuming that an int is stored in a four bytes of memory.	
3000  3004 3008 3012 3016
  |     |    |    |    |
  v[0]  v[1] v[2] v[3] v[4]
quindi ora il puntatore punta all'elemento v[2]
if an integer is stored in eight bytes of memory, then the preceding calculation would result in memory location 3016 (3000 + 2 *8)
> SUBSTRUCTING INTEGERS FROM POINTERS
supponi ora che vPtr punti a v[4] (address 3016), the statement:
	vPtr -= 4;
would set vPtr = 3016 - 4 * 4 = 3000 => il puntatore puntera' at the beginning of the built-in array. If a pointer is being incremented or decremented by one, the increment (++) or decrement (--) operators can be used. Each of the statements
	++vPtr;
	vPtr++;
increments the pointer to point to the built-in array's next element. Each of the statements:
	--vPtr;
	vPtr--;
decrements the pointer to point to the built-in array's previous element.
NOTE: there is no bounds checking on pointer arithmetic. You must ensure that every pointer arithmetic operation that adds an integer to or subtracts an integer from a pointer results in a pointer that references an element within the built-in array's bounds [quindi mi vien da pensare molto importante effettuare prima un sizeof per verificare il size degli elementi perche' a seconda che siano 4 o 8 byte un vPtr++ ti porta a puntare indirizzi diversi!!]
> SUBTRACTING POINTERS
[pag354deitel]
Se per esempio riprendiamo il built-in array v di sopra. If vPtr contains the address 3000 and v2Ptr contains the address 3008, the statement
	x = v2Ptr - vPtr;
would assing to x the number of built-in array elements from vPtr to v2Ptr. 
Lo puoi anche vedere cosi' (mio ragionamento): (3008 - 3000) / 4 = 2 
dove 4 sta per il numero di bytes per elemento.
Pointer variables pointing to the same built-in array may be subtracted from one another.
COMMON PROGRAMMING ERROR: subtracting or comparing two pointers that do not refer to elements of the same built-in array is a logic error.

>> POINTER ASSIGNMENT 
[pag355]
A pointer can be assigned to another pointer if both pointers are of the SAME type. Otherwise a cast operator (normally a reinterpret_cast) must be used to convert the value of the pointer on the right of the assignment to the pointer type on the left of the assignment.
The exception to this rule is the pointer to void (i.e. void *) , which is a generic pointer capable fo representing any pointer type. 
Any pointer to a fundamental type or class type can be assigned to a pointer of type void * without casting.
HOWEVER the pointer of type void * must first be cast to the proper pointer type [sembra un po' di essere come in fonderia, come in una pressa lo devi "castare" pressare con il proper pointer type]
CANNOT DEREFERENCE A VOID * 
A void * pointer cannot be dereferenced. For example the compiler knows that a pointer to int refers to four bytes of memory on a machine with four-byte integers, but a pointer to void simply contains a memory address for an unknown data type - the compiler does not know the precise number of bytes to which the pointer refers and the data type. The compiler must know the data type to determine the number of bytes to dereference for a particular pointer - for a pointer to void, this number of bytes cannot be determined.
COMMON PROGRAMMING ERROR: assigning a ointer of one type to a pointer of another (other than void *) without using a cast (normally a reinterpret_cast) is a compilation error.
ALLOWED OPERATION ON VOID * POINTERS ARE:
- comparing void * pointers with other pointers
- casting void * pointers to other pointer types 
- assigning addresses to void * pointers.
All other operations on void * pointers are compilations errors 
COMPARING POINTERS
Pointers can be compared using equality and relational operators.
Comparisons using relational operators are meaningless unless the pointers point to elements of the same built-in array. Pointer comparisons compare the addresses stored in the pointers. 
A common use of pointer comparison is determining whether a pointer has the value of nullptr, 0 or NULL (i.e. the pointer does not point to anything).

>> INDIRECTION = referencing a value through a point.
Extract from the 8.1 introduction
in chapter 6 we say that references can be used to perform pass-by-reference. Pointers also enable pass-by-reference and can be used to create and manipulate dynamic data structures that can grow and shrink, such as linked lists, queues, stacks and trees.
We also show the intimate relationship among built-in arrays and pointers. C++ inherited built-in arrays from the C programming language. Anyway in new software development projects, you should favor array and vector objects to built-in arrays. 
Similarly, C++ actually offers two types of strings :
- string class object (quella che si usa sin dal primo hello program)
- C-style, pointer-based strings
In new software developments projects, you should favor string class objects. 
NOTE: the so called "polymorphic processing" associated with object-oriented programming is performed with pointers and references. 
NOTE2: null pointers prior to C++11
In earlier versions of C++ the value specified for a null pointer was 0 or NULL. NULL is defined in several standard library headers to represent the value 0. Initializing a pointer to NULL is equivalent to inizializing a pointer to 0, but prior to C++11, 0 was used by convention. The value 0 is the only integer value that can be assigned directly to a pointer variable without first casting the integer to a pointer type.

>> POLYMORPHISM
[pag518deitel]
Suppose that we design a video game that manipulates objects of many different types, including objecdts of classes Martian, Venutian, Plutonian, Spaceship, and LaserBeam. Imagine that each f these classes inherits form the common base class SpaceObject [sembra essere un analogo del IOOjbect che incontriamo nel sorgente di OF] which contains the member function draw. Each derived class implments this function in a manner appropriate for this class. A screen-manager program maintains a container  (e.g. a vector) that holds "SpaceObject" pointers to objects of the various classes. To refresh the screen, the screen manager periodically sends each object the same message (in this case "draw"). Each type of object respond in a unique way. For example, a Martian object might draw ifself in red with the appropriate number of antennae, a SpaceShip obejct might draw itself as a silver flying saucer (disco volante), and a "LaserBeam" object might draw itself as a bright red beam across the screen.
The same message (in this case "draw")  sent to a variety of objects has many forms of results, hence the term polymorphism.
A polymorphic screen manager falicilitates adding new clases to a sysmtem with minimal modifications to its code. Suppose that we want to add objects of class Mercurian to our video game. To do so, we must build a class Mercurian that inhertis from SpaceObject, but provides its own definition of member function "draw". Then, when pointers to objects of class Mercurian appear in the container, you do not need to modify the code for the screen manager. The screen manager invokes member function draw on every object in the container, regardless of the object's type, so the new Mercurian objects simply "plug right in". Thus without modifiying the system (other than to build and include the classes themselves) you can use polymorphism to accommodate additional classes , including ones that were not even envisioned when the system was created >> that's why we can say that >> POLYMORPHISM PROMOTES EXTENSIBILTIY
- FROM pag520 
> we can assign the address of a derived class object to a base-class pointer, then show that invoking a function via the base-class pointer invokes the base-class functionality in the derived-class object [explained in section 12.3.1]
> on the contrary, if we assign the address of a base-class object to a derived-class pointer it will result in a compilation error [explained in section 12.3.2].
> in section 12.3.3 we assign the address of derived-class object to a base-class pointer, then examin how the base-class pointer can be used to invoke only the base-class functionality (when we attempt to invoke derived-class member functions through the base-class pointer, compilation error occur.)
> finally in section 12.3.4 we demonstrate how to get polymorphic behaviour from base-class pointers aimed at derived-class object. We introduce  virtual functions and polymorphism by declaring a base-class function as virtual. We then assign the address of a derived-class object to the base-class pointer and use that pointer to invoke derived-class functionality (precisely the capability we need to achieve polymorphic behaviour)
A KEY CONCEPT in these examples is to demonstrate that with puclic inheritance an object of a derived class can be treated as an object of its base class. 
NOTE from pag 535
DRIVERS and POLYMORPHISM / >> POLYMORPHISM and DRIVERS
[pag535deitel]
Polymorphism is particularly effective for implmentin layered software systems. In operating systems, for example, each type of physical device could operate quite differently from the others. Even so, commands to read or write data from and to devices may have  a certain uniformity. The write message sent to a device-driver object needs to be interpreted specifically in the context of that device driver and how that device driver manipulates devices of a specific type. However the write call itself really is no different from the write to any other device in the system (= place some number of bytes from memory onto that device). An object-oriented operating system could use an abstract base class to provide an interface appropriate for all device drivers.Then through inheritance from that abstract base class, derived classes are formed that all operate similarly. The capabilities (i.e. public functions) offered by the device driveres are provided as pure virtual functions in the astract base class. The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of device drivers. This architecture also allows new devices to be added to a system easily. The user can just plug in he device and install its new device driver. The operating system "talks" to this new device through its device driver, which has the same public member functions as all other device drivers (= those defined in the device driver abstract base class).
>> OVERHEAD OF POLYMORPHISM pag550 in terms of additional memory consumption and processor time.
[pag550deitel]
Il polymorphism non e' la migliore soluzione in tutte le situazioni. For example C++ standard library classes  like array or vector are implemented without polymorphism and "virtual" function to avoid the associated execution-time overhead and achieve optimal performance.
In section 12.7 is explain the data structures that the compiler builds at compile time to support polymorphism at execution time. You'll see that polymorphism is accomplished through three levels of pointers, i.e. >> triple indirection. 
When C++ compiles a class that has one or more virtual functions, it builds a virtual function table (>> vtable) for that class. The vtable contains pointers to the class's virtual functions. 
Just as the name of a built-in array contains the address in memory of the array's first element, a pointer to a function contains the stating address in memory of the code that perform the function's task. An executing program uses the vtable  to select the proper function implementation each time a virtual function fo the class is called.
- any class that has one or more null pointers in its vtable is an abstract class. 
- classes without anyu null vtable pointers are concrete class.
>> POLYMORPHISM PERFORMANCE [pag553]
- polymorphism as typically implemented with virtual functions and dynamic binding in C++ is efficient. You can use these capabilities  with nominal impact on performance. 
- virtual functions and dynamic binding enable polymorphic programming as an alternative to switch logic programming. Optimizing compilers normally generate polymorphic code that's nearly as efficient as hand-coded switch-based logic. Polymorphism's oeverhead is acceptable for most applications. In some situations (such as real-time applications) with stringent performance requirements - polymorphism's overhead may be too high.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> POLYMORPHISM [pag449 jesse book]
On Day 12 "Implementing Inheritance" you learned how to write virtual functions in derived classes. This is the fundamental building block of polymorphism: the capability to bind specific, derived class objects to base class pointers at runtime. 
In this lesson we will learn:
	- what multiple inheritance is and how to use it 
	- what virtual inheritance use and how to use it
	- what abstract classes are and when to use them
	- what pure virtual function are. 
>> SINGLE INHERITANCE PROBLEMS [pag450 jesse book]
Suppose you've been working with your animal classes for a while, and you've divided the class hierarchy into Birds and Mammals. The Bird class includes the member function Fly(). The Mammal class has been divided into a number of types of Mammals, including Horse. The Horse class includes the member function Whinny() [= nitrire] and Gallop()
Suddenly you realize you need a Pegasus object: a cross between a Horse and a Bird. A Pegasus can Fly(), it can Whinny() and it can Gallop(). With single inheritance, you're in quite a jam. 
With single inheritance, you can only pull from one of these existing classes. You can make Pegasus a Bird, but then it won't be able to Whinny() or Gallop(). You can make it a Horse, but then it won' be able to Fly().
Your first solution is to copy the Fly() method into the Pegasus class and derive Pegasus from Horse. This works fine, at the cost of having the Fly() method in two places (Bird and Pegasus). If you change one, you must remember to change the other. Of course, a developer who comes along months or years later to maintain your code must also know to fix both places. 
Soon, however, you have a new problem. You want to create a list of Horse objects and a list of Bird objects. You'd like to be able to add your Pegasus objects to either list, but if a Pegasus is a Horse, you can't add it to a list of Birds. 
You have a couple of potential solutions. You can rename the Horse method Gallop() to Move(), and then override Move() in you Pegasus object ot do the work of Fly(). You would then override Move() in your other horses to do the work of Gallop(). Perhaps Pegasus could be clever enough ot gallop short distances and fly longer distances. 

	Pegasus::Move(long distance)
	{
		if (distance > veryFar)
			fly(distance);
		else
			gallop(distance);
		end
	}

This is a bit limiting. Perhaps one day Pegasus will want to fly a short distance or gallop a long distance. Your next solution might be to move Fly() up into Horse, as illusted in the following Listing 14.1. The problem is that most horses can't fly, so you have to make this method do nothing unless it is a Pegasus. 
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.1 START If Horses could Fly...
 // Listing 14.1. If horses could fly...
// Percolating Fly() up into Horse

#include <iostream>
using namespace std;

class Horse
{
  public:
     void Gallop(){ cout << "Galloping...\n"; }
     virtual void Fly() { cout << "Horses can't fly.\n" ; }  // providing the method Fly() to Horse.
  private:
     int itsAge;
};

class Pegasus : public Horse
{
  public:
     virtual void Fly() 
          {cout<<"I can fly! I can fly! I can fly!\n";}  // overriding the Fly() method since a Pegasus can fly. 
};

const int NumberHorses = 5;
int main()
{
   Horse* Ranch[NumberHorses];
   Horse* pHorse;
   int choice,i;
   for (i=0; i<NumberHorses; i++)
   {
      cout << "(1)Horse (2)Pegasus: ";
      cin >> choice;    // choose between a Horse or a Pegasus
      if (choice == 2)
         pHorse = new Pegasus;
      else
         pHorse = new Horse;
      Ranch[i] = pHorse;
   }
   cout << endl;
   for (i=0; i<NumberHorses; i++)
   {
      Ranch[i]->Fly();    // depending on whether the object is a Horse or a Pegasus, the correct Fly() method is called. 
      delete Ranch[i];
   }
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.1 END If Horses could Fly...
This program certainly works although at the expense of the Horse class having a Fly() method. 
NOTE: these examples have been stripped down to their bare essentials (to their bare asses - pulp fiction) to illustrate the points under consideration. Constructors, virtual destructors and so on have been removed to keep the code simple. This is not recommended for your programs. 
-------------------------------------------------------------------------------------------------------
>> PERCOLATING UPWARD [pag 452 jesse]Putting the required function higher in the class hierarchy is a common solution to this problem and results in many functions "percolating up" into the base class. The base class is then in grave danger of becoming a global namespace for all the functions that might be used by any of the derived classes. This can seriously undermine the class typing of C++, and can create a large and cumbersome base class. 
In general, you wnat to percolate shared functionality up the hierarchy, without migrating the interface of each class. This means that if two classes that share a common base class (for example Horse and Bird both share Animal) and have a function in common (both birds and horses eat, for example), you'll want to move that functionality up into the base class and create a virtual function. 
What you'll want to avoid, however, is percolating a function (such as Fly) up where it doesn't belong just so you can call that function only on some derived classes, when it doesn't fit the meaning of that base class.
- Additional observation from pag 487 Is percolating  upward always a good thing? 
Yes if you are percolating shared functionality upward. No, if all you are moving is interface. That is, if all the derived classes can't use the method, it is a mistake to move it up into a common base class. If you do, you'll have to switch on the runtime type of the object before deciding if you can invoke the function.  
>> CASTING DOWN [pag453 jesse] 
An alternative to this approach, still within single inheritance, is to keep the Fly() method withing Pegasus and only call it if the pointer is actually pointing to a Pegasus object. To make this work, you need to be able to ask your pointer what type it is really pointing to. This is known as >> RUN TIME TYPE IDENTIFICATION (>> RTTI)
Because RTTI is a newer feature of the C++ specification, not all compilers support it. If your compiler does not support RTTI, you can mimic it by putting a method that returns an enumerated type in each of the classes. You can then test that type at runtime and call Fly() if it returns Pegasus
CAUTION : Beware of using RTTI in your programs. Needing to use it might be an indication of poor inheritance hierarchy design. Consider using virtual functions, templates, or multiple inheritance instead. 
In the previous listing 14.1 example, you declared both Horse and Pegasus objecdts and placed them in an array of Horse objects. Everything was placed as a Horse. With RTTI, you would check each of these Horses to see if it was just a horse or if indeed a Pegasus had actually been created. 
To call Fly() however, you must cast the pointer, telling it that the object it is pointing  to is a Pegasus object, not a Horse. This is called >> casting down [>> cast down] because you are casting  the Horse object down to a more derived type. 
C++ officially, though perhaps reluctantly, supports casting down using the new (@2004) >> dynamic_cast operator. Here's how it works. If you have a pointer to a base class such as Horse, and you assign to it a pointer to a derived class, such as Pegasus, you can use the Horse pointer polymorphically. If you then need to get at the Pegasus object, you create a Pegasus pointer and use the dynamic_cast operator to make the conversion. 
At runtime, the base pointer is examined. If the conversion is proper, your new Pegasus pointer is fine. If the conversion is improper, if you didn't really have a Pegasus object after all, then your new pointer is null. The following listing 14.2 illustrates this point: 
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.2 START Casting down
// Listing 14.2 Using dynamic_cast.
// Using rtti

#include <iostream>
using namespace std;

enum TYPE { HORSE, PEGASUS };

class Horse
{
  public:
    virtual void Gallop(){ cout << "Galloping...\n"; }     // now the Fly() method can be kept out of Horse, and it is not called on Horse object. 

  private:
    int itsAge;
};

class Pegasus : public Horse
{
  public:
    virtual void Fly()
        {cout<<"I can fly! I can fly! I can fly!\n";}
};

const int NumberHorses = 5;
int main()
{
   Horse* Ranch[NumberHorses];
   Horse* pHorse;
   int choice,i;
   for (i=0; i<NumberHorses; i++)
   {
      cout << "(1)Horse (2)Pegasus: ";
      cin >> choice;
      if (choice == 2)
         pHorse = new Pegasus;
      else
         pHorse = new Horse;
      Ranch[i] = pHorse;
   }
   cout << endl;
   for (i=0; i<NumberHorses; i++)
   {
      Pegasus *pPeg = dynamic_cast< Pegasus *> (Ranch[i]);
      if (pPeg != NULL)
         pPeg->Fly();       // when Fly() is called on Pegasus objects, however the object must be explicitly cast (come fatto nella riga "Pegasus *pPeg = dynamic_cast< Pegasus *> (Ranch[i]);" giusto sopra). Since Horse objects don't have the methodFly(), so the pointer must be told it is pointing to a Pegasus object before being used. 
      else
         cout << "Just a horse\n";

      delete Ranch[i];
   }
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.2 END Casting down END
 This solution also works, however it is not recommended. The need for you to cast the pegasus object it is a warning that something might be wrong with your design. This program effectively undermines the virtual function polymorphism because it depends on casting the object to its real runtime type.
- Additional thoughts about >> casting from pag 487 jesse
Why is casting bad? Casting isn't bad if it is done in a way that is tyep-safe. Casting can, however, be used to undermine the strong type checking in C++, and that is what you want to avoid. If you are swicthing on the runtime type of the objectandthen casting a pointer, that might be a warning sign that soemthing is wrong with your design. In addition,  function should work with the declared type of their arguments and member variables, and not depend on "knowing"  what the calling program will provide through some sort of implicit contract. If the assumption turns out to be wrong, strange and unpredictable problems can results.  
--------------------------------------------------------------------------------------------------------------------------
>> ADDING TO TWO LISTS [pag456 jesse]
The other problem with these solutions is that you've declared Pegasus to be a type of Horse, so you cannot add  a Pegasus object to a list of Birds. You've paid the price of either moving Fly() up into Horse or casting down the pointer, and yet you still don't have the full functionality you need. 
One final, single inheritance solution presents itself. You can push Fly(), Whinny() and Gallop() all up into a common base class of both Bird and Horse: Animal. Now, instead of having a list of Birds and a list of Horses, you can have one unified list of Animals. This works, but eventually leads to a base class that has all of the characteristics of all of its descendant classes. So who needs descendant classes then?
Alternatively, you can leave the methods where they are and cast down Horses and Birds and Pegasus objects, but that is even worse!
DO move functionality up the inheritance hierarchy when it is conceptually cohesive with the meaning of the ancestor class. 
DO avoid performing actions based on the runtime type of the object (use virtual methods, templates, and multiple inheritance)
DON'T clutter ancestor classes with capabilities that are only added to support a need for polymorphism in descedant classes.  
------------------------------------------------------------------------------------------------------------------------------------------------------
>> MULTIPLE INHERITANCE [pag456 jesse]
It is possible to derive a new class from more than one base class. This is called multiple inheritance. To derive from more than the base class, you separate each base class by commas in the class designation, as shown here: 
	class DerivedClass : public BaseClass1, public BaseClass2 { }
This is exactly like declaring single inheritance with an additional base class, BaseClass2 added. 
The following listing 14.3 illustrates how to declare Pegasus so that it derives from both Horses and Birds. The program then adds Pegasus objects to both types of lists. 
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.3 START
// Listing 14.3. Multiple inheritance.

#include <iostream>
using std::cout;
using std::cin;
using std::endl;

class Horse   // declaration of the Horse class
{
  public:
    Horse() { cout << "Horse constructor... "; }    // il constructor 
    virtual ~Horse() { cout << "Horse destructor... "; }  // il destructor 
    virtual void Whinny() const { cout << "Whinny!... "; }   // e il method "Whinny" print the message "Whinny!" to the screen. 
  private:
    int itsAge;
};

class Bird   // declaration of the Bird class
{
  public:
    Bird() { cout << "Bird constructor... "; }   // il constructor 
    virtual ~Bird() { cout << "Bird destructor... "; } // il destructor 
	// quindi seguono i due methods della Bird class, il method "Chirp" e il method "Fly" 
	// in a real program, these methods might, for example, activate the speaker or generate animated images. 
    virtual void Chirp() const { cout << "Chirp... ";  }  
    virtual void Fly() const
    {
       cout << "I can fly! I can fly! I can fly! ";
    }
  private:
    int itsWeight;
};

class Pegasus : public Horse, public Bird   // declaration of the Pegasus class using multiple inheritance. You can see that this class is derived from both Horse and Bird. 
{
  public:
    void Chirp() const { Whinny(); }   // overriding the Chirp method. This Pegasus Chirp method simply does a call to the Whinny() method, which it inherits from Horse.
    Pegasus() { cout << "Pegasus constructor... "; }
    ~Pegasus() { cout << "Pegasus destructor...  "; }
};

const int MagicNumber = 2;
int main()
{
   Horse* Ranch[MagicNumber];  // creazione della list Ranch with pointers to Horse objects
   Bird* Aviary[MagicNumber]; // creazione della list Aviary with pointers to Birds objects
   Horse * pHorse;
   Bird * pBird;
   int choice,i;
   for (i=0; i<MagicNumber; i++)
   {
      cout << "\n(1)Horse (2)Pegasus: ";
      cin >> choice;
      if (choice == 2)
         pHorse = new Pegasus;
      else
         pHorse = new Horse;
      Ranch[i] = pHorse;
   }
   for (i=0; i<MagicNumber; i++)
   {
      cout << "\n(1)Bird (2)Pegasus: ";
      cin >> choice;
      if (choice == 2)
         pBird = new Pegasus;
      else
         pBird = new Bird;
      Aviary[i] = pBird;
   }

   cout << endl;
   for (i=0; i<MagicNumber; i++)
   {
      cout << "\nRanch[" << i << "]: " ;
      Ranch[i]->Whinny();
      delete Ranch[i];
   }

   for (i=0; i<MagicNumber; i++)
   {
      cout << "\nAviary[" << i << "]: " ;
      Aviary[i]->Chirp();
      Aviary[i]->Fly();
      delete Aviary[i];
   }
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.3 END
>> PARTS of a MULTIPLY INHERITED OBJECT / >> MULTIPLE INHERITED OBJECTS PARTS [pag460 jesse]
When the Pegasus object is created in memory, both the base classes form part of the Pegasus object, as illustrated in the following picture: 

										 /---------------------\
                                         |         Horse          |
                                         -----------------------
                                          |          Bird           |
                                         -----------------------
                                         |         Pegasus      |
                                         \---------------------/

This figure represents an entire Pegasus object. This includes the new features added in the Pegasus class and the features picked up from the base classes. 
Several issues arise with objects with multiple base classes. For example, what happens if two base classes that happen to have the same name have virtual functions or data? How are multiple base class constructors initialized? What happens if multiple base classes both derive from the same class? The next sections answer these questions and explore how multiple inheritance can be put to work. 
-----------------------------------------------------------------------------------------------------------------------------------------
>> CONSTRUCTORS IN MULTIPLY INHERITED OBJECTS / >> MULTIPLY INHERITED OBJECTS CONSTRUCTORS [pag460 jesse]
If Pegasus derives from both Horse an Bird, and each of the base classes has constructors that take parameters, the Pegasus class initializes these constructors in turn. The following 14.4 listing illustrates how this is done.
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.4 START
// Listing 14.4
// Calling multiple constructors

#include <iostream>
using namespace std;

typedef int HANDS;
enum COLOR { Red, Green, Blue, Yellow, White, Black, Brown } ;  // COLOR declaration

class Horse     // declaration of the class Horse. 
{
  public:
    Horse(COLOR color, HANDS height);   // Horse's constructor : it takes two parameters in input, color and height
    virtual ~Horse() { cout << "Horse destructor..." << endl; }
    virtual void Whinny()const { cout << "Whinny!... "; }
    virtual HANDS GetHeight() const { return itsHeight; }
    virtual COLOR GetColor() const { return itsColor; }
  private:
    HANDS itsHeight;
    COLOR itsColor;
};

Horse::Horse(COLOR color, HANDS height):
itsColor(color),itsHeight(height)
{
   cout << "Horse constructor..." << endl;
}

class Bird  // Bird class declaration 
{
  public:
    Bird(COLOR color, bool migrates);
    virtual ~Bird() {cout << "Bird destructor..." << endl;  }
    virtual void Chirp()const { cout << "Chirp... ";  }
    virtual void Fly()const
    {
      cout << "I can fly! I can fly! I can fly! ";
    }
    virtual COLOR GetColor()const { return itsColor; }
    virtual bool GetMigration() const { return itsMigration; }

  private:
    COLOR itsColor;
    bool itsMigration;
};

Bird::Bird(COLOR color, bool migrates):       // implementation of the Bird constructor
itsColor(color), itsMigration(migrates)
{
   cout << "Bird constructor..." << endl;
}

class Pegasus : public Horse, public Bird   // Pegasus class declaration
{
  public:
    void Chirp()const { Whinny(); }
    Pegasus(COLOR, HANDS, bool,long); // Pegasus constructor 
    ~Pegasus() {cout << "Pegasus destructor..." << endl;}   // Pegasus destructor 
    virtual long GetNumberBelievers() const
    {
      return  itsNumberBelievers;
    }

  private:
    long itsNumberBelievers;
};

Pegasus::Pegasus(              // implementation of Pegasus's constructor
   COLOR aColor,
   HANDS height,
   bool migrates,
   long NumBelieve):
   Horse(aColor, height),      // Horse constructor is initialized with color and height
   Bird(aColor, migrates),     // Bird constructor is initialized with colour and the Boolean indicating if it migrates.
   itsNumberBelievers(NumBelieve)
{
   cout << "Pegasus constructor..." << endl;
}

int main()
{
   Pegasus *pPeg = new Pegasus(Red, 5, true, 10);  // Pegasus pointer is created 
   pPeg->Fly();
   pPeg->Whinny();
   cout << "\nYour Pegasus is " << pPeg->GetHeight();
   cout << " hands tall and ";
   if (pPeg->GetMigration())
      cout << "it does migrate.";
   else
      cout << "it does not migrate.";
   cout << "\nA total of " << pPeg->GetNumberBelievers();
   cout << " people believe it exists." << endl;
   delete pPeg;
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------------- LISTING 14.4 END
OUTPUT : 
[1008 Day14] >> g++ List1404.cpp -o List1404.exe
[1009 Day14] >> ./List1404.exe 
Horse constructor...
Bird constructor...
Pegasus constructor...
I can fly! I can fly! I can fly! Whinny!... 
Your Pegasus is 5 hands tall and it does migrate.
A total of 10 people believe it exists.
Pegasus destructor...
Bird destructor...
Horse destructor...
------------------------------------------------------------------------------------
>> AMBIGUITY RESOLUTION / >> Member is ambigous error message resolution / >> ambiguous message error
In the above 14.4 listing, both the Horse class and the Bird class have a method GetColor(). 
You' ll notice that these methods were not called in Listing 14.4. You might need to ask the Pegasus object to return its color, but you have a problem: the Pegasus class inherits from both Bird and Horse. They both have a color, and their methods for getting that color have the same names and signatures. This creates an ambiguity for the compiler, which we must resolve:
If you simply write 
	COLOR currentColor = pPeg->GetColor();  
you receive a compiler error 
	Member is ambiguous:  'Horse::GetColor' and 'Bird::GetColor'
You can resolve this ambiguity with an explicit call to the function you want to invoke: 
	COLOR currentColor = pPeg -> Horse::GetColor();
Any time you need to resolve which class a member function or member data inherits from, you can fully qualify the call by prepending the class name to the base class data or function
(Come scritto qui di seguito, c'e' anche un altra opzione: overriding the function within Pegasus)
Note that if Pegasus were to override this function, the problem would be moved, as it should be , into the Pegasus member function:
	virtual COLOR GetColor()const { return Horse::GetColor(); }
This hides the problem from clients of the Pegasus class and encapsulates within Pegasus the knowledge of which base class from which it wants to inherit its color. A client is still free to force the issue by writing 
	COLOR currentColor = pPeg ->Bird::GetColor();
-----------------------------------------------------------------------------------------------------------------
>> SHARED BASE CLASS INHERITANCE / >> inheriting from shared base class [pag464 jesse]
What happens if both Bird and Horse intherit from a common base class, such as Animal? 
Suppose for example to have 

      Animal               Animal
          |                        |
      Horse                 Bird
          \                       /
            \                   /
                Pegasus

As you can see nello schemino sopra, two base class object exist. When a function or data member is called in the shared base class, another ambiguity exist. For example, if Animal declares itsAge as a member variable and GetAge() as a member function, and you call pPeg ->GetAge(), did you mean to call the getAge() function you inherit from Animal by way of Horse, or by way of Bird? You must resolve  this ambiguity as well, as illustrated in the following 14.5 listing : 
----------------------------------------------------------------------------------------------------------------------------- LISTING 14.5 START
	// Listing 14.5
	// Common base classes

	#include <iostream>
	using namespace std;

	typedef int HANDS;
	enum COLOR { Red, Green, Blue, Yellow, White, Black, Brown } ;

	class Animal        // declaration of the class Animal : it is the common base to both horse and bird
	{
	  public:
		Animal(int);   // mi sembra questo sia il constructor 
		virtual ~Animal() { cout << "Animal destructor...\n"; }  // e questo il destructor
		virtual int GetAge() const { return itsAge; }   // accessor GetAge
		virtual void SetAge(int age) { itsAge = age; }   // accessor SetAge
	  private:
		int itsAge;    // this class just have one member variable "itsAge"
	};

	Animal::Animal(int age):
	itsAge(age)
	{
	   cout << "Animal constructor...\n";
	}

	class Horse : public Animal      // Horse class declaration derived from the Animal base class
	{
	  public:
		Horse(COLOR color, HANDS height, int age);   // Horse constructor  
		virtual ~Horse() { cout << "Horse destructor...\n"; }   // Horse destructor 
		virtual void Whinny()const { cout << "Whinny!... "; }
		virtual HANDS GetHeight() const { return itsHeight; }
		virtual COLOR GetColor() const { return itsColor; }
	  protected:
		HANDS itsHeight;
		COLOR itsColor;
	};

	Horse::Horse(COLOR color, HANDS height, int age):
	Animal(age),   
	itsColor(color),itsHeight(height)
	{
	   cout << "Horse constructor...\n";
	}

	class Bird : public Animal  // declaring the Bird class to derive from Animal
	{
	  public:
		Bird(COLOR color, bool migrates, int age);
		virtual ~Bird() {cout << "Bird destructor...\n";  }
		virtual void Chirp()const { cout << "Chirp... ";  }
		virtual void Fly()const
		        { cout << "I can fly! I can fly! I can fly! "; }
		virtual COLOR GetColor()const { return itsColor; }
		virtual bool GetMigration() const { return itsMigration; }
	  protected:
		COLOR itsColor;
		bool itsMigration;
	};

	Bird::Bird(COLOR color, bool migrates, int age):
	Animal(age),
	itsColor(color), itsMigration(migrates)
	{
	   cout << "Bird constructor...\n";
	}

	class Pegasus : public Horse, public Bird   // Pegasus inherits both from Bird and Horse.
	{
	  public:
		void Chirp()const { Whinny(); }
		Pegasus(COLOR, HANDS, bool, long, int);
		virtual ~Pegasus() {cout << "Pegasus destructor...\n";}
		virtual long GetNumberBelievers() const
		{ return  itsNumberBelievers; }
		virtual COLOR GetColor()const { return Horse::itsColor; }
		virtual int GetAge() const { return Horse::GetAge(); }   // chaining up in order to disambiguate, or fully qualify the method we want. In questo modo e' chiaro che vogliamo il GetAge method from the Horse class. 
	  private:
		long itsNumberBelievers;
	};

	Pegasus::Pegasus(               // Pegasus constructor begins, this constructor takes 5 parameters
	   COLOR aColor,
	   HANDS height,
	   bool migrates,
	   long NumBelieve,
	   int age):
	   Horse(aColor, height,age),
	   Bird(aColor, migrates,age),
	   itsNumberBelievers(NumBelieve)
	{
	   cout << "Pegasus constructor...\n";
	}

	int main()
	{
	   Pegasus *pPeg = new Pegasus(Red, 5, true, 10, 2);
	   int age = pPeg->GetAge();
	   cout << "This pegasus is " << age << " years old.\n";
	   delete pPeg;
	   return 0;
	}

----------------------------------------------------------------------------------------------------------------------------- LISTING 14.5 END

>> VIRTUAL INHERITANCE [pag468 jesse book]
In the previous listing, the Pegasus class went to some extend to disambiguate which of its Animal base classes it meant to invoke. Most of the time, the decision as to which one to use is arbitrary, after all the Horse and the Bird have the same base class. 
It is possible to tell C++ that you do not want two copies of the shared base class, but rather to have a single shared base class, as  show in the sketch below:

				    	Animal 
                     /             \
                Horse        Bird
                    \              /
                      Pegasu

You accomplish this by making Animal a virtual base class of both Horse and Bird. The Animal class does not change at all. The Horse and Bird classes change only in their use of the term "virtual" in their declarations. Pegasus, however, changes substantially. 
Normally, a class's constructor initializes only its own variables and its base class. Virtually inherited base classes are an expection, however. They are initialized by their most derived class. Thus, Animal is initialized not by Horse and Bird, but by Pegasus. Horse and Bird have to initialize Animal in their constructors, but these initializations will be ignored when a Pegasus object is created.   ----------------------------------------------------------------------------------------------------------------------------- LISTING 14.6 START
// Listing 14.6
// Virtual inheritance
#include <iostream>
using namespace std;

typedef int HANDS;
enum COLOR { Red, Green, Blue, Yellow, White, Black, Brown } ;

class Animal        // common base to both horse and bird
{
  public:
    Animal(int);
    virtual ~Animal() { cout << "Animal destructor...\n"; }
    virtual int GetAge() const { return itsAge; }
    virtual void SetAge(int age) { itsAge = age; }
  private:
    int itsAge;
};

Animal::Animal(int age):
itsAge(age)
{
   cout << "Animal constructor...\n";
}

class Horse : virtual public Animal  // Horse declares that it inherits virtually from Animal
{
  public:
    Horse(COLOR color, HANDS height, int age);
    virtual ~Horse() { cout << "Horse destructor...\n"; }
    virtual void Whinny()const { cout << "Whinny!... "; }
    virtual HANDS GetHeight() const { return itsHeight; }
    virtual COLOR GetColor() const { return itsColor; }
  protected:
    HANDS itsHeight;
    COLOR itsColor;
};

Horse::Horse(COLOR color, HANDS height, int age):
Animal(age),
itsColor(color),itsHeight(height)
{
   cout << "Horse constructor...\n";
}

class Bird : virtual public Animal  // Bird declares that it inherits virtually from Animal
{
  public:
    Bird(COLOR color, bool migrates, int age);
    virtual ~Bird() {cout << "Bird destructor...\n";  }
    virtual void Chirp()const { cout << "Chirp... ";  }
    virtual void Fly()const
            { cout << "I can fly! I can fly! I can fly! "; }
    virtual COLOR GetColor()const { return itsColor; }
    virtual bool GetMigration() const { return itsMigration; }
  protected:
    COLOR itsColor;
    bool itsMigration;
};

Bird::Bird(COLOR color, bool migrates, int age):
Animal(age),
itsColor(color), itsMigration(migrates)
{
   cout << "Bird constructor...\n";
}

class Pegasus : public Horse, public Bird   // Pegasus inherits from both Bird and Horse and as the most derived object of Animal, it also initializes Animal. 
{
  public:
    void Chirp()const { Whinny(); }
    Pegasus(COLOR, HANDS, bool, long, int);
    virtual ~Pegasus() {cout << "Pegasus destructor...\n";}
    virtual long GetNumberBelievers() const
         { return  itsNumberBelievers; }
    virtual COLOR GetColor()const { return Horse::itsColor; }
  private:
    long itsNumberBelievers;
};

Pegasus::Pegasus(
   COLOR aColor,
   HANDS height,
   bool migrates,
   long NumBelieve,
   int age):
   Horse(aColor, height,age),
   Bird(aColor, migrates,age),
   Animal(age*2),
   itsNumberBelievers(NumBelieve)
{
   cout << "Pegasus constructor...\n";
}

int main()
{
   Pegasus *pPeg = new Pegasus(Red, 5, true, 10, 2);
   int age = pPeg->GetAge();
   cout << "This pegasus is " << age << " years old.\n";
   delete pPeg;
   return 0;
}

----------------------------------------------------------------------------------------------------------------------------- LISTING 14.6 END
SUMMARY >> VIRTUAL INHERITANCE [pag472 jesse]
Riassumendo :  to ensure that derived classes have only one instance of common base classes, declare the intermediate classes to inherit virtually from the base class. 
Example :
	class Horse : virtual public Animal
	class Bird : virtual public Animal
	class Pegasus : public horse, public bird

>> VIRTUAL INHERITANCE PROBLEMS [pag 472 jesse]
Although multiple inheritance offers several advantages over single inheritance, many C++ programmers are reluctant to use it. The problems they cite are that it makes debugging harder, that evolving multiple inheritance class hierarchies is harder and more risky than evolving single inheritance class hierarchies, and that nearly everything that can be done with multiple inheritance can be done without it. Other languages, such as Java and C#, don't support multiple inheritance of classes for some of the same reasons. 
These are valid concerns, and you will want to be on your guard against installing needless complexity into your programs. Some debuggers have hard time with multiple inheritance, and some designers are needlessly made complex by using multiple inheritance when it is not needed.
DO: 
	- DO use multiple inheritance when a new class needs functions and features from more than one base class. 
	- DO use virtual inheritance when the most derived classes must have only one instance of the shared base class. 
	- DO initialize the shared base class from hte most derived class when using virtual base classes. 
DON'T 
	- DON'T use multiple inheritance when single inheritance will do.
	 
>> MIXINS / >> CAPABILITY CLASS [pag473 jesse]
One way to strike a middle ground between multiple inheritance and single inheritance is to use what are called mixins. Thus, you might have your Horse class derive from Animal and from Displayable. Displayable would just add a few methods for displaying any object onscreen. 
A mixin, or capability class is a class that adds specialized functionality without adding many additional methods or much data. 
Capability classes are mixed into a derived class the same as any other class might be, by declaring the derived class to inherit publicly from them. The only difference between a capability class and any other class is that the capability class has little or no data. This is an arbitrary distinction, of course, and is just a shorthand way of noting that at times all you want to do is mix in some additional capabilities without complicating the derived class.
This will, for some debuggers, make it easier to work with mixins than with more complex mutiply inhertied objects. In addition, less likelihood exists of ambiguity in accessing the data in the other principal base class. For example, if Horse derives from Animal and Displayable, Displayable would have no data. Animal would be just as it always was, so all the data in Horse would derive from Animal, but the functions in Horse would derive from both. 
NOTE: the term mixin comes from an ice cream store in Sommerville, Massachussets, where candies and cakes were mixed into the basic ice cream flavors. This seeed like a good methaphor to some of the object-oriented programmers who used to take a summer break there, especially while working with the object-oriented programming language SCOOPS

>> ABSTRACT DATA TYPES [pag473 jesse] 
Often, you will create a hierarchy of classes together. For example, you might create a Shape class, and derive from that Rectangle and Circle. From Rectangle, you might derive Square as a special case of Rectangle. 
Each of the derived classes will override the Draw() method, the GetArea() method, and so forth. The following listing 14.8 illustrates a bare-bone implementation of the Shape class and its derived Circle and Rectangle class. 
-------------------------------------------------------------------------------------------------------------------------------- LISTING 14.8 START
//Listing 14.8 Abstract Data Types

#include <iostream>
using std::cout;
using std::cin;
using std::endl;

class Shape    // declaration of the Shape class
{
  public:
     Shape(){}   // constructor 
     ~Shape(){}   // destructor
     virtual long GetArea() = 0;
     virtual long GetPerim()= 0;
     virtual void Draw() = 0;
  private:                             
};


class Circle : public Shape    // Circle class derived from Shape class
{
  public:
    Circle(int radius):itsRadius(radius){}
    ~Circle(){}
// nelle 3 seguenti righe si effettua l'overriding delle3 virtual methods della Shape class
// note that there is no need to add the word "virtual", because that is part of their inheritance. But there is no harm in doing so either, as shown below in the Rectangle class. It is a good idea to include the term virtual as a reminder, a form of documentation
    long GetArea() { return 3 * itsRadius * itsRadius; }  
    long GetPerim() { return 6 * itsRadius; }
    void Draw();
  private:
    int itsRadius;
    int itsCircumference;
};

void Circle::Draw()
{
   cout << "Circle drawing routine here!\n";
}


class Rectangle : public Shape
{
  public:
    Rectangle(int len, int width):
    itsLength(len), itsWidth(width){}
    virtual ~Rectangle(){}
// as suggested above anche se non mandatorio conviene scrivere "virtual" prima dei methods ereditati da Shape, anche se di per se' non necessario visto che per inheritance vengono automaticamente considerati dei virtual methods.
    virtual long GetArea() { return itsLength * itsWidth; }
    virtual long GetPerim() {return 2*itsLength + 2*itsWidth; }
    virtual int GetLength() { return itsLength; }
    virtual int GetWidth() { return itsWidth; }
    virtual void Draw();
  private:
    int itsWidth;
    int itsLength;
};

void Rectangle::Draw()
{
   for (int i = 0; i<itsLength; i++)
   {
      for (int j = 0; j<itsWidth; j++)
         cout << "x ";

   cout << "\n";
   }
}

class Square : public Rectangle // la class Square eredita da Rectangle, dobbiamo giusto override il GetPerim() method
{
  public:
    Square(int len);
    Square(int len, int width);
    ~Square(){}
    long GetPerim() {return 4 * GetLength();}  // overriding GetPerim()
};

Square::Square(int len):
Rectangle(len,len)
{}

Square::Square(int len, int width):
Rectangle(len,width)
{
   if (GetLength() != GetWidth())
   cout << "Error, not a square... a Rectangle??\n";
}

int main()
{
   int choice;
   bool fQuit = false;
   Shape * sp;

   while ( !fQuit )
   {
      cout << "(1)Circle (2)Rectangle (3)Square (0)Quit: ";
      cin >> choice;

      switch (choice)
      {
        case 0:   fQuit = true;
           break;
        case 1: sp = new Circle(5);
           break;
        case 2: sp = new Rectangle(4,6);
           break;
        case 3: sp = new Square(5);
           break;
        default: 
           cout <<"Please enter a number between 0 and 3"<<endl;
           continue;
           break;
      }
      if( !fQuit )
         sp->Draw();
      delete sp;
      sp = 0;
      cout << endl;
   }
   return 0;
}
-------------------------------------------------------------------------------------------------------------------------------- LISTING 14.8 END
g++ List1408.cpp -o List1408.exe
./List1408.exe 
(1)Circle (2)Rectangle (3)Square (0)Quit: 1
Circle drawing routine here!

(1)Circle (2)Rectangle (3)Square (0)Quit: 2
x x x x x x 
x x x x x x 
x x x x x x 
x x x x x x 

(1)Circle (2)Rectangle (3)Square (0)Quit: 3
x x x x x 
x x x x x 
x x x x x 
x x x x x 
x x x x x 

(1)Circle (2)Rectangle (3)Square (0)Quit: 0
---------------------------------------------------------------------------------------------


>> ABSTRACT CLASS [pag 477 jesse bella definizione!]
NOTE: if a client tried to instantiate a Shape, it would be troubling. It might be desirable to make that impossible (nel programma sopra e' tecnically possible to instantiate a shape, nelle righe seguenti, grazie all'utilizzo delle pure virtual function it mostrerrano come rendere impossibile l'instantion di una classe e permettere giusto la sua derivazione). After all, the Shape class exists only to provide an interface for the classes derived from it; as such, it is an >> abstract data type, or >> ADT
In an abstract class, the interface represents a concept (such as shape) rather than a specific object (such a circle). In C++, an abstract class is always the base class to other classes, and it is not valid to make an instance of an abstract class.
-----------------------------------------------------------------------------------------------
>> PURE VIRTUAL FUNCTIONS  [pag477 jesse]
C++ supports the creation of abstract classes by providing the pure virtual function. A virtual function is made pure by initializing it with zero, as in 
	virtual void Draw() = 0
In this example, the class has a Draw() function, but it has a null implementation and cannot be called. It can however, be overwritten within  descendants classes.
Any class with one or more pure virtual functions is an abstract class, and it becomes illegal to instantiate. In fact, it is illegal to instantiate an object of any class that is an abstract class or any class that inherits from an abstract class and doesn't implement all of the pure virtual functions. Trying to do so causes a compile-time error. Putting a pure virtual function in your class signals two things to clients of your class: 
	- don't make an object of this class; derive from it.
	- be certain to override the pure virtual functions your class inherites. 
Any class that derives from an abstract class inherits the pure virtual function as pure, and somust override EVERY pure virtual function if it wants to instantiate objects. Thus, if Rectangle inherits from Shape, and Shape has three pure virtual functions, Rectangle must override all three or it, too, will be an abstract class (insomma Rectangle deve override tutte le funzioni pure che eredita dall'abstract class, altrimenti restera' pure lui una classe astratta e non potra' essere istanziato, non potrai creare degli oggetti a partire dalla classe.) The following listing 14.8 rewrite the above 14.7 Shape class to be an abstract data type.
Note that the workings  of the program are totally unaffected. The only difference is that it would now be impossible to make an object of class Shape. 
--------------------------------------------------------------------------------------- START OF 14.8
//Listing 14.8 Abstract Data Types
#include <iostream>
using std::cout;
using std::cin;
using std::endl;

class Shape // here we declare the abstract class "Shape". It is abstract because all its virtual functions are initialized with zero. 
{
  public:
     Shape(){}
     ~Shape(){}
     virtual long GetArea() = 0;
     virtual long GetPerim()= 0;
     virtual void Draw() = 0;
  private:                             
};

class Circle : public Shape
{
  public:
    Circle(int radius):itsRadius(radius){}
    ~Circle(){}
    long GetArea() { return 3 * itsRadius * itsRadius; }
    long GetPerim() { return 6 * itsRadius; }
    void Draw();
  private:
    int itsRadius;
    int itsCircumference;
};

void Circle::Draw()
{
   cout << "Circle drawing routine here!\n";
}


class Rectangle : public Shape
{
  public:
    Rectangle(int len, int width):
    itsLength(len), itsWidth(width){}
    virtual ~Rectangle(){}
    virtual long GetArea() { return itsLength * itsWidth; }
    virtual long GetPerim() {return 2*itsLength + 2*itsWidth; }
    virtual int GetLength() { return itsLength; }
    virtual int GetWidth() { return itsWidth; }
    virtual void Draw();
  private:
    int itsWidth;
    int itsLength;
};

void Rectangle::Draw()
{
   for (int i = 0; i<itsLength; i++)
   {
      for (int j = 0; j<itsWidth; j++)
         cout << "x ";

   cout << "\n";
   }
}

class Square : public Rectangle
{
  public:
    Square(int len);
    Square(int len, int width);
    ~Square(){}
    long GetPerim() {return 4 * GetLength();}
};

Square::Square(int len):
Rectangle(len,len)
{}

Square::Square(int len, int width):
Rectangle(len,width)
{
   if (GetLength() != GetWidth())
   cout << "Error, not a square... a Rectangle??\n";
}

int main()
{
   int choice;
   bool fQuit = false;
   Shape * sp;

   while ( !fQuit )
   {
      cout << "(1)Circle (2)Rectangle (3)Square (0)Quit: ";
      cin >> choice;

      switch (choice)
      {
        case 0:   fQuit = true;
           break;
        case 1: sp = new Circle(5);
           break;
        case 2: sp = new Rectangle(4,6);
           break;
        case 3: sp = new Square(5);
           break;
        default: 
           cout <<"Please enter a number between 0 and 3"<<endl;
           continue;
           break;
      }
      if( !fQuit )
         sp->Draw();
      delete sp;
      sp = 0;
      cout << endl;
   }
   return 0;
}
-------------------------------------------------------------------------------- END OF 14.8
>> ABSTRACT DATA TYPES / >> ABSTRACT CLASS SUMMARY [pag 478 jesse]
Declare a class to be an abstract class (also called an abstract data type) by including one or more pure virtual functions in the class declaration. Declare a pure virtual function by writing "= 0" after the function declaration.
Example 
	class Shape
	{
		virtual void Draw() = 0;   // pure virtual
	}
------------------------------------------------------------------------------------
>> IMPLEMENTING  PURE VIRTUAL FUNCTIONS / >> PURE VIRTUAL FUNCTIONS IMPLEMENTATIONS  [pag478 jesse]
Typically the pure virtual functions in an abstract base class are never implemented. Because no objects of that type are ever created, no reason exists to provide implementations, and the abstract class works purely as the definition of an interface to objects, which derive from it. 
It is possible however to provide an implementation to a pure virtual function. The function can then be called by objects derived from the astract class, perhaps to provide common functionality to all the overridden functions. Listing 14.9 (see below) reproduces Listing 14.7 this time with Shape as an abstract class and with an implementation for the pure virtual function Draw(). The Circle class overrides Draw(), as it must, but it then chainsup to the base class function for additional functionality. 
In this example, the additional functionality is simply an additional message printed, but one can imagine that the base class provides a shared drawing mechanism, perhaps setting up a window that all derived classes will use. 
------------------------------------------------------------------------------------------------- START LISTING 14.9
	 //Listing 14.9 Implementing pure virtual functions

	#include <iostream>
	using namespace std;

	class Shape   // we declare the abstract class "Shape" 
	{
	  public:
		Shape(){}
		virtual ~Shape(){}
// all three of its accessor methods are declare to be pure victual.
		virtual long GetArea() = 0; 
		virtual long GetPerim()= 0;
		virtual void Draw() = 0;
	  private:
//  Note that it is not necessary to declare ALL the accessor methods as pure virtual. But it is still a good practice. If any one were declared pure virtual, the class would have been a abstract class.

	};

	void Shape::Draw() // implementation of the PURE VIRTUAL FUNCTION draw. 
	{
	   cout << "Abstract drawing mechanism!\n";
	}

	class Circle : public Shape
	{
	  public:
		Circle(int radius):itsRadius(radius){}
		virtual ~Circle(){}
		long GetArea() { return 3.14 * itsRadius * itsRadius; }
		long GetPerim() { return 2 * 3.14 * itsRadius; }
		void Draw();  // the derived class Circle must override the pure virtual function, 
	  private:                                                        // but then, it can
		int itsRadius;                                             // chains up to the 
		int itsCircumference;                                // base class function 
	};                                                                    // for additional functionality
                                                                           //              | 
	void Circle::Draw()                                        //              |                           
	{                                                                      //              |
	   cout << "Circle drawing routine here!\n"; //              |
	   Shape::Draw();         // <--------------------------------/    In this example the additional functionality is simply 
	}                                   // an additional message printed, but one can imagine that the base class provides a shared drawing mechanism, perhaps
                                        // setting up a window that all derived classes will use.


	class Rectangle : public Shape
	{
	  public:
		Rectangle(int len, int width):
		itsLength(len), itsWidth(width){}
		virtual ~Rectangle(){}
		long GetArea() { return itsLength * itsWidth; }
		long GetPerim() {return 2*itsLength + 2*itsWidth; }
		virtual int GetLength() { return itsLength; }
		virtual int GetWidth() { return itsWidth; }
		void Draw();
	  private:
		int itsWidth;
		int itsLength;
	};

	void Rectangle::Draw()
	{
	   for (int i = 0; i<itsLength; i++)
	   {
		  for (int j = 0; j<itsWidth; j++)
		     cout << "x ";

	   cout << "\n";
	   }
	   Shape::Draw();
	}


	class Square : public Rectangle
	{
	  public:
		Square(int len);
		Square(int len, int width);
		virtual ~Square(){}
		long GetPerim() {return 4 * GetLength();}
	};

	Square::Square(int len):
	Rectangle(len,len)
	{}

	Square::Square(int len, int width):
	Rectangle(len,width)

	{
	   if (GetLength() != GetWidth())
	   cout << "Error, not a square... a Rectangle??\n";
	}

	int main()
	{
	   int choice;
	   bool fQuit = false;
	   Shape * sp;

	   while (fQuit == false)
	   {
		  cout << "(1)Circle (2)Rectangle (3)Square (0)Quit: ";
		  cin >> choice;
	 
		  switch (choice)
		  {
		   case 1: sp = new Circle(5);
		         break;
		   case 2: sp = new Rectangle(4,6);
		         break;
		   case 3: sp = new Square (5);
		         break;
		   default: fQuit = true;
		         break;
		  }
		   if (fQuit == false)
		   {
		      sp->Draw();
		      delete sp;
		      cout << endl;
		   }
		}
		return 0;
	 }

------------------------------------------------------------------------------------------------- END LISTING 14.9

>> ABSTRACTION HIERARCHIES / >> complex hierarchies of abstraction [pag482 jesse]
At times, you will derive abstract classes from other abstract classes. It might be that you will want to make some of the derived pure virtual functions nonpure, and leave others pure. If you create the Animal class, you can make Eat(), Sleep(), Move(), and Reproduce() all be pure virtual functions. Perhaps from Animal you derive Mammal and Fish. On examination, you decide that every Mammal will reproduce in the same way, and so you make Mammal::Reproduce() nonpure [in modo che la puoi definire direttamente all'interno della classe Mammal, non c'e' bisogno di renderla pura, visto che la puzza e' sempre la stessa] but you leave Eat(), Sleep() and Move() as pure virtual functions. 
From Mammal you derive Dog, and Dog must override and implement the three remaining pure virtual functions so that you can make objects of type Dog.
What you've said, as class designer, is that no Animals or Mammals can be instantiated, but all the Mammal's can inherit the provided Reproduce() method without overrinding it. The following Listing 14.10 illustrates this technique with a bare-bone implementation of these classes [I like the bare-bone implementation! Cosi' metti bene in rilievo tutta la struttura senza annacquarla tra righe di implementazione. Talvolta concisione aiuta alla compresione!]
-------------------------------------------------------------------------------------------------------------- LISTING 1410 starts
// Listing 14.10
// Deriving ADTs from other ADTs
#include <iostream>
using namespace std;

enum COLOR { Red, Green, Blue, Yellow, White, Black, Brown } ;

class Animal        // common base to both Mammal and Fish
{
  public:
    Animal(int);
    virtual ~Animal() { cout << "Animal destructor...\n"; }
    virtual int GetAge() const { return itsAge; }  // non pure virtual accessor for GetAge, since it is share by all animals
    virtual void SetAge(int age) { itsAge = age; }
    // then we define the following 5 pure functions:
    virtual void Sleep() const = 0;
    virtual void Eat() const = 0;
    virtual void Reproduce() const = 0;
    virtual void Move() const = 0;
    virtual void Speak() const = 0;
  private:
    int itsAge;
};

Animal::Animal(int age):
itsAge(age)
{
   cout << "Animal constructor...\n";
}

class Mammal : public Animal   // deriving Mammal from Animal 
{
  public:                                                                               
    Mammal(int age):Animal(age)
      { cout << "Mammal constructor...\n";}
    virtual ~Mammal() { cout << "Mammal destructor...\n";}
    virtual void Reproduce() const    // overriding Reproduce() providing a common  form of reproduction for all Mammals. 
      { cout << "Mammal reproduction depicted...\n"; }    // this is certainly NOT pure.
};

class Fish : public Animal
{
  public:
    Fish(int age):Animal(age)
      { cout << "Fish constructor...\n";}
    virtual ~Fish() {cout << "Fish destructor...\n";  }
    virtual void Sleep() const { cout << "fish snoring...\n"; }
    virtual void Eat() const { cout << "fish feeding...\n"; }
    virtual void Reproduce() const        // Fish mus override Reproduce() because Fish derives directly from Animal and cannot take the advantage of Mammalian reproduction
      { cout << "fish laying eggs...\n"; }
    virtual void Move() const
      { cout << "fish swimming...\n";   }
    virtual void Speak() const { }
};

class Horse : public Mammal
{
  public:
    Horse(int age, COLOR color ):
    Mammal(age), itsColor(color)
      { cout << "Horse constructor...\n"; }
    virtual ~Horse() { cout << "Horse destructor...\n"; }
    virtual void Speak()const { cout << "Whinny!... \n"; }
    virtual COLOR GetItsColor() const { return itsColor; }
    virtual void Sleep() const
      { cout << "Horse snoring...\n"; }
    virtual void Eat() const { cout << "Horse feeding...\n"; }
    virtual void Move() const { cout << "Horse running...\n";}
    // se vogliamo possiamo non stare a scrivere Reproduce(), tanto e' gia' stato overraidata in Mammal() e visto che Horse eredita' tutti i methods from Mammal non c'e' piu' bisogno di riscriverla qui.
  protected:
    COLOR itsColor;
};

class Dog : public Mammal
{
  public:
    Dog(int age, COLOR color ):
    Mammal(age), itsColor(color)
       { cout << "Dog constructor...\n"; }
    virtual ~Dog() { cout << "Dog destructor...\n"; }
    virtual void Speak()const { cout << "Whoof!... \n"; }
    virtual void Sleep() const { cout << "Dog snoring...\n"; }
    virtual void Eat() const { cout << "Dog eating...\n"; }
    virtual void Move() const  { cout << "Dog running...\n"; }
    virtual void Reproduce() const      
      { cout << "Dogs reproducing...\n"; }     // a differenza di Fish in cui overring Reproduce() era obbligatorio [altrimenti sarebbe rimasta una classe astratta e non ne avresti potuto istanziare un Fish object] ora che stiamo definendo un Dog (derivato da Mammal in cui il method Reproduce() e' gia stato overraidato) non e' piu' obbligatorio ovverdare Reproduce, ma se vogliamo nessuno ci impedisce di farlo
// Note that Fish, Horse, and Dog all override the remaining pure virtual functions, so that objects of their type can be instantiated. 
  protected:
    COLOR itsColor;
};

int main()
{
   Animal *pAnimal=0; // an Animal pointer is used to point to the various derived objects in turn. 
   int choice;
   bool fQuit = false;

   while (fQuit == false)
   {
      cout << "(1)Dog (2)Horse (3)Fish (0)Quit: ";
      cin >> choice;
 
      switch (choice)
      {   
         case 1: pAnimal = new Dog(5,Brown);   // base on the runtime binding of the pointer the correct method is called in the derived class.
                 break;
         case 2: pAnimal = new Horse(4,Black);
                 break;
         case 3: pAnimal = new Fish (5);
                 break;
        default: fQuit = true;
                 break;
       }
       if (fQuit == false)
       {   
          pAnimal->Speak();
          pAnimal->Eat();
          pAnimal->Reproduce();
          pAnimal->Move();
          pAnimal->Sleep();
          delete pAnimal;
          cout << endl;
       }  
    }
    return 0;
 }

-------------------------------------------------------------------------------------------------------------- LISTING 1410 ends
NOTE: it would have been a compile-time error to try to instantiate an Animal or Mammal, as both are abstract classes. 

>> WHICH CLASSES ARE ABSTRACT ? / >> ABSTRACT when and why? >> ABSTRACTION LEVEL 
In one program, the class Animal is abstract; in another it is not. What determines whether to make a class abstract?
The answer to this question is decided not by any real world instrinsic factor, but by what  makes sense in your program. If you are writing  a program that depicts a farm or a zoo, you might want Animal to be an abstract class, but Dog to be a class from which you can instantiate objects. 
On the other hand, if you are making an animated kennel, you might want to keep Dog as an abstract class and only instantiate type of dogs: retrievers, terriers, and so forth. The level of abstraction is a function of how finely you need to distinguish your types. 
DO
	- DO use abstract classes to provide common description of capabilities provided in a number of related classes. 
	- DO make pure virtual any function that must be overridden.
DON'T
	- DON'T try to instantiate an object of an abstract class. 

FINAL OBSERVATION from Q&A pag 487 
>> VIRTUAL function always? Why not make all functions virtuals?
Virtual functions are supported by a virtual function table, which incurs runtime overhead, both in the size of the program and in the performance of the program.  
If you have very small classes that you don't expect to subclass, you might not want to make any of the functions virtual. However, when this assumption changes, you need to be careful to go back and make the ancestor clas functions virtual, or unexpected problems can result.
>> VIRTUAL DESTRUCTOR when?
As a general rule of thumb, if you've made any functions in your class virtual, be certain to make the destructor virtual as well. 
>> ABSTRACT CLASS but why bother? Why bother making an abstract class, why not just make it non abstract and avoid creating any object of that type?
The purpose of many of the conventions in C++ is to enlist the compiler in finding bugs, so as to avoid runtime bugs in code that you give your customers. Making a class abstract (that is, giving it pure virtual functions) causes the compiler to flag any objects created of that abstract type as errors.  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> POLYMORPHISM = means that a member function will produce different results depending on the type of object for which it is being called.
[mike pag322 game programming]
--------------------------------------------------------------------
//Polymorphic Bad Guy
//Demonstrates calling member functions dynamically

#include <iostream>

using namespace std;

class Enemy
{
public:
    Enemy(int damage = 10);
    virtual ~Enemy();
    void virtual Attack() const;
    
protected:
    int* m_pDamage;
};

Enemy::Enemy(int damage)
{
    m_pDamage = new int(damage);
}

Enemy::~Enemy()               
{
    cout << "In Enemy destructor, deleting m_pDamage.\n";
    delete m_pDamage;
    m_pDamage = 0;
}

void Enemy::Attack() const
{
    cout << "An enemy attacks and inflicts " << *m_pDamage << " damage points.";
}  

class Boss : public Enemy
{
public:
    Boss(int multiplier = 3); 
    virtual ~Boss();
    void virtual Attack() const;
    
protected:
    int* m_pMultiplier; 
};

Boss::Boss(int multiplier)
{
    m_pMultiplier = new int(multiplier);
}

Boss::~Boss()                 
{
    cout << "In Boss destructor, deleting m_pMultiplier.\n";
    delete m_pMultiplier;
    m_pMultiplier = 0;
} 

void Boss::Attack() const
{
    cout << "A boss attacks and inflicts " << (*m_pDamage) * (*m_pMultiplier)
         << " damage points.";
} 

int main()
{    // look here ciccio bella spiegazione di -> in pag 325 mike game programming 
     // perche' questi strani -> * ect : it is useful because it allows you to deal with objects without requiring that you know their exact type.
    cout << "Calling Attack() on Boss object through pointer to Enemy:\n";
    Enemy* pBadGuy = new Boss();
    pBadGuy->Attack();    
   
    cout << "\n\nDeleting pointer to Enemy:\n";
    delete pBadGuy;
    pBadGuy = 0;
   
    return 0;
}

--------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> virtual ~nomeClasse;   spiegazione a pag 326 mike game programming
evita potentiali problemi di free memory and pointer deletion 
SUSUME: a good rule of thumb is that if you have any virtual member functions in a class, you should make the destructor virtual too. 

>> POW 
[pag165 deitel]
Visto che C++ does not include an exponentiation operator, we need to use the standard library function pow
	pow(x,y)
calculates the value of x raised to yth power.
Per usarla non dimenticarti di scrivere 
	#include <cmath> 
come nell'esempio di pagina 165deitel 

>> PRECEDENCE Rules of operator precedence
- For the ARITHMETIC OPERATORS:
they are generally the same as those in algebra:
1) operators in expressios contained within pairs of parenthesis are evaluated first. Parenthesis are said to be at the "highest level of precedence"
2) multiplication, division and modulus operations are applied next. 
If an expression contains several moltiplication, division and modulus operations, operators are applied from left to right. Moltiplication, division and modulus are said to be on the same level of precedence. 
3) addition and subtraction operations are applied last. If an expression contains several addition and subtraction operations, operators are applied from left to right. 
	a + b + c
so a + b is calculated first, then c is added to that sum to determine the whole expression's value. 	
Addition and subtraction also have the same level of precedence. 	 
[pag50deitel]
4) the = assignment operator is applied last because its precedence is lower than that of any of the arithmetic operators.
example the polynomial y = ax^2 + bc + c in C++ diventa: 
	y = a * x * x + b * c + c
	  6   1   2   4   3   5   
dove i numeri sotto indicano l'ordine con cui C++ apply the operators.
5) a differenza di scilab (**) non esiste arithmetic operator for exponentiation in C++. quindi x^2 diventa x * x or possiamo usare the standard library function pow ("power") that performs exponentiation.
6) It's acceptable to place unnecessary parentheses in an expression to make the expression clearer. example 
	y = ( a * x * x ) + ( b * x ) + c
[pag52deitel]
- for RELATIONAL OPERATORS (< > <= >=) e EQUALITY OPERATORS (== !=)
The equality operators both have the same level of precedence, which is lower than that of the relational operators, and associate from left to right.
[pag53deitel]
- for the ASSIGNMENT OPERATOR = 
the associativity is RIGHT to LEFT 
[see nice summary pag 56 fig2.14 deitel + see appendix A pag968 + pag 893 deitel]
[see also nice summary pag184 operator precedence and associativity]
>> ASSOCIATIVITY / >> PRECEDENCE OPERATOR TABLE from pag 893 deitel
They're shown top to bottom in decreasing order of precedence:
Operators                               ASSOCIATIVITY   TYPE
::	(unary; right to left)	            left to right	primary
::  (binary; left to right) 
()  (grouping parenthensis) 
() [] . -> ++ -- static_cast<type>()	left to right	postfix
++ -- + - ! delete sizeof 				right to left	prefix
	* ~ & new
*   / %                                 left to right   multiplicative
+   -                                   left to right   additive
<< >>                                   left to right 	shifting
< <= > >=                               left to right   relational
== !=                                   left to right   equality
&                                       left to right   bitwise AND
^                                       left to right   bitwise XOR
|                                       left to right   bitwise OR
&&                                      left to right   logical AND
||                                      left to right   logical OR
?:                                      right to left   conditional
= += -= *= /= %= &= |= ^= <<= >>=       right to left   assignment
,                                       left to right   comma
----------------------------------------------------------------------------
----------------------------------------------------------------------------
>> PRECEDENCE operator [pag32 moo book]
NOTE: te li listo by precedence from highest to lowest 
NOTE2: ---------------------- = serve per separare grouping with the same precedence
------------------------------------------------------------------------------------ START TABLE
x.y         the member y of object x  [cioe' y e' una della funzioni di cui dispone l'oggetto x]
x[y]        the element in objhect x indexed by y
x++         increments x, returning the original value of x
x--         decrements x, returning the original value of x
------------------------------------------------------------------------------------
++x         increments x, returning the incremented value
--x         decrements x, returning the decremented value
!x          logical negation. If x is true then !x is false
------------------------------------------------------------------------------------
x * y       product of x and y
x / y       quotient of x and y. If both operands are integral, so is the result
			the implementation chooses whether to round toward zero or -inf
x % y       remainder, equivalent to x - ((x/y) * y) . x and y must be integral
------------------------------------------------------------------------------------
x + y       sum of x and y
x - y       results of subtracting y from x 
------------------------------------------------------------------------------------
x >> y      for integral x and y, x shifted right by y bits; y must be non negative
            if x is an istream reads from x into y
x << y      for integral x and y, x shifted left by y bits; y must be non negative
			if x is an ostream, writes y onto x
------------------------------------------------------------------------------------
x relop y   where relop = RELation OPerators yield a bool indicating the truth of the relation 
			the operators (<, >, <=, and >=) have their obvious meanings
------------------------------------------------------------------------------------ 
x == y      yields a bool indicating whether x equals y
x != y      yields a bool indicating whther x is not equal to y
------------------------------------------------------------------------------------
x && y      yields a bool indicating whether both x and y are true
			evaluate y only if x is true
------------------------------------------------------------------------------------
x || y      yields a bool indicating whether either x or y is true
			evaluates y only is x is false
------------------------------------------------------------------------------------
x = y       assign the value of y to x, yielding x as its result
x op= y     compound assignment operators;
			equivalent to x = x op y, where op is one of + - * / % & | ^ << >>
x ? y : z   yields y if x is true, z otherwise. Evaluates only one of y and z.
------------------------------------------------------------------------------------- END TABLE



>> bitfields / >> bit field [deitel pag894]
C++ provides the ability to specify the number of bits in which an integral type or enum type member of a class or a structure is stored. Such a memter is refereed to as a bit field.
Bit fields enable better memory utilization by storing data in the minimum number of bits required. Bit field member must be declared as an integral or enum type.
Consider the following structure definition:
	struct BitCard
	{
		unsigned face : 4;
		unsigned suit : 2;
		unsigned color : 1;
	} // end struct BitCard
The definition contains three unsigned bit fields (face, suit and color) used to represen a card from a deck of 52 cards. A bit field is declared by following an integral type or enum type member with a colon (:) and an integer constant representing the width of the bit field (i.e. the number of bits in which the member is stored). The width must be an integer constant. 
The preceding structure definition indicates that 
	member face is stored in four bits
	member suit in 2 bits 
	member color in one bit
The number of bits is based on the desired range of values for each struture member. Member face stores values between 0 (Ace) and 12 (King) (four bits can store a value between 0 and 15). Member suit stores values between 0 and 3 (0 = Diamonds, 1 = Hearts, 2 = Clubs, 3 = Spades), two bits can store a value between 0 and 3. Finally, member color stores either 0 (red) or 1 (black), one bit can store either 0 or 1. 
NOTE: although bit fields save space, using them can cause the compilerto generate slower executing machine language code. This occurs because it takes extra machine language operations to access only portions of an addressable storage unit. This is one of many examples of the space time trade offs that occur in computer science.
NOTE2 it is possible to specify unnamed bit field, in which case the field is used as >> padding in the structure [pag897 deitel] (= padding = riempimento dello spazio inutilizzato).
For example the structure definition uses an unnamed three bit field as padding, nothing can be stored in those three bits. Member b is stored in another storage unit. 
	struct Example
	{
		unsigned a : 13;
		unsigned   : 3; // align to next storage unit boundary
		unsigned b : 4;
	} // end struct Example
An unnamed bit field with a zero width is used to align the next bit field on a new storage unit boundary. For example the structure definition
	struct Example
	{
		unsigned a : 13;
		unsigned   : 0; // align to next storage unit boundary
		unsigned b : 4;
	} // end struct Example
uses an unnamed 0 bit field to skip the remining bits (as many as there are) of the storage unit in which a is stored an align b on the next storage unit boundary.
COMMON PROGRAMMING ERROR: attempting to take the address of a bit field (the & operator may not be sued with bit fields because a pointer can designate only a particular byte in memory and bit fields can start in the middle of a byte) is a compilation error.
COMMON PROGRAMMING ERROR2: attempting to access individual bits of a bit field with subscripting as if they were elements of an array is a compiaton error. Bit fields are not "arrays of bits""
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> precision / >> setprecision / >> floating point precision  
[pag574deitel]  [also example @pag39 moo book]
We can control the precision of floating-point numbers (i.e. the number of digits to the right of the decimal point) by using either the setprecision stream manipulator or the precision member function of ios_base. A call to either of these sets the precision for all subsequent output operations until the next precision setting call.
A call to member function precision with no argument return the current precision setting (this is what you need to use so that you can restore the original precision eventually after a sticky setting is no longer needed) See prgraom fig13.9 pag 572 to see some code that print a table that shows the square root of 2, with precision varying from 0 to 9
Extract from /home/dia/Deitel-Code_Examples/ch13/fig13_09/Fig13_09:
	   // set precision for each digit, then display square root
	   for ( places = 0; places <= 9; ++places )
	      cout << setprecision( places ) << root2 << endl;
	} // end main 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PROTECTED 
[pag501deitel]
Using protected access offers an intermediate level of protection between public and private access.  
Ricorda che 
	- a base class's public members are accessible within its body and anwhere that the program has a handle (i.e. a name, reference or pointer) t an object of that class or one of its derived classes.
	- a base class's private members are accessible only within its body and to the "friends" of that base class. 
	- a base class's protected members can be accessed within the body of that base class, by members and friends of that base class, and by members and friend of ANY CLASSES DERIVED from that base class.
[nota "base class" lo diciamo in relazione alle "derived class" che vengono derivate dalle base classes usando inheritance]
NOTE: 
vantaggi of protected over private 
C'e' si un piccolo vantaggio dal punto di vista della performance. 
- inheriting protected data members slightly improves performae, because we can directly access the members without incurring the overhead of calls to set and get member functions. In most cases, it's better anyway to use "private" data members to encourage proper software engineering, and leave code optimization issues to the compiler. Your code will be easier to maintain, modify nad debug
MA VI SONO DUE GROSSI SVANTAGGI CHE ti inducono a preferire l'utilizzo di "private" al posto di "protected"
- primo svantaggio e' che an invalid value can easily be asigne to the protected data member, thus leaving the object in a incosistent state.
- second problem with using protected data members is that derived class member functions are more likely to be written so that they depend on the base class implementation. Such software is said to be fragile or >> brittle, because a small change in the base class can "break" derived-class implementation. 
It's BETTER to declare base-class data members "private" (as opposed to declaring them protected) enables you to change the base-class implementation without having to change derived class implementation. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////]:)] 

>> OOOOOOO

>> open file / >> file open / >> FILE OPEN
[pag603]
you can create an ofstream object without opening a specific file, in this case a file can be attached to the object later. For example, the statement
	ofstream outClientFile;
creates an ofstream object that's not yet associated with a file. The ofstream member function open opens a file and attaches it to an existing ofstream as follows. 
	outClientFile.open("client.txt", ios::out);
ERROR PREVENTION: some operating systems allow you to open the same file multiple times simultaneouly. Avoid doing this because it can lead to subtle problems.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////]:)] 



>> OPEN FILE TEST / >> TEST IF FILE OPENED SUCCESSFULLY / >> EXIT PROGRAM EXAMPLE / >> TERMINATE PROGRAM EXAMPLE
[pag603 deitel] /home/dia/Deitel-Code_Examples/ch14/fig14_03
////////////////
   // open the file 
   ofstream outClientFile( "clients.txt", ios::out );	
   // exit program if unable to create file
   if ( !outClientFile ) // overloaded ! operator
   {
      cerr << "File could not be opened" << endl;
      exit( EXIT_FAILURE );
   } // end if
/////////
NOTE: passing EXIT_SUCCESS (also define in <cstdlib>) to exit indicates that the program terminated normally; passing any other value  (in this case "EXIT_FAILURE") indicates that the program terminated due to an error.
OMAGE: thanks Ciccio & Deitel helped to solve the problem in creating a message recovery error and exit in FEAMapper Nastran. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> OPEN KEEP windows open / >> batch file / >> console window keep open mike's way pag10 mike
Se ti capita che una volta cliccato sul programma exe si chiuda subito e ti impedisca di vederne il risultato, puoi creare un batch file that runs your console program and pauses, keeping the console window open so you can see the results of your program. For example if your compiled program is name tron.exe you can simply create a batch file comprising the two lines
	tron.exe
	pause
To create a batch file 
- Open a text editor (like editpad o notepad, nor word or wordpad)
- type your text
- save the file in the same folder with your tron.exe file. Give the file a .bat extension, so in this case, tron.bat would be a good name (in pratica in editpad lo salvi normalmente selezioni come formato unspecified file e lo nomini tron.bat). 
Finally run the batch file by double clicking its icon. You should see the results of the program since the batch file keeps the console window open.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> openFOAM C file structure
di solito all'interno di un file C di openFOAM ritroviamo le seguenti sezioni :
	// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * Private Member Functions * * * * * * * * * * //
	// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //
	// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //
	
>> OpenFOAM H file structure
1) /*help iniziale*/ contenente Class, Description and SourceFiles [e da li che Doxygen ne ricostruisce la documentazione]
2) la class declaration contenente :
		una sezione private con 
			// Private data
			// Private member functions
		una sezione public
			// Runtime type information
			// Constructors
			// Destructor
			// Member Functions	
			
///////////////////////////////////////////////////////////////////////////			

>> PREDICATE FUNCTIONS 
[pag378deitel]
Access functions that can read or write an object's data members. A common use of access functions is to test the truth or falsity of conditions : such functions are called a predicate functions.

>> predicate [pag63 moo book] = optional third arugment of the >> sort function.
If this third argument is present, the sort function will use it to compare elements instead of using the < operator. 
----------------------------------------------------------------------
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc]
	bool compare(const Student_info& x, const Student_info& y)
	{
		return x.name < y.name;
	}
	...	
	// alphabetize the records
	sort(students.begin(), students.end(), compare);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> PREPROCESSING DIRECTIVE
a preprocessing directive begins with # and is a message to the C++  preprocessor. Preprocessing directives are processed before the program is compiled. 
example 
	#include <iostream>
tells the C++ preprocessor to include the contents of the input/output stream header, which contains information necessary to compile programs that use std::cin and std::out and the stream insertion << and stream extraction >> operators.	
[pag57deitel]  

>> preprocessor varialbe pag 67 moo book
like #ifndef directive, helps you to control how a program is compiled
Example 
	#ifndef GUARD_median_h
	#define GUARD_median_h
	
	// `median.h'--final version
	#include <vector>
	double median(std::vector<double>);
	
	#endif
-----------------------------------------
Explanation : 
the GUARD_media_h is the name of a >> preprocessor variable
the #ifndef directive asks the preprocessor to process everything between it and the next matching #endif if the give name is not defined.
The first time median.h is included in a program GUARD_media_H will be undefined, so the preprocessor will look at the rest of the file. The first thing it does is to define GUARD_media_h, so that subsequent attempts to include median.h will have no effect. The only the subtlety is that it is a good idea for the #ifndef to be the very first line of the file, without even a comment before it. The reason is that some C++ implementations detect files that have this form and, if the variable is defined, do not even bother to read the file the second time around.
[cioe' detto in parole spicciole: #ifndef ti aiuta ad avere una compilazione piu' efficiente]
///////////////////////////////////////////////////////////////////////////////

>> principle of least privilege
[pag346]
Alway give a function enough access to the data in its parameters to accomplish its specified task, but no more. Let the principle of least privilege be your guide. You can combine "const" with pointer declarations to enforce the principle of least privilege.
A) abbiamo visto che quando un argument e' passato by value, a copy of the argument is passed to the function. If the copy is modified in the called function, the original value in the caller does not change. In some instances, even the copy of the argument's value should not be altered in the called function
B) Oppure potremmo in maniera piu' effience passare alla funzione un built-in array by reference. Visto che e' passato by reference the called function ha il potere di modificarlo. Qualora volessimo assicurarci che non venga modificato dalla called function, dobbiamo usare alcune precauzioni.
Example
Consider a function tha takes 
1) a pointer to the initial element of a built-in array and 
2) the array's size 
as arguments and subsequently display the built-in array's elements.
Such a function should loop through the elements and output each individually. The built-in array's size is used in the function's body to determine the highest subscript so the loop can terminate when the displaying completes. The size does not need to change in the function body, so it should be declared "const"  to ensure that it will not change. Because the built-in array is only being displayed, it, too should be declared const. This is especially important because built-in array are always passed by reference and could easily be changed in the called function. An attempt to modify a const value is a compilation error.
There are 4 ways to pass a pointer to a function
A) nonconstant pointer to nonconstant data [highest access privilege]
B) nonconstant pointer to    constant data
C)    constant pointer to nonconstant data
D)    constant pointer to    constant data [minimum access privilege]
Each combination provides a different level of access privilege.
A) the highest access is grantedd by a nonconstant pointer to nonconstant data: example
	int *countPtr;
the data can be modified through the dereferenced pointer, and the pointer can be modified to point to other data. Such a pointer's declaration does not include const.
B) A nonconstant pointer to constant data is a pointer that can be modified to point to any data item of the appropriate type, but the data to which it points cannot be modified through that pointer.
	const int *countPtr;	
The declaration is read from right to left as "countPtr is a pointer to an integer constant" or more precisely, "countPtr is a non-constant pointer to an integer constant"
C) constant pointer to nonconstant data, example:
	int * const ptr = &x; 
ptr is a constant pointer to a non constant integer. The pointer is initialized with the address of integer variable x. 
A constant pointer to nonconstant data  is a pointer that always points to the same memory location, and the data at that location can be modified through the pointer. Pointers that are declared const must be initialized when they're declared, but if the pointer is a function parameter, it's initialized with the pointer that's passed to the function.
D) constant pointer to    constant data
such a pointer always points to the same memory location, and the data at that location cannot be modified via the pointer.
example:
	const int *const ptr = &x;
this declaration is read from right to left as "ptr is constant pointer to an integer constant"
cfr esempi completi see codice:
	ch08/fig08_10/fig08_10.cpp
	ch08/fig08_11/fig08_11.cpp
o vedi fig8.10 e fig8.11 pag 348-351
Performance tip: if they do not need to be modified by the called function, pass large objects using pointers to constant data or references to constant data, to obtain the performance benefits of pass-by reference and avoid the copy overhead of pass-by-value. In effetti quando a pointer to an object is passed, only a copy of the address of the object must be made, the object itself is not copied.
////////////////////////////////////////////////////////////////////

>> PRIVATE DATA MEMBERS OF A CLASS
[pag458 deiteil]
trovi un esempio a pag 459 
	private:
   size_t size; // pointer-based array size
   int *ptr; // pointer to first element of pointer-based array
[extract from /home/dia/Deitel-Code_Examples/ch10/fig10_09_11/Array.h]

>> PROGRAM CONTROL 
[pag106 deitel]
Specifying the order in which statements (actions) execute is called program control.

>> predicative functions are Accesss that function can read or display data. Predicative functions are used to test the truth or falsity of conditions. 
Example :
- potremmo creare a "isFull" predicate function that might test a container-class object to determine whether it has no additional room. 
[pag386deitel]

>> PROMPT 
A prompt is a message that directs the user to take a specific action example 
	std::cout << "Enter StarGate Code: ";
we like to read the preceding statement as "std::cout gets the string "Enter StarGate Code: ""	

>> PSEUDOCODE
[pag106deitel]
Pseudocode (or "fake" code) is an artificial and informal language that helps you develop algorithms without having to worry about the details of C++ language syntax.
The pseudocode is helpful for developing algorithms that will be converted to structured C++ programs. Pseudocode does NOT execute on computers. Rather, it helps you "think out" a program before attempting to write it ina a programming language, such as C++. A carefully prepared pesudocode program can easily be converted to a corresponding C++ program. In many cases, this simply requires replacing pseudocode statements with C++ equivalents.
	Pseudocode normally describes only executable statements, which cause specific actions to occur after you to convert a program from pseudocode to C++ . We tipically do not include variable declarations in our pesudocode. Some programmers choose to list variables and mention their purposes at the beginning of pseudocode programs. 

>> PSEUDOCODE [pag132 mike programming game]
Plan your program formally on paper, it will almost always result in time (and frustration) saved.
Programming is a lot like construction. Without a plan you'll likely struggle through the process and waste time. You might even end up with a program that doesn't quite work.
Use pseudocode (a language that falls somewhere between English and a formal programming language). Anyone that understand english, should be able to follow pseudocode
Example 
	If you can design a new and useful spaceship
		then that's your spaceship
	Otherwise
		take an existing spaceship and rename it and paint it with some fancy colours
	Make an infomercial about your spaceship cargo services
	Show the infomercial on the BladeRunner blimps over the city. 
	Charge $50000 per cargo mission
	Sell 100 cargo missions 
>> STEPWISE REFINEMENT [pag133 mike programming game] 
Your programming plan might not be finished after only one draft. Often pesudocode need multiple passes before it can be implemented in programming code. Stepwise refinement means to rewrite pesudocode to make it more detailed and ready for implementation. By taking each step described in pseudocode and breaking it down into a series of simpler steps, the plan becomes closer to programming code.
You keep breaking down each step until you feel that entire plan could be fairly easily translated into a program.  
For example, take a step from the pseudo code above 
	Make an infomercial about your spaceship cargo services
This might seems too vague. How do you create an informercial? Using the stepwise refinement you can break down the single step into several others so it becomes:
	Write a script for an informercial about your cargo services 
	Rent Lucas Film Studios for a week
	Hire production crew 
	Hire actors 
	Film the infomercial
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> PUBLIC SERVICES / class's public services
i public services altri non sono che the class's public member functions. For example at pag84 fig3.9 : class GradeBook interface contains a constructor and member functions setCourseName, getCourseName and displayMessage. GradeBook's clients (e.g., main) use this functions to request  the class's services. 
[refiti a una classe]

>> PUBLIC STATIC DATA MEMBER
[pag300]
Public static data member can also be accessed outside of the class, even when no objects of the class exist, using the class name followed by the scope resolution operator (::) and the name of the data member. 
EXAMPLE 
[from pag 299 deitel]
	public:
   		// constant -- number of students who took the test
   		static const size_t students = 10; // note public data
this data member student specifies the size of an array. 
- "student" is set to public so that it's accessible to the class's clients. 
- Declaring students with the const qualifier indicates that this data member is constant (its value cannot be changed after being initialized)
- keyword static in this variable declaration indicates that the data member is shared by ALL OBJECTS of the class 

>> PURE VIRTUAL FUNCTION
[pag534deitel]
A pure virtual function is specified by placing "=0" in its declaration as for example 
	virtual void nameFunction() const = 0;
The "=0" is a pure specifier. Pure virtual functions typically do not provide implementations, though they can.
Each concrete derived class must override all base-class pure virtual functions with concreate implementations of those functions; otherwise the derived class is also abstract. 
Although we cannot instantiate objects of an abstract base class, we can use the abstract base class to declare pointers and references that can refer to objects of any concrete classes dervied from the abstract class. Programs typically use such pointers and references to manipulate derived-class objects polymorphically.

>> put
[pag 568 deitel]
we can use the put member function to output characters. For example, the statement
	cout.put ( 'A' );
displays a single character A. Calls to put may be cascaded, as in the statement
	cout.put( 'A' ).put( '\n' );
which outputs the letter A followed by a newline character. As with << the preceding statement executes in this manner, because the dot operator (.) associates from left to right, and the put member function returns a reference to the ostream objct (cout) that received the put call. The put function also may be called with a numeric expression that presents an ASCII value, as in the following statement, which also ouputs A:
	cout.put( 65 );
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> QQQQQQQ

>> QUIT PROGRAM / EXIT PROGRAM
[source http://stackoverflow.com/questions/1116493/how-to-quit-a-c-program]
Call the std::exit function. 

>> qualified name [pag5 moo book]


>> QUEUES 
[pag799 deitel]
Queue nodes are removed only from the head of the queue and are inserted only at the tail of the queue. For this reason, a queue is referred to as a first-in, first-out (FIFO) data structure. The insert and remove operations are called
	>> enqueue = insert element/node ad the tail of the queue
	>> dequeue = remove element/node from the head of the queue
- Application of Queues
> Computers that have a single processor can service only one user at a time. Entries for the other users are placed ina queue. 
Each entry gradually advances to the front of the queue as users receive service. The entry at the front of the queue is the next to receive service.
> PRINTERS: queues are also used to support >> print spooling: for example, a single printer might be shared by allusers of a network. Many users can send print jobs to the printer, even when the printer is already busy. These print jobs are placed in a queue until the printer becomes available. A program called a >> spooler manges the queue to ensure that, as each print job completes, the next print job is sent to the printer.
> NETWORK: information packect also wait in queues in computer networks. Each time a packet arrives at a netword node, it must be routed to the next node on the network along the path to the packet's final destination. The routing node routes one packet at a time, so additional packets are enqueued until the router can route them
> SERVERS: a file server in a computer network handles file access requests from many clients throughout the network. Servers have a limited capacity to service requests from clients. When that capacity is exceeded, client requests wait in queues.  
////////////////////////////////////////////////////////////////

>> RRRRRRR

>> RANDOM NUMBER GENERATION rand / >> rand
[pag214]
the c++ standard library function rand produces integers at random 
	i = rand();
the function rand generates an unsigned integer between 0 and RAND_MAX (a symbolic constant defined in the <cstdlib> header)
The range of values produced directly by the function rand often is different than what a specific application requires. For example a program that simulates rolling a six-sided die would require random integers in the range 1 to 6 [except if is an Inception Die]. A program that simulates coin tossing might require only 0 for "heads" and 1 for "tails" [except for the coin of Rosencrantz and the lucky coin of Harvy Dent]
Example supponi di voler produrre number integer random compresi tra 1 e 6
to produce random integers in the range 0 to 5 [come accade nel lancio di un dado] we use the modulus operator % with rand as follows:
	rand() % 6
This is called scaling. The number 6 is called the >> scaling factor. We then >> shift the range of numbers produced by adding 1 to our previous result (in modo che al posto del range 0 5 shift i risultati nel range 1 6)
see example pag 215deitel
	(1 + rand() % 6 );
We can generalize this as : 
	number = shiftingValue + rand() % scalingFactor
where  [pag219deitel] 
- shiftingValue is equal to the first number in the desired range of consecutive integers and 
- scalingFactor is equal to the width of the desired range of consecutive integers.
NB function rand actually generates pseudorandom numbers. Repeatedly calling rand produces a sequence of numbers that appears to be random. However, the sequence repeats itself each time the program executes. Questo e' desiderabile nella fase di debug di un simulation program, this repeatability is essential for proving that corrections to the program work properly. Once a program has been thoroughly debugged, it can be conditioned to produce a different sequence of random numbers for each execution. This is called randomizing and is accomplished with the X++ standard library function srand. 

>> vector<double>& /  to const vector of double example from pag 54 moo book
"a name is a reference to an objects" means "the name is another name for the object"
So for example if we write
	vector<double> homework;
	vector<double>& hw = homework;   // here hw is a synonym for homework, we are just saying that "hw" is another name for "homework"
From that point, anything we do to hw is equivalent to doing the same thing to homework and viceversa.
We can also create a read-only synonym for "homework" in the following way:
	const vector<double>& chw = homework;
this expression still says that chw is another name for homework, but the const promises taht we will not do anything to change chw that might change its value.
NOTE: when we say that a parameterhas type const vector<double>&, we are asking the implementation ot give us direct access to the accosiated argument, without copying it, and also promising that we won't change the parmeter's value (which would otherwise change the argument too) pag55 moo book
------------------------------------------------------------------------------------ EXAMPLE start
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/grade.cc]
#include <stdexcept>
#include <vector>
#include "grade.h"
#include "median.h"
#include "Student_info.h"

using std::domain_error;  using std::vector;


// compute a student's overall grade from midterm and final exam grades and homework grade
double grade(double midterm, double final, double homework)
{
	return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

// compute a student's overall grade from midterm and final exam grades
// and vector of homework grades.
// this function does not copy its argument, because `median' does so for us.
double grade(double midterm, double final, const vector<double>& hw)
{
	if (hw.size() == 0)
		throw domain_error("student has done no homework");
	return grade(midterm, final, median(hw));
}

double grade(const Student_info& s)
{
	return grade(s.midterm, s.final, s.homework);
} 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> vector separate elements of a vector into two vectors. [pag76 moo book]
[per esempio il seguente programma prende un vettore ed toglie e salva in un secondo vettore tutti gli elementi che sono al di sotto di una certa soglia limite. Nel vettore di input restano solo gli elementi che sono al di sopra della soglia]
example from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/fails_vec1.cc
--------------------------------------------------------------------------------------------------------
	#include <vector>
	#include "Student_info.h"
	#include "grade.h"	
	using std::vector;
	// separate passing and failing student records: first try
	vector<Student_info> extract_fails(vector<Student_info>& students)  // nota come il function parameter sia una reference [la & che segue <Student_info>, so changes to the paremeter are reflected in the argument]
	{
		vector<Student_info> pass, fail;
	
	#ifdef _MSC_VER
		for (std::vector<Student_info>::size_type i = 0;
	#else
		for (vector<Student_info>::size_type i = 0;
	#endif
		     i != students.size(); ++i)
			if (fgrade(students[i]))
				fail.push_back(students[i]);
			else
				pass.push_back(students[i]);
	
		students = pass;  // we copy the passing records back into "students", obliterating the previous contents of students 
		return fail; // return the failing records.
	}
[note this version requires enough memory to hold two copies of each student record]
In the following version we become more spartan and instead of having two vector pass and fail, we will just create a single local variable, named fail, to hold the value that we intend to return. For each record in students, we will compute the grade. If it is a passing grade, we'll leave the record alone; if it's failing grade, we'll append a copy of it to fail, and remove it from students.
We need a way to remove an element from a vector. The good news is that such a facility exists; the bad news is that removing elements from vectors is slow enough to argue against using this approach for large amounts of input data. If the data we process get really big, performance degrades to an astonishing extent. For example if all of our students were to fail, the execution time of the function that we are about to see would grow proprotionally to the square of the number of students. That means that for a class of 100 students, the program would take 10,000 times as long to run as it would for one student. The problem is that our input records are stored in a vector, which is optimized for fast random access. One price of that optimization is that is can be expensive to insert or delete elements other than at the end of the vector.
A) SLOW SOLUTION using erase member function
/home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/fails_vec2.cc
------------------------------------------------------------------------------------ 
#include <vector>
#include "Student_info.h"
#include "grade.h"

using std::vector;

// second try: correct but potentially slow
vector<Student_info> extract_fails(vector<Student_info>& students)
{
	vector<Student_info> fail;
#ifdef _MSC_VER
	std::vector<Student_info>::size_type i = 0;
#else
	vector<Student_info>::size_type i = 0;
#endif

	// invariant: elements `[0,' `i)' of `students' represent passing grades
	while (i != students.size()) {
		if (fgrade(students[i])) {
			fail.push_back(students[i]);
			students.erase(students.begin() + i);
		} else
			++i;
	}
	return fail;
}
----------------------------------------------------------------
B) USING LIST INSTEAD OF VECTORS for better performance [pag85 moo book]
Because our function requires only sequential access, we do not need to use indices (del tipo students[i] ), which provide the ability to access any element randomly. Instead, we'd like to rewrite the function so as to restrict access to the container elements to operations that support only sequential access. To that end, the C++ library supplies an assortment of types called iterators, which allow access to data structures in ways that the library can control. This control lets the library ensure efficient implementation. 
>> INDEX versus ITERATORS [pag81 moo book]
Per esempio cio' che si puo' scrivere usando un index:
	for (vector<Student_info>::size_type i = 0;
			i != students.size(); ++i)
		cout << students[i].name << endl;
si puo' riscriverlo usando un iterator:
	for (vector<Student_info>::const_iterator iter = students.begin();  // qui "iter" initially refers to the first element in "students" 
		iter != students.end(); ++iter ) {
		cout << (*iter).name << endl;  // this writes the current element's "name" member on the standard output
	}   
// NOTE: *iter : we access the element of the vector by calling the dereference operator *. When applied to an iterator the * operator returns an lvalue that is the element to which the iterator refers.
// NOTE dobbiamo scrivere (*iter).name e non *iter.name perche' . ha priorita' rispetto a * prima dobbiamo recuperare the value that the iterator iter denotes. E poi applicargli la member function name.
// NOTE this combination of operatios is so common that there is an abbreviation for it instead of 
	(*iter).name
we can write
	iter->name
Then we can rewrite l'esempio sopra as 
	for (vector<Student_info>::const_iterator iter = students.begin(); 
		iter != students.end(); ++iter ) {
		cout << iter->name << endl;  
	}   
Quindi ora, in questo momento posso dire che guardando iter->name ne vedo il significato: hai un iteratore "iter" che ti ritorna un valore di uno degli elementi di un container/vettore e a cui applichi -> la member function name

>> ITERATORS TYPES [pag80 moo book]
Every standard container, such as vector, defines two associated iterator types:
	container-type::const_iterator
	container-type::iterator
where container-type is the container type, such as vector<Student_info>, that includes the type of the container elements. When we wnat to use an iterator to change the values stored in the container, we use the iterator type. If we need only read access, then we use the const_iterator type. 
Abstraction is selective ignorance. The details of what particular type an iterator has may be complicated, but we don't need to understand these details. All we need to know is how to refer to the iterator type, and what operations the iterator allows.
We don't need to know the actual type of iter. All that we need to know is that vector<Student_info> has a member named const_iterator that defines a type that we can use to obtain read-only access to elements of the vector.
The other thing we need to know is that there is an automatic conversion from type iterator to type const_iterator. As we're about to learn, students.begin() returns an iterator, but we said that iter is a const_iterator. In order to initialize iter with the value of students.begin(), the implementation converts the iterator value into the corresponding const_iterator. This conversion is one way, meaning that we can convert an iterator to a const_iterator but not vice-versa.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE vs COPY into function / >> copy vs reference 
Ciccio detto in parole semplici: se all'interno di una funzione vedi un "&" significa che si NON si sta copiando il vettore, bensi semplicemente dando alla funzione l'accesso diretto al vettore e la sua eventuale modifica. 
example "COPY parameter to function" from pag 53 moo book
	double media(vector<double> vec)
		...
		sort(vec.begin(), vec.end());
nella precedente funzione visto che il vettore viene sortato, e' bene fare una copia del vettore, in modo che il vettore originale non venga modificato e che si esegui il sort solo sulla copia del vettore passato alla funzione.
example2 "REFERENCE parameter" from pag 57-58 moo book
	double grade(const vector<double>& hw)
	{
		...
	}
in this case the & asks the implementation not to copy the argument, and the "const" promises that the program will not change the parameter. Such parameters are an important technique for making programs more efficient. They are a good idea whenever the function will NOT change the parameter's value, and the parameter is of a type, such as vector or string, with values that might be time-consuming to copy.
On the contrary it is usaully not worth the bother to use const references for parameters of simple built-in types, such as int or double. Such small objects are usually fast enough to copy, that there' s little, if any, overhead in passing them by value.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> reference count [pag260 moo book]
Reference count is an object that keeps track of how many objects refer to another object. 
We increment the reference count each time that we create a new reference to our target object, and we decrement the reference count each time a referring object goes away. When the last referring object goes away, the reference count will become zero. At that point we'll know that it is safe to destroy the target object.
This technique can save a lot of unneeded memory management and copying of data.

>> RANDOM NUMBERS C++11 
[pag224]
C++11 provides many classes that represent various random-number generation "engines" and "distributions".
- an engine implements a random-number generation algorithm that produces pseudorandom numbers. 
- a distribution controls the range of values produced by an engine, the types of those values (e.g. int, double) and the statical properties of the values. 
For esempio we could choose the default random-number generation engine "default_random_engine" and a "uniform_int_distribution", which evenly distributes pseudorandom integers over a specified range of values. The default range is from 0 to the maximum value of an int on your platform.

>> GAME TERMINOLOGY / >> GAMING TERMINOLOGY
>> RPG = Role Playing Game
>> RTS = Real Time Strategy
>> FPS = First Person Shooter


>> RANGE-BASED FOR STATEMENT [=  lo statement FOR range-based, cioe' un ciclo for senza contatori, che si ripete basandosi sul range (range-based) del vettore]
[pag293deitel]
	for (rangeVariableDeclaration : expression)
		statement
where the rangeVarriableDeclaration  has a type and an identifier (ex int item) and expression is the array through which to iterate.  
Example:
   array< int, 5 > items = { 1, 2, 3, 4, 5 };
   // display items before modification
   cout << "items before modification: ";
   for ( int item : items )
      cout << item << " ";
The "for ( int item : items )" line can be read as "for each iteration, assign the next element of items to int variable item, then execute the following statement". Thus, for each iteration, identifier item represents one element in items. The line is equivalent to the following counter-controlled repetition:
	for ( int counter = 0; counter < items.size(); ++counter )
		cout << items[ counter ] << " ";
In range variable Declarations possiamo anche usare delle reference (&). 
Example pag 294 line 17-18: we use the range-based "for" to modify an array's contents
   for ( int &itemRef : items )
      itemRef *= 2;
itemRef is an int reference (&). Recall that a reference is an alias for another variable in memory [in this case, one of the array's elements). We use an int reference because items contains int values and we want to modify each element's value]. Because itemRef is declared as a reference, any change you make to itemRef changes the correspoding element value in the array.
LIMITATION and WHEN TO USE [pag295deitel]
The range-based for statement can be used in place of the counter-controlled "for" statement whenever code looping through an array does not require access to the element's  subscript. For example, totaling the integers in an array requires access only to the element value, the elements subscripts are irrelevant. 
However, if a program must use subscripts for some reason other than simply to loop through an array (ex. to print a subscript number next to each array value) you should use the counter-controlled for statement. 
NOTE1: It's common to process all the elements of an array. The C++11 range-based for statement allows you to do this without using a counter, thus avoiding the possibility of "stepping outside" the array and eliminating the need for you to implement your own bounds checking.
NOTE2: when processing all the elements of an array, if you don't need to access an array element's subscript, use the range-based for statement.


>> READ DATA FROM A SEQUENTIAL FILE 
[pag605 deitel]
see example /home/dia/Deitel-Code_Examples/ch14/fig14_06
	   // ifstream constructor opens the file          
   ifstream inClientFile( "clients.txt", ios::in );
///////////
The previous line creates an ifstream object called inClientFile and associates it with the clients.txt file. The arguments in parentheses are passed to the ifstream contructor, which opens the file and establishes a "line of communication" with the file.
NOTE: good programming practice
If a file's contents should not be modified, use ios::in to open it only for input. This prevents unintentional modificantion of the file's contents and is nother example of the principle of least privilege.
>> OPEN FILE for input 
[pag606deitel]
Objects of class ifstream are opened for input by default, so the statement
	ifstream inClientFile("arthemis.txt");
opens arthemis.txt for input. Just as with an ofstream object, an ifstream object can be created without opening a specific file, because a file can be attached to it later.
>> ENSURING THAT THE FILE WAS OPENED // >> TEST IF FILE OPEN / >> OPEN FILE TEST / >> CHECK FILE OPEN / >> OPEN FILE CHECK
[pag606deitel] from example /home/dia/Deitel-Code_Examples/ch14/fig14_06
   // exit program if ifstream could not open file
   if ( !inClientFile ) 
   {
      cerr << "File could not be opened" << endl;
      exit( EXIT_FAILURE );
   } // end if
///////////////////
>> READ FROM FILE 
from example /home/dia/Deitel-Code_Examples/ch14/fig14_06
   // display each record in file
   while ( inClientFile >> account >> name >> balance )
      outputLine( account, name, balance );
/////
using function outputLine definita nelle righe 36-41 di fig14_06.cpp possiamo display i records
////////////////////
>> file position pointers / >> seekg / >> seekp
[pag607 deitel]
The file position pointer is an integer vlue that specifies the location in the file as a number of bytes from the file's starting location (this is also referred to as the >> offset from the beginning of the file). 
To retrieve data sequentially from a file, programs normally start reading from the beginning of the file and read all the data consecutively until the desired data is found. It might be necessary to process the file sequentially several times (from the beginning of the file) during the execution of a program. Both istream and ostream provide member functions for reprositioning the file position pointer (the byte number of the next byte in teh file to be read or written). These member functions are:
	>> seekg (= seek get) for istream and 
	>> seekp (= seek put) for ostream. 
Each istream object has a get pointer, which indicates the byte number in the file from which the next input is to occur, and each ostream object has a put pointer, which indicates the byte number in the file at which then next output should be placed. 
The statement
	inClientFile.seekg(0);
repositions the file-position pointer to the beginning of the file (location 0) attached to inClientFile. The argument to seekg is a long integer. A second argument can be specified to indicate the seek direction, which can be 
	>> ios::beg (the default) for positioning relative to the beginning of a stream, 
	>> ios::cur for positioning relative to the current position in a stream or 
	>> ios::end for positioning relative to the end of a stream.
EXAMPLES:
	// position to the nth byte of fileObject (assumes ios::beg)
	fileObject.seekg (n);
	// position n bytes forward in fileObject
	fileObject.seekg (n, ios::cur );
	// position n bytes back from en of fileObject
	fileObject.seekg (n, ios::end );
	// position at end of fileObject
	fileObject.seekg (0, ios::end );
The same operations can be performed using ostream member function seekp. Member functions 
	>> tellg
	>> tellp
are provided to return the current locations of the get an put pointer, respectively. The following statement assigns the get file-position pointer value to variable location of type long:
	location = fileObject.tellg();
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> copy algorithm pag 102 moo book 
the copy algorithm takes three iterators, which we'll call begin, end and out
	copy(begin, end, out)
and copies all the elements in the range [begin, end) to a sequence of elements starting at "out" and extending as far as necessary.
In other words:
	copy(begin, end, out)
has the same effect as 
	while (begin != end)
		*out++ = *begin++;
except that the while body changes the values of the iterators, and "copy" doesn't
NOTE: 
	*out++ = *begin++; 
e' la forma compatta di 
	*out = *begin;
	++out;
	++begin;
-----------------------------------------------------------------------------------
>> iterator adaptors [pag102 moo book]
Iterator adaptors are functions that yield iterators with properties that are related to their arguments in useful ways. The iterator adaptors are defined in <iterator>. The most common iterator adaptor is back_inserter, which takes a container as its arugment and yields an iterator that, when used as a destination, appends values to the container. For example, back_inserter(ret) is an iterator that, when used as a destination, appends elements to ret. Therefore,
	copy(bottom.begin(), bottom.end(), back_inserter(ret));
copies all of the elements of "bottom" and appends them to the end of ret. After this function completes, the size of ret will have increased by bottom.size(). 
/////////////////////////////////////////////////////////////////////////////////////////////////////

>> reverse algorithm / >> merge algorithm / >> unique algorithm / >> copy_backward
[pag711 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_08/fig16_08.cpp
output of the program:
	array a1 contains: 1 3 5 7 9
	array a2 contains: 2 4 5 7 9	
	After copy_backward, results contains: 1 3 5 7 9
	After merge of a1 and a2 results2 contains: 1 2 3 4 5 5 7 7 9 9
	After unique results2 contains: 1 2 3 4 5 7 9
	array a1 after reverse: 9 7 5 3 1
>> copy_backward
[pag712 deitel]
	 23    // place elements of a1 into results in reverse order
	 24    copy_backward( a1.cbegin(), a1.cend(), results.end() );
Line24 use the copy_backward algorithm to copy elements in the range from a1.cbegin() up to, but not including a1.cend(), placing the elements in results by starting from the element before results.end() and working toward the beginning of the array. The algorithm returns an iterator positioned at the last element copied into the results (i.e. the beginnig of results because of the backward copy). The elements are planed in results in the same order as a1. This algorithm requires three bidirectional iterator arguments (iterators that can be incremented and decremented to iterate forward and backward through a sequence, respectively).
Once difference between copy_backward and copy is that the iterator returned from copy_backward is positioned at the last element copied (i.e. the first element in the sequence). Also copy_backward can manipulate overlapping ranges of elements in a container as long as the first element to copy is not in the destination range of elements.
[cioe' se ho ben capito, alla fine (come si vede dall'esempio di output sopra, "results" contiene gli stessi elementi di a1, solo che l'ORDINE con cui sono stati copiati e' backward un po come se cominciassi a ricopiare un libro a partire dall'ultima pagina risalendo fino alla prima. Cio' non significa poi che la copia del libro abbia le pagine in ordine inverso, aperta la prima pagina avrai pag1, il fatto che pag1 sia stata copiata alla fine del processo di copiatura, non inverte l'ordine delle pagine)]
NB: in addition to the copy and copy_backward algorithms, C++11 now includes the move and move_backward algorithms. These use C++11's new move semantics (discussed in Chapter 24 C++11 additional feature) to move, rather than copy, objects from one container to another.
---------------------------------------------------------
>> merge algorithm 
[pag713 deitel]
	 30    // merge elements of a1 and a2 into results2 in sorted order
	 31    merge( a1.cbegin(), a1.cend(), a2.cbegin(), a2.cend(),
	 32       results2.begin() );
Lines 31-32 use the merge algorithm to combine two sorted ascending sequences of values into a third sorted ascending sequence.
---------------------------------------------------------
>> back_inserter / >> front_inserter / >> inserter iterator adapters
[pag713 deitel]
---------------------------------------------------------
>> duplicate >> list duplicate how to 
https://stackoverflow.com/questions/23465097/c-how-to-count-how-many-times-occur-the-same-string-in-a-list
int main()
{
  map<string,int> stringMap;

  for (int i=0;i<3;i++)
  {
    cout<<"Enter string: ";
    string s;
    cin>>s;
    if(stringMap.find(s)!=stringMap.end())
    {
      stringMap[s]++;
    }
    else
    {
      stringMap[s]=1;
    }

  }
  for (map<string,int>::const_iterator itr = stringMap.cbegin();  itr!=stringMap.cend(); ++itr)
  {
    if(itr->second > 1)
       cout<<itr->first << " occurs "<<itr->second<<" times"<<endl;
    else
       cout<<itr->first << " occurs "<<itr->second<<" time"<<endl;
  }
  return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> unique algorithm / >> duplicate remove >> rimuovi doppioni / >> doppioni removal
[pag713 deitel]
	 37    // eliminate duplicate values from results2
	 38    auto endLocation = unique( results2.begin(), results2.end() );
line38 uses the unique algorithm on on the sorted sequence of elements in the range from results2.begin() up to, but not including results2.end(). After this algorithm is applied to a sorted sequence with duplicate values, only a single copy of each value remains in the sequence. The algorithm takes two arguments that must be at least forward iterators. The algorithm returns an iterator positioned after the last element in the sequence of unique values. The values of all elements in teh container after the last unique value are undefined.
NOTE : to compile the program in linux workstation in order to avoid the following error we need to add the -std=c++11 tag therefore
message error:
/usr/include/c++/4.8.2/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.
SOLUTION 
# you need to copy from the USB to the local hard drive altrimenti dona problemi di eseguibile. Se esegui le seguenti istruzioni direttamente sui file della USB dona executable right issues
cd /home/alseny/CplusPlusPlayground/Deitel_Code_Examples/ch16/fig16_08
g++ -std=c++11 -o fig16_08.exe fig16_08.cpp
chmod -R 777 fig16_08.exe
[1038 fig16_08] >> ./fig16_08.exe 
	array a1 contains: 1 3 5 7 9 
	array a2 contains: 2 4 5 7 9 
	After copy_backward, results contains: 1 3 5 7 9 
	After merge of a1 and a2 results2 contains: 1 2 3 4 5 5 7 7 9 9 
	After unique results2 contains: 1 2 3 4 5 7 9 
	array a1 after reverse: 9 7 5 3 1 
---------------------------------------------------------
>> reverse algorithm 
[pag714 deitel]
	 43    cout << "\n\narray a1 after reverse: ";
	 44    reverse( a1.begin(), a1.end() ); // reverse elements of v1
line44 uses the reverse algorithm to reverse all the elements in the range from a1.begin() up to, but not including a1.end(). The algorithm takes two arguments that must be at least bidirectional iterators.
---------------------------------------------------------
>> copy_if algorithm
[pag714 deitel]
from C++11 you can find the copy algorithms copy_if and copy_n. The copy_if algorithm copies each element from a range if the unary predicate function in its fourth argument returns true for that element.
[cioe' suppongo sia della forma copy_if (a1.begin(), a1.end(), outputIterator, greaterThan)
- dove greaterThan e' una unary predicate function tipo quella di pag 708 deitel line 93 
bool greaterThan ( int value )
	{
		return value > 10;
	}
quindi solo i valori che sono piu' grandi di 10 verranno copiati.
- percio' che riguarda l'outputIterator e' della forma di pag 714 deitel line 14, cioe' fornisce il container in cui verranno copiati gli elementi di a1 soddisfacenti la condizione specificata in greaterThan 
]
>> copy_algorithm 
[pag714 deitel]
The copy_n algorithm copies the number of elements specified by its second argument from the location specified by its first argument (an input iterator). The elements are output to the location specified by its third argument (an output iterator).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> inplace_merge / >> unique_copy / >> reverse_copy
[pag714 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_09/fig16_09.cpp
OUTPUT [nota bene l'array initiale conteneva 1 3 5 7 9 1 3 5 7 9]
array a1 contains: 1 3 5 7 9 1 3 5 7 9
After inplace_merge, a1 contains: 1 1 3 3 5 5 7 7 9 9
After unique_copy results1 contains: 1 3 5 7 9
After reverse_copy, results2 contains: 9 9 7 7 5 5 3 3 1 1
//////////////////////////////////////////////////////////
>> inplace_merge 
[pag715 deitel]
   // merge first half of a1 with second half of a1 such that 
   // a1 contains sorted set of elements after merge
   inplace_merge( a1.begin(), a1.begin() + 5, a1.end() );
the previous line uses the inplace_merge algorithm to merge two sorted sequences of elements in the same container.
In the example the elements from a1.begin() + 5 up to, but not including a1.end(). This algorithm requires its three iterator arguments to be at least bidirectional iterators. A second version of this algorithm takes as a fourth argument a binary predicate function for comparing elements in the two sequences.
--------------------------------------------------
>> unique_copy algorithm [per copiare giusto un ]
[pag715 deitel]
 28    // copy only unique elements of v1 into results1
 29    unique_copy( a1.cbegin(), a1.cend(), back_inserter( results1 ) );
 30    cout << "\nAfter unique_copy results1 contains: ";
 31    copy( results1.cbegin(), results1.cend(), output );
line 29 uses the unique_copy algorithm to make a copy of all the unique elements in the sorted sequence of values from a1.cbegin() up to but not including, a1.cend(). The copied elements are placed into vector results1.
[nota come si usi >> back_insert in modo da inserire gli elementi piuttosto che sostituirli, in tal modo il vettore puo' crescere per storare elementi aggiuntivi]
The first two arguments mut be at least input iterators and the last must be at least an output iterator. In this example, we did not preallocate enough elements in results1 to store all the elements copied from a1. Instead, we use function back_inserter (defined in header <iterator>  [cfr line 7 #include <iterator>]) to add elements to the end of results1. The back_inserter uses vector's >> push_back member function to insert elements at the end of the vector. Because the back_inserter insers an element rather than replacing an existing element's value, the vector is able to grow to accommodate additional elements. A second version of the unique_copy algorithm takes as a fourth argument a binary predicate function for comparing elements for equality. 
------------------------------------------------------
For a >> push_back member function example see also pag 42 moo book
	vector<double> homework;  // the type of elements contained in a vector is specified within <> brackets, in this case "double"
 	double x;
	// invariant: `homework' contains all the homework grades read so far
	while (cin >> x)
		homework.push_back(x);   // it appends a new element to the end of the vector. As a side effect, it increases the size of the vector by one.
------------------------------------------------------
>> reverse_copy algorithm
[pag715 deitel]
 35    // copy elements of a1 into results2 in reverse order
 36    reverse_copy( a1.cbegin(), a1.cend(), back_inserter( results2 ) );
 37    cout << "\nAfter reverse_copy, results2 contains: ";
 38    copy( results2.cbegin(), results2.cend(), output );
line 36 uses the reverse_copy algorithm to make a reversed copy of the elements in the range a1.begin() up to , but not including, a1.cend(). The copied elements are inserted into results2 using a back_inserter object to ensure that the vector can grow to accommodate the appropriate number of elements copied. Algorithm reverse_copy requires first two iteartor arugments to be at least bidirectional iterators and its third to be at least an output iterator.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> RECURSIVE FUNCTION / >> RECURSION 
[pag248deitel]
For some problems, it's useful to have functions call themselves. A recursive function is a function that calls itself, either directly, or indirectly (through another function).
NB: the C++ standard document indicates that main should not be called within a program or recursively. Its sole purpose is to be the starting point for program execution.
- recursive call pag249deitel
- recursion step pag249deitel
- recursive factorial example : pag249
(a) Procession of recursive calls per calcolare il fattoriale di 5
5!                                                            Final value 120
5 * 4!                                              5 * 4! -> 120 is returned 
    4 * 3!                                  4 * 3! ->  24 is returned 
        3 * 2!                       3 * 2! ->  6 is returned            
            2 * 1!           2 * 1!  ->  2 is returned
                1   --> 1    ->  1 is returned
[dalla fig 6.27pag250 del testo si comprende meglio]
The succession of recursive calls proceeeds until 1! is evaluated to be 1, terminating the recursion. 
The the values are returned from each recursive calls to its caller until the final value is calculated and returned 
- pag 252deitel -> example using recursion: Fibonacci Series 
chiosa estetico-architetturale: The Fibonacci series occurs in nature and, in particular, describes a form of spiral. The ration of successive Fibonacci numbers converges on a constant value of 1.618... This number frequently occurs in nature and has been called the golden ratio or the golden mean. Humans tend to find the golden mean aesthetically pleasing. Architects often design windows, rooms, and buidings whose length and width are in the ratio of the golden mean (1.618). Postcards are often desinged with a golden mean length/width ratio.
- ITERATION vs RECURSION / RECURSION vs ITERATION 
[pag255]
> A recursive approach is generally chosen when the recursive approach more naturally mirrors the problem and results in a program that's easier to understand and debug. BUT recursion has negative. It repeatedly invokes the mechanism, and consequently the overhead of function calls. This can be expensive in both processor time and memory space. While ITERATION usually occurs within a function, so the overhead of repeated functions calls and extra memory assignment is omitted.
- SUMMARY of RECURSION EXAMPLES and EXERCISES in deitel book see table pag257
--------------------------------------------------------------------------------

>> RECURSION [pag124 jesse book] / >> direct recursion vs >> indirect recursion 
Direct Recursion = when the function calls itself
Indirect Recursion = when a function calls another function that then calls the first function.

>> REFERENCE PARAMETER 
[pag238 deitel]
a reference parameter is an alias for its corresponding argument in a function call.
Example: the following declaration in a function header
	int &count
when read from right to left is pronounced "count is a reference to an int" 
example : pass-by-value vs pass-by-reference a pag239
Nell'esempio puoi vedere come nella funzione squareByReference si usi nella line 35 un reference parameter &numberRef
	void squareByReference ( int &numberRef)
	{...}
numberRef punta/si riferisce ad un numero intero [per avere un esempio con mano di cio' che intendo dirti vedi l'esempio nella voce successiva >> REFERENCE AS ALIASES within a FUNCTION]. Cio' significa che quando nella funzione main chiamo la funzione inserendo come input la variabile z
	squareByReference( z );
tale variabile z potra' essere modificata direttamente dalla funzione chiamata. Forse guardando l'esempio direttamente potrai comprendere meglio che da queste parole in cui non riesco bene ad esprirti il concetto, tutto sommato semplice: il simbolo & messo prima del parametro tra le parentesi tonde della definizione della funzione fa si' che le operazioni effettuate sul parametro della funzione chiamata vengano applicate al parametro della funzione chiamante, e' una sorta di simbolic link. 
MA A CHE SERVE TUTTA QUESTA COMPLICATIONE? 
Serve ad esempio a migliorare la performance. Supponi di avere una grossa matrice su cui la funzione chiamata debba effettuare delle operazioni. Se effettuassi un passaggio by value, dovresti fare una copia dell'oggetto, la funzione chiamata quindi agisce sulla copia dell'oggetto. Se invece effettui un passaggio by reference la funzione chiamata non agisce su una copia dell'oggetto ma sull'oggetto stesso, e ti eviti la perdita di tempo di dover copiare grossi oggetti. 
[da pag239: for passing large objects, use a constant reference parameter to simulate the appearance and security of pass-by-value and avoid overhead of passing a copy of the large object.] 
 

>> REFERENCE AS ALIASES within a FUNCTION
[pag239-240]
References can also be used as aliases of other variables within a function
	int count = 1; // declare integer variable count
	int &cRef = count; //create cRef as an alias for count
	++cRef; / increment count (using its alias cRef)
All operations supposedly performed on the alis are actually performed on the original variable. The alias is simply another name for the original variable. 

>> REFERENCE pag177 chapter 6 mike game programming // >> REFERENCE OPERATOR / >> & REFERENCE OPERATOR
A reference provides another name for a variable. Whatever you do to a reference is done to the variable to which it refers. You can think of a reference for a variable (= another name that the variable goes by).
The example below declares and initializes a variable to hold a score and then creates a reference that refers to the variable.
To declare and initialize a reference, start with the type of value to which the reference will refer, followed by the reference operator (&), followed by the reference name, followed by =, followed by the variable to which the reference will refer. 
FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/referencing.cpp]
------------------------------------------------------------------------------------------------------------
		// Referencing
		// Demonstrates using references
		#include <iostream>
		using namespace std;
		int main()
		{
		    int myScore = 1000; // create variable to hold our score
		    int& mikesScore = myScore;  // create a reference: mikesScore is an alias for myScore. mikeScore does not hold its own "int" value; it's simply another way to get at the "int" value that myScore holds.
		    
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";
		    
		    cout << "Adding 500 to myScore\n";
		    myScore += 500;
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";  // this line will display the same value it access the same single chunk of memory. Remember there is only one value, and it is stored in the variable myScore. mikesScores simply provides another way to get to that value.
		
		    cout << "Adding 500 to mikesScore\n";
		    mikesScore += 500;
		    cout << "myScore is: " << myScore << "\n";
		    cout << "mikesScore is: " << mikesScore << "\n\n";
		
		    return 0;
		}
------------------------------------------------------------------------------------------------------------
NOTE: one way to understand references is to think of them as nicknames. For example, suppose you've got a friend named Eugene, and he (understandably) asks to be called by a nickname, Gibby, not much of an improvement, but it's what Eugene wants. So when you're at a party with your friend, you can call him over using either Eugene or Gibby. Your friend is only one person, but you can call him using either his name or a nick-name. In the same way, you can get to a single value stored in a variable by using its variable name or the name of a reference to that variable.
NOTE2: because a reference must always refer to another value, you must initialize the reference when you declare it. If you don't, you'll get a compile error. The following is quite illegal. 
	int& mikesScore;  // don't try this at home! 
NOTE3: A REFERENCE CANNOT BE REASSIGNED! A reference always refers to the variable with which it was initialized. You can't reassign a reference to refer to another variable so, for example, the results of the following code might not be obvious
	int myScore = 1000;
	int& mikesScore = myScore;
	int larrysScore = 2500; // corvette courtesy Duude Lebowsky
	mikesScore = larrysScore;
The line mikesScore = larryScore; does not reassign the reference mikesScore so it refers to larrysScore because a reference can't be reassigned. However, because mikesScore is just another name for myScore, the mikesScore = larrysScore; is equivalent to myScore = larrysScore;, which assigns 2500 to myScore. And after all is said and done, myScore becomes 2500 and mikesScore still refers to myScore.
NOTE4: references come in quite handy when you are passing variables to functions because when you pass a variable to a function, the function gets a copy of the variable. This means that the original variable you passed (called the argument variable) can't be changed. Sometimes this might be exactly what you want because it keeps the argument variable safe and unalterable.
FULL EXAMPLE
----------------------------------------------------------------------------
		// Swap
		// Demonstrates passing references to alter argument variables
		
		#include <iostream>
		
		using namespace std;
		
		void badSwap(int x, int y);  
		void goodSwap(int& x, int& y);  
		
		int main()
		{
		    int myScore = 150;
		    int yourScore = 1000;
		    cout << "Original values\n";
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		    
		    cout << "Calling badSwap()\n";
		    badSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n\n";
		        
		    cout << "Calling goodSwap()\n";
		    goodSwap(myScore, yourScore);
		    cout << "myScore: " << myScore << "\n";
		    cout << "yourScore: " << yourScore << "\n";
		
		    return 0;
		}
		
        // with this function only copies of the score values are sent to the function, the argument variables that hold the scores are unchanged
		void badSwap(int x, int y)  // passing argument by value // >> pass by value // >> argument by value / >> by value
		{
		    int temp = x;
		    x = y;
		    y = temp;
		} // when the function ends, both x and y go out of scope and cease to exist. Contro then returns to main(), where myScore and yourScore won't be changed
		
        // this function uses references, with this function the argument variables will be successfully exchanged
		void goodSwap(int& x, int& y)  // >> pass by reference // reference pass [pag184 mike programming game] 
		{
		    int temp = x;
		    x = y;
		    y = temp;
		}
/* NOTE: to pass by reference you must first declare the parameter as a reference. You can tell that a call to goodSwap() passes both arguments by reference by looking at the function header 
	void goodSwap(int& x, int& y);  
This means that when I call goodSwap(), the parameter x will refer to myScore and the parameter y will refer to yourScore. This means that x is just another name for myScore and y is just another name for yourScore. When goodSwap() executes and x and y exchange values, what really happens is that myScore and yourScore exchange values.
*/
----------------------------------------------------------------------------
OUTPUT PROGRAM 
	[2047 chapter06] >> ./swap 
	Original values
	myScore: 150
	yourScore: 1000
	
	Calling badSwap()
	myScore: 150
	yourScore: 1000
	
	Calling goodSwap()
	myScore: 1000
	yourScore: 150
NOTE >> EFFICIENCY PASS REFERENCES / >> PASSING REFERENCES FOR EFFICIENCY / >> PASS REFERENCE EFFICIENCY [pag14 mike programming game]
Passig a variable by value creates some overhead because you must COPY the variable before you assign it to a parameter. When we're talking about variables of simple, built-in types, such as an int or a float, the overhead is negligible. But a large object, such as one that represents an entire 3D world, could be expensive to copy. 
Passing by reference, on the other hand, is efficient because you don't make a copy of an argument variable. Instead, you simply provide access to the existing object through a reference. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> pass by value / >> by value [see also pag 109 jesse]
The arguments passed in to the function are local to the function. Changes made to the arguments do not affect the values in the calling function. This is known as >> passing by value, which means a local copy of each argument is made in the function. 
example :
// Listing 5.4 - demonstrates passing by value
#include <iostream>

using namespace std;   
void swap(int x, int y);
  
int main()
{
   int x = 5, y = 10;
  
   cout << "Main. Before swap, x: " << x << " y: " << y << endl;
   swap(x,y);
   cout << "Main. After swap, x: " << x << " y: " << y << endl;
   return 0;
}
  
void swap (int x, int y)
{
   int temp;
  
   cout << "Swap. Before swap, x: " << x << " y: " << y << endl;
  
   temp = x;
   x = y;
   y = temp;
  
   cout << "Swap. After swap, x: " << x << " y: " << y << endl;
}
////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE CONSTANT PASS / >> PASS CONSTANT REFERENCE / >> CONSTANT REFERENCE  [pag186 and 187 mike programming game]
A constant reference is a restricted reference. It acts like any other reference, except you can't use it to change the value to which it refers. To create a constant reference, simply put the keyword const before the type in the reference declaration. 
FULL PROGRAM [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/inventory_displayer.cpp]
-------------------------------------------------
	// Inventory Displayer
	// Demonstrates constant references
	
	#include <iostream>
	#include <string>
	#include <vector>
	
	using namespace std;
	
	//parameter vec is a constant reference to a vector of strings
	void display(const vector<string>& inventory);  // we put the keyword const before the type in the reference declaration to create a constant reference. It's like providing the function read-only access to the argument
	
	int main()
	{
	    vector<string> inventory;
	    inventory.push_back("sword");
	    inventory.push_back("armor");
	    inventory.push_back("shield");  
	    
	    display(inventory);  // this results in an efficient and safe function call. It's efficient because only a reference is passed; the vector is not copied. It's safe because the reference to the vector is a constant reference: inventory can't be changed by display().
	
	    return 0;
	}
	
	//parameter vec is a constant reference to a vector of strings
	void display(const vector<string>& vec)
	{
	    cout << "Your items:\n";
	    for (vector<string>::const_iterator iter = vec.begin(); 
	         iter != vec.end(); ++iter)
		{
	         cout << *iter << endl;
		}
	}
-------------------------------------------------
HINT: a constant reference comes in handy in another way. If you need to assign a constant value to a reference, you have to assign it to a constant reference. (A non constant reference won't do)
RESUME: >> PASS ARGUMENTS WAYS, how to choose [pag187 mike programming game]
there are three different ways to pass argument
	1) pass by value
	2) pass by reference 
	3) pass by constant reference
How do you decide which method to use. Here are some guidelines
1) By value: pass by value when an argument variable is one of the fundamental built-in types, such as bool, int or float. Objects of these types are so small that passing by reference doesn't result in any gain in efficiency. 
You should also pass by value when you want the computer to make a copy of a variable. You might want to use a copy if you plan to alter a parameter in a function, but you don't want the actual argument variable to be affected. 
2) as a constant reference: pass a constant reference when you want to efficiencly pass a value that you don't need to change.
3) as a reference: pass a reference only when you want to alter the value of the argument variable. However, you should try to avoid changing argument variables whenever possible. 
--------------------------------------------- Ulteriori informazioni about "references" from summary pag 207 mike game programming
- a reference is an alias; it's another name for a variable
- you creare a reference using & (= the referencing operator)
- a reference must be initialized when it's declared
- a reference can't be changed to refer to a different variable
- whatever you do to a reference is done to the variable to which the reference refers
- when you assign a reference to a variable, you create a new copy of the referenced valued
- when you pass a variable to a function by value, you pass a copy of the variable to the function
- when you pass a variable to a function by reference, you pass access to the variable.
- passing by reference can be more efficient than passing by value, especially when you are passing large objects
- passing a reference provides direct access to the argument variable passed to a function. As a result, the function can make changes to the argument variable
- a constant reference can't be used to change the value to which it refers. You declare a constant reference by using the keyword const
- you can't assign a constant reference or a constant value to a non constant reference
- passing a constant reference to a function protects the argument variable from being changed by that function 
- changing the value of an argument variable passed to a function can lead to confusion, so game programmers consider passing a constant reference before passing a non constant reference
- returning a reference can be more efficient than returning a copy of a value, especially when you are returning large objects
- you can return a constant reference to an object so the object can't be changed through the returned reference 
- a basic technique of game AI is to have the computer consider all of its legal moves and all of its opponent's legal replies before deciding which move to take next.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCE RETURN / >> RETURN from function [pag188 mike programming game]
Jus like when you pass a value, when you return a value from a function, you're really returning a COPY of the value. Again, for values of the asic built-in types, this isn't a big deal. However, it can be expensive operation if you're returning a large object. Returning a reference is an efficient alternative. 
FULL EXAMPLE [/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter06/inventory_referencer.cpp]
NOTE: before you can return a reference from a function, you must specify that you're returning one. That's what we do in the refToElement() function header:
	string& refToElement(vector<string>& inventory, int i); 
by using the reference operator string& when I specify the return type, I'm saying that the function will return a reference to a string object (not a string object ifself). You can use the reference operator & as we did to specify that a function returns a reference to an object of particular type.Simply put the reference operator after the type name.
--------------------------------------------------- FULL EXAMPLE start
		// Inventory Referencer
		// Demonstrates returning a reference
		
		#include <iostream>
		#include <string>
		#include <vector>
		
		using namespace std;
		
		//returns a reference to a string
		string& refToElement(vector<string>& inventory, int i); 
		
		int main()
		{
		    vector<string> inventory;
		    inventory.push_back("sword");
		    inventory.push_back("armor");
		    inventory.push_back("shield");
		
		    //displays string that the returned reference refers to 
		    cout << "Sending the returned reference to cout:\n";   
		    cout << refToElement(inventory, 0) << "\n\n";   // display the first item through a returned reference
		
		    //assigns one reference to another -- inexpensive assignment 
            // >> REFERENCE TO REFERENCE ASSIGNMENT [pag191 mike programming] 
		    cout << "Assigning the returned reference to another reference.\n";
		    string& rStr = refToElement(inventory, 1);  // this is an efficient assignment because assigning a reference to a reference does not involve the copying of an object.
		    cout << "Sending the new reference to cout:\n";
		    cout << rStr << "\n\n";
		
		    //copies a string object -- expensive assignment
		    cout << "Assigning the returned reference to a string object.\n";
		    string str = refToElement(inventory, 2);  // note : this line does not assign a reference to str. It can't , because str is a string object. Instead the code copies the element to which the returned reference refers and assign that new copy of the string object to str. Because this kind of assignment involves copying an object, it's more expensive than assigning one reference to another. 
		    cout << "Sending the new string object to cout:\n";
		    cout << str << "\n\n";
		    
		    //altering the string object through a returned reference
		    cout << "Altering an object through a returned reference.\n";
		    rStr = "Healing Potion"; // because rStr refers to the element in position 1 of inventory, this code changes inventory[1] so it's equal to "Healing Potion"
		    cout << "Sending the altered object to cout:\n";
		    cout << inventory[1] << endl;		
		    return 0;
		}
		
		//returns a reference to a string
		string& refToElement(vector<string>& vec, int i)
		{
		    return vec[i];   // this line returns a reference to the element at position i in the vector. Notice that there is nothing in the return statement to indicate that the function returns a reference. The function header and prototype determine whether a function returns an object or a reference to an object.
		}
--------------------------------------------------- FULL EXAMPLE END 
NOTE TRAP: Altough returning a reference can be an efficient way to send information back to a calling function, you have to be careful not to return a reference to an >> out of scope object (= an object that ceases to exist). For example, the following function returns a reference to a string object that no longer exists after the function ends (that's illegal)
----------
	string& badReference()
	{
		string local = "This string will cease to exist once the function ends.";
		return local;
	}
----------
Once way to avoid this type of problem is to NEVER RETURN A REFERENCE TO A LOCAL VARIABLE
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> REFERENCES FULL EXAMPLE  TIC TAC TOE GAME 

			// Tic-Tac-Toe
			// Plays the game of tic-tac-toe against a human opponent
			
			#include <iostream>
			#include <string>
			#include <vector>
			#include <algorithm>
			
			using namespace std;
			
			// global constants
			const char X = 'X';
			const char O = 'O';
			const char EMPTY = ' ';
			const char TIE = 'T';
			const char NO_ONE = 'N';
			
			// function prototypes
			void instructions();
			char askYesNo(string question);
			int askNumber(string question, int high, int low = 0);
			char humanPiece();
			char opponent(char piece);
			void displayBoard(const vector<char>& board);
			char winner(const vector<char>& board);
			bool isLegal(const vector<char>& board, int move);
			int humanMove(const vector<char>& board, char human);
			int computerMove(vector<char> board, char computer);
			void announceWinner(char winner, char computer, char human);
			
			// main function
			int main()
			{
			    int move;
			    const int NUM_SQUARES = 9;
			    vector<char> board(NUM_SQUARES, EMPTY);
			
			    instructions();
			    char human = humanPiece();
			    char computer = opponent(human);
			    char turn = X;
			    displayBoard(board);
			
			    while (winner(board) == NO_ONE)
			    {
			        if (turn == human)
			        {
			            move = humanMove(board, human);
			            board[move] = human;
			        }
			        else
			        {
			            move = computerMove(board, computer);
			            board[move] = computer;
			        }
			        displayBoard(board);
			        turn = opponent(turn);
			    }
			
			    announceWinner(winner(board), computer, human);
			
			    return 0;
			}
			
			// functions
			void instructions()
			{
			    cout << "Welcome to the ultimate man-machine showdown: Tic-Tac-Toe.\n";
			    cout << "--where human brain is pit against silicon processor\n\n";
			
			    cout << "Make your move known by entering a number, 0 - 8.  The number\n";
			    cout << "corresponds to the desired board position, as illustrated:\n\n";
			    
			    cout << "       0 | 1 | 2\n";
			    cout << "       ---------\n";
			    cout << "       3 | 4 | 5\n";
			    cout << "       ---------\n";
			    cout << "       6 | 7 | 8\n\n";
			
			    cout << "Prepare yourself, human.  The battle is about to begin.\n\n";
			}
			
			char askYesNo(string question)
			{
			    char response;
			    do
			    {
			        cout << question << " (y/n): ";
			        cin >> response;
			    } while (response != 'y' && response != 'n');
			
			    return response;
			}
			
			int askNumber(string question, int high, int low)
			{
			    int number;
			    do
			    {
			        cout << question << " (" << low << " - " << high << "): ";
			        cin >> number;
			    } while (number > high || number < low);
			
			    return number;
			}
			
			char humanPiece()
			{
			    char go_first = askYesNo("Do you require the first move?");
			    if (go_first == 'y')
			    {
			        cout << "\nThen take the first move.  You will need it.\n";
			        return X;
			    }
			    else
			    {
			        cout << "\nYour bravery will be your undoing... I will go first.\n";
			        return O;
			    }
			}
			
			char opponent(char piece)
			{
			    if (piece == X)
				{
			        return O;
				}
			    else
				{
			        return X;
				}
			}
			
			void displayBoard(const vector<char>& board)
			{
			    cout << "\n\t" << board[0] << " | " << board[1] << " | " << board[2];
			    cout << "\n\t" << "---------";
			    cout << "\n\t" << board[3] << " | " << board[4] << " | " << board[5];
			    cout << "\n\t" << "---------";
			    cout << "\n\t" << board[6] << " | " << board[7] << " | " << board[8];
			    cout << "\n\n";
			}
			
			char winner(const vector<char>& board)
			{
			    // all possible winning rows
			    const int WINNING_ROWS[8][3] = { {0, 1, 2},
			                                     {3, 4, 5},
			                                     {6, 7, 8},
			                                     {0, 3, 6},
			                                     {1, 4, 7},
			                                     {2, 5, 8},
			                                     {0, 4, 8},
			                                     {2, 4, 6} };
			    const int TOTAL_ROWS = 8;
			
			    // if any winning row has three values that are the same (and not EMPTY),
			    // then we have a winner
			    for(int row = 0; row < TOTAL_ROWS; ++row)
			    {
			        if ( (board[WINNING_ROWS[row][0]] != EMPTY) &&
			             (board[WINNING_ROWS[row][0]] == board[WINNING_ROWS[row][1]]) &&
			             (board[WINNING_ROWS[row][1]] == board[WINNING_ROWS[row][2]]) )
			        {
			            return board[WINNING_ROWS[row][0]];
			        }
			    }
			
			    // since nobody has won, check for a tie (no empty squares left)
			    if (count(board.begin(), board.end(), EMPTY) == 0)
			        return TIE;
			
			    // since nobody has won and it isn't a tie, the game ain't over
			    return NO_ONE;
			}
			
			inline bool isLegal(int move, const vector<char>& board)
			{
			    return (board[move] == EMPTY);
			}
			
			int humanMove(const vector<char>& board, char human)
			{
			    int move = askNumber("Where will you move?", (board.size() - 1));
			    while (!isLegal(move, board))
			    {
			        cout << "\nThat square is already occupied, foolish human.\n";
			        move = askNumber("Where will you move?", (board.size() - 1));
			    }
			    cout << "Fine...\n";
			
			    return move;
			}
			
			int computerMove(vector<char> board, char computer)
			{ 
			    unsigned int move = 0;
			    bool found = false;
			
			    //if computer can win on next move, that's the move to make
			    while (!found && move < board.size())
			    {
			        if (isLegal(move, board))
			        {
						//try move
			            board[move] = computer;
			            //test for winner
			            found = winner(board) == computer;   
						//undo move
			            board[move] = EMPTY;
			        }
			
			        if (!found)
			        {
			            ++move;
			        }
			    }
			  
			    //otherwise, if opponent can win on next move, that's the move to make
			    if (!found)
			    {
			        move = 0;
			        char human = opponent(computer);
			
			        while (!found && move < board.size())
			        {
			            if (isLegal(move, board))
			            {
							//try move
							board[move] = human;  
							//test for winner
			                found = winner(board) == human;     
						    //undo move
							board[move] = EMPTY;        
			            }
			
			            if (!found)
			            {
			                ++move;
			            }
			        }
			    }
			
			    //otherwise, moving to the best open square is the move to make
			    if (!found)
			    {
			        move = 0;
			        unsigned int i = 0;
			
			        const int BEST_MOVES[] = {4, 0, 2, 6, 8, 1, 3, 5, 7};
			        //pick best open square
			        while (!found && i <  board.size())
			        {
			            move = BEST_MOVES[i];
			            if (isLegal(move, board))
			            {
			                found = true;
			            }
			
			            ++i;
			        }
			    }
			
			    cout << "I shall take square number " << move << endl;
				return move;
			}
			
			void announceWinner(char winner, char computer, char human)
			{
				if (winner == computer)
			    {
			        cout << winner << "'s won!\n";
			        cout << "As I predicted, human, I am triumphant once more -- proof\n";
			        cout << "that computers are superior to humans in all regards.\n";
			    }
			
				else if (winner == human)
			    {
			        cout << winner << "'s won!\n";
			        cout << "No, no!  It cannot be!  Somehow you tricked me, human.\n";
			        cout << "But never again!  I, the computer, so swear it!\n";
			    }
			
				else
			    {
			        cout << "It's a tie.\n";
			        cout << "You were most lucky, human, and somehow managed to tie me.\n";
			        cout << "Celebrate... for this is the best you will ever achieve.\n";
				}
			}
---------------------------------------------------------------------------------------------
NOTE: in the real world: Game Designers work countless hours on concept papers, design documents, and prototypes before programmers write any game code. Once the design work is done, the programmers start their work (more planning). It's only after programmers write their own technical designs that they then begin coding in earnest. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCES [pag256 jesse book]
Pointers can be used to manipulate objects on the free store and to refer to those objects indirectly. References give you almost all the power of pointers but with a much easier syntax. 
>> REFERENCE definizione: A reference is an alias; when you create a reference, you initialize it with the name of another object, the target. From that moment on, the reference acts as an alternative name for the target, and anything you do to the reference is really done to the target.
You create a reference by writing the type of the target object, followed by the name of the reference, followed by an equal sign, followed by the name of the target object.
References can have any legal variable name, but some programmers prefer to prefix reference names with the letter "r". Thus, if you have an integer variable name someInt, you can make a reference to that variable by writing the following:
		int &rSomeRef = someInt;
This statement  is read as "rSomeRef is a reference to an integer". The reference is initialized to refer to "someInt". 
NOTE: References differ from other variables that you can declare in that they must be initialized when they are declared. If you try to create [jajaja mi ricordava pulp fiction jules "if you dare to create"...] a reference variable without assigning, you receive a compiler error. 
NOTE2: the space before the reference operator is required; the space between the reference operator and the name of the reference variable is optional 
	int &rSomeRef = someInt; // OK
	int & rSomeRef = someInt; // OK  [direi quasi quasi che preferisco la seconda]
NOTE3: note that the reference operator (&) is the same symbol as the one used for the address-of operator. These are not the same operator, however, although clearly they are related. [well thank you for that observation. Look like "The hippo comes out at night. But I don't remember why" sono related e non son la stessa. E non apporti spiegazioni aggiuntive. Ciccio spiega: secondo me cio' che vuol dire e'. L'  "&", when used as address-of operator, obtains the memory address of its operand. E non dev'essere preceduto dal type di cio' a cui sta puntando. Il "&" when used as reference operator dev'essere preceduto dal type dell'oggetto a cui sta targetta. Cosi' come "&" address-of ti fa ottenere l'indirizzo a cui si puntava , & reference ti fa ottenere l'oggetto a cui si targetta/punta. ]	
Example
	//Listing 9.1 - Demonstrating the use of references
	  
	#include <iostream>
	 
	int main()
	{
		using namespace std;
		int  intOne;  // local variable is declared
		int &rSomeRef = intOne;  // the reference rSomeRef is declared and initialized to refer to the integer intOne
	  
		intOne = 5;
		cout << "intOne: " << intOne << endl;
		cout << "rSomeRef: " << rSomeRef << endl;
	  
		rSomeRef = 7; // since rSomeRef is a reference, it is an alias for intOne, and thus the 7 is really assigned to intOne
		cout << "intOne: " << intOne << endl;    // ecco perche' nell'output dello screen vedrai che intOne = rSomeRef = 7 
		cout << "rSomeRef: " << rSomeRef << endl;
		
		return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------------------------
>> ADDRESS-OF OPERATOR (&) ON REFERENCES / >> & ON REFERENCES [pag257 jesse book]
What happens if you take the address of a reference variable? If you ask a reference for its address, it returns the address of its target. That is the nature of references. They are aliases for the target.  The following listing demonstrates taking the address of a reference variable called rSomeRef. 
------------------------------
//Listing 9.2 - Demonstrating the use of references
  
#include <iostream>
  
int main()
{
    using namespace std;
    int  intOne;
    int &rSomeRef = intOne;  // rSomeRef is initialized as a reference to intOne; in this line "&" is used to declare a reference to an integer
	                                               
  
    intOne = 5;
    cout << "intOne: " << intOne << endl;
    cout << "rSomeRef: " << rSomeRef << endl;
  
    cout << "&intOne: "  << &intOne << endl;              // here "&" e' utilizzato per return the address of the integer variable intOne
    cout << "&rSomeRef: " << &rSomeRef << endl;    // here "&" e' utilizzato per return the address of the reference "rSomeRef" che altri non e' che un alias di intOne e quindi dona lo stesso indirizzo. Be careful to distinguish "&" like used in the line "int &rSomeRef = intOne;" above from the "&" used to return an address. The compiler knows how to distinguish these two uses by the context in which they are being used.
  
    return 0;
}
-----------------------------
OUTPUT  [compiled and run via DEVC++ on windows 7]
	intOne: 5
	rSomeRef: 5
	&intOne: 0x22fe34
	&rSomeRef: 0x22fe34     
as expected the 2 address are identical.	
-----------------------------
NOTE: C++ gives you no way to access the address of the reference itself because it is not meaningul as it would be if you were using a pointer or other variable. References are initialized when created, and they always act as a synonym for their target, even when the address-of operator is applied. 
For example, if you have a class called President, you might declare an instance of that class as follows
	President Donald_Trump; 
You might then declare a reference to President and initialize it with this object 
	President &MightyPresidentOfAllTimes = Donald_Trump;
One one President exists; both identifiers refer to the same object of the same class. Any action you take on MightyPresidentOfAllTimes is taking on Donald_Trump as well.
-------------------------------
NOTE2 [pag259 jesse book] Reference variables CANNOT be reassigned! Reference variables are always aliases for their target. What appears to be a reassignment turns out to bve the assignment of a new value to the target. See the following example:
//Listing 9.3 - Reassigning a reference
  
#include <iostream>
  
int main()
{
   using namespace std;
   int  intOne; // integer variable is declared 
   int &rSomeRef = intOne; // reference to an integer is declared

   intOne = 5;
   cout << "intOne:    " << intOne << endl;
   cout << "rSomeRef:  " << rSomeRef << endl;
   cout << "&intOne:   "  << &intOne << endl;
   cout << "&rSomeRef: " << &rSomeRef << endl;
  
   int intTwo = 8;  
   rSomeRef = intTwo;  // not what you think! rSomeRef continues to refer to intOne
   cout << "\nintOne:    " << intOne << endl;
   cout << "intTwo:    " << intTwo << endl;
   cout << "rSomeRef:  " << rSomeRef << endl;
   cout << "&intOne:   "  << &intOne << endl;
   cout << "&intTwo:   "  << &intTwo << endl;
   cout << "&rSomeRef: " << &rSomeRef << endl;
   return 0;
}
---------------------------------- OUTPUT
intOne:    5
rSomeRef:  5
&intOne:   0x22fe34
&rSomeRef: 0x22fe34

intOne:    8
intTwo:    8
rSomeRef:  8
&intOne:   0x22fe34
&intTwo:   0x22fe30
&rSomeRef: 0x22fe34           <- nota come rSomeRef continues to refer to intOne and not intTwo
-----------------------------------
NOTE: in the line " rSomeRef = intTwo;" above, the programmer tries to reassign rSomeRef to now be an alias to the variable intTwo, but that is not what happens. What actually happens is that rSomeRef continues to act as an alias for intOne, so this assignment is equivalent to the following 
	intOne = intTwo;
Sure enough when the values of intOne and rSomeRef are printed, they are the same as intTwo.  In fact when the address are printed, you see
&intOne:   0x22fe34
&intTwo:   0x22fe30
&rSomeRef: 0x22fe34           <- nota come rSomeRef continues to refer to intOne and not intTwo
DO : 
	- DO use references to create an alias to an object
	- DO initialize all references 
DON'T
	- DON'T try to reassign a reference
	- DON'T confuse the address-of operator with the reference operator. 
------------------------------------------------------------------------------------
[pag260 jesse book] >> OBJECT REFERENCES / >> REFERENCING OBJECTS 
Any object can be referenced, including user defined objects. Note that you create a  reference to an object, but NOT to a class. For instance, your compiler will not allow this: 
		int & rIntRef = int;     // wrong!
You must initialize rIntRef to a particular integer, such as this: 
		int howBig = 200;
		int & rIntRef = howBig;
In the same way, you don't initialize a reference to a Cat: 
		Cat & rCatRef = Cat; // wrong!
You must initialize a reference to a particular Cat object:
		Cat Frisky;
		Cat & rCatRef = Frisky;
References to objects are used just like the object itself. Member data and methods are accessed using the normal class memeber access operator (.) and just as with the built-in types, the reference acts as an alias to the object. 
The following example illustrates this: 
// Listing 9.4 - References to class objects
  
#include <iostream>
  
class SimpleCat
{
 public:
    SimpleCat (int age, int weight);
    ~SimpleCat() {}
    int GetAge() { return itsAge; }
    int GetWeight() { return itsWeight; }
  private:
    int itsAge;
    int itsWeight;
};
  
SimpleCat::SimpleCat(int age, int weight)
{
   itsAge = age;
   itsWeight = weight;
}
  
int main()
{
   SimpleCat Frisky(5,8); // we declare Frisky as a SimpleCat object. 
   SimpleCat & rCat = Frisky; //  the reference "rCat" is declared and initialized to refer to "Frisky"
  
   std::cout << "Frisky is: ";
   std::cout << Frisky.GetAge() << " years old." << std::endl; // here we access the method GetAge using the SimpleCat object "Frisky"
   std::cout << "And Frisky weighs: ";
   std::cout << rCat.GetWeight() << " pounds." << std::endl;  // in this line we access the method GetWeight 
                                                                                                            // using the SimpleCat reference "rCat"
   return 0;                                                                                          // note that the access is identical, si usa come al solito il "." operator
}                                                                                                           // Again, the reference is an alias for the actual object.
----------------------------
OUTPUT 
Frisky is: 5 years old.
And Frisky weighs: 8 pounds.
-------------------------------------------------------------------
Riassumendo 
REFERENCES : references act as an alias to another variable. Declare a reference by writing the type, followed by the reference operator (&), followed by the reference name. References must be initialized at the time of creation. 

Example 1
	int hisAge;	
	int &rAge = hisAge; // qui effettuiamo una reference a una variabile, cioe' detto in parole spicciole creiamo un alias, un poco come quando in uno script ./basrch per evitare di dover digitare tutte le volte un lungo path si crea un alias "OF17"
Example 2
	Cat Boots;
	Cat &rCatRef = Boots; // qui effettuiamo una reference all'oggetto Boots appartenente alla classe Cat.
// Ci sono ci sono! cominciamo a comprendere e sentirsi a nostro agio nel mondo degli Objects!	
------------------------------------------------------------------------------------------------------------------
>> NULL POINTERS and NULL REFERENCES / >> REFERENCES NULL [pag262 jesse]	
When pointers are not initialized or when they are deleted, they ought to be assigned to null (0). This is not true for references because they must be initialized to what they reference when they are declared. 
However, because C++ needs to be usable for device drivers, embedded systems, and real time systems that can reach directly into the hardware, the ability to reference specific addresses is valuable and required. For this reason, most compilers support a null or numeric initialization of a reference without much complaint, crashing only if you try to use the object in some way when that reference would be invalid. 
Taking advantage of this in normal programming, however is still not a good idea. When you move your program to another machine or compiler, mysterious bugs might develop if you have hull references (it's a little bit like the gremlins. E poi valli tu a tritura tutti nei frullatori)
-----------------------------------------------------------------------
>> PASS ARGUMENTS / >> PASSING FUNCTION ARGUMENTS BY REFERENCE [pag262 jesse]
We have learned that functions have two limitations: arugments are passed by value and the return statement can return only a value. 
Passing values to a function by reference can overcome both of these limitations. In C++ passing a variable by reference is accomplished in two ways: using pointers and using references. Note the difference: you pass by reference using a pointer, or you pass a reference using a reference. 
The syntax of using a pointer is different from that of using  a reference, but the net effect is the same. Rather than a COPY being created withing the scope of the function, the actual original object is (effectively) made directly available to the function. 
Passing an object by reference enalbes the function to change the object being referred to. 
On day 5,  you learned that functions are passed their parameters on the stack. When a function is passed a value by reference (using either pointers or references), the address of the orignal object is put on the stack, not the entire object. In fact, on some computers, the address  is actually held in a register and nothing is put on the stack. In either case, because an address is being passed, the compiler knows how to get  to the original object, and changes are made there and not in a copy.
Nei due esempi qui sotto ti presentiamo il passing by value (che effettua una copia quindi l'oggetto originale resta inalterato) e il passing by reference or with pointer in cui si modifica l'oggetto originale
-------------------------------------------------------------------- Demonstrating passing by value [the original value does not change]
	//Listing 9.5 - Demonstrates passing by value
	#include <iostream>
	  
	using namespace std;
	void swap(int x, int y);
	  
	int main()
	{
		int x = 5, y = 10;
	  
		cout << "Main. Before swap, x: " << x << " y: " << y << endl;
		swap(x,y);
		cout << "Main. After swap, x: " << x << " y: " << y << endl;
		return 0;
	}
	  
	void swap (int x, int y)
	{
		int temp;
	  
		cout << "Swap. Before swap, x: " << x << " y: " << y << endl;
	  
		temp = x;
		x = y;
		y = temp;
	  
		cout << "Swap. After swap, x: " << x << " y: " << y << endl;
	}
-------------------------------------------------------------------------
	OUTPUT 
	Main. Before swap, x: 5 y: 10
	Swap. Before swap, x: 5 y: 10
	Swap. After swap, x: 10 y: 5
	Main. After swap, x: 5 y: 10
come puoi vedere i valore in main restano inalterati, i valori non sono stati scambiati. 
To swap the values in main, tow way are possible in C++: you can make the parameters of swap() pointers to the original values, or you can pass in references to the original values. 
-------------------------------------------------------------------- MAKING swap() work with pointers
	//Listing 9.6 Demonstrates passing by reference
	#include <iostream>
	  
	using namespace std;
	void swap(int *x, int *y);     // nota come qui stiamo utilizzando pointer  to the variables rather than "void swap (int x, int y) "
	  
	int main()
	{
		int x = 5, y = 10;
	  
		cout << "Main. Before swap, x: " << x << " y: " << y << endl;
		swap(&x,&y);
		cout << "Main. After swap, x: " << x << " y: " << y << endl;
		return 0;
	}
	  
	void swap (int *px, int *py)
	{
		int temp;
	  
		cout << "Swap. Before swap, *px: " << *px <<
		   " *py: " << *py << endl;
	  
		temp = *px;
		*px = *py;
		*py = temp;
	  
		cout << "Swap. After swap, *px: " << *px << 
		   " *py: " << *py << endl; 
	}
-----------------------------------------------------
OUTPUT	
Main. Before swap, x: 5 y: 10
Swap. Before swap, *px: 5 *py: 10
Swap. After swap, *px: 10 *py: 5
Main. After swap, x: 10 y: 5        <---- come puoi vedere ora anche i valori in main sono stati scambiati.
------------------------------------------------
ANALYSIS of the program: when you pass a pointer you pass in the address of the object, and thus the function  can manipulate the value at that address. To make swap() change the actual values of x and y by using pointers, the function swap() needs to be declared to accept two int pointers. Then by dereferencing the points, the values of x and y will actuall be accessed and swapped. 
Using pointers to pass by reference as shown in the program above works, but the syntax is cumbersome in two ways. 
1) the repated need to dereference the pointers within the swap() function makes it prone error (for instance, if you fail to dereference the pointer, the compiler still lets you assign an integer to the pointer, and a subsequent user experiences an addressing error. This is also hard to read.)
2) the fact that the user need to pass the address of the variables in the calling function makes the inner workings of swap() too visible. It is a goal of an object-oriented language such as C++ to prevent the user of a function from worrying about how it works. Passing the pointers puts the burden on the calling function rather than where it belongs (on the function being called.). The following listing rewrites the swap() function using references:
--------------------------------------------------
//Listing 9.7 Demonstrates passing by reference
// using references!
#include <iostream>
  
using namespace std;
void swap(int &x, int &y);
  
int main()
{
    int x = 5, y = 10;
 
    cout << "Main. Before swap, x: " << x << " y: " 
       << y << endl;
  
    swap(x,y);  // here we call the function swap, but now are "x" and "y" and not their addresses that are passed. 
	                    // The calling function simply passes the variables
  
    cout << "Main. After swap, x: " << x << " y: " 
       << y << endl;
 
    return 0;
}
  
void swap (int &rx, int &ry)    // the variables are identified as references. Quindi tutto cio' che effettueremo su "rx" e "ry" verra' in realta' effettuato sulle variabili "x" e "y". "rx" e "ry" are just aliases for the original variables and can be used as such
{
    int temp;
  
    cout << "Swap. Before swap, rx: " << rx << " ry: " 
       << ry << endl;
 
    temp = rx;
    rx = ry;
    ry = temp;
  
  
    cout << "Swap. After swap, rx: " << rx << " ry: " 
       << ry << endl;
  
}
------------------------------------------------
OUTPUT
Main. Before swap, x: 5 y: 10
Swap. Before swap, rx: 5 ry: 10
Swap. After swap, rx: 10 ry: 5
Main. After swap, x: 10 y: 5
-------------------------------------------------
As you can see from this listing, references provide the convenient and ease of use of normal variables, with the power and pass-by-reference capability of pointers.
--------------------------------------------------------------------------------------------
>> function headers and prototypes [pag267 jesse book]
Listing 9.6 shows "swap()" using pointers
	swap(&x,&y);  
    ...
	void swap (int *px, int *py)  // using pointers
and Listing 9.7 shows it using references
    swap(x,y);  
	...
	void swap (int &rx, int &ry) // using references 
Using the function that takes references is easier, and the code is easier to read, but how does the calling function knows if the values are passed by references or by values? As a client (or user) of swap(), the programmer must ensure that "swap()" will, in fact, change the parameters. 
This is another use for the function prototype. By examining the parameters declared in the prototype, which is typically in a header file along with all  the other portotyes, the programmer knows that the values passed into swap() are passed by reference, and thus will be swapped properly 
If swap() had been a member function of a class, the class declaration, also available in a header file, would have supplied this information. 
[>> interface philosophy]
In C++ clients of classes and functions can RELY ON THE HEADER FILE to tell ALL THAT IS NEEDED. The header acts as the interface to the class or function. The actual implementation is hidden from the client. This enables the programmer to focus on the problem at hand and to use the class or function without concern for how it works.
When Colonel John Roebling designed the Brooklyn Bridge, he worried in detail about how the concrete was poured and now the wire for the bridge was manufactured. He was intimately involved in the mechanical and chemical processes required to create his materials. Today, however, engineers make more efficient use of their time by using well-understood building materials, without regard to how their manufacturer produced them.
It is the goal of C++ to enable programmers to rely on well-understood classes and functions without regard to their internal working. These "component parts" can be assembled to produce a program, much the same way wires, pipes, clamps and other parts are assembled to produce buildings and bridges.
In much the same way that an engineer examines the spec sheet for a pipe to determine its load-bearing capacity, volume, fitting size, and so forth, a C++ programmer reads the declaration of a function or class to determine what services it provides, what parameters it takes, and what values it returns.
----------------------------------------------------------------------
>> MULTIPLE VALUES RETURN / >> RETURNING MULTIPLE VARIABLES [pag268 jesse]
Functions can only return one value. What if you need to get two values back from a function? One way to solve this problem is to pass two objects into the function, by reference. The function can then fill the objects with the correct values. Because passing by reference allows a function to change the original objects, this effectively enables the function to return two pieces of information. This approach bypasses the return value of the function, which can then be reserve for reporting errors. 
Once again, this can be done by references or pointers. The following listing 9.8 demonstrates a function that returns three values: two as pointer parameters and one as the return value of the function. 
 ------------------------------------------------------------------------
 //Listing 9.8 - Returning multiple values from a function
  
#include <iostream>

using namespace std;
short Factor(int n, int* pSquared, int* pCubed);
  
int main()
{
    int number, squared, cubed;
    short error;
  
    cout << "Enter a number (0 - 20): ";
    cin >> number;
  
    error = Factor(number, &squared, &cubed);  // the "number" inputted from user and the addresses of "squared" and "cubed" are passed to the function Factor()
  
    if (!error)
    {
       cout << "number: " << number << endl;
       cout << "square: " << squared << endl;
       cout << "cubed: "  << cubed   << endl;
    }
    else
       cout << "Error encountered!!" << endl;
    return 0;
}
  
short Factor(int n, int *pSquared, int *pCubed)
{
    short Value = 0;
    if (n > 20)
       Value = 1;
    else
    {
	// nota come the values needed, il quadrato e il cubo di n are returned by changing the pointers that were passed into the function.
       *pSquared = n*n;    // These values are assigned to the original variables by the use of indirection.  
       *pCubed = n*n*n;  
       Value = 0;
    }
    return Value;
}
--------------------------------------------------------------------
OUTPUT
Enter a number (0 - 20): 3
number: 3
square: 9
cubed: 27
Process exited after 3.917 seconds with return value 0
続行するには何かキーを押してください . . .
-----------------------------------------------------------------------
TIP: because passing by reference or by pointer allows uncontrolled access to object attributes and methods, you should pass the minimum required for the function to do its job. This helps to ensure that the function is safer to use and more easily understandable.
-----------------------------------------------------------------------
[switching to linux workstation ALDRHII to give white house runway for composition take-off.]
Although list 9.8 (see program just above) works, it can be made easier to read and maintain by using references rather than pointers. The following 9.9 shows the same program rewritten to use references. 
[/home/alseny/edylab/CPlusPlusPlayGround/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day09/List0909.cpp]
----------------------------------------------------------------------- LISTING 9.9 using references
	//Listing 9.9
	// Returning multiple values from a function
	// using references
	#include <iostream>
	 
	using namespace std;
	  
	enum ERR_CODE { SUCCESS, ERROR }; // an enum has been added to make the return value easier to understand. 
                                                                     // cioe' ERR_CODE e' la variabile di ritorno della funzione. 
	  
	ERR_CODE Factor(int, int&, int&); // now Factor() is declared to take references to "squared" and "cubed" rather than to pointers.  This makes the manipulation far simpler and easier to understand.
	  
	int main()
	{
		int number, squared, cubed;
		ERR_CODE result;
	  
		cout << "Enter a number (0 - 20): ";
		cin >> number;
	  
		result = Factor(number, squared, cubed);
	  
		if (result == SUCCESS)
		{
		   cout << "number: " << number << endl;
		   cout << "square: " << squared << endl;
		   cout << "cubed: "  << cubed   << endl;
		}
		else
		   cout << "Error encountered!!" << endl;
		return 0;
	}
	  
	ERR_CODE Factor(int n, int &rSquared, int &rCubed)
	{
		if (n > 20)
		   return ERROR;   // simple error code
		else
		{
		   rSquared = n*n;
		   rCubed = n*n*n;
		   return SUCCESS;
		}
	}
--------------------------------------------------------------------------------------------------------------------------------------
LINUX launch 
g++ List0909.cpp -o List0909.exe
./List0909.exe
-------------------------------------------
OUTPUT
Enter a number (0 - 20): 4 
number: 4
square: 16
cubed: 64
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> EFFICIENCY / >> REFERENCE vs >> PASS by >> VALUE / >> pass by reference vs >> pass by value. [pag271 jesse]
Each time you pass an object into a function by value, a copy of the object is made. Each time you return an object from a function by value, another copy is made. These objects are copied onto the stack. Doing so takes time and memory. For small objects, such as built-in integer values this is a trivial cost. But with larger user-created objects the cost is greater. Copying them onto the stack can be very expensive in performance and meory consumption. 
Another cost occurs as well. With the classes you create, ech of these temporary copies is created when the compiler calls a special constructor: the copy constructor. The copy constructor is called each time a temporary copy of the object is put on the stack. When the temporary object is destroyed, which happens when the function returns, the object's destructor is called. If an object is returned by the function by value, a copy of that object must be made and destroyed as well. With large objects, these constructor and destructor called can be expensive in speed and use of memory. 
Here an example listing 9.10 showing how often the copy constructor and destructor are called. 
-------------------------------------------------------------------------------------------------------------------
//Listing 9.10 - Passing pointers to objects
  
#include <iostream>
  
using namespace std;
class SimpleCat
{
   public:
     SimpleCat ();              // constructor   
     SimpleCat(SimpleCat&);     // copy constructor
     ~SimpleCat();              // destructor
};
  
SimpleCat::SimpleCat()
{
    cout << "Simple Cat Constructor..." << endl;
}
  
SimpleCat::SimpleCat(SimpleCat&)
{
   cout << "Simple Cat Copy Constructor..." << endl;
}
  
SimpleCat::~SimpleCat()
{
   cout << "Simple Cat Destructor..." << endl;
}
  
SimpleCat FunctionOne (SimpleCat theCat);  // this is the first function that receives the "Cat" by value and then returns it by value
SimpleCat* FunctionTwo (SimpleCat *theCat); // this is the second function that receives a pointer to the object, rather than the object itself, and returns a pointer to the object. 
  
int main()
{
    cout << "Making a cat..." << endl;
    SimpleCat Frisky;  // a SimpleCat object named "Frisky" is instantiated
    cout << "Calling FunctionOne..." << endl;
    FunctionOne(Frisky);
    cout << "Calling FunctionTwo..." << endl;
    FunctionTwo(&Frisky);
    return 0;
}
  
// FunctionOne, passes by value
SimpleCat FunctionOne(SimpleCat theCat)
{
    cout << "Function One. Returning... " << endl;
    return theCat;
}
  
// functionTwo, passes by reference
SimpleCat* FunctionTwo (SimpleCat  *theCat)
{
    cout << "Function Two. Returning... " << endl;
    return theCat;
}
///////////////////////////////////////////////////////////////////////// OUTPUT 
COMPILING
g++ List0910.cpp -o List0910.exe
./List0910.exe 
OUTPUT: 
	Making a cat...
	Simple Cat Constructor...
	Calling FunctionOne...
	Simple Cat Copy Constructor...
	Function One. Returning... 
	Simple Cat Copy Constructor...
	Simple Cat Destructor...
	Simple Cat Destructor...
	Calling FunctionTwo...
	Function Two. Returning... 
	Simple Cat Destructor...
----------------------------------------------------------------------------
>> CONST POINTER PASS / >> PASSING CONSTANT POINTER [pag 274 jesse]
Also if (in the code above) passing a pointer to FunctionTwo() is more efficient, it is dangerous. 
	SimpleCat* FunctionTwo (SimpleCat  *theCat)
FunctionTwo() is not meant to be allowed to change the SimpleCat object it is passed, yet it is given the address of SimpleCat. This seriously exposes the original objecdt to change and defaults the protection offered in passing by value. 
Passing by value is like giving a museum a photograph of your masterpiece instead of the real thing. If vandals mark it up, there is no harm done to the original. Passing by reference is like sending your home address to the museum and inviting the guests to come over and look at the real thing.
The solution is to pass a pointer to a constant SimpleCat. Doing so prevents calling any non-const method on SimpleCat, and thus protects the object from change. 
Passing a constant reference allows your guests to see the original painting, but not to alter it in any way. [un po come lasciare vedere la Gioconda ma proteggendola dietro uno spesso vetro antiproiettile]
Here's an example: 
// LISTING 9.11 Passing pointer to a constant object 
	//Listing 9.11 - Passing pointers to objects
	  
	#include <iostream>
	  
	using namespace std;
	class SimpleCat
	{
	   public:
		 SimpleCat();
		 SimpleCat(SimpleCat&);
		 ~SimpleCat();
	  
		 int GetAge() const { return itsAge; }      // accessor constant function 
		 void SetAge(int age) { itsAge = age; }    // accessor non constant function 
	  
	   private:
		 int itsAge;
	};
	  
	SimpleCat::SimpleCat()
	{
		cout << "Simple Cat Constructor..." << endl;
		itsAge = 1;
	}
	  
	SimpleCat::SimpleCat(SimpleCat&)
	{
		 cout << "Simple Cat Copy Constructor..." << endl;
	}
	  
	SimpleCat::~SimpleCat()
	{
		cout << "Simple Cat Destructor..." << endl;
	}
	  
	const SimpleCat * const FunctionTwo 
		(const SimpleCat * const theCat);
	  
	int main()
	{
		cout << "Making a cat..." << endl;
		SimpleCat Frisky;
		cout << "Frisky is " ;
		cout << Frisky.GetAge();
		cout << " years old" << endl;
		int age = 5;
		Frisky.SetAge(age);
		cout << "Frisky is " ;
		cout << Frisky.GetAge();
		cout << " years old" << endl;
		cout << "Calling FunctionTwo..." << endl;
		FunctionTwo(&Frisky);
		cout << "Frisky is " ;
		cout << Frisky.GetAge();
		cout << " years old" << endl;
		return 0;
	}
	  
	// functionTwo, passes a const pointer
	const SimpleCat * const FunctionTwo 
		(const SimpleCat * const theCat)
	{
		cout << "Function Two. Returning..." << endl;
		cout << "Frisky is now " << theCat->GetAge();
		cout << " years old " << endl;
		// theCat->SetAge(8);   const!
		return theCat;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OUTPUT 
COMPILING 
	g++ List0911.cpp -o List0911.exe
	./List0911.exe 
OUTPUT 
Making a cat...
Simple Cat Constructor...
Frisky is 1 years old
Frisky is 5 years old
Calling FunctionTwo...
Function Two. Returning...
Frisky is now 5 years old 
Frisky is 5 years old
Simple Cat Destructor...
---------------------------------------------------------------------------------------------------------------------------------------------------------------
REFERENCES as an Alternative [pag 277 jesse]
Listing 9.11 solves the prolbme of making extra copies, and thus saves the calls to the copy constructor and destructor. It uses constant pointers to constant objects, and thereby solves the problem of the function changing  the object. It is still somewhat cumbersome however, because the objects passed to the function are pointers. 
Because you know the object will never be null, it would be easier to work within the function if a reference were passed, rather than a pointer. Listing 9.12 illustrates this: 
---------------------------------------------------------------------------------------------------------------------------------------------------------------
//Listing 9.12 - Passing references to objects
  
#include <iostream>
  
using namespace std;
class SimpleCat
{
   public:
     SimpleCat();
     SimpleCat(SimpleCat&);
     ~SimpleCat();
  
     int GetAge() const { return itsAge; }
     void SetAge(int age) { itsAge = age; }
  
   private:
     int itsAge;
};
  
SimpleCat::SimpleCat()
{
    cout << "Simple Cat Constructor..." << endl;
    itsAge = 1;
}
  
SimpleCat::SimpleCat(SimpleCat&)
{
    cout << "Simple Cat Copy Constructor..." << endl;
}
  
SimpleCat::~SimpleCat()
{
    cout << "Simple Cat Destructor..." << endl;
}
  
const     SimpleCat & FunctionTwo (const SimpleCat & theCat);
  
int main()
{ 
    cout << "Making a cat..." << endl;
    SimpleCat Frisky;
    cout << "Frisky is " << Frisky.GetAge() << " years old" << endl;
    int age = 5;
    Frisky.SetAge(age);
    cout << "Frisky is " << Frisky.GetAge() << " years old" << endl;
    cout << "Calling FunctionTwo..." << endl;
    FunctionTwo(Frisky);
    cout << "Frisky is " << Frisky.GetAge() << " years old" << endl;
    return 0;
}
  
// functionTwo, passes a ref to a const object
const SimpleCat & FunctionTwo (const SimpleCat & theCat)
{
    cout << "Function Two. Returning..." << endl;
    cout << "Frisky is now " << theCat.GetAge();
    cout << " years old " << endl;
    // theCat.SetAge(8);   const!
    return theCat;
}
//////////////////////////////////////// COMPILE 
 g++ List0912.cpp -o List0912.exe
./List0912.exe 
OUTPUT
	Making a cat...
	Simple Cat Constructor...
	Frisky is 1 years old
	Frisky is 5 years old
	Calling FunctionTwo...
	Function Two. Returning...
	Frisky is now 5 years old 
	Frisky is 5 years old
	Simple Cat Destructor...
-----------------------------------------------------------
The  output is identical to that produced by listing 9.11. The only significant change is that FunctionTwo() now takes and returns a reference to a constant object. Once again, working with references is somewhat simpler than working with  pointers, and the same savings and efficiency are achieved, as well as the safety provided by using "const"
NOTE: >> const references : C++ programmers do not usually differentiate between "constant reference to a SimpleCat object" and "referenceto a constant SimpleCat object". References themselves can never be reassigned to refer to another object, and so they are always constant. If the keyword "const" is applied to reference, it is to make the object referred to constant.
>> REFERENCES vs POINTERS / >> POINTERS vs REFERENCES [pag279 jesse]
Experienced C++ programmers strongly prefer references to pointers. References are cleaner and easier to use, and they do a better job of hiding information, as you saw in the previous example. 
References cannot be reassigned however. If you need to point first to one object and then to another, you must use a pointer. References cannot be null, so if any chance exists that the object in question might be null, you must not use a reference. You must use a pointer. 
An example of the latter concern is the operator new. If new cannot allocate memory on the free  store, it returns a null pointer. Because a reference shouldn't be null, you must not initialize a reference to this memory until you've checked that it is not null. The following example shows how to handle this. 
	int *pInt = new int;  // a pointer to int, "pInt" is declared and initialized with the memory returned by the operator new.
	if (pInt != NULL)   // the address of pInt is tested, if it is not null
		int &rInt = *pInt;   // then pInt is dereferenced. 
The result of dereferencing an int variable is an int object, and rInt is initialized to refer to that object. Thus, rInt becomes an alias to the int returned by the operator new. 
CONCLUDENDO 
- DO pass parameters by reference whenever possible 
- DO use "const" to protect references and pointers whenever possible
- DON'T use pointers if references will work
- DON'T try to reassign a reference to a different variable. You can't
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REFERENCES and POINTERS REMIX / >> MIXING REFERENCES AND POINTERS [pag280 jesse]
It is perfectly legal to declare both pointers and references in the same function parameter list, along with objects passed by value. Here's an example 
	Cat * SomeFunction (Person &theOwner, House *theHouse, int age);
This declaration says that SomeFunction takes three parameters. The first is a reference to a Person object, the second is a pointer to the House object, and the third is an integer. It returns a pointer to a Cat object. 
The question of where to put the reference (&) or the indirection operator (*) when declaring these variables is a great controversy. When declaring a reference, you can legally write any of the following 
A) Cat& rFrisky;    [the one you usually find in OpenFOAM]
B) Cat &rFrisky; 
C) Cat & rFrisky;
--------------------
Whitespace is completely ignored, so anywhere you see a space here you can put as many spaces, tab, and new lines as you want. 
Which of the three is the best? Here are the arguments for all three
A) rFrisky is a variable whose name is rFrisky and whose type can be thought of  as "reference to Cat object". Thus this argument goes, the & should be with the type. 
B) Those choosing this option say that in fact the type of rFrisky is not "reference to Cat object", the type is Cat. The & is part of the declarator which includes the variable name and the ampersand, so it is better for them to write Cat &rFrisky; 
Moreover they say when you declare more references and variable on the same line, for example 
	Cat& rFrisky, rBoots;
you could think that both rFrisky and rBoots are references to Cat objects, but it is not the case, only rFrisky is a reference to Cat, and rBoots is not a reference but just a plain old Cat variable. That's why for them it's more clear and less confusing to write 
	 Cat &rFrisky, rBoots;
Actually the author of this book suggest that also the above style should be avoided. It is better to declare reference and nonreference variables on different lines: 
	Cat& rFrisky;
	Cat  boots; 
C) Finally many programmers opt out of the argument and go with the middle position, that of putting the & in the middle of the 2
	Cat & rFrisky; 
Of course everything said so far about the reference operator (&)  applies equally well to the indirection operator (*)
NOTE:
- many programmers like the following conventions for declaring references  and pointers: 
	1) put the ampersand &	 and asterisk in the middle, with a space on either side. 
	2) never declare references, pointers and variables all on the same line. 
Ciccio estetically between 
1)
	Cat &rFrisky, rBoots;
2) 
	Cat& rFrisky;
	rBoots;
3) 
	Cat & rFrisky;
	rBoots;
I prefer 3. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>> OUT OF SCOPE REFERENCES / returning out of scope references [pag 281 jesse]
After C++ programmers learn to pass by reference, they have a tendency to go hog-wild. It is possible however, to overdo it. Remember that a reference is always an alias to some other object. If you pass a reference into or out of a function, be certain to ask yourself "What is the object I'm aliasing, and will it still exist every time it's used?"
The following listing 9.13 illustrates the danger of returning  a reference to an object that no longer exists. 
// Listing 9.13
// Returning a reference to an object
// which no longer exists
  
#include <iostream>
  
class SimpleCat
{
   public:
     SimpleCat (int age, int weight);
     ~SimpleCat() {}
     int GetAge() { return itsAge; }
     int GetWeight() { return itsWeight; }
   private:
     int itsAge;
     int itsWeight;
};
  
SimpleCat::SimpleCat(int age, int weight)
{
    itsAge = age;
    itsWeight = weight;
}
  
SimpleCat &TheFunction();
  
int main()
{
    SimpleCat &rCat = TheFunction();
    int age = rCat.GetAge();
    std::cout << "rCat is " << age << " years old!" << std::endl;
    return 0;
}
  
SimpleCat &TheFunction()
{
    SimpleCat Frisky(5,9);
    return Frisky;
}
/////--------------------------------------------------------------------------------------------------------------------------------
If we try to compile it on our linux machine we get : 
g++ List0913.cpp -o List0913.exe
List0913.cpp: In function ‘SimpleCat& TheFunction()’:
List0913.cpp:37:15: warning: reference to local variable ‘Frisky’ returned [-Wreturn-local-addr]
     SimpleCat Frisk
---------------------------------- if you try to compile it on the Borland compiler you get: 
	Compile error: Attempting to return a reference to a local object! 
La ragione e' che when TheFunction() returns, the local object, Frisky, is destroyed. The reference returned by this function is an alias to a non existing object, and this is a bad thing. Some compilers (come il nostro gcc compiler in Linux) are smart enough to catch this error and don't let you run the program. Others let you run the program with unpredictable results. 
One solution to this problem could be >> RETURN a reference to an object on the heap. 
If TheFunction() create Frisky on the heap, when you return from TheFunction(), Frisky still exists. With this approach the program will compile, links and appear to work BUT IT IS A TIME BOMB WAITING TO GO OFF!!! The problem with an approach like that is : what do you do with the memory allocated for Frisky when you are done with it? Listing 9.14 illustrate this problem: 
// Listing 9.14 - Resolving memory leaks
  
#include <iostream>
  
class SimpleCat
{
   public:
     SimpleCat (int age, int weight);
     ~SimpleCat() {}
     int GetAge() { return itsAge; }
     int GetWeight() { return itsWeight; }
  
   private:  
     int itsAge;
     int itsWeight;
};
  
SimpleCat::SimpleCat(int age, int weight)
{
     itsAge = age;
     itsWeight = weight;
}
  
SimpleCat & TheFunction();
  
int main()
{
    SimpleCat & rCat = TheFunction();
    int age = rCat.GetAge();
    std::cout << "rCat is " << age << " years old!" << std::endl;
    std::cout << "&rCat: " << &rCat << std::endl;
    // How do you get rid of that memory?
    SimpleCat * pCat = &rCat;
    delete pCat;
    // Uh oh, rCat now refers to ?? as stated earlier A REFERENCE MUST ALWAYS ALIAS AN ACTUAL OBJECT. If it references a null object the program is invalid. 
    return 0;
}

SimpleCat &TheFunction()
{
    SimpleCat * pFrisky = new SimpleCat(5,9);     // memory is allocated on the free store and assigned to a pointer 
    std::cout << "pFrisky: " << pFrisky << std::endl;
    return *pFrisky;
}
//------------------------------------------------------------------------------------------
The solution to avoid  using 
    delete pCat;
    // Uh oh, rCat now refers to ??
is to declare the object in the calling function and then to pass it to TheFunction() by reference. 
---------------------------------------------------------------------------------------------------------------------------------------
>> POINTER ownership [pag285 jesse book]
When your program allocates memory on the free store, a pointer is returned. It is imperative that you keep a pointer to that memory because after the pointer is lost, the memory cannot be deleted and becomes a memory leak. 
As you pass this block of memory between functions, someone will OWN the pointer. Typically the value in the block is passed using references, and the function that created the memory is the one that deletes it. But this is a general rule, not an ironclad one. 
It is dangerous for one function to create memory and another to free it, however. Ambiguity about who owns the pointer can lead to one of two problems: forgetting to delete a pointer or deleting it twice. Either one can cause serious problems in your program. It is safer to build your functions so that they delete the memory they create. 
If you are writing a function that needs to create memory and then pass it back to the calling function, consider changing your interface. Have the calling function allocate the memory and then pass it into your function by reference. This moves all memory management out of your program and back to the function that is prepared to delete it.
CONSIGLI
DO pass parameters by value when you must. 
DO return by value when you must. 
DON'T pass by reference if the item referred to might go out of scope.
DON'T lose track of when and where memory is allocated so you can be certain it is also freed.


>> OVERLOADED MEMBER FUNCTIONS  / >> OVERLOAD OPERATORS / >> DYNAMIC ALLOCATED VARIABLES [pag289 jesse book]
 //Listing 10.1 Overloading class member functions
 #include <iostream>
 
 // Rectangle class declaration
 class Rectangle
 {
   public:
     // constructors
     Rectangle(int width, int height);
     ~Rectangle(){}
 
     // overloaded class function DrawShape
     void DrawShape() const;                                         // OVERLOADING
     void DrawShape(int aWidth, int aHeight) const;    // OVERLOADING 
 // note that the version of DrawShape() that takes no parameters simply calls the version that takes two parameters, passing in the current member variables.
// ADVICE : try very hard to avoid duplicating code in two functions. Otherwise, keeping them in sync when changes are made to one or the other will be difficult and error-prone.
   private:
     int itsWidth;
     int itsHeight;
 };
 
 //Constructor implementation
 Rectangle::Rectangle(int width, int height)
 {
    itsWidth = width;
    itsHeight = height;
 }
 
 
 // Overloaded DrawShape - takes no values
 // Draws based on current class member values
 void Rectangle::DrawShape() const
 {
    DrawShape( itsWidth, itsHeight);
 }
 
 
 // overloaded DrawShape - takes two values
 // draws shape based on the parameters
 void Rectangle::DrawShape(int width, int height) const
 {
    for (int i = 0; i<height; i++)
    {
       for (int j = 0; j< width; j++)
       {
          std::cout << "*";
       }
    std::cout << std::endl;
    }
 }
 
 // Driver program to demonstrate overloaded functions
 int main()
 {
    // initialize a rectangle to 30,5
    Rectangle theRect(30,5);
    std::cout << "DrawShape():" << std::endl;
    theRect.DrawShape();
    std::cout << "\nDrawShape(40,2):" << std::endl;
    theRect.DrawShape(40,2);
    return 0;
 }
---------------------------------------------------------------------------------------------------------------------- END OF FILE 
 DEFAULT VALUES Alternative 
Just as global functions can have one or more default values, so can each member function of a class. The same rules apply for declaring the default values, as illustrated in the following listing Listing 10.2
//Listing 10.2 Default values in member functions
 
#include <iostream>
 
using namespace std;
 
// Rectangle class declaration
class Rectangle
{
   public:
     // constructors
     Rectangle(int width, int height);
     ~Rectangle(){}
     void DrawShape(int aWidth, int aHeight, 
          bool UseCurrentVals = false) const;
 
   private:
     int itsWidth;
     int itsHeight;
};
 
//Constructor implementation
Rectangle::Rectangle(int width, int height):
itsWidth(width),       // initializations
itsHeight(height)
{}                     // empty body
 
 
// default values used for third parameter
void Rectangle::DrawShape(
int width,
int height,
bool UseCurrentValue
) const                // end of the function header. nota che visto che gli spazi bianchi non contano in C++ 
{                          // l'header scritto sopra si sarebbe anche potuto scrivere: "void Rectangle::DrawShape(int width, int height, bool UseCurrentValue) const"
    int printWidth;
    int printHeight;
 
    if (UseCurrentValue == true)    // if  UseCurrentValue is true then the other 2 parameter width and height are completely ignored
    {
       printWidth = itsWidth;       // use current class values
       printHeight = itsHeight;
    }
    else      // 
    {
       printWidth = width;         // use parameter values
       printHeight = height;
    }
 
 
    for (int i = 0; i<printHeight; i++)
    {
       for (int j = 0; j< printWidth; j++)
       {
          cout << "*";
       }
       cout << endl;
    }
 }
 
// Driver program to demonstrate overloaded functions
int main()
{
    // initialize a rectangle to 30,5
    Rectangle theRect(30,5);
    cout << "DrawShape(0,0,true)..." << endl;
    theRect.DrawShape(0,0,true);
    cout <<"DrawShape(40,2)..." << endl;
    theRect.DrawShape(40,2);
    return 0;
}
----------------------------------------------------------------------------------------------------------------------
The two above programs 10.1 and 10.2 accomplish the same thing, but the overloaded functions in listing 10.1 are easier to understand and more natural to use. Default value will quickly become unusably complex as new variations are added. 
How do you decide whether to use function overloading or default values ? [>> overloading vs >> default values pag294]
Here's a rule of thumb: 
1) No reasonable default value exists. 
2) you need different algorithms. 
3) you need to support different types in your parameter list.
>> DEFAULT CONSTRUCTOR [pag294 jesse book]
The point of a constructor is to establish the object; for example, the point of a Rectangle constructor is to make a valid rectangle object. Before the constructor runs, no rectangle exists, only an area of memory. After the constructor finishes, there is a complete ready to use rectable object. This is a key benefit of object oriented programmig: the calling program does not have to do anything to ensure that the object stars in a self-consistent state.
As discussed on day 6 if you do not explicitly declare a constructor for your class, a default constructor is created that takes no parameters and does nothing. You are free to make your own constructor , however, that takes no arguments but that "sets up"  your object as required. 
The constuctor provided for your is called the "default" constructor, but by convention so is any constructor that takes no parameters. This can be a bit confusing, but it is usually clear which one is meant from the context. 
Take note that if you make any constructors at all, the default constructor is not provived by the compiler. So if you want a constructor that takes no parameters and you've created any other constructors, you must add the default constructor yourself!
>> CONSTRUCTOR OVERLOAD / >> OVERLOAD CONSTRUCTORS / >> OVERLOADING CONSTRUCTORS [pag295 jesse book]
Constructors, like all member functions, can be overloaded. The capability to overload constructors is very powerful and very flexible.  
For example you might have a rectangle object that has two constructors: the first that takes a length and a width and makes a rectangle of that size. The second that takes no values and makes a default sized rectangle. The following 10.3 listing implements this idea: 
---------------------------------------------------------------------------------------------------------------
 // Listing 10.3 - Overloading constructors
 
 #include <iostream>
 using namespace std;
 
 class Rectangle
 {
   public:
     Rectangle();   // declaration of the default constructor 
     Rectangle(int width, int length); // declaration of the second constructor which takes 2 integer variables
     ~Rectangle() {}
     int GetWidth() const { return itsWidth; }
     int GetLength() const { return itsLength; }
   private:
     int itsWidth;
     int itsLength;
 };
 
 Rectangle::Rectangle()
 {
    itsWidth = 5;
    itsLength = 10;
 }
 
 Rectangle::Rectangle (int width, int length)
 {
    itsWidth = width;
    itsLength = length;
 }
 
 int main()
 {
    Rectangle Rect1; // creating a rectangle using the default constructor. 
    cout << "Rect1 width: " << Rect1.GetWidth() << endl;     // and printing its
    cout << "Rect1 length: " << Rect1.GetLength() << endl;  // values 
 
    int aWidth, aLength;
    cout << "Enter a width: ";
    cin >> aWidth;
    cout << "\nEnter a length: ";
    cin >> aLength;
 
    Rectangle Rect2(aWidth, aLength); // calling the constructor taking two parameters
// Just as it does any overloaded function, the compiler chooses the right constructor, based on the number and type of the parameters. 
    cout << "\nRect2 width: " << Rect2.GetWidth() << endl;
    cout << "Rect2 length: " << Rect2.GetLength() << endl;
    return 0;
 }
-----------------------------------------------------------------------------------------------
>> OBJECT INITIALIZATION / >> INITIALIZING OBJECTS [pag 297 jesse book]
Up to now, we've been setting the member variables of objects in the body of the constructor. Constructors, however, are invoked in two stages : the initialization stage and the body. 
Most variables can be set in either stage, either by initializing in the initialization stage or by assigning  in the body of the constructor. It is cleaner and often more efficient to initialize member variables at the initialization stage. The following example shows how to initialize member variables: 

Cat():    // constructor name and parameters
itsAge(5),  itsWeight(100)         // initialization list, if more than a member variable needs to be initialized separated them by a ","
{ }         // body of constructor

Listing 10.4 shows the definition of the constructor from Listing 10.3 with initialization of the member variables in  the initialization portion of the constructor rather than by doing  assignments in the body : 
--------------------------------------------------------------------------
// Listing 10.4  Initializing Member Variables
Rectangle::Rectangle():       // default constructor definition 
    itsWidth(5),
    itsLength(10)
{
}

Rectangle::Rectangle (int width, int length):      // second constructor definition
    itsWidth(width),
    itsLength(length)
{
}
----------------------------------------------------------------------------
>> COPY CONSTRUCTOR [pag298 jesse]
In addition to providing a default constructor and destructor, the compiler provides a default copy constructor. The copy constructor is called every time a copy of an object is made. 
When you pass an object by value, either into a function or as a function's return value,  a temporary copy of that object is made. If the object is a user-defined object, the class's copy constructor is called. All copy constructors take one parameter, a reference to an object of the same class. It is a good idea to make it a constant reference because the constructor will not have to alter the object passed in. For example : 
	Cat(const Cat &  theCat);
Here, the Cat constructor takes a constant reference to an existing Cat object. The goal of this copy constructor is to make a copy of "theCat".  
The default copy constructor simply copies each member variable from the object passed as a parameter to the member variables of the new object. This is called a >> member-wise copy (or also called >> shallow copy), and although this is fine for most member variables, it breaks pretty quickly for member variables that are pointers to objects on the free store. 
A >> shallow or member wise copy copies the exact values of one object's member variables into another object. Pointers in both objects end up pointing to the same memory. 
A >> deep copy copies the values allocated on the heap to newly allocated memory. 
If the Cat class includes a member variable, itsAge, that is a pointer to an integer on the free store, the default copy constructor copies the passed-in Cat's itsAge member variable to the new Cat's itsAge member variable. The two objects now point to the same memory. 
This leads to a disaster when either Cat goes out of scope. If the original Cat's descructor frees his memory and the new Cat is still pointing to the memory, a stray pointer has been created, and the program is in mortal danger. The solution is to create your own copy constructor and to allocate the memory as required. After the memory is allocated the old values can be copied into the new memory. This is called a >> deep copy.  The following listing 10.5 illustrates how to do this: 
-----------------------------------------------------------------------------------------------------------------------------
 // Listing 10.5 - 
// Copy constructors

#include <iostream>
using namespace std;

class Cat
{
  public:
    Cat();              // default constructor is declared 
    Cat (const Cat &);  // copy constructor is declared; nota come  il constructor is receiving a constant reference to an object of its same type.  
    ~Cat();             // destructor
    int GetAge()   const   { return *itsAge; }
    int GetWeight() const  { return *itsWeight; }
    void SetAge(int age)   { *itsAge = age; }

  private:      // nelle due righe seguenti tow member varaibles are declared, each as a pointer to an integer 
    int *itsAge;
    int *itsWeight;
};

Cat::Cat()
{  // allocating room on the free store for the two variables "itsAge" and "itsWeight"
   itsAge = new int;     
   itsWeight = new int;
   *itsAge = 5;
   *itsWeight = 9;
}

Cat::Cat(const Cat & rhs)  // on this line begins the copy constructor. Note that the parameter is "rhs". 
{                                          // it is common to refer to the parameter to a copy constructor as rhs, which stands for right-hand side. 
   itsAge = new int;
   itsWeight = new int;
   *itsAge = rhs.GetAge();  // public access
   *itsWeight = *(rhs.itsWeight); // private access
}

Cat::~Cat()
{
   delete itsAge;
   itsAge = 0;
   delete itsWeight;
   itsWeight = 0;
}

int main()
{
   Cat Frisky;
   cout << "Frisky's age: " << Frisky.GetAge() << endl;
   cout << "Setting Frisky to 6...\n";
   Frisky.SetAge(6);
   cout << "Creating Boots from Frisky\n";
   Cat Boots(Frisky);
   cout << "Frisky's age: " <<     Frisky.GetAge() << endl;
   cout << "Boots' age: " << Boots.GetAge() << endl;
   cout << "setting Frisky to 7...\n";
   Frisky.SetAge(7);
   cout << "Frisky's age: " <<     Frisky.GetAge() << endl;
   cout << "boot's age: " << Boots.GetAge() << endl;
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------- 
--------------------------------------------------------------------------  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> operator overloading / >> overloading operator [pag302 jesse book]
C++ has a number of built-in types, including int, float, char and so forth. Each of these has a number of built-in operators, such as addition (+) and multiplication (*). C++ enables you to add these operators to your own classes as well. To example operator overloading fully, the following listing 10.6 creates a new class, Counter. A Counter object will be sued in counting in loops and other applications in which a number must be incremented, decremented or otherwise tracked. 
------------------------------------------------------------------------------------------------------------------------
	// Listing 10.6    // As it stands this is a pretty useless class. 
	//  - The Counter class

	#include <iostream>
	using namespace std;

	class Counter  // useless class: unlike an honest red blooded int, the Counter object cannot be incremented, decremented, added, assigned, or otherwise manipulated.
	{
	  public:
		Counter();
		~Counter(){}
		int GetItsVal()const { return itsVal; }
		void SetItsVal(int x) {itsVal = x; }

	  private:
		int itsVal;

	};

	Counter::Counter():
	itsVal(0)
	{}

	int main()
	{
	   Counter i;
	   cout << "The value of i is " << i.GetItsVal() << endl;
	   return 0;
	}
------------------------------------------------------------------------------------------------------------------------ EOF
>> increment function 
Operator overloading restores much of the functionality that has been stripped out of this class. Two ways exist, for example, to add the capability to increment a "Counter" object. The first is to write an increment method, as shown in the following listing:
-------------------------------------------------------------------------------------------------------------------------
	// Listing 10.7 - 
	// The Counter class

	#include <iostream>
	using namespace std;

	class Counter
	{
	  public:
		Counter();
		~Counter(){}
		int GetItsVal()const { return itsVal; }
		void SetItsVal(int x) {itsVal = x; }
		void Increment() { ++itsVal; }    // increment function definition

	  private:
		int itsVal;
	};
	 
	Counter::Counter():
	itsVal(0)
	{}

	int main()
	{
	   Counter i;
	   cout << "The value of i is " << i.GetItsVal() << endl;
	   i.Increment();
	   cout << "The value of i is " << i.GetItsVal() << endl;
	   return 0;
	}
//--------------------------------------------------------------------------------------------------------------------------------------- EOF
Although this program works, it is cumbersome to use. The program cries out for the capability to add a ++ operator, and of coarse this can be done.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[from pag325 jesse] SUMMARY : Overloading class constructors enables you to create flexible classes that can be created from other objects. Initialization of objects happens at the initialization stage of construction and is more efficient than assigning values in the body of the constructor.  The copy constructor and the assignment operator are supplied by the compiler if you don't create your own, but they do a member wise copy of the class. In classes in which member data includes pointers to the free store, these methods must be overridden so that you can allocate memory for the target member variable.
"this" refers to the current object and is an invisible parameter  to all member functions. The dereferenced "this" pointer is often returned by overloaded operators so that they can participate in expressions. 
>> CONVERSION OPERATORS [pag323 jesse book] (>> operator keyboard): Conversion operator enable you to create classes that can be used in expressions that expect a different type of object. They are exceptions to the rule that all functions return an explicit value; like constructors and destructors, they have no return type. 
Q&A
- Why would I ever use default values when I can overload a function?
It is easier to maintain one function than two, and it is often easier to understand a function with default parameters than to study the bodies of two functions. Furthermore updating one of the functions and neglecting to update the second is a common source of bugs. 
- When writing a class constructor, how do I decide what to put in the initialization and what to put in the body of the constructor?
A simple rule of thumb is to do as much as possible in the initialization phase (that is initialize all member variables there). Some things, like computations (including those used for initialization) and print statements, must be in the body of the constructor. 
- What is the difference between a declaration and a definition? A definition sets aside memory; a declaration does not. Almost all declarations are definitions; the major exceptions are class declarations, function prototypes, and "typedef" statements. 
- How does the copy constructor differ from the assignment operator (=)?
The assignment operator acts on an existing object; the copy constructor creates a new one. 
- What is the "this" pointer?  
The "this" pointer is  a hidden parameter in every member function that points to the object itself.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> REGISTER VARIABLE
[pag226]
Data in the machine-language version of a program is normally loaded into "registers" for calculations and other processing.
The storage-class specifier register can be placed before an automatic variable declaration to suggest that the compiler maintain the variable  in one of the computer's high speed hardware registers rather than in memory. Example:
	register unsigned int counter = 1;
Often register is unnecessary. Today's optimizing compilers can recognize frequently used variables and may place them in registers without needing a "register" declaration.

>> RELATIONAL AND EQUALITY OPERATORS
Useful to evaluate a comparison between two expressions. The result of a relational operation is a Boolean value that can only be true or false, according to its Boolean result: 
Here's the list:
EQUALITY OPERATORS
	== -> equal to 
	!= -> not equal to
RELATIONAL OPERATORS	 
	>  -> greater than
	<  -> less than 
	>= -> greater than or equal to
	<= -> less than or equal to
IMPORTANT nota come l'uguale venga sempre dopo <= OK e non =< [it would give you a sintax error]
!= OK e non =!. Se usassi =! in some cases will not be a sintax error, but almost certainly will be a logic error (if fatal logic error the program will terminate prematurely, if nonfatal logic error the program will continue executing, but usually produces incorrect results)	
examples:
	(7 == 5)  //  evaluates to false
    (5  > 4)  //  evaluates to true
    (3 != 2)  //  evaluates to true
    (6 >= 6)  //  evaluates to true
    (5 <  5)  //  evaluates to false
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> REMOVE / >> remove_if / >> remove_copy / >> remove_copy_if
[pag697 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_03/fig16_03.cpp
>> remove exemple d'emploi
	 13    const size_t SIZE = 10;
	 14    array< int, SIZE > init = { 10, 2, 10, 4, 16, 6, 14, 8, 12, 10 };
	 15    ostream_iterator< int > output( cout, " " );
	 16 
	 17    array< int, SIZE > a1( init ); // initialize with copy of init
	 18    cout << "a1 before removing all 10s:\n   ";
	 19    copy( a1.cbegin(), a1.cend(), output );
	 20 
	 21    // remove all 10s from a1
	 22    auto newLastElement = remove( a1.begin(), a1.end(), 10 );
	 23    cout << "\na1 after removing all 10s:\n   ";
	 24    copy( a1.begin(), newLastElement, output );
Line 22 uses the remove algorithm to eliminate from a1 all elements with the value 10 in the range from ai.begin() up to but not including a1.end(). The first two iterator arguments must be forward iterators. This algorithm does not modify the number of eleements in the container or destroy the eliminated elements, but it does move all elements that are not eliminated toward the beginning of the container. The algorithm returns an iterator positioned after the last element that was not removed. Elements from the iterator position to the end of the container have unspecified values.
>> remove_copy algorithm
Line 32 uses the remove_copy algorithm to copy all elements from a2 that do not have the value 10 in the range from a2.cbegin() up to, but not including a2.cend(). The elements are placed in c, starting at position c.begin(). The iterators supplied as the first two arguments must be input iterators. The iterator supplied as the third argument must be an output iterator so that the elemetn being copied  can be inserted into the copy location. This algorithm returns an iterator positioned after the last element copied into vector c.
[pag699 deitel]
>> remove_if algorithm [pag 699 deitel]
>> remove_copy_if algorithm
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> replace / >> replace_if / >> replace_copy / >> replace_copy_if
[pag700 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_04/fig16_04.cpp
Come puoi vedere dall'esempio puoi usare i replace algorithm in maniera simile a quanto fa li comando replace in un text editor, tutte le volte che trova l'elemento cercato lo sostituisce.
Example from line 22
	replace( a1.begin(), a1.end(), 10, 100 );
line 22 uses the replace algorithm to replace all elements with the value 10 in the range a1.begin() up to, but not including a1.end() with the new value 100.
[abbiamo compilato il programma via Visual Studio 2013 @Orion1 eccoti l'output
	a1 before removing all 10s:
	   10 2 10 4 16 6 14 8 12 10
	a1 after removing all 10s:
	   2 4 16 6 14 8 12
	
	a2 before removing all 10s and copying:
	   10 2 10 4 16 6 14 8 12 10
	c after removing all 10s from a2:
	   2 4 16 6 14 8 12 0 0 0
	
	a3 before removing all elements greater than 9:
	   10 2 10 4 16 6 14 8 12 10
	a3 after removing all elements greater than 9:
	   2 4 6 8
	
	a4 before removing all elements
	greater than 9 and copying:
	   10 2 10 4 16 6 14 8 12 10
	c2 after removing all elements
	greater than 9 from a4:
	   2 4 6 8 0 0 0 0 0 0
]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> RTTI = RunTime Type Information [pag554 deitel]

>> RETURN 
the return statement causes the main function to finish. Return may be followed by a return code ex
	return 0;
A return code of 0 for the main function is generally interpreted as the program worked as expected without any errors during its execution. This is the most usual way to end a C++ console program. 

>> RETURN CONTROL from a function to its caller
there are several ways to return control to the point at which a function was invoked. 
1) if the function does not return a result (i.e. it has a void return type), control returns when the program reaches the function ending right brace, or by execution of the statement
	return;
2) if the function does return a result, the statement
	return expression;
evaluates the expression and returns the value of expression to the caller.

>> REUSABILITY tips 
1) [pag83] to make a class reusable ALWAYS seperate your class into another file from the "main" function. Do not place "main" in the same file with a class definition. Function "main" begins the execution of every program, and every program must have exactly one "main" function. if other programmers include your class definition che hai scritto in un file che contiene anche "main", they get extra "baggage", their programs will then have two "main" functions. Attempting to compile a program with two "main" functions produces an error. 
2) it is customary to define reusable source code (such as a class) in a file that by convention has a .h file extension - known as a header. Programs use 
	#include
preprocessing directives to include headers and take advantage of reusable software components (such as for example type "string" provided in the C++ standard library)
Quindi la struttura generale sara' : avrai almeno due files 
A) il file *.cpp , il source code file che contiene the "main" funcntion, preceduta da degli #include per includere dei types provided dalla standard library (ex #include <iostream>) o userdefine types (ex #include "miaClass")
B) il file *.h chiamato anche header: contiene la class definition (ex "miaClass.h") che resta cosi' separata dal file *.cpp contenente "main"
In tal modo l'*.h potra' essere riutilizzato in altri programmi.
[pag84deitel]

>> SSSSSSS

>> SML Simpletron Machine Language [pag779 deitel]

>> self referential class [pag779]

>> stable_partition / >> partition [pag 119 moo book]
stable_partition is an algorithm that takes a sequence and rearranges its elements so that the ones that satisfy a predicate precede the ones that do not satisfy it.
There are two version of this algorithm: partition and stable_partition
- partition might rearrange the elements within each category, 
- stable_partition keeps them in the same order aside from the partitioning.
So, for example, if the sutdnet names were already in anphabetical order, and we wanted to keep them that way within each category, we would need to use stable_partition rather than partition.

>> STREAM [pag593 jesse]
In this lesson you will learn: 
1) what streams are and how they are used.
2) how to manage input output using streams. 
3) how to write and read from files using streams. 
-------------------------------------------------------------------------
OVERVIEW of STREAMS / >> STREAMS OVERVIEW 
C++ does not define how data is written to the screen or to a file, nor how data is read into a program. However the standard C++ library includes the iostream library, which facilitates input and output (I/O). 
The advantage of having the input and output kept apart from the language and handled in libraries is that it is easier to make the language "platform-independent". That is, you can write C++ programs on a PC and then recompile them and run them on a Sun Workstation, or you can take code created using a Windows C++ compiler and recompile and run it on Linux. The compiler manufacturer supplies the right library, and everything works. At least, that's the theory. 
NOTE: >> LIBRARY : a library is a collection of object (.obj or .o) files that can be linked to your program to provide additional functionality. This is the most basic form of code reuse and has been around since ancient programmers chiseled 1s and 0s into the walls of caves. 
Today streams are generally less important for C++ programming (expect perhaps for flat file input). C++ programs have evolved to use operating system or compiler vendor-provided graphical user interface (GUI) libraries for working with the screen, files and the user. This includes Windows libraries, X Windows libraries, and Borland's Kylix abstraction of both the Windows and X Windows user interfaces. Because these libraries are specialized to the operating system and are not part of the C++ standard, they are not discussed in this lesson. Becuase stream are  a part of C++ standard, they are discussed in this lesson. In addition it is good to understand streams in order to understand the inner workings of input and output. You should however, quickly move to learning your operating system or vendor supplied GUI library as well.  
------------------------------------------------------------
ENCAPSULATION OF DATA FLOW [pag594 jesse]
Text input and output can be accomplished using the iostream classes. The iostream classes view the flow of data as being a stream of data, one byte following another. If destionation of the stream is a file or the console screen, the source of the data that will be flowing is usually some part of your program. If the stream is reversed, the data can come from the keyboard or a disk file and can be "poured" into your data variables.
One principal goal of streams is to encapsulate the problems of getting the data to and from the disk or the console screen. After a stream is created, your program works with the stream and the stream takes care of the details
----------------------------------------------------------
>> BUFFERING / >> UNDERSTANDING BUFFERING [pag594 jesse]
Writing to the disk (and to a lesser extent the console screen [gia' vero, well it's not a c++ example but tipo quando con scilab lasciavamo outputtato i risultati del for loop il tempo di esecuzione di espandeva a 1sec a 1000sec...]) is very expensive. It takes a long time (relatively speaking) to write data to the disk or to read data from the disk, and execution of the program can be blocked by disk writes and reads. To solve this problem, streams provide "buffering". When buffering is used, data is written into the stream, but is not written  back out to the disk immediately. Instead the stream's buffer fills and fills, and when it is full, it writes to the disk all at once. Picture water tricklin into the top of a tank and the tank filling and filling, but no water running out of the bottom. 
[note: although data is technically a plural noun (e si dal latino datum -> quarta declinazione nominativo plurare diventa data, visto ci ricordiamo ancora dopo tanti anni!) we treat it as singular, as do nearly all native speaker of English.] 
- EMPTYING the BUFFER : when the water (data) reaches the top, the valve opens and all the water flows out in a rush. 
- REFILLING the BUFFER : after the buffer is empty, the bottom valve closes, the top valve opens and more water flows into the buffer tank and refills it.  
- FLUSHING the BUFFER : every once in a while, you need to get the water out of the tank even before it is full. This is called flushign the buffer. 
You should be aware that one of the risks of using buffering is the possibility that the program will crash while data is still in the buffers. If this occurs, you might lose those data.
--------------------------------------------------------------
>> STREAMS and >> BUFFER object oriented implementation approach. 
C++ takes an object-oriented view towards the implementing streams and buffers. It does this with the use of a number of classes and objects:
A) the >> streambuf class manages the buffer, and its member functions provide the capability to fill,  empty, flush and otherwise manipulate the buffer. 
B) the >> ios class is the base class to the input and output stream classes. The ios class has a streambuf object as a member variable. 
C) the >> istream and >> ostream  classes derive from the ios class and specialize input and output stream behaviour respectively. 
D) the >> iostream class is derived from both the istream and ostream classes and provides input and output methods for writing to the screen. 
E) the >> fstream classes provide input and output from files. 
-------------------------------------------------------------------------------
>> STANDARD I/O Objects [pag 597 jesse]
When a C++ program that includes the >> iostream classes starts, four objects are created and initialized: 
1) >> cin (pronounced "see-in") handles input from the standard input, the keyboard
2) >> cout (pronouncecd "see-out") handles output to the standard output, the console screen. 
3) >> cerr (pronounced "see-err")  handles unbuffered output to the standard error device, the console screen. Because this is unbuffered, everything sent to cerr is written to the standard error device immediately, without waiting for the buffer to fill or for a flush command to be received. 
4) >> clog (pronounced "see-log") handles buffered error messages that are output to the standard error device, the console screen. It is common for this to be "redirected" to a log file.
NOTE: the iostream class library is added automatically to your program by the compiler. All you need to do to use these functions is to put the appropriate "include" statement at the top of your program listing: 
	#include <iostream>
---------------------------------------------------------------------------------
>> REDIRECTION OF THE STANDARD STREAMS [pag598 jesse]/ >> STREAM REDIRECTION   
Each of the standard devices, input, output, and error, can be redirected to other devices. The standard error stream (cerr) is often redirected to a file, and standard input (cin) and output (cout) can be piped to files using operating system commands. 
The redirection operators for DOS, the Windows command prompt, and Unix are "<" redirect input, and ">" redirect output. Unix providesmore advanced redirection capabilities than DOS or the standard Windows command prompt. However, the general idea is the same: take the output intended for the console screen and write it to a file, or pipe it into another program. Alternatively, the input for a program can be extracted from a file rather than from the keyboard.
--------------------------------------------------------------------------------------------
>> CIN input / >> input using CIN [pag599 jesse]
The global object CIN is responsible for input and is made available to your program when you include iostream. In previous examples, you used the overloaded extraction  operator (>>) to put data into your program's variables. How does it work? The syntax, as you might remember is as follows: 
	int someVariable;
	cout << "Enter a number: ";
	cin >> someVariable;
The global object cout is discussed later in this lesson; for now, focus on the third line, cin >> someVariable; What can you guess about cin?
Clearly, it must be a global object because you didn't define it in your code. You know from previous operator experience that cin has overloaded the extraction opereator (>>) and that the effect is to write whatever data cin has in his buffer into your local variable someVariable. 
What might not be immediately obvious is that cin has overloaded the extraction oprator for a great variety of parameters, among them int&, short&, long&, double&, float&, char&, char* and so forth. When you write cin >> someVariable; the type of someVariable is assessed. In the preciding example, someVariable is an integer, so the following function is called:
	istream & operator >> (int &)
Note that  because the parameter is passed by reference, the extraction operator is able to act on the original variable. 
The following listing 17.1 illustrates the use of cin : 
--------------------------------------------------------------------------------------------------------------------------------- 17.1 STARTS
//Listing 17.1 - character strings and cin

#include <iostream>
using namespace std;

int main()
{
   int myInt;
   long myLong;
   double myDouble;
   float myFloat;
   unsigned int myUnsigned;

   cout << "Int: ";
   cin >> myInt;
   cout << "Long: ";
   cin >> myLong;
   cout << "Double: ";
   cin >> myDouble;
   cout << "Float: ";
   cin >> myFloat;
   cout << "Unsigned: ";
   cin >> myUnsigned;

   cout << "\n\nInt:\t" << myInt << endl;
   cout << "Long:\t" << myLong << endl;
   cout << "Double:\t" << myDouble << endl;
   cout << "Float:\t" << myFloat << endl;
   cout << "Unsigned:\t" << myUnsigned << endl;
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.1 ENDS
OUTPUT 
	[1039 Day17] >> g++ List1701.cpp -o List1701.exe
	[1040 Day17] >> ./List1701.exe 
	Int: 3
	Long: 1279090
	Double: 3409802
	Float: 0.7
	Unsigned: 1099

	Int:	3
	Long:	1279090
	Double:	3.4098e+06
	Float:	0.7
	Unsigned:	1099
---------------------------------------------------------------------------------------------------------------------------------
>> INPUT STRINGS / >> STRINGS INPUT [pag600 jesse]
"cin" can also handle character pointer (char *) arguments; thus, you can create a character buffer and use cin to fill it. For example, you can write the following: 
	char YourName[50]
	cout << "Enter your name: ";
	cin >> YourName;
If you enter Jesse, the variable YourName is filled with the characters J, e, s, s, e, \0. The last character is a null; cin automatically ends the string with a null character, and you must have enough room in the buffer to allow for the entire string plus the null. The null signals the "end of string" to the cin object.
>> STRING PROBLEM / >> WHITESPACE separator / >> WHITE SPACE separator [pag601 jesse]
After all this success with cin, you might be surprised when you try to enter a full name into a string. cin has trouble getting the full name because it believes that any white space is a separator. When it sees a space or a new line, it assumes the input for the parameter is complete, and in the case of strings, it adds a null character right then and there.    The listing 17.2 illustrates this problem: 
	//Listing 17.2 - character strings and cin

	#include <iostream>

	int main()
	{
	   char YourName[50];
	   std::cout << "Your first name: ";
	   std::cin >> YourName;
	   std::cout << "Here it is: " << YourName << std::endl;
	   std::cout << "Your entire name: ";
	   std::cin >> YourName;
	   std::cout << "Here it is: " << YourName << std::endl;
	   return 0;
	}
---------------------------------------------------------------------
OUTPUT 
[1041 Day17] >> g++ List1702.cpp -o List1702.exe
[1042 Day17] >> ./List1702.exe 
Your first name: Jesse
Here it is: Jesse
Your entire name: Jesse Liberty   // visto che Liberty viene dopo un whitespace, non viene preso in considerazione.
Here it is: Jesse
-----------------------------------------------------------------------
To understand why this work this way, examine the following 17.3 listing, which shows input for several fields : 
--------------------------------------------------------------------------------------------------------------------------------------- 17.3 START
//Listing 17.3 - character strings and cin

#include <iostream>
using namespace std;

int main()
{
   int myInt;
   long myLong;
   double myDouble;
   float myFloat;
   unsigned int myUnsigned;
   char myWord[50];

   cout << "int: ";
   cin >> myInt;
   cout << "Long: ";
   cin >> myLong;
   cout << "Double: ";
   cin >> myDouble;
   cout << "Float: ";
   cin >> myFloat;
   cout << "Word: ";
   cin >> myWord;
   cout << "Unsigned: ";
   cin >> myUnsigned;

   cout << "\n\nInt:\t" << myInt << endl;
   cout << "Long:\t" << myLong << endl;
   cout << "Double:\t" << myDouble << endl;
   cout << "Float:\t" << myFloat << endl;
   cout << "Word: \t" << myWord << endl;
   cout << "Unsigned:\t" << myUnsigned << endl;

   cout << "\n\nInt, Long, Double, Float, Word, Unsigned: "; // this line prompts the user for all the input at once, and then each "word" of input is assigned to the appropriate variable.  
   cin >> myInt >> myLong >> myDouble; // It is to facilitate this kind of multiple assignment that cin must consider each word in the input to be the full input for each variable. If cin was to consider the entire input to be part of one variable's input, this kind of concatenation input would be impossible.
   cin >> myFloat >> myWord >> myUnsigned;
   cout << "\n\nInt:\t" << myInt << endl;
   cout << "Long:\t" << myLong << endl;
   cout << "Double:\t" << myDouble << endl;
   cout << "Float:\t" << myFloat << endl;
   cout << "Word: \t" << myWord << endl;
   cout << "Unsigned:\t" << myUnsigned << endl;

   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------- 17.3 END
OUTPUT
[1044 Day17] >> ./List1703.exe 
int: 8      // FIRST WAY : the program asks you to input each of the parameters separately
Long: 23402
Double: 339845220
Float: 3.809
Word: Ciao
Unsigned: 87

Int:	8    // and when you finishes gives you the output. 
Long:	23402
Double:	3.39845e+08
Float:	3.809
Word: 	Ciao
Unsigned:	87

Int, Long, Double, Float, Word, Unsigned: 3 342 2890890 6.2090 Aplus -2 // SECOND WAY: the program asks you to input the parameters all at once, scrivili uno dopo l'altro senza premere enter, giusto separandoli l'uno dall'altro da un whitespace. 

Int:	3  // output: all works well just like before. 
Long:	342
Double:	2.89089e+06
Float:	6.209
Word: 	Aplus
Unsigned:	4294967294   // note: il fatto che al posto di -2 venga scritto un "4294967294" is because cin believes it is writing to an unsigned integer. So the bit pattern of -2 was evaluated as an unsigned integer, and when written out by cout, the value 4294967294  was displayed. The unsigned value 4294967294 has the exact bit pattern of the signed value -2.

Later, you will see how to enter an entire string into a buffer, including multiple words. For now, the question arises "How does the extraction operator manage this trick of concatenation?"
>> CIN RETURN VALUE [pag603 jesse book]
The return value of cin is a reference to an istream object. Because cin itself is an istream object, the return value of one extraction operation can be the input to the next extraction. 
	int varOne, varTwo, varThree;
	cout << "Enter three numbers: " ;
	cin >> varOne >> varTwo >> varThree ;
When you write "cin >> varOne>> varTwo >> varThree;"  the first extraction is evaluated (cin >> varOne). The return value from this is another istream object, and that object's extraction operator gets the varaible varTwo. It is as if you had written this: 
	((cin >> varOne) >> varTwo) >> varThree ;
You'll see this technique repeated later when cout is discussed. 
--------------------------------------------------------------------------------------------------------------------------
>> CIN MEMBER FUNCTIONS / Other member functions of cin. [pag604 jesse book]
In addition to overloading operator>>, cin has a number of other member functions. These are used when finer control over the input is required. These functions allow you to do the following : 
- get a single character 
- get strings
- ignore input 
- look at the next character in the buffer
- put data back to the buffer. 
>> SINGLE CHARACTER INPUT [pag604 jesse book]
operator>> taking a character reference can be used to get a single character from the standard input. The member function get() can also be used to obtain a single character, and can do so in two ways: get() can be used with no parameters, in which case the return value is used, or it can be used with a reference to a character. 
>> USING GET with no parameters / >> GET with no parameters [pag 604 jesse]
The first form of  get() is without parameters. This returns the value of the character found and return EOF (end of file) if the end of the file is reached. get() with no parameters is not often used. 
Unlike using cin to get multiple values, it is not possible to concatenate this use of get() for multiple input because the return value is not an iostream object. Thus, the following  doesn't work: 
	cin.get() >>myVarOne >> myVarTwo; // it's illegal 
The return value of cin.get() >> myVarOne is actually an integer, not an iostream object. 
A common use of get() with no parameters is illustrated in the follwing listing 17.4 : 
-------------------------------------------------------------------------------------------------------------------------------------- 17.4 starts
// Listing 17.4 - Using get() with no parameters

#include <iostream>

int main()
{
    char ch; // here we declare a local character varible, ch. 
	// The following while loop asigns the input received from cin.get() to ch, and if it is not EOF, the string is printed out. 
    while ( (ch = std::cin.get()) != EOF)
    {
      std::cout << "ch: " << ch << std::endl;
    }
    std::cout << "\nDone!\n";
    return 0;
}  
-------------------------------------------------------------------------------------------------------------------------------------- 17.4 ends
OUTPUT 
[1047 Day17] >> g++ List1704.cpp -o List1704.exe
List1704.cpp: In function ‘int main()’:
List1704.cpp:8:38: error: ‘EOF’ was not declared in this scope
     while ( (ch = std::cin.get()) != EOF)
--------- ops abbiamo errore, vediamo come risolverlo. 
SOLUTION we need to add into the source code file, the line "#include <stdio.h>" as suggested here https://stackoverflow.com/questions/4577453/fcgio-cpp50-error-eof-was-not-declared-in-this-scope/8974532
#include <iostream>
#include <stdio.h>
OK this solved the problem
[1048 Day17] >> ./List1704.exe 

H
ch: H
ch: 

10       // se il tuo input e' costituito da piu' di un carattere te lo separa in due righe differenti.
ch: 1
ch: 0
ch: 

201
ch: 2
ch: 0
ch: 1

ctrl+C per uscire dal programma

>> GET() with a character reference parameter [pag606 jesse]
When a character varaible is passed as input to get(), that character variable is filled with the next character in the input stream. The return value is an iostream object, and so this form of get(), can be concatenated, as illustrated in the following listing 17.5: 
---------------------------------------------------------------------------------------------------------------------------------- 17.5 starts
// Listing 17.5 - Using get() with parameters

#include <iostream>
#include <stdio.h>

int main()
{
   char a, b, c;  // three character variables are created 

   std::cout << "Enter three letters: ";

   std::cin.get(a).get(b).get(c);  // cin.get() is called three times, concatenated. First, cin.get(a) is called. This puts the first letter into "a" and returns cin so that when it is done, cin.get(b) is called, putting the next letter into "b". Finally cin.get(c) is called and the third letter is put in "c". NOTE: because cin.get(a) evaluates to cin, you could have written this: "cin.get(a) >> b;"  In this form, cin.get(a) evaluates to cin, so the second phrase is cin >> b; 

   std::cout << "a: " << a << "\nb: ";
   std::cout << b << "\nc: " << c << std::endl;
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------  17.5 ends
[1049 Day17] >> g++ List1705.cpp -o List1705.exe
[1050 Day17] >> ./List1705.exe 
Enter three letters: edy
a: e
b: d
c: y
----------------------------------------------------------------------------------------------------------------------------------
DO 
	- DO use the extraction operator >> when you need to skip over whitespace. 
	- DO use get() with a character parameter when you need to examine every character, including whitespace. 
DON'T
	- DON'T stack cin statements to get multiple input if it isn't clear what you are doing. It is better to use multiple commands that are easier to understand than to use one long command. 
----------------------------------------------------------------------------------------------------------------------------------
>> GETTING STRINGS FROM STANDARD INPUT / >> STRINGS FROM STANDARD INPUT [pag607 jesse]
The extraction operator can be used to fill a character array, as can the third version of the member functions get() and the member function getline(). 
This form of get() takes three parameters : 
	get ( pCharArray, StreamSize, TermChar ); 
The first parameter (pCharArray) is a pointer to a character array, the second parameter (StreamSize) is the maximum number of characters to read plus one, and the third parameter (TermChar) is the termination character. 
If you enter 20 as the second parameter, get() reads 19 characters then null- terminates the string, which it store in the first parameter. The third parameter, the termination character, defaults to newline('\n'). If a termination character is reached before the maximum number of characters is read, a null is written and the termination character is left in the buffer.
The following listing 17.6 illustrates the use of this form of get()
--------------------------------------------------------------------------------------------------------------------------------- 17.6 starts
// Listing 17.6 - Using get() with a character array

#include <iostream>
using namespace std;

int main()
{
   char stringOne[256];   // creiamo character array stringOne
   char stringTwo[256];  // creiamo character array stringTwo

   cout << "Enter string one: ";
   cin.get(stringOne,256);  // calling cin.get(). The first parameter is the buffer to fill, and the second is one more than the maximum number for get() to accept (the extra position being given to the null character, ['\0']). There is not a third parameter shown, however, this is defaulted. The defaulted third parameter is a newline.
   cout << "stringOne: " << stringOne << endl;   // when the user enters "San Francisco" (come mostrato sotto) and ends the phrase with a newline (abbiamo premuto tasto invio) that phrase is put into stringOne, followed by a terminanting null.  

   cout << "Enter string two: ";
   cin >> stringTwo; // this time just the extraction operator is used. Because the extraction operator takes everything up to the first whitespace, only the string For with a terminanting null character, is stored in the secondo string, which, of course, is not what was intended. 
   cout << "StringTwo: " << stringTwo << endl;
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.6 ends
OUTPUT : 
[1051 Day17] >> g++ List1706.cpp -o List1706.exe
[1052 Day17] >> ./List1706.exe 
Enter string one: San Francisco
stringOne: San Francisco
Enter string two: Los Angeles
StringTwo: Los
----------------------------------------------------------------------------------------------------------------------------------
Using get() with the three parameters is perfectly valid for obtaining strings; however, it is not the only solution. Another way to solve this problem is to use getline(), as illustrated in the following 17.7 listing: 
--------------------------------------------------------------------------------------------------------------------------------- 17.7 starts
// Listing 17.7 - Using getline()

#include <iostream>
using namespace std;

int main()
{
   char stringOne[256];
   char stringTwo[256];
   char stringThree[256];

   cout << "Enter string one: ";
   cin.getline(stringOne,256);  // the string inputted by the user, is ready by using getline(). Like get(), getline() takes a buffer and a maximum number of characters. Unlike get(), however, the terminating newline is read and thrown away. With get(), the terminating newline is not thrown away. It is left in the input buffer. 
   cout << "stringOne: " << stringOne << endl;

   cout << "Enter string two: "; // the user is prompted for the second time. Let's suppose for the following explanations that the user inputs "four five six" 
   cin >> stringTwo; // and this time the extraction operator is used.  
   cout << "stringTwo: " << stringTwo << endl; //  however, only the first word, "four"  is put in stringTwo.

   cout << "Enter string three: ";  // then "Enter string three" is displayed 
   cin.getline(stringThree,256);  // and getline() is called again. Because "five six" is still in the input buffer, it is immediately read up to the newline; getline() terminates and the string in stringThree is printed in the following line 
   cout << "stringThree: " << stringThree << endl;  // the user has no chance to enter the third string because the input buffer contained data that fulfilled the request this prompt was making. 
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.7 ends
[1053 Day17] >> g++ List1707.cpp -o List1707.exe
[1054 Day17] >> ./List1707.exe 
Enter string one: New York City
stringOne: New York City
Enter string two: four five six
stringTwo: four 
Enter string three: stringThree:  five six
----------------------------------------------------------------------------------------------------------------------------------
>> CIN.IGNORE() [pag610 jesse]
At times, you want to ignore the remaining characters on a line until you hit either >> EOL (= end of line) or EOF (= end of file). The member function ignore() serves this purpose. 
ignore() takes two parameters: the maximum number of characters to ignore and the termination character. If you write 
	"ignore(80, '\n') 
up to 80 characters will be thrown away until a newline character is found. The newline is then thrown away and the ignore() statement ends. The following listing 17.8 illustrates the use of ignore(): 
--------------------------------------------------------------------------------------------------------------------------------- 17.8 starts
// Listing 17.8 - Using ignore()
#include <iostream>
using namespace std;

int main()
{
   char stringOne[255]; // creating two characters arrays "stringOne" and "stringTwo"
   char stringTwo[255];

   cout << "Enter string one:"; // the user is prompted for input and let's suppose that he types "once upon a time", followed by pressing the Enter key.  
   cin.get(stringOne,255); // get() is used to read this string. get() fills stringOne and terminates on the newline, but leaves the newline character in the input buffer 
   cout << "String one: " << stringOne << endl;

   cout << "Enter string two: ";  // the user is prompted again 
   cin.getline(stringTwo,255); // the getline() reads the input buffer up to the newline. Because a newline was left in the buffer by the call to get(), this line terminates immediately, before the user can enter any new input. 
   cout << "String two: " << stringTwo << endl;

   cout << "\n\nNow try again...\n";

   cout << "Enter string one: "; // the user is prompted again and let's suppose that he inputs exactly the same input as before "once upon a time"
   cin.get(stringOne,255);
   cout << "String one: " << stringOne<< endl;

   cin.ignore(255,'\n');  // this time ignore() is used to empty the input stream by "eating" the newline character. 

   cout << "Enter string two: ";
   cin.getline(stringTwo,255);   // Thus, when the getline() call, the input buffer is empty and the user can input the next line of the story.
   cout << "String Two: " << stringTwo<< endl;
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.8 ends 
OUTPUT 
[1055 Day17] >> g++ List1708.cpp -o List1708.exe
[1056 Day17] >> ./List1708.exe 
Enter string one:once upon a time
String one: once upon a time
Enter string two: String two:      // the buffer is not empty the user can't input.
                                                              // questo e' lo spazio vuoto dovuto al fatto che stringTwo si vede assegnato la new line character che restava nel buffer

Now try again...
Enter string one: once upon a time
String one: once upon a time    // this time ignore() is used to empty the input stream by "eating" the newline character. 
Enter string two: there was a    // Thus, when the getline() call, the input buffer is empty and the user can input the next line of the story.
String Two: there was a 
----------------------------------------------------------------------------------------------------------------------------------
>> PEEKING at and RETURNING CHARACTERS : peek() and putback() / >> PEEK() / >> PUTBACK() [pag611 jesse]
The input object "cin" has two additional methods that can come in rather handy: peek(), which looks at but does not extract the next character, and putback(), which inserts a character into the input stream. The following 17.9 listing illustrates how these might be used. The purpose of this program is to turn any exclamation marks (!) into dollar signs ($) and to remove any pound symbols (#).
[>> PARSING TEXT / >> SUBSTITUTE character in text / >> DELETE character from text]
--------------------------------------------------------------------------------------------------------------------------------- 17.9 starts
// Listing 17.9 - Using peek() and putback()
#include <iostream>
using namespace std;

int main()
{
   char ch;  // declaring character variable "ch"
   cout << "enter a phrase: ";  // the user is prompted to enter a phrase. Let's suppose that the user inputs "Now!is#the!time#for!fun#!"
   while ( cin.get(ch) != 0 )  // keep looping as long as you are getting characters other than the end of file. Cioe' per stoppare il programma devi premere CTRL+C, in tal modo cin.get(ch) diventa uguale a 0, il quale non e' diverso != da zero, quindi il while cycle si interrompe. 
   {
      if (ch == '!')  // if the current character is an exclamation mark it is thrown away
         cin.putback('$');  // and the symbol $  is put back into the input buffer. 
      else  // if it is not an exclamation point
         cout << ch; // then the character is printed. 
      while (cin.peek() == '#') // the next character is "peeked" at, and when pound symbols # are found, they are removed using the ignore() method. 
         cin.ignore(1,'#'); // removing the # symbols found, by using the ignore() method. This is not the most efficient way to do either of these things (and it won't find a # symbol if it is the first character), but it does illustrate how these methods work.
   }
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.9 ends 
OUTPUT : 
[1057 Day17] >> g++ List1709.cpp -o List1709.exe
[1058 Day17] >> ./List1709.exe 
enter a phrase: Now!is#the!time#for!fun#!
Now$isthe$timefor$fun$
------------------------------
NOTE: peek() and putback() are typically used for parsing strings and othe data, such as when writing a compiler. 

>> OUTPUT  WITH COUT [pag613 jesse book]
We have used cout along wih the overloaded insertion operator (<<) to write strings, integers, and other numeric data to the screen. It is also possible to format the data, aligning columns and writing numeric data in decimal and hexadecimal. This section shows you how. 
>> FLUSHING THE OUTPUT / >> OUTPUT CLEAR / >> OUTPUT CLEAN / >> EMPTY BUFFER / >> BUFFER EMPTY [pag613]
We've already seen that using "endl" writes a newline and then flushes the output buffer. "endl" calls cout's member function flush(), which writes all the data it is buffering. You can also call the flush() method directly, either by calling the flush() member method or by writing the following : 
	cout << flush();
This can be convenient when you need to ensure that the output buffer is emptied and that the contents are written to the screen.   
>> OUTPUT FUNCTIONS  / >> FUNCTIONS for doing output [pag613 jesse]
Just as extraction operator can be supplemented with get() and getline(), the insertion operator can be supplemented with put() and write(). 
>> PUT() / >> writing characters with PUT() [pag613 jesse]
The function put() is used to write a ingle character  to the output device. Because put() returns an ostream reference and because cout is an ostream object, you can concatenate put() the same as you can stack the insertion operator. The following listing 17.10 illustrates this idea: 
--------------------------------------------------------------------------------------------------------------------------------- 17.10 starts
 // Listing 17.10 - Using put()
  
#include <iostream>
  
int main()
{
   std::cout.put('H').put('e').put('l').put('l').put('o').put('\n'); 
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.10 ends
OUTPUT : 
[1059 Day17] >> g++ List1710.cpp -o List1710.exe
[1060 Day17] >> ./List1710.exe 
Hello
---------------
NOTE: the line "std::cout.put('H').put('e').put('l').put('l').put('o').put('\n'); " is evaluated in the following way : 
std::cout.put('H') writes the letter H to the screen and returns a cout object. This leaves the following : 
	cout.put('e').put('l').put('l').put('o').put('\n');
The letter "e" is then written, and, again, a cout object is returned leaving: 
	cout.put('l').put('l').put('o').put('\n');
This process repeats, each letter being written and the cout object returned until the final character ('\n') is written and the function returns. 
----------------------------------------------------------------------------------------------------------------------------------

>> WRITE() / >> writing more with write() [pag614 jesse]
The function write() works the same as the insertion operator (<<) except that it takes a parameter that tells the function the maximum number of characters to write: 
	cout.write(Text, Size)
As you can see, the first parameter for write() is the text that will be printed. The second parameter, Size, is the number of characters that will be printed from "Text". Note that this number might be smaller or larger than the actual size of the Text. If it is larger, you will output the values that reside in memory after the Text value. The following Listing 17.11 illustrates its use. This listing prints from a phrase. Each time  it prints a different amount of the phrase.
--------------------------------------------------------------------------------------------------------------------------------- 17.11 starts
// Listing 17.11 - Using write()
#include <iostream>
#include <string.h>   // including string.h so that we can use the function "strlen" 
using namespace std;

int main()
{
   char One[] = "One if by land";  // creating the phrase to print 

   int fullLength = strlen(One);  // getting the length of the string "One" by using the method "strlen" that was included with the string directive "#include <string.h>" see above
   int tooShort = fullLength -4;  // ne deriviamo due lunghezze, una troppo piccola rispetto alla string
   int tooLong = fullLength + 6; // e l'altra troppo lunga rispetto alla stringa

   cout.write(One,fullLength) << endl;  // using the actual length of the string, so the correct full phrase is printed. 
   cout.write(One,tooShort) << endl;  // this time the size is 4 character shorter, that's why in the output below you just get "One if by" i 4 caratteri di "land" sono persi
   cout.write(One,tooLong) << endl;  // this time the size is 6 character longer. So after the phrase is written, the next six bytes of contingous memory are written. Anything could be in this memory, so your output might vary from what is shown in the OUTPUT below. 
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.11 ends
OUTPUT: 
[1061 Day17] >> g++ List1711.cpp -o List1711.exe
[1062 Day17] >> ./List1711.exe 
One if by land
One if by 
One if by land�p
--------------------------------------------

>> MANIPULATORS / >> FLAGS / >> STATE FLAG / >> FORMATTING INSTRUCTIONS [pag615 jesse]
The output stream maintains a number fo state flags, determining  which base (decimal or hexadecimal)  to use, how wide to make the fields, and what character to use to fill in fields. 
A state flag is a byte (= 8 bits), in cui a ciascuno degli 8 bit e' assegnato un significato particolare.
Manipulating bits in this way is discussed in Lesson Day21 "What's next". Each of ostream's flags can be set using member functions and manipulators. 

>> COUT.WIDTH() [pag 615 jesse]
The default width of your output will be just enough space to print the number, character, or string in the output buffer. You can change this by using width(). 
Because width() is a member function, it must be invoked with a cout object. It only changes the width of the very next output field and then immediately reverts to the default. The following listing 17.2 illustrates its use: 
--------------------------------------------------------------------------------------------------------------------------------- 17.12 starts
	// Listing 17.12 - Adjusting the width of output
	#include <iostream>
	using namespace std;

	int main()
	{
	   cout << "Start >";
	   cout.width(25); // si setta width a 25. Questo viene applicato al cout che segue immediatamente dopo 
	   cout << 123 << "< End\n"; // visto che nella linea precedente width e' settata a 25 vedi nell'output un grosso spazio di 25-3 = 22 prime delle 3 cifre "123"

	   cout << "Start >";
	   cout.width(25);  // setting another time the width as 25
	   cout << 123<< "< Next >";   // questo "123" si vedra' preceduto ad 25-3 = 22 spaces davanti
	   cout << 456 << "< End\n"; //  questo "456" invece is printed in a field whose width is reset to just large enough; as stated, the effect of width() lasts only as long as the very next output. Quindi una volta che viene applicato al print di "123", cessa di validita' e non viene piu' applicato al print successivo di "456" 

	   cout << "Start >";
	   cout.width(4);  // for this final print adottiamo un width "4" that is smaller than the width of "123456"
	   cout << 123456 << "< End\n"; // in tal caso il width "4" viene ignorato. A width that is too small will not truncate what is being displayed. 
	   return 0;
	}
--------------------------------------------------------------------------------------------------------------------------------- 17.12 ends
OUTPUT : 
[1063 Day17] >> g++ List1712.cpp -o List1712.exe
[1064 Day17] >> ./List1712.exe 
Start >                      123< End     // se conti con il cursore vedrai che tra il > e il 1 ci sono 22 spazi, che con i 3 spaces occupati da 123 fanno un 25 di width esattamente come settato con l'espressione "cout.width(25);"
Start >                      123< Next >456< End
Start >123456< End

----------------------------------------------------------------------------------------------------------------------------------
>> FILL CHARACTERS / >> ************************ FILLING CHARACTERS / >> FILL() [pag617 jesse]
Normally, cout fills the empty field created by a call to width() with spaces, as shown previously. At times, you might want to fill the area with other characters, such as asterisks. To do this, you call fill() and pass in as a parameter the character you want used as a fill character. The following listing 17.13 illustrates this : 
--------------------------------------------------------------------------------------------------------------------------------- 17.13 starts
// Listing 17.13 - fill()

#include <iostream>
using namespace std;

int main()
{
   cout << "Start >";    // like in the previous listing 17.12 we print the value "123" in a width area of 25.
   cout.width(25);
   cout << 123 << "< End\n";

   cout << "Start >";   // again we print the value "123" in a width area of 25 but this time we set the * as fill character 
   cout.width(25);
   cout.fill('*');          // the fill character is set to an asterisk 
   cout << 123 << "< End\n";
   cout << "Start >";
   cout.width(25);
   cout << 456 << "< End\n";  // unlike the width() function, whicn only apply to the next output, the new fill() character remains until you change it. 
  
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.13 ends
OUTPUT 
[1065 Day17] >> g++ List1713.cpp -o List1713.exe
[1066 Day17] >> ./List1713.exe 
Start >                      123< End
Start >**********************123< End
Start >**********************456< End    // asterisk set as filling character keeps to be valid also in the subsequent prints. 

---------------------------------------------------------------------------------------------------------------------------------
>> FORMATTING  OUTPUT / >> FLAGS SETTINGS / >> OUTPUT FORMAT / >> STATE of an object / >> managing the state of output: set flags [pag617 jesse]
Objects are said to have state when some or all of their data represents a condition that can change during the course of the program.
For example, you can set whether to show trailing zeros (so that 20.00 is not truncated to 20).
The iostream objects keep track of their state by using flags. You can set these flags by calling setf() and passing in one of the predefined enumerated constants. For example, to turn trailing >> zeros on, you call setf(ios::showpoint). 
The enumerated constants are scoped to the iostream class (ios) and thus when used with setf(), they are called with teh full qualification ios::flagname, such as ios::showpoint. The following Table 17.1 show some of the flags you can use. When using these flags, you need to include iostream in your listing. In addition, for those flags that require parameters, you need to include iomanip.
TABLE 17.1 Some of the iostream Set Flags
	showpoint  -> displays a decimal point and trainling zeros as requied by precision 
	showpos -> turns on the plus sign (+) before positive numbers. 
	left -> aligns output to the left 
	right -> aligns output to the right
	internal -> aligns the sign for a number to the left and aligns the value to the right 
	scientific -> shows floating point values in sicientific notation 
	fixed -> shows floating point numbers in decimal notation 
	showbase -> adds "0x" in front of hexadecimal numbers to indicate that it is a hexadecimal value 
	Uppercase -> shows hexadecimal and scientific numbers in uppercase 
	dec -> sets th base of the numbers for display to decimal  
	oct -> sets the bas eof the numbers for display to octal (= base 8)   
	hex -> sets the bas eof the numbers for display to hexadecimal (= base 16)
The flags shown in the table above, can also be concatenated into the insertion operator. The following listing 17.14 illustrates these settings. As a bonus, Listing 17.14 also introduces the >> setw manipulator, which sets the width but can also be concatenated with the insertion operator.  
--------------------------------------------------------------------------------------------------------------------------------- 17.14 starts
// Listing 17.14 - Using setf
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
   const int number = 185; // declaring the a constant int number
   cout << "The number is " << number << endl; // normal print 
// this gives "The number is 185"

   cout << "The number is " << hex <<  number << endl;  // concatenating the manipulator hex, so that the value of "number" will be displayed in hexadecimal. 
// this gives "The number is b9"

   cout.setf(ios::showbase); // the flag showbase is set. This causes the prefix 0x to be added to all hexadecimal numbers, as reflected in the output. 
   cout << "The number is " << hex <<  number << endl;  // this gives "The number is 0xb9"

   cout << "The number is " ;
   cout.width(10); // we set width to 10, and by default the value is pushed to the extreme right. 
   cout << hex << number << endl;  // this gives  "The number is       0xb9"

   cout << "The number is " ;
   cout.width(10);   // again width set to 10
   cout.setf(ios::left); // but this time the alignment is set to the left and the number is printed flush left this time. 
   cout << hex << number << endl;     // this gives "The number is 0xb9      "

   cout << "The number is " ;
   cout.width(10); // again width set to 10
   cout.setf(ios::internal); // but this time the alignment is internal. Thus, the 0x is printed flush left, but teh value b9 is printed flush right. 
   cout << hex << number << endl;  // this gives "The number is 0x      b9"

   cout << "The number is " << setw(10) << hex << number << endl;
   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.14 ends
OUTPUT : 
[1067 Day17] >> g++ List1714.cpp -o List1714.exe
[1068 Day17] >> ./List1714.exe 
The number is 185   // from cout << "The number is " << number << endl;
The number is b9  // cout << "The number is " << hex <<  number << endl;
The number is 0xb9 // from cout.setf(ios::showbase);   cout << "The number is " << hex <<  number << endl;
The number is       0xb9   // from  cout.width(10);   cout << hex << number << endl;
The number is 0xb9        // from    cout.width(10); cout.setf(ios::left);  cout << hex << number << endl;
The number is 0x      b9  // from    cout.width(10); cout.setf(ios::internal); cout << hex << number << endl;
The number is 0x      b9  // from    cout << "The number is " << setw(10) << hex << number << endl;
NOTE: you should notice in this listing that if the flags are used within the cout list that they do not need to be qualified; hex can be passed as hex. When you use the setf() function, you need to quailify the flags to the class; hex is passed as ios::hex. 

---------------------------------------------------------------------------------------------------------------------------------
>> STREAMS vs >> PRINTF() function [pag620 jesse]
Most C++ implementations also provide the standard C I/O libraries, including the printf() statement. Although printf() is in some ways easier to use than cout, it is much less desiderable. 
- printf() does not provide type safety, so it is easy to inadvertently tell it to display an integer as if it were a character, and viceversa.
- printf() does not support classes, and so it is not possible to teach it how to print your clas data; you must feed each class member to printf() one by one. 
Because there is a lot of legacy code using printf(), this section briefly reviews how printf() takes a formatting string as its first parameter and then a series of values as its remaining parameters. 
The formatting string is a quoted string of text an conversion specifiers. All conversion specifiers must begin with the percent symbol (%). The common conversion speciferes are presented in the following table 17.2: 
	%s    used for strings 
	%c    used for integers 
	%l     used for long integer
	%ld   used for long double 
	%f     used for float 
Each of the conversion specifiers can also provide a width statement and a precision statement, expressed as a float, where the digits to the left of the decimal are used for the total width, and the digits to the right of the decimal provide the precision for floats. 
Example 
%5d           is the specifier of a 5-digit-wide integer 
%15.5f      is the specifier of a 15-digit-wide float, of which the final five digits are dedicated to the decimal portion. 
The following Listing 17.15 illustrates various uses of printf():
--------------------------------------------------------------------------------------------------------------------------------- 17.15 starts
//17.15 Printing with printf()
#include <stdio.h>

int main()
{
   printf("%s","hello world\n"); // this is the printf in the standard form :  the conversion specifier %s indicates that this is a string. And the value for the string is, in this case, the quoted string "hello world"

   char *phrase = "Hello again!\n";  // un maniera alternativa di ottenere lo stesso risultato : using a char pointer rather than quoting the string right in place in the printf() statement.
   printf("%s",phrase);

   int x = 5;
   printf("%d\n",x);   // using the integer conversion specifier (%d) and for its value the integer variable x is used. 

   char *phraseTwo = "Here's some values: ";
   char *phraseThree = " and also these: ";
   int y = 7, z = 35;
   long longVar = 98456;
   float floatVar =  8.8f;

   printf("%s %d %d",phraseTwo,y,z);  // here three values are concatenated. Each conversion specifier is supplied, and then the values are provided, separated by commas. 
   printf("%s %ld %f\n",phraseThree,longVar,floatVar);

   char *phraseFour = "Formatted: ";
   printf("%s %5d %10d  %10.5f\n",phraseFour,y,z,floatVar); // format specifications are used to set the width and precision. As you can see all this is somewhat easier than using manipulators. As stated previously, however, the limitation here is that no type checking occurs and printf() cannot be declared a friend or member function of a class. So, if you want to print the various member data of a class, you must call each accessor method in the argument list sent to the printf() statement. 

   return 0;
}
--------------------------------------------------------------------------------------------------------------------------------- 17.15 ends
[1069 Day17] >> g++ List1715.cpp -o List1715.exe
	List1715.cpp:8:19: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]
    [...] un po di warning ma nessun errore critico.
[1070 Day17] >> ./List1715.exe 
hello world
Hello again!
5
Here's some values:  7 35 and also these:  98456 8.800000
Formatted:      7         35     8.80000
----------------------------------------------------------------------------------------------------------------------------------
>> OUTPUT manipulation summary / >> FORMAT OUTPUT MANIPULATION / >> cout format special characters [pag622 jesse]
Can you summarize how to manipulate output?
Answer: (with special thanks to Robert Francis) To format output in C++, you use a combination of 
A) special characters, 
B) output manipulators, 
C) and flags. 

A) SPECIAL CHARACTERS
The following special characters are included in an output string being sent to "cout" using the insertion operator: 
	\n    -> Newline 
	\r     -> Carriage return
	\t     -> Tab
	\\     -> Backlash
	\ddd (octal number)     -> ASCII character
	\a      -> Alarm (ring bell)
For example
	cout << "\aAn error occured\t"
rings the bell, 	prints an error message, and moves to the next tab stop. 

B) OUTPUT MANIPULATORS
Manipulators are used with the cout operator. Those manipulators that take arguments require that you include iomanip in your file. The following is a list of manipulators that do not require iomanip:
	flush    -> flushes the output buffer
	endl    -> inserts newline and flushes the output buffer
	oct    -> sets output base to octal
	dec    -> stes output base to decimal 
	hex    -> sets output base to hexadecimal 
The following is a list of manipulators that do require iomanip: 
	setbase(base)    -> sets output base (0=decimal, 8=octal, 10=decimal, 16=hex)
	setw(width)    -> sets minimum output field width
	setfill(ch)    -> fills characters to be used when width is defined
	setprecision(p)    -> sets precision for floating-point numbers
	setiosflags(f)    -> sets one or more ios flags
	resetiosflags(f)    -> resets one or more ios flags
For example 
	cout << setw(12) << setfill('#') << hex << x << endl;
sets the field width to 12, sets the fill character to '#', specifies hex output, prints the value of 'x', puts a newline in the buffer, and flushes the buffer. All the manipulators except flush, endl, and setw remain in effect until changed or until the end of the program. setw returns to the default after the current cout.  

C) FLAGS
A number of flags can be used with teh setiosflags and resetiosflags manipulators. These were listed in table 17.1 pag618 (te le avevo gia' riscritte sopra, e te le recopio qui per convenience) 
TABLE 17.1 Some of the iostream Set Flags
	showpoint  -> displays a decimal point and trainling zeros as requied by precision 
	showpos -> turns on the plus sign (+) before positive numbers. 
	left -> aligns output to the left 
	right -> aligns output to the right
	internal -> aligns the sign for a number to the left and aligns the value to the right 
	scientific -> shows floating point values in sicientific notation 
	fixed -> shows floating point numbers in decimal notation 
	showbase -> adds "0x" in front of hexadecimal numbers to indicate that it is a hexadecimal value 
	Uppercase -> shows hexadecimal and scientific numbers in uppercase 
	dec -> sets th base of the numbers for display to decimal  
	oct -> sets the bas eof the numbers for display to octal (= base 8)   
	hex -> sets the bas eof the numbers for display to hexadecimal (= base 16)
Additional information can be obtained from file "ios" and from your compiler's documentation. 
----------------------------------------------------------------------------------------------------------------------------------
>> FILE INPUT AND OUTPUT >> READ FROM FILE / >> WRITE TO FILE / >> FILE READ / >> FILE WRITE [pag623 jesse]
Streams provide a uniform way of dealing with data coming from the keyboard or the hard disk and going out to the console screen or hard disk. In either case, you can use the insertion and extraction operators or the other related functions and manipulators. To open and close files, you create "ifstream" and "ofstream" objects as described in the next few sections. 
---------------------------------------------------------------------------------------------------------------------------------
>> OFSTREAM usage / >> using the ofstream [pag624 jesse]
The particular objects used to read from or write to files are called ofstream objects. These are derived from the iostream objects you've been using so far. 
To get started with writing to a file, you must first create an ofstream object, and then associate that object with a particular file on your disk. To use ofstream objects, you must be certain to include fstream in your program. 
NOTE: because fstream includes iostream, you do not need to include iostream explicitly. 
------------------------------------------------------------------------------------------------
>> CONDITION STATES / >> eof() / >> bad() / >> fail() / >> good() [pag624 jesse]
The iostream objects maintain flags that report on the state of your input and output. You can check each of these flags using the Boolean functions eof(), bad(), fail() and good(). The function eof() returns true if the iostream object has encountered  EOF, end of file. The function bad() returns true if you attempt  an invalid operation. The function fail() returns true anytime bad() is true or an operation fails. Finally, the function good() returns true anytime all the three other functions are false (cioe' no EOF encountered, no attempted invalid operations, no failed operations)
-----------------------------------------------------------------------------------------------------------------------
>> OPEN FILE / >> FILE OPENING / >> READ FILE / >> WRITE TO FILE / >> WRITE FILE >> opening files for input and output [pag624 jesse]
To use a file, you must first open it. To pen the file myfile.cpp with an ofstream object, declare an instance of an ofstream object and pass in the filename as a parameter: 
	ofstream fout("myfile.cpp");  // cioe' apre il file per scriverci dentro e donare cosi' un output allo user
This attempts to open the file, myfile.ccp, for output. 
Opening this file for input works the same way, except that it uses an ifstream object: 
	ifstream fin("myfile.cpp"); // cioe' apre il file per leggerci dentro ed usarne il contenuto come INput per il programma
Note that "fout" and "fin" are name YOU define; here, fout has been used to reflect its similarity to cout, and fin has been used to refelect its similarity to cin. These could also be given names that reflect what is in the file they are accessing. 
[cioe' avremmo potuto scrivere ofstream fileOutputAdelaide("myfile.cpp")]
One important file stream function that you will need right away is >> close(). Every file stream object you create opens a file for reading (input), writing (output), or both.  It is important to close() the file after you finish reading or writing; this ensures that the file won't be corrupted and that the data you've written is flushed to the disk. 
After the stream objects are associated with files, they can be used the same as any other stream objects. The following Listing 17.16 illustrates this:
--------------------------------------------------------------------------------------------------------------------- 17.16 starts
//Listing 17.16 Opening Files for Read and Write
#include <fstream>
#include <iostream>
using namespace std;

int main()
{
   char fileName[80]; // creating buffer for the file name
   char buffer[255];    // setting aside another buffer for user input
   cout << "File name: ";  // the user is prompted to enter a filename
   cin >> fileName; // writing the entered filename into the "filename" buffer.

   ofstream fout(fileName);  // open for writing  : in questa linea an ofstream object is created "fout", which is associated with the new filename. This opens the file. ACHTUNG: if the file already exists, ITS CONTENTS ARE THROWN AWAY!
   fout << "This line written directly to the file...\n"; // writing a string of text directly to the file.
   cout << "Enter text for the file: ";
   cin.ignore(1,'\n');  // eat the newline after the file name ; in questa linea the newline character left over from the user's input of the filename is eaten by using the ignore() function you learned about earlier. 
   cin.getline(buffer,255);  // get the user's input
   fout << buffer << "\n";   // and write it to the file
   fout.close();             // close the file, ready for reopen

   ifstream fin(fileName);    // reopen for reading
   cout << "Here's the contents of the file:\n";
   char ch;
   while (fin.get(ch))
      cout << ch;

   cout << "\n***End of file contents.***\n";

   fin.close();            // always pays to be tidy
   return 0;
} 
--------------------------------------------------------------------------------------------------------------------- 17.16 ends
OUTPUT 
[1006 Day17] >> ./List1716.exe 
File name: antigravityMachinen         
Enter text for the file: It's not because you cannot find a solution to something, that you don't need to think about it
Here's the contents of the file:
This line written directly to the file...
It's not because you cannot find a solution to something, that you don't need to think about it

***End of file contents.***
[1007 Day17] >> ls  // ed in effetti all'interno della stessa cartella in cui hai lanciato il programma, troverai il nuovo file 
	antigravityMachinen
con dentro scritta la frase : 
	This line written directly to the file...
	It's not because you cannot find a solution to something, that you don't need to think about it
-----------------------------------------------------------------------------------------------------------------------
>> APPEND FILE / >> APPEND TO FILE / >> changing the default behaviour of ofstream on Open [pag626 jesse book]
The default behaviour upon opening a file is to create teh file if it doesn't yet exist and to truncate the file (that is, delete all its contents) if it does exist. If you don't want this default behaviour, you can explicitly provide a second argument to the constructor of your ofstream object. 
Valid values for the second argument include : 
[>> append]
- ios:app   -> appends to the end of existing files rather than truncating them.
	note: "app" is short for "append"
- ios::ate   -> places you at the end of the file, but you can write data anywhere in the file.
	note: "ate" is short for "at end"
- ios::trunc -> causes existing file to be truncated; the default. 
	note: "trunc" is short for "truncate"
- ios::nocreate -> if the file does not exist, the open fails.
- ios::noreplace -> if the file does already exist, the open fails. 
The following listing 17.17 illustrates using append by reopening the file from Listing 17.16 and appending to it. 
---------------------------------------------------------------------------------------------------------------------------------- listing 17.17 starts
//Listing 17.17 Appending to the End of a File
#include <fstream>
#include <iostream>
using namespace std;

int main()   // returns 1 on error
{
   char fileName[80];
   char buffer[255];
   cout << "Please reenter the file name: ";
   cin >> fileName;

   ifstream fin(fileName); // this time an input file stream object is created 
// >> INPUT FILE un espressione che puo' generare confusione 
// Per INPUT FILE si intende un file di INPUT per il programma, cioe' un file da aprire per leggerci dentro
// Al contrario un >> OUTPUT FILE sara' un file che apri per scriverci dentro, in modo da donare un file di output all'utilizzatore del programma.
   if (fin)                // already exists?      [note that "if(fin)" is synonymous with "if (fin.good()) "]
   {                        // if the file already exists its contents are printed with the following lines
      cout << "Current file contents:\n";
      char ch;
      while (fin.get(ch))
         cout << ch;
      cout << "\n***End of file contents.***\n";
   }
   fin.close(); // closing the input file 

   cout << "\nOpening " << fileName << " in append mode...\n";

   ofstream fout(fileName,ios::app);  // reopening the the same file this time in append mode 
   if (!fout) // the file is tested to ensure that the file was opened properly
// note that "!fout" is the same as testing "if (fout.fail())". 
   {   // if the file cannot be opened we print an error message and the program ends with the return statement.
      cout << "Unable to open " << fileName << " for appending.\n";   
      return(1);
   }

// on the contrary if the file opens successfully the user is then prompted to enter the text 
   cout << "\nEnter text for the file: ";
   cin.ignore(1,'\n');
   cin.getline(buffer,255);
   fout << buffer << "\n";
   fout.close(); // then the file is closed again.

   fin.open(fileName);  // reassign existing fin object!  ; ora riapriamo il file in read mode; however this time "fin" does not need to be redeclared. It is just reassigned to the same filename. 
   if (!fin) // as before we testing the opening of the file. 
   {
      cout << "Unable to open " << fileName << " for reading.\n";
      return(1);
   }
   cout << "\nHere's the contents of the file:\n";
   char ch;
   while (fin.get(ch))
      cout << ch;     // printring the contents of the file to screen
   cout << "\n***End of file contents.***\n";
   fin.close(); // closing the file for the final time.
   return 0;
}
---------------------------------------------------------------------------------------------------------------------------------- listing 17.17 ends 
OUTPUT
[1011 Day17] >> ./List1717.exe 
Please reenter the file name: antigravityMachinen
Current file contents:
This line written directly to the file...
It's not because you cannot find a solution to something, that you don't need to think about it

***End of file contents.***

Opening antigravityMachinen in append mode...

Enter text for the file: NEXT TO THE WALL keep next to the wall. Impenetrabile? non voltarle le spalle. Fedele restale accanto e l'improbabile non diventera' impossibile. 

Here's the contents of the file:
This line written directly to the file...
It's not because you cannot find a solution to something, that you don't need to think about it
NEXT TO THE WALL keep next to the wall. Impenetrabile? non voltarle le spalle. Fedele restale accanto e l'improbabile non diventera' impossibile. 

***End of file contents.***
----------------------------------------------------------------------------------------------------------------------------------
DO 
	- DO test each open of a file to ensure that it opened successfully.
	- DO reuse existing ifstream and ofstream objects. 
	- DO close all fstream objects when you are done using them.  
DON'T
	- DON'T try to close or reassign "cin" or "cout"
	- DON'T use printf() in your C++ programs if you don't need to.
----------------------------------------------------------------------------------------------------------------------------------
>> BINARY vs >> TEXT FILES  [pag629 jesse]
Some operating systems distinguish between text files and binary files. Text files store everything as text so large numbers such as 54,325 are stored as a string of numerals ('5', '4', '3', '2', '5') . This can be inefficient, but has the advantage that the text can be read using simple programs such as the DOS and Windows command-line program "type".
To help the file system distinguish between text and binary files, C++ provides the ios::binary flag. On many systems, this flag is ignored because all data is stored in binary format. On some rather prudish systems, the ios::binary flag is illegal and doesn't even compile!
Binary files can store not only integers and strings, but also entire data structures. You can write all the data at one time by using the write() method of fstream. 
If you use write() you can recover the data using read(). Each of these functions expects a pointer to character, however, so you must cast the address of your class to be a pointer to character. 
The second argument to these functions is the number of characters expected to be read or written, which you can determine using sizeof(). None that what is being written is the data, not the methods. What is recovered is only data. The following listing 17.18 illustrates writing the contents of an object to a file. 
---------------------------------------------------------------------------------------------------------------------------------- listing 17.18 starts
//Listing 17.18 Writing a Class to a File
#include <fstream>
#include <iostream>
using namespace std;
  
class Animal  // declaration of the class animal 
{
  public:
     Animal(int weight,long days):itsWeight(weight),DaysAlive(days){}
     ~Animal(){}
  
     int GetWeight()const { return itsWeight; }
     void SetWeight(int weight) { itsWeight = weight; }
  
     long GetDaysAlive()const { return DaysAlive; }
     void SetDaysAlive(long days) { DaysAlive = days; }
 
  private:
     int itsWeight;
     long DaysAlive;
};
  
int main()   // returns 1 on error
{
   char fileName[80];
  
  
   cout << "Please enter the file name: ";
   cin >> fileName;
   ofstream fout(fileName,ios::binary);  // in this line a file is created and opened for output in binary mode.  ["for output" = per scriverci poi dentro]
   if (!fout)
   {
      cout << "Unable to open " << fileName << " for writing.\n";
      return(1);
   }
  
   Animal Bear(50,100); //  an animal whose weight is 50 and who is 100 days old is created 
   fout.write((char*) &Bear,sizeof Bear); // its data is written to the file 
  
   fout.close();  // the file is closed. 
  
   ifstream fin(fileName,ios::binary); // reopening the file for reading in binary mode 
   if (!fin)
   {
      cout << "Unable to open " << fileName << " for reading.\n";
      return(1);
   }
  
   Animal BearTwo(1,1);  // A second animal is created, whose weight is 1 and who is only one day old. The data from the file is read into this new animal object see @readingData@ below
   cout << "BearTwo weight: " << BearTwo.GetWeight() << endl;
   cout << "BearTwo days: " << BearTwo.GetDaysAlive() << endl;
  
   fin.read((char*) &BearTwo, sizeof BearTwo);  // @readingData@ : since the data from the file is read into the BearTwo object, the existing data is wiping out, and it is replaced with the data from the file. That's why in the output the BearTwo, that initially weighs 1 and is 1 day old, becomes 50 kg heavy and 100 days old.
  
   cout << "BearTwo weight: " << BearTwo.GetWeight() << endl;
   cout << "BearTwo days: " << BearTwo.GetDaysAlive() << endl;
   fin.close();
   return 0;
}
---------------------------------------------------------------------------------------------------------------------------------- listing 17.18 ends
OUTPUT :
[1014 Day17] >> g++ List1718.cpp -o List1718.exe
[1015 Day17] >> ./List1718.exe 
Please enter the file name: riptide   // vedrai cosi' che nella stessa cartella viene creato un file "riptide" in formato binario
BearTwo weight: 1
BearTwo days: 1
BearTwo weight: 50
BearTwo days: 100
-------------------------------------------------------------------------------------------------------------------------------------
>> COMMAND LINE PROCESSING / >> COMMAND LINE OPTIONS [pag631 jesse]
Many operating systems, such as DOS and UNIX, enable the user to pass parameters to your program when the program starts. These are called command-line options and are typically separated by spaces on the command line. For example: 
	SomeProgram Param1 Param2 Param3
These parameters are not passed to main() directly. Instead, every program's main() function is passed TWO parameters:
1) the first parameter is an integer count of the number of arguments on the command line. Note that the program name itself is counted, so every program has at least one parameter. In the case of 
	SomeProgram Param1 Param2 Param3
has 4 parameters, that is the name of the program "SomeProgram" plus the three parameters that make a total of four command line arguments
2) the second parameter passed to main() is an array of pointers to character strings. Because an array name is a constant pointer to the first element of the array, you can declare this argument to be a pointer to a pointer to char, a pointer to an array of char, or an array of arrays of char. 
Typically, 1) the first argument is called >> argc (argument count) but you can call it anything you like.
The 2) second argument is often called >> argv (argument vector)  but again this is just a convention. 
It is common to test "argc" to ensure you've received the expected number of arguments and to use argv to access the strings themselves. Note that argv[0] is the name of the program, and argv[1] is the first parameter to the program, represented as a string. If your program takes two numbers as arguments, you need to translate these numbers to strings. The following listing 17.19 illustrates how to use the command-line arguments.  
---------------------------------------------------------------------------------------------------------------------------------- listing 17.19 starts
//Listing 17.19 Using Command-line Arguments
#include <iostream>
int main(int argc, char **argv) // the function main declares two arguments: argc is an integer that contains the count of command-line arguments, and argv is a pointer to the array of strings. 
// each string in the array pointer to by argv is a command line argument. Note that argv could just as easily have been declared as char *argv[] or char argv[][] . It is a matter of programming style how you declare argv; even though this program declared it as a pointer to pointer, arrays offsets were still used to access the individual strings. 
{
   std::cout << "Received " << argc << " arguments...\n";  // argc is used to print the number of command line arguments. 
   for (int i=0; i<argc; i++)
      std::cout << "argument " << i << ": " << argv[i] << std::endl;  // each of the command line arguments is printed, passing hte null terminated strings to cout by indexing into the array of strings. 
   return 0;
}
---------------------------------------------------------------------------------------------------------------------------------- listing 17.19 ends
OUTPUT 
[1018 Day17] >> g++ List1719.cpp -o List1719.exe
[1019 Day17] >> ./List1719.exe 
Received 1 arguments...  // se lanci giusto il programma senza scrivere nulla, avrai giusto un argument, il nome del programma stesso.
argument 0: ./List1719.exe
[1020 Day17] >> ./List1719.exe Navigator Flying Towards The Infinite and Beyond // ecco cosa accade se fai seguire il programma da una lista di parole:
Received 8 arguments...  // argc ci dona il numero totale di command line arguments = 7 (le nostre 7 parole inserite) + 1 (the program name ifself)
argument 0: ./List1719.exe
argument 1: Navigator
argument 2: Flying
argument 3: Towards
argument 4: The
argument 5: Infinite
argument 6: and
argument 7: Beyond
----------------------------------------------------------------------------------------------------------------------------------
A more common use of command line arguments is illustrated by modifying Listing 17.18 to take the filename as a command-line argument, as shown in the following 17.20 Listing. The declaration of the Animal class is the sam as in LIsting 17.18. This time however, rather than prompting  the user for the filename, command line arguments are used. 
---------------------------------------------------------------------------------------------------------------------------------- Listing 17.20 starts
//Listing 17.20 Using Command-line Arguments
#include <fstream>
#include <iostream>
using namespace std;  
class Animal
{
  public:
     Animal(int weight,long days):itsWeight(weight),DaysAlive(days){}
     ~Animal(){}
  
     int GetWeight()const { return itsWeight; }
     void SetWeight(int weight) { itsWeight = weight; }
  
     long GetDaysAlive()const { return  DaysAlive; }
     void SetDaysAlive(long days) { DaysAlive = days; }
  
  private:
     int itsWeight;
     long DaysAlive;
};
  
//rather than prompting  the user for the filename, command line arguments are used. 
int main(int argc, char *argv[])   // returns 1 on error
{    
   if (argc != 2)  // se lo user lancia giusto il programma "./List1720" senza nessun argument che lo segue, allora si printa su screen il seguente errore: 
   {
      cout << "Usage: " << argv[0] << " <filename>" << endl; // note that by using argv[0] rather than >> hard coding a program name, you can compile the program to have any name, and this usage statement works automatically. You can even rename the executable after it was compiled and the usage statement will still be correct!
// da questa frase comprendo meglio cosa si intenda per "hard coding", "hard code". You hard code quando al posto di mettere un parametro generale tipo "argv[0]" che rappresenti le varie possibilita', metti nero su bianco un nome specifico, piu' facile da scrivere ma perdi in generalita'.
      return(1);  // e si stoppa il programma ritornando 1. 
   }
 
// le linee seguenti vengono eseguite se lo user ha inserito un argument dopo il nome del programma tipo "./List1720 Navigator" 
   ofstream fout(argv[1],ios::binary); // opening the supplied fileName for binary output [cioe' per scrivere all'interno del file in formato binary] . No reason exists to copy the filename into a local temperary buffer. It can be used directly by accessing argv[1]
   if (!fout)
   {
      cout << "Unable to open " << argv[1] << " for writing.\n";  // continuaimo ad usare lo stesso trick di usare "argv[1]" in modo che verra' scritto il nome dell'argument immesso dalla user dopo il nome del programma (cioe' se typi "./List1720.exe Navigator" argv[1] e' Navigator)
      return(1);
   }
  
   Animal Bear(50,100);
   fout.write((char*) &Bear,sizeof Bear);
  
   fout.close();
   
   ifstream fin(argv[1],ios::binary); // reopening the same file for input [= per leggere il binary format che e' contenuto all'interno del file]
   if (!fin)
   {
      cout << "Unable to open " << argv[1] << " for reading.\n";
      return(1);
   }
  
   Animal BearTwo(1,1);
  
   cout << "BearTwo weight: " << BearTwo.GetWeight() << endl;
   cout << "BearTwo days: " << BearTwo.GetDaysAlive() << endl;
  
   fin.read((char*) &BearTwo, sizeof BearTwo);
  
   cout << "BearTwo weight: " << BearTwo.GetWeight() << endl;
   cout << "BearTwo days: " << BearTwo.GetDaysAlive() << endl;
   fin.close();
   return 0;
}
---------------------------------------------------------------------------------------------------------------------------------- Listing 17.20 ends
OUTPUT 
[1021 Day17] >> g++ List1720.cpp -o List1720.exe
[1022 Day17] >> ./List1720.exe 
Usage: ./List1720.exe <filename>
[1023 Day17] >> ./List1720.exe Navigator
BearTwo weight: 1
BearTwo days: 1
BearTwo weight: 50
BearTwo days: 100
[1024 Day17] >> vi Navigator // e dentro vi troverai il contenuto salvato in binario
----------------------------------------------------------------------------------------------------------------------------------
SUMMARY 
In this lesson streams were introduced, and teh global objects cout and cin were described. 
The goal of the istream and ostream objects is to encapsulate the work of writing to device drivers and buffering input and output. 
Four standard stream objects are created in every program 
	cout 
	cin 
	cerr
	clog 
Each of these can be redirected by many operating systems. 
The istream object cin is used for input, and its most common use is with the overloaded extraction operator (<<).
The ostrream object cout is used for output, and its most common use is with the overloaded insertion operator (>>).
[CICCIO trick per non confondere "insertion operator" vs "extraction operator"
>> insertion operator e' usato per INSerire qualcosa nell'output device (i.e. screen)  il suo simbolo e'  ">>" cioe' andando da sinistra a destra come la punta di una freccia comprime ed inserisce informazione dentro lo schermo 
>> extraction operator e' usato to EXTRACT qualcosa da un file or prompt from the user. Il suo simbolo e' "<<" che letto da sinistra a destra assomiglia all'imbuto di un hoover che aspira e decOMPRIME l'informazione for later further processing.]
Each of these objects has a number of the other member functions, such as get() and put(). Because the common forms of each of these methods returns a reference to a stream object, it is easy to concatenate each of these operators and functions. 
The state of stream objects can be changed by using manipulators. These can set the formatting and display characteristics and various other attributes of the stream objects. 
File I/0 can be accomplished by using the fstream class,  which derive from the stream classes. In addition to supporting the normal insertion and extraction operators, these objects also support read() and write() for storing and retreiving large binary objects.

Q&A
	- What is the difference between cerr and clog?
cerr is not buffered. Everything written to cerr is immediately written out. This is fine for errors to be written to the console screen, bu might have too high a performance cost for writing logs to disk. clog buffers its output, and thus can become more efficient, at the risk of losing part of the log if the program crashes. 
	- Why were streams created if printf() works well?
printf() does not support the strong type system of C++, and it does not support user-defined classes. Support for printf() is really just a carryover from the C programming language.  
	- What is the difference between cin.read() and cin.getline() ?
[>> cin.read() vs >> cin.getline()]
cin.read() is used for reading binary data structures 
getline() is used to read from the istream's buffer
	- What are the three forms of cin.get()  and what are their differences?
> The first form of get() is without parameters. This returns the value of the character found, and will return EOF (end of file) if the end of the file is reached. 
> The second form of get() takes a character reference as its parameter; that character is filled with the next character in the input stream. The return value is an iostream object. 
> The third form of get() takes an array, a maximum number of characters to get, and a terminating character. This form of get() fills the array with up to one fewer characters than the maximum (appending null) unless it reads the terminating character, in which case it immediately writes a null and leaves the terminating  character in  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

-------------------------------------------------------------------------------------------------------------------------
>> STATIC MEMBER DATA / >> SHARE DATA among object of the same type [pag506 jesse]
SHARING DATA AMONG OBJECTS OF THE SAME TYPE
At times we will want to keep track of data that applies to all objects of the same type. For example, you might want to know how many  objects for a specific class have been created in your program, and how many are still in existence. >> Static member variables are variables that are shared among all instances of a class. They are a compromise between global data , which is available to all parts of your program, and member data, which is usually available only to each object. 
[insomma se effettuiamo la metafora che l'intero programma e' NewYorkCity and the class we are focus our attention on is a citizen of NY, a global data would be il telefono del municipio che tutti i cittadini hanno sotto mano. A member data would be the number of computer in your home, di cui solo il cittadino stesso e' a conoscenza. A static member data would be il numero di emergenza del Queens District Fire Department, that is shared only by the instances of NY citizen living in Queens. ]
You can think of a static member as belonging  to the class rather than to the object. Normal member data is one per object, but static members are one per class. The following listing 15.1 declares a Cat object with a static data member, HowManyCats. This variable keeps track of now many Cat objects have been created. This is done by incrementing the static variable HowManyCats with each construction and decrementing  it with each destruction. 
------------------------------------------------------------------------------------------------------------------------------------ LISTING 15.1 START
	//Listing 15.1 static data members

	#include <iostream>
	using namespace std;

	class Cat
	{
	  public:
         // constructor for Cat
		Cat(int age):itsAge(age){HowManyCats++; }   // at each creation of a new Cat object the static member variable HowManyCats is incremented

        // destructor for Cat
		virtual ~Cat() { HowManyCats--; } // at each destruction of a new Cat object the static member variable HowManyCats is decremented

		virtual int GetAge() { return itsAge; }
		virtual void SetAge(int age) { itsAge = age; }
		static int HowManyCats;   // declaring static member variable. This variable keeps track of how many Cat objects have been created. 
        // note that in this HowManyCats declaration no storage space is set aside [cioe' e' sbagliato scrivere "static int HowManyCats = 0;" ]. Unlike the nonstatic member varaibles, no storage space is set aside by instantiating a Cat object because the HowManyCats member variable is not in the object.  On the contrary the variable is initialized outside of the class Cat see below @HowManyCatsInitialization@
	  private:
		int itsAge;  // @nonStaticMemberVariable@

	};

	int Cat::HowManyCats = 0; // @HowManyCatsInitialization@ static member variables are initialized OUTSIDE the class. 
/* ATTENTION !!! It is a common mistake to forget to declare static member variables and then to forge to define them. Don't let this happen to you! Of course, if it does, the linker will catch it with a pithy error message such as the following 
>> undefined symbol Cat::HowManyCats
On the contrary you don't need to do this for itsAge [see tag @nonStaticMemberVariable@] because it is a nonstatic member variable and is defined each time you make a Cat object. 
*/

	int main()
	{
	   const int MaxCats = 5; int i;
	   Cat *CatHouse[MaxCats];
	   for (i = 0; i<MaxCats; i++)
		  CatHouse[i] = new Cat(i);  // creating 5 new Cat object for five times, therefore the HowManyCats is incremented each time e il suo valore finale e' 5. 
           // nota come nella class Cat il constructor fosse "Cat(int age)" quind Cat(i) significa che usiamo la variabile i per assegnarla all'eta del gatto => itsAge = i 

	   for (i = 0; i<MaxCats; i++)
	   {
		  cout << "There are ";
		  cout << Cat::HowManyCats;
		  cout << " cats left!" << endl;
		  cout << "Deleting the one that is ";
		  cout << CatHouse[i]->GetAge();     // once you display the age of the cat
		  cout << " years old" << endl;
		  delete CatHouse[i];                         // you delete it e cosi' facendo vista la maniera con cui abbiamo dichiarato il destructor  "virtual ~Cat() { HowManyCats--; }" , la variable HowManyCats viene automaticamente decrementata.
		  CatHouse[i] = 0;                              
	   }
	   return 0;
	}
------------------------------------------------------------------------------------------------------------------------------------ LISTING 15.1 END
OUTPUT 
[1023 Day15] >> g++ List1501.cpp -o List1501.exe
[1024 Day15] >> ./List1501.exe 
There are 5 cats left!
Deleting the one that is 0 years old
There are 4 cats left!
Deleting the one that is 1 years old
There are 3 cats left!
Deleting the one that is 2 years old
There are 2 cats left!
Deleting the one that is 3 years old
There are 1 cats left!
Deleting the one that is 4 years old
---------------------------------------------------------------------------------------------

OBSERVATION : note that in the above program the static member variable "HowManyCats" is public and is accessed directly by main(). There is no reason for you to expose this member variable in this way. In fact, it is preferable to make it private along with the other member variables and provide a public accessor method, as long as you will always access the data through an instance of Cat. On the other hand, if you want to access  this data directly, without necessarily having a Cat object available, you have two options :
1) Keep it public, like in the Listing 15.2 just below   [o come suppongo pure questo listing] 
2) provide a static member function, as it will be discussed later.

---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.2 START
//Listing 15.2 static data members

#include <iostream>
using namespace std;

class Cat
{
  public:
     Cat(int age):itsAge(age){HowManyCats++; }
     virtual ~Cat() { HowManyCats--; }
     virtual int GetAge() { return itsAge; }
     virtual void SetAge(int age) { itsAge = age; }
     static int HowManyCats;

  private:
     int itsAge;
};

int Cat::HowManyCats = 0;

void TelepathicFunction();

int main()
{
   const int MaxCats = 5; int i;
   Cat *CatHouse[MaxCats];

   for (i = 0; i < MaxCats; i++)
   {
      CatHouse[i] = new Cat(i);
      TelepathicFunction();
   }

   for ( i = 0; i < MaxCats; i++)
   {
      delete CatHouse[i];
      TelepathicFunction();
   }
   return 0;
}

// Listing 15.2 is very much like Listing 15.1 expect for the addition of a new function, TelepathicFunction(). 
void TelepathicFunction()
{
   cout << "There are ";
   cout << Cat::HowManyCats << " cats alive!" << endl;
}
/* This function which does not create a Cat object, nor does it take a Cat object as a parameter, yet it can access the HowManyCats member variable. 
Again it is worth reemphasizing that this member variable is not in any particular object. It is in the class, where it is accessible to any member function. If public, this variable can be accessed by any function in the program, even when that function does not have an instance of a class.

*/
---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.2 END
OUTPUT 
[1025 Day15] >> g++ List1502.cpp -o List1502.exe
[1026 Day15] >> ./List1502.exe 
There are 1 cats alive!
There are 2 cats alive!
There are 3 cats alive!
There are 4 cats alive!
There are 5 cats alive!
There are 4 cats alive!
There are 3 cats alive!
There are 2 cats alive!
There are 1 cats alive!
There are 0 cats alive!
--------------------------------------------------------------------------------------------------------------------------------------------------
An alternative is to declare the static member variable HowManyCats to have a private access. If you do you can access it through a member function, but then you must have an object of that class available.  This approach is shown in the following listing 15.3. You will learn an alternative to this access (using static member functions) immediately after the analysis of Listing 15.3
---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.3 START
//Listing 15.3 private static data members
#include <iostream>
using std::cout;
using std::endl;

class Cat
{
  public:
    Cat(int age):itsAge(age){HowManyCats++; }
    virtual ~Cat() { HowManyCats--; }
    virtual int GetAge() { return itsAge; }
    virtual void SetAge(int age) { itsAge = age; }
    virtual int GetHowMany() { return HowManyCats; }

  private:
    int itsAge;
    static int HowManyCats;   // now the HowManyCat variable is declared to have private access 
/* you now cannot access this variable from nonmember functions such as TelepathicFunction() from the previous listing
Even thourgh HowManyCats is static, it is still within the scope of the class. As such, any class function, such as GetHowMany(), can access it, just as member functions can access any member data. However, for a function outside of a Cat object to call GetHowMany(), it must have a Cat object on which to call the function. 
*/

};

int Cat::HowManyCats = 0;

int main()
{
   const int MaxCats = 5; int i;
   Cat *CatHouse[MaxCats];

   for (i = 0; i < MaxCats; i++)
      CatHouse[i] = new Cat(i);

   for (i = 0; i < MaxCats; i++)
   {
      cout << "There are ";
      cout << CatHouse[i]->GetHowMany();
      cout << " cats left!\n";
      cout << "Deleting the one that is ";
      cout << CatHouse[i]->GetAge()+2;
      cout << " years old" << endl;
      delete CatHouse[i];
      CatHouse[i] = 0;
   }
   return 0;
}

---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.3 END
DO
	- DO use static member variables to share data among all instances of a class
	- DO make static member variables protected or private  if you want to restrict access to them
DON'T 
	- DON'T use static member variables to store data for one object. Static member data i shared among all objects of its class.
--------------------------------------------------------------------------------------------------------------------------------------------
>> STATIC MEMBER FUNCTIONS  [pag511 jesse]
Static member functions are like static member variables : They exist not in an object but in the scope of the class. Thus they can be called without having an object of that class, as illustrated in the following 15.4 Listing: 
---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.4 START
//Listing 15.4 static data members

#include <iostream>

class Cat
{
  public:
    Cat(int age):itsAge(age){HowManyCats++; }
    virtual ~Cat() { HowManyCats--; }
    virtual int GetAge() { return itsAge; }
    virtual void SetAge(int age) { itsAge = age; }
    static int GetHowMany() { return HowManyCats; } // since HowManyCats variable is declared private [see tag @privateVar@ below] we need a public static accessor function (in modo da poter accedere al valore della private static variable). Because GetHowMany() is public, it can accessed by any function, and because it is static, no need exists to have an object of type Cat on which to call it. Thus on line @accessPublicAccessor@ below, the function TelepathicFunction() is able to access the public static accessor, even though it has no access to a Cat object. 
  private:
    int itsAge;
    static int HowManyCats; // the static member variable HowManyCats is declared to have private access  [@privateVar@]
};

int Cat::HowManyCats = 0;

void TelepathicFunction();

int main()
{
   const int MaxCats = 5;
   Cat *CatHouse[MaxCats]; int i;
   for (i = 0; i < MaxCats; i++)
   {
      CatHouse[i] = new Cat(i);
      TelepathicFunction();
   }

   for ( i = 0; i < MaxCats; i++)
   {
      delete CatHouse[i];
      TelepathicFunction();
   }
   return 0;
}

void TelepathicFunction()
{
   std::cout <<"There are "  << Cat::GetHowMany()   // @accessPublicAccessor@  : Because GetHowMany() is public, it can accessed by any function, and because it is static, no need exists to have an object of type Cat on which to call it. Thus on line @accessPublicAccessor@ below, the function TelepathicFunction() is able to access the public static accessor, even though it has no access to a Cat object. You should note, however, that the function is fully qualified when it is called, meaning the function call is prefixed with the class name followed by two colons (cioe' GetHowMany() dev'essere preceduto da Cat::). You could also have called GetHowMany() on the Cat objects available in main(), the same as with any other accessor functions. 
             <<" cats alive!" << std::endl;
}
---------------------------------------------------------------------------------------------------------------------------------------- LISTING 15.4 END
NOTE: Static member functions do not have a "this" pointer. Therefore, they cannot be declared "const". Also, because member data variables are accessed in member functions using the "this" pointer, static member functions cannot access any nonstatic member variables!
>> STATIC MEMBER FUNCTIONS SUMMARY [pag513 jesse book]
You can access static member functions by calling them on an object of the class the same as you do any other member function, or you can call them without an object by fully qualifying the class and object name. 
Example 
class Cat 
{
	public:   // definisci un public static accessor
		static int GetHowMany() { return HowManyCats; }   
	private:  // in modo da porter accedere alla static variable che dichiari as private
		static int HowManyCats;
};
int Cat::HowManyCats = 0;
int main()
{
	int howMany; 
	Cat theCat;   // define a cat
	howMany = theCat.GetHowMany();   // access through an object
	howMany = Cat::GetHowMany();    // access without an object
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------
>> POINTERS to functions [pag514 jesse]
Just as an array name is a constant pointer to the first element of the array, a function name is  a constant pointer to the function. It is possible to declare a pointer variable that points to a function and to invoke the function by using that pointer. This can be very useful; it enables you to create programs that decide which functions to invoke based on user input. 
The only tricky part about function pointers is understanding the type of the object being pointed to. A pointer to "int" points to an integer variable, and a pointer to a function must point to a function of the appropriate  return type and signature. 
In the declaration 
	long ( * funcPtr ) (int);
funcPtr is declared to be a pointer (note the * in front of the name) that points to a functon that takes an integer parameter and returns a long. The parenthesis around * are necessary because teh parentheses around int bind more tightly; that is, they have higher precedence than the indirection operator (*). Without the first parenthesis, this would declare a function that takes an integer and return a pointer to long. (Remember spaces are meangless here)
Examine these two declarations: 
	long * Function (int);
	long (* funcPtr) (int);
The first, Function() is a function taking an integer and returning a pointer to a variable of type long. The second, funcPtr, is a pointer to a function taking an integer and returning a variable of type long. 
The declaration of a function pointer will always include the return type and the parentheses indicating the type of the parameters, if any. Listing 15.5 illustrates the declaration and use of function pointers. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------  Listing 15.5 start
	// Listing 15.5 Using function pointers
	#include <iostream>
	using namespace std;

// we define the following four functions each with the same return type and signature, returning "void" and taking two references to integers. 
	void Square (int&,int&); // @youCanPoint to me@
	void Cube (int&, int&); // @youCanPoint to me@
	void Swap (int&, int &); // @youCanPoint to me@
	void GetVals(int&, int&); // @youCanPoint to me@

	void PrintVals(int, int);

	int main()
	{
	   void (* pFunc) (int &, int &); // pFunc is declared to be a pointer to a function that returns void and takes two integer reference parameters.  Because the signatures match, any of the previous function [@youCanPoint to me@] can be pointed to by pFunc. The user is repeatedly offered the choice of which functions to invoke. and pFunc is assigned accordingly. 
	   bool fQuit = false;

	   int valOne=1, valTwo=2;
	   int choice;
	   while (fQuit == false)
	   {
		  cout <<  "(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: ";
		  cin >> choice;
		  switch (choice)
		  {
		      case 1: pFunc = GetVals; break;
		      case 2: pFunc = Square; break;
		      case 3: pFunc = Cube; break;
		      case 4: pFunc = Swap; break;
		     default: fQuit = true; break;
		  }

		  if (fQuit == false)
		  {

		      PrintVals(valOne, valTwo);  // current values of the two integers is printed
		      pFunc(valOne, valTwo); // the currently assigned function is invoked.
		      PrintVals(valOne, valTwo); // the values of the two integers are printed again. 
		  }
	   }
	   return 0;
	}

	void PrintVals(int x, int y)
	{
	   cout << "x: " << x << " y: " << y << endl;
	}

	void Square (int & rX, int & rY)
	{
	   rX *= rX;
	   rY *= rY;
	}

	void Cube (int & rX, int & rY)
	{
	   int tmp;

	   tmp = rX;
	   rX *= rX;
	   rX = rX * tmp;

	   tmp = rY;
	   rY *= rY;
	   rY = rY * tmp;
	}

	void Swap(int & rX, int & rY)
	{
	   int temp;
	   temp = rX;
	   rX = rY;
	   rY = temp;
	}

	void GetVals (int & rValOne, int & rValTwo)
	{
	   cout << "New value for ValOne: ";
	   cin >> rValOne;
	   cout << "New value for ValTwo: ";
	   cin >> rValTwo;
	} 
-------------------------------------------------------------------------------------------------------------------------------------------------------------  Listing 15.5 end
	[1027 Day15] >> g++ List1505.cpp -o List1505.exe
	[1028 Day15] >> ./List1505.exe 
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 2
	x: 1 y: 2
	x: 1 y: 4
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 3
	x: 1 y: 4
	x: 1 y: 64
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 4
	x: 1 y: 64
	x: 64 y: 1
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 2
	x: 64 y: 1
	x: 4096 y: 1
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 3
	x: 4096 y: 1
	x: 0 y: 1
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 1
	x: 0 y: 1
	New value for ValOne: 56
	New value for ValTwo: 3
	x: 56 y: 3
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 2
	x: 56 y: 3
	x: 3136 y: 9
	(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: 0
----------------------------------------------------------------------------------
SUMMARY >> FUNCTION POINTERS / >> POINTER TO FUNCTION [pag517 jesse]
A pointer to function is invoked the same as the functions it points to, except that the function pointer name is used instead of the function name. 
Assign a pointer to function to a specific by assigning to the function name without the parameters. The function name is a constant pointer to the function itself. Use the pointer to function the same as you would the function name. The pointer to function must agree in return value and signature with the function  to which you assign it. 
Example 
	long (*pFuncOne) (int, int);
	long SomeFunction (int, int);
	pFuncOne = SomeFunction; 
	pFuncOne(5,7);
ACHTUNG : Be aware that pointers to functions can be highly dangerious. You can accidentally assign to a function pointer when you want to call the function, or you can accidentally call the function when you want to assign to its pointer.
--------------------------------------------------------------------------------------------------------------------------
Why Use function pointers [pag 517 jesse]
Generally you shouldn't use function pointers. Function pointers date from the days of C, before object-oriented programming was available. They were provided to allow for a programming style that had some of the virtues of object orientation; however, if you are writing a program that is highly dynamic and needs to operate different  functionality based on runtime decisions, this can be a viable solution. You certainly could write a program like the above Listing 15.5 without function pointers, but the use of these pointers makes the intent and use of the program explicit: pick a function from a list, and then invoke it. 
Listing 15.6 uses the function prototypes and definitions from Listing 15.5, but the body of the program does not use a function pointer. Examine the differences between these two listings. 
------------------------------------------------------------------------------------------------------------------------- Listing 15.6  STARTS
// Listing 15.6 Without function pointers

#include <iostream>
using namespace std;

void Square (int&,int&);
void Cube (int&, int&);
void Swap (int&, int &);
void GetVals(int&, int&);
void PrintVals(int, int);

int main()
{
   bool fQuit = false;
   int valOne=1, valTwo=2;
   int choice;
   while (fQuit == false)
   {
      cout << "(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: ";
      cin >> choice;
      switch (choice)
      {
        case 1:
          PrintVals(valOne, valTwo);
          GetVals(valOne, valTwo);
          PrintVals(valOne, valTwo);
          break;

        case 2:
          PrintVals(valOne, valTwo);
          Square(valOne,valTwo);
          PrintVals(valOne, valTwo);
          break;

        case 3:
          PrintVals(valOne, valTwo);
          Cube(valOne, valTwo);
          PrintVals(valOne, valTwo);
          break;

        case 4:
          PrintVals(valOne, valTwo);
          Swap(valOne, valTwo);
          PrintVals(valOne, valTwo);
          break;

       default :
          fQuit = true;
          break;
      }
   }
   return 0;
}

void PrintVals(int x, int y)
{
   cout << "x: " << x << " y: " << y << endl;
}

void Square (int & rX, int & rY)
{
   rX *= rX;
   rY *= rY;
}

void Cube (int & rX, int & rY)
{
   int tmp;

   tmp = rX;
   rX *= rX;
   rX = rX * tmp;

   tmp = rY;
   rY *= rY;
   rY = rY * tmp;
}

void Swap(int & rX, int & rY)
{
   int temp;
   temp = rX;
   rX = rY;
   rY = temp;
}

void GetVals (int & rValOne, int & rValTwo)
{
   cout << "New value for ValOne: ";
   cin >> rValOne;
   cout << "New value for ValTwo: ";
   cin >> rValTwo;
}

------------------------------------------------------------------------------------------------------------------------- Listing 15.6  ENDS
OBSERVATIONS: Settings aside the increased size of the above code (comparato rispetto al listing 15.5) and the repeated calls to do the same thing, the overall clarity is somewhat diminished. This is an artificial case, however, created to show how pointers to functions work. In real-world conditions, the advantages are even clearer: Pointers to functions can eliminate duplicate code, clarify a program, and enable tables of functions that can be called bsed on runtime conditions. 
TIP: Object oriented programming should generally allow you to avoid the need to create or pass pointers to functions. Instead, call the desired function on the desired object or the desired static member function on the class. If you need an array of function pointers, ask yourself whether what you really need is an array of appropriate objects. 
SHORTHAND INVOCATION : the pointer to function does not need to be dereferenced, although you are free to do so. Therefore, if pFunc is a pointer to a function taking an integer and returning a variable of type long, and you assign pFunc to a matching function, you can invoke that function with either 
	pFunc(x);
or 
	(*pFunc) (x);
The two forms are identical. The former is just a shorthand version of the latter.
--------------------------------------------------------------------------------------------------------------------------  
>> ARRAYS OF POINTERS TO FUNCTIONS / >> POINTERS TO FUNCTIONS / >> ARRAY POINTERS TO FUNCTIONS
Just as you can declare an array of pointers to integers, you can declare an array of pointers to functions returning a specific value type and with a specific signature. The following listing 15.7 again rewrites Listing 15.5, this time using an array to invoke all the choices at once. 
------------------------------------------------------------------------------------------------------------------------------ Listing 15.7 STARTS
// Listing 15.7 
//demonstrates use of an array of pointers to functions

#include <iostream>
using namespace std;

void Square(int&,int&);
void Cube(int&, int&);
void Swap(int&, int &);
void GetVals(int&, int&);
void PrintVals(int, int);

int main()
{
   int valOne=1, valTwo=2;
   int choice, i;
   const MaxArray = 5;
   void (*pFuncArray[MaxArray])(int&, int&); // the array pFuncArray is declared to be an array of five pointers to functions that return void and that take two integer references. 

   for (i=0; i < MaxArray; i++)     // with this for cycle the user is asked to pick the functions to invoke, and each member of the array is assigned the address of the appropriate function. 
   {
      cout << "(1)Change Values (2)Square (3)Cube (4)Swap: ";
      cin >> choice;
      switch (choice)
      {
        case 1:   pFuncArray[i] = GetVals; break;
        case 2:   pFuncArray[i] = Square; break;
        case 3:   pFuncArray[i] = Cube; break;
        case 4:   pFuncArray[i] = Swap; break;
        default:  pFuncArray[i] = 0;
      }
   }

   for (i=0; i < MaxArray; i++) // with this for cycle, each function is invoked in turn. The result is printed after ech invocation. 
   {
      if ( pFuncArray[i] == 0 )
         continue;
      pFuncArray[i](valOne,valTwo);
      PrintVals(valOne,valTwo);
   }
   return 0;
}

void PrintVals(int x, int y)
{
   cout << "x: " << x << " y: " << y << endl;
}

void Square (int & rX, int & rY)
{
   rX *= rX;
   rY *= rY;
}

void Cube (int & rX, int & rY)
{
   int tmp;

   tmp = rX;
   rX *= rX;
   rX = rX * tmp;

   tmp = rY;
   rY *= rY;
   rY = rY * tmp;
}

void Swap(int & rX, int & rY)
{
   int temp;
   temp = rX;
   rX = rY;
   rY = temp;
}

void GetVals (int & rValOne, int & rValTwo)
{
   cout << "New value for ValOne: ";
   cin >> rValOne;
   cout << "New value for ValTwo: ";
   cin >> rValTwo;
}

------------------------------------------------------------------------------------------------------------------------------ Listing 15.7 ENDS
>> POINTERS TO FUNCTIONS TO OTHER FUNCTIONS / >> PASSING POINTERS TO FUNCTIONS TO OTHER FUNCTIONS [pag523 jesse]
The pointers to functions (and arrays of pointers to functions, for that matter) can be passed to other functions, which can take action and then call the right function using the pointer. You might improve listing 15.5 for example, by passing the chosen function pointer to another function [outside of main()], which prints the values, invokes the function and then prints the values again. The following listing 15.8  illustrates this variation.
------------------------------------------------------------------------------------------------------------------------------ Listing 15.8 STARTS
// Listing 15.8 Without function pointers

#include <iostream>
using namespace std;

void Square (int&,int&);
void Cube (int&, int&);
void Swap (int&, int &);
void GetVals(int&, int&);
// @pointerToFunction@
void PrintVals(void (*)(int&, int&),int&, int&);  // PrintVals is declared to be a function taking three parameters. 
// the first "void (*)(int&, int&)" is a pointer to a function that returns void but takes two integer reference parameters, and the second and third arguments to PrintVals are integer references.  
// This is the kind of declaration that you use infrequetly and probably look up in the book each time you need it, but it will save your program on those rare occasions when it is exactly the required construct. 

int main()
{
   int valOne=1, valTwo=2;
   int choice;
   bool fQuit = false;

   void (*pFunc)(int&, int&);  // in this line pFunc is declared to be a pointer to a function returning "void" and taking two parameters, both integer references. 

   while (fQuit == false)
   {
      cout << "(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: ";
      cin >> choice;
      switch (choice)
      {
        case 1:   pFunc = GetVals; break;
        case 2:   pFunc = Square; break;
        case 3:   pFunc = Cube; break;
        case 4:   pFunc = Swap; break;
        default:  fQuit = true; break;
      }
     
      if (fQuit == false)
         PrintVals ( pFunc, valOne, valTwo);   // calling PrintVals using the function pointer, pFunc, as the first parameter. 
   }

   return 0;
}

void PrintVals( void (*pFunc)(int&, int&),int& x, int& y)
{
   cout << "x: " << x << " y: " << y << endl;
   pFunc(x,y);
   cout << "x: " << x << " y: " << y << endl;
}

void Square (int & rX, int & rY)
{
   rX *= rX;
   rY *= rY;
}

void Cube (int & rX, int & rY)
{
   int tmp;

   tmp = rX;
   rX *= rX;
   rX = rX * tmp;

   tmp = rY;
   rY *= rY;
   rY = rY * tmp;
}

void Swap(int & rX, int & rY)
{
   int temp;
   temp = rX;
   rX = rY;
   rY = temp;
}

void GetVals (int & rValOne, int & rValTwo)
{
   cout << "New value for ValOne: ";
   cin >> rValOne;
   cout << "New value for ValTwo: ";
   cin >> rValTwo;
}

------------------------------------------------------------------------------------------------------------------------------ Listing 15.8 ENDS
>> TYPEDEF with POINTERS and FUNCTIONS / >> TYPEDEF POINTERS FUNCTIONS [pag 525 jesse]
The construct void (*) (int&, int&)  [see tag @pointerToFunction@ above] is cumbersome, at best. You can use typedef to simplify this, by declaring a type (in the following listing 15.9, it is called VPF) as a pointer to a function returning void and taking two integer references. Listing 15.9 rewrites listing 15.8 using this typedef statement.
------------------------------------------------------------------------------------------------------------------------------ Listing 15.9 START
// Listing 15.9. 
// Using typedef to make pointers to functions more readable

#include <iostream>
using namespace std;

void Square(int&,int&);
void Cube(int&, int&);
void Swap(int&, int &);
void GetVals(int&, int&);
typedef  void (*VPF) (int&, int&) ; // in this line, typedef is used to declare VPF to be of the type "pointer to function that returns void and takes two parameters, both integer references"
void PrintVals(VPF,int&, int&); // in this way, the function PrintVals can be declared in a more simpler way: it takes three pameters, a VPF and two integer references. 
/*
After the type VPF is defined, all subsequent uses to declare pFunc and PrintVals() are much cleaner. As you can see, the output is identical. Remember, a typedef primarily does a replacement. In this case, using the typedef makes your code much easier to follow.
*/

int main()
{
   int valOne=1, valTwo=2;
   int choice;
   bool fQuit = false;

   VPF pFunc;  // here pFunc is now declare to be of type VPF. 

   while (fQuit == false)
   {
      cout << "(0)Quit (1)Change Values (2)Square (3)Cube (4)Swap: ";
      cin >> choice;
      switch (choice)
      {
        case 1:   pFunc = GetVals; break;
        case 2:   pFunc = Square; break;
        case 3:   pFunc = Cube; break;
        case 4:   pFunc = Swap; break;
        default:  fQuit = true; break;
      }
      
      if (fQuit == false)
         PrintVals ( pFunc, valOne, valTwo);
   }
   return 0;
}

void PrintVals( VPF pFunc,int& x, int& y)
{
   cout << "x: " << x << " y: " << y << endl;
   pFunc(x,y);
   cout << "x: " << x << " y: " << y << endl;
}

void Square (int & rX, int & rY)
{
   rX *= rX;
   rY *= rY;
}

void Cube (int & rX, int & rY)
{
   int tmp;

   tmp = rX;
   rX *= rX;
   rX = rX * tmp;

   tmp = rY;
   rY *= rY;
   rY = rY * tmp;
}

void Swap(int & rX, int & rY)
{
   int temp;
   temp = rX;
   rX = rY;
   rY = temp;
}

void GetVals (int & rValOne, int & rValTwo)
{
   cout << "New value for ValOne: ";
   cin >> rValOne;
   cout << "New value for ValTwo: ";
   cin >> rValTwo;
}

------------------------------------------------------------------------------------------------------------------------------ Listing 15.9 END

>> POINTERS TO MEMBER FUNCTIONS / >> POINTERS MEMBER FUNCTIONS [pag528 jesse]
Up till this point, all the function pointers you've created have been for general, non class functions. It is also possible to create pointers to functions that are members of classes. This is a highly advanced and infrequently used technique that should be avoided whenever possible. It is, however, important to understand this technique as some people do choose to use it. 
To create a pointer to a member function, use the same syntax as with a pointer to a function, but include the class name and the scoping operator (::). Thus, if pFunc points to a member function of the class Shape, which takes two integers  and returns void, the declaration for pFunc is the following. 
	void (Shape::*pFunc) (int, int) ;     // si in effetti e' la prima volta che vediamo una costruzione del genere.
Pointers to member functions are used in the same way as pointers to functions, except that they require an object of the correct class on which to invoke them. The following Listing 15.10 illustrates the use of pointers to member functions.   
-------------------------------------------------------------------------------------------------------------------------- LISTING 15.10 START
//Listing 15.10 Pointers to member functions using virtual methods

#include <iostream>
using namespace std;


// in the following block, the abstract class Mammal is declared with two pure virtual methods: Speak() and Move(). Mammal is subclassed into Dog, Cat, and Horse, each of which overrides Speak() and Move().   NOTE : >> subclassed = cioe' classe derivata a partire da una altra classe.
class Mammal
{
  public:
     Mammal():itsAge(1) {  }
     virtual ~Mammal() { }
     virtual void Speak() const = 0;
     virtual void Move() const = 0;
  protected:
     int itsAge;
};

class Dog : public Mammal
{
  public:
    void Speak()const { cout << "Woof!" << endl; }
    void Move() const { cout << "Walking to heel..." << endl; }
};


class Cat : public Mammal
{
  public:
    void Speak()const { cout << "Meow!" << endl; }
    void Move() const { cout << "slinking..." << endl; }
};


class Horse : public Mammal
{
  public:
    void Speak()const { cout << "Winnie!" << endl; }
    void Move() const { cout << "Galloping..." << endl; }
};


int main()
{
   void (Mammal::*pFunc)() const =0;
   Mammal* ptr =0;
   int Animal;
   int Method;
   bool fQuit = false;

   while (fQuit == false)
   {
      cout << "(0)Quit (1)dog (2)cat (3)horse: "; // the user is asked to choose the type of animal to create.
      cin >> Animal;   // Based on this seletion, a new subclass of Animal is created on the free store and assigned to ptr in the following block.
      switch (Animal)  
      {
        case 1:   ptr = new Dog; break;
        case 2:   ptr = new Cat; break;
        case 3:   ptr = new Horse; break;
        default:  fQuit = true; break;
      }
      if (fQuit == false)
      {
         cout << "(1)Speak  (2)Move: ";   // the user is now given a second prompt asking him to select the method to invoke. 
         cin >> Method;
         switch (Method)     // the method selected by the user is then assigned to the pointer pFunc in the following block. 
         {
           case 1:  pFunc = Mammal::Speak; break;
           default: pFunc = Mammal::Move; break;
         }

          (ptr->*pFunc)();   // in this line the method chosen is invoked by the object created, by using the pointer ptr to access the object and pFunc to access the function. 
         delete ptr; // delete is called on the pointer ptr to return the memory set aside for the object to the free store. Note that no reason exists  to call delete on pFunc because this is a pointer to code, not an object on the free store. In fact, attempting to do so generates a compile-time error. 
      }
   }
   return 0;
}
-------------------------------------------------------------------------------------------------------------------------- LISTING 15.10 END

>> ARRAYS OF POINTERS TO MEMBER FUNCTIONS / > ARRAYS POINTER MEMBER FUNCTIONS [pag531 jesse]
As with pointers to functions, pointers to member functions can be stored in an array. The array can be initialized with the addresses of various member functions, and these can be invoked by offsets into the array. The following listing 15.11 illustrates this technique: 
-------------------------------------------------------------------------------------------------------------------------- LISTING 15.11 STARTS
//Listing 15.11 Array of pointers to member functions
#include <iostream>
using std::cout;
using std::endl;

class Dog // creation of the class Dog 
{
  public:  // the Dog class has 7 member functions all sharing the same return type and signature.
    void Speak()const { cout << "Woof!" << endl; }
    void Move() const { cout << "Walking to heel..." << endl; }
    void Eat() const { cout << "Gobbling food..." << endl; }
    void Growl() const { cout << "Grrrrr" << endl; }
    void Whimper() const { cout << "Whining noises..." << endl; }
    void RollOver() const { cout << "Rolling over..." << endl; }
    void PlayDead() const { cout << "The end of Little Caesar?" << endl; }
};

typedef void (Dog::*PDF)()const ;  // using typedef to declare PDF to be a pointer to a member function of Dog that takes no parameters and return no values and that is const: cioe' esattamente come the signature of the seven member functions of Dog. 
int main()
{
   const int MaxFuncs = 7;
   PDF DogFunctions[MaxFuncs] =  // the array DogFunctions is declared to hold seven of the member functions declared in the Dog class, and it is initialized with the addresses of these functions.
      {Dog::Speak,
       Dog::Move,
       Dog::Eat,
       Dog::Growl,
       Dog::Whimper,
       Dog::RollOver,
       Dog::PlayDead };

   Dog* pDog =0;
   int Method;
   bool fQuit = false;

   while (!fQuit)
   {
      cout << "(0)Quit (1)Speak (2)Move (3)Eat (4)Growl";   // the user is prompted to pick a method. 
      cout << " (5)Whimper (6)Roll Over (7)Play Dead: ";   // Unless Quit is picked, a new Dog is created on the heap, and then the correct method is invoked on the array on line @line46@ tag
      std::cin >> Method;
      if (Method <= 0 || Method >= 8)
      {
         fQuit = true;
      }
      else
      {
         pDog = new Dog;
// la seguente tecnica e' corretta ma e' meglio evitarla a tutti  i costi
         (pDog->*DogFunctions[Method-1])();  // @line46@ questa e' un'altra di quelle linee abbastanza rare in C++, tecnicita' avanzata, tipo il virtuosismo di un Rubistain suonante scale e trilli con le mani incrociate. Ecco il significato.   "(pDog->*DogFunctions[Method-1])(); " it is a call to a method in an object using a pointer stored to the method that is stored in an array at the offset of Method-1. Once again this is a technique that should be avoided whenever possible. If it must be used, document it extensively and try to think of another way to accomplish the desired  task. 
         delete pDog;
      }
   }
   return 0;
}
-------------------------------------------------------------------------------------------------------------------------- LISTING 15.11 ENDS
DO 
	- DO invoke pointers to member functions on a specific object of a class
	- DO use typedef to make pointer to member function declarations easier to read. 
DON'T 
	- DON'T use ointer to member function when simler solutions are possible. 
	- DON'T forget the parenthesis when declaring  a pointer to a function (versus a function that returns a pointer) 
SUMMARY: 
In this lesson you learnt how to create static member variables in your class. Each class, rather than each object, has one instance of the static member variable. It is possible to access this member variable without an object of the class type by fully qualifying  the name, assuming you've declared the static member to have public access. 
You learned that one use of static member variables is as counters across instances of the class. Because they are not part of the object, the declaration of static member variables does not allocate memory, and static member variables must be defined and initialized outside the declaration of the class. 
Static member functions are poart of the class in the same way that static member variables are. They can be accessed without a particular object of the class and can be used to access static member data. Static member functions cannot be used to access nonstatic member data because they do not have the this pointer. Because static member functions do not have a this pointer, they also cannot be made const. const in a member function indicates that this is const.
This lesson also included one of the more complex topics in C++. You learned how to declare and use pointers to functions and pointers to member functions. You saw how to create array of these pointers and how to pass them to functions, and how to call the functions whose pointers were stored in this way. You learned that this is not really a great idea, and the object-oriented tehcniques should allow you to avoid this in almost every situation.  
Q&A 
- Why use static data when I can use global data?
Static data is scoped to the class. In this manner, static data is available only through an object of the class, through an explicit call using the class name if they are public, or by using a static member function. Static data is typed to the class type, however, and the restricted access and strong typing makes static data safer than global data. 
- Why use static member functions when I can use global functions?
Static member functions are scoped to the class and can be called only by using an object of the class or an explicit full specification (such as ClassName::FunctionName()).
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> short circuit evaluation [pag25 moo book]
like with the || operator (the or operator that tests whether either of its operands is true). 
	condition1 || condition2
if condition1 is true, the condition2 won't be evaluated at all. This property is called short circuit evaluation. [migliora la performance, perche' stare a sprecare il tempo se il resto sia vero o meno, quando si ha gia' la verita' in mano?]

>> standard header [pag2 moo book]
for example 
	#include <iostream>
Including a standard header makes the associated library facilities available to the program. 

>> SCOPE of a VARIABLE
the scope of a variable specifies where it can be used in a program (esempio a restricted use all'interno di un for cycle) 
[pag161deitel]
SCOPE [altra definizione a pag225]
An identifier's scope is where the identifier can be referenced in a program. Some identifiers can be referenced throughout a program; others can be referenced from only limited portions of a program.  
[see also pag228deitel]
Also : [pag6 moo book] the statements between a pair of matching braces {} constitute a scope.
> The portion of the program where an identifier can be used is known as its scope. For example, when we declare a local variable in a block, it can be referred only in that block and in blocks nested within that block. 
> Ci sono sei tipologie di scope
- block scope 
- function scope   [vedi voce >> FUNCTION SCOPE]
- global namespace scope
- function-prototype scope
- class scope
- namespace scope
COMMON PROGRAMMING ERROR: accidentally using the same name for an identifier in an inner block that's used for an identifier in an outer block, when in fact you want the identifier in the outer block to be active for the duration of the inner block, is typically a logic error. [=> quindi sugo del discorso: non usare per nomi di variabili contenute in nested blocks dei nomi di variabili che hai gia' utilizzato nel blocco esterno che circonda i nested blocks]
OSSERVAZIONE 2:
[from pag231]
nota come quando si usa 
	static int 
all'interno di una funzione l'inizializzazione viene effettuata the first time the function is called, mentre nelle successive si prende il valore che la variabile ha assunto
OSSERVAZIONE 3 [from pag261deitel]: static-storage-duration variables exist from the point at which the program begins execution until the program terminates.Unlike automatic variables, static local variables retain their values when the function in which they're declared returns to its caller.

>> SCOPE OF A CLASS / >> CLASS SCOPE
[pag384 deitel]
A class's data members and member functions belong to that class's scope. Nonmember functions are defined at "global namespace scope" by default
same page see def: >> handle of an object , >> implicit handle
pag 386 class scope vs >> block scope

>> SCOPES [mike game programming pag153]
A variable's scope determines where the variable can be seen in your program. Scopes allow you to limit the accessibility of variables and are the key to encapsulation, helping keep separate parts of your program, such as functions, apart from each other.
Example 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter05/scoping.cpp
NOTE: every time you use curly braces to create a block, you create a scope. Functions are on example of this. Variables declared in a scope aren't visible outside of that scope. This means that variables declared in a function aren't visible outside of that function. 
Variables declared inside a function are considered >> local variables, they're local to the function. This is what makes functions encapsulated.
NOTE: come mostrato nell'esempio qui sotto (extracted from Full Example below), you can create a nested scope with a pair of curly braces in an existing scope. example
	    {
        cout << "In main() in a new scope var is: " << var << "\n\n";

        cout << "Creating new var in new scope.\n";
        int var = 10;  // variable in new scope, hides other variable named var    -> una volta usciti da queste parenthesis non si potra' piu' avere il valore di var = 10 
        cout << "In main() in a new scope var is: " << var << "\n\n";
        }
-----------------------------------------------------------------------
Full Example 
	// Scoping
	// Demonstrates scopes
	
	#include <iostream>
	
	using namespace std;
	
	void func();
	
	int main()
	{
	    int var = 5;  // local variable in main()
	    cout << "In main() var is: " << var << "\n\n";
	
	    func();
	
	    cout << "Back in main() var is: " << var << "\n\n";
	
	    {
	        cout << "In main() in a new scope var is: " << var << "\n\n";
	
	        cout << "Creating new var in new scope.\n";
	        int var = 10;  // variable in new scope, hides other variable named var
	        cout << "In main() in a new scope var is: " << var << "\n\n";
	    }
	
	    cout << "At end of main() var created in new scope no longer exists.\n";
	    cout << "At end of main() var is: " << var << "\n";
	
	    return 0;
	}
	
	void func()
	{
	    int var = -5;  // local variable in func()
	    cout << "In func() var is: " << var << "\n\n";
	}
------------------------------------------------------------- end program
NOTE: when you define variables inside "for" loops, "while" loops, "if" statements, and "switch" statements, these variables don't exist outside their structures. They act like variables declared in a nested scope. For example, in the following code, the variable "i" doesn't exist outside the loop. 
	for(int i=0; i < 10; ++i)
	{
		cout << i;
	} // i doesn't exist outside the loop.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> SENTINEL CONTROLLED REPETITION 
[pag125deitel]
in a sentinel controlled repetition the number of repetitions is not known before the loop begins executing. We use a special value called  a sentinel value (also called a signal value, a dummy value or flag value) to indicate "end of data entry".

>> SEQUENTIAL EXECUTION 
[deitel 107]
Normally, statements in a program execute one after the other in the order in which they're written. This is called sequential execution. Various C++ statements enable you to specify that the next statement to execute may be other than the next one in sequence. This is called transfer of control.

>> SET FUNCTION advice
[from 97 deitel]
A public set function should carefully scrutineze any attempt to modify the value of a data member to ensure that the new value is appropriate for that data item.
Making data member private and controlling access, especially write access, to those data members through public member functions helps ensure data integrity. 

>> SET OPERATIONS [nell'ambito dei standard library algorithms]
[pag716 deitel]
>> set_difference / >> set_intersection / >> set_symmetric_difference / >> set_union
they are useful for manipulating sets of sorted values.
EXAMPLE @ /home/dia/Deitel-Code_Examples/ch16/fig16_10/fig16_10.cpp
OUTPUT 
a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	a3 contains: 4 5 6 11 15
	
	a1 includes a2
	a1 does not include a3
	
	set_difference of a1 and a2 is: 1 2 3 9 10
	
	set_intersection of a1 and a2 is: 4 5 6 7 8
	
	set_symmetric_difference of a1 and a3 is: 1 2 3 7 8 9 10 11 15  [>> set_symmetric_difference cioe' per raccogliere tutti gli elementi di a1 e di a3 che non appartengono all'intersezione di a1 e a3]
	
	set_union of a1 and a3 is: 1 2 3 4 5 6 7 8 9 10 11 15
------------------------------------------------------------------
>> includes algorithm
[pag717 deitel]
 25    // determine whether a2 is completely contained in a1
 26    if ( includes( a1.cbegin(), a1.cend(), a2.cbegin(), a2.cend() ) )
 27       cout << "\n\na1 includes a2";
 28    else
 29       cout << "\n\na1 does not include a2";
lines 26 adn 32 call the includes algorithm, which compares two sets of sorted values to determine whether every element of the second set is in the first set. If so, includes returns true; otherwise, it returns false. The first two iterator arguments must be at least input iterators and must describe the first set of values. In line 26 the first set consists of the elements from a1.cbegin() up to, but not including, a1.cend(). The last two iterator arguments must be at least input iterators and must describe the second set of values. In this example, the second set consists of the elements from a2.cbeing() up to, but not including a2.cend().
Esempio di output 
	a2 contains: 4 5 6 7 8
	a3 contains: 4 5 6 11 15
	
	a1 includes a2
	a1 does not include a3
---------------------------------------------------------------------
>> set_difference algorithm \ >> difference find between to containers. 
[pag718 deitel]
 39    // determine elements of a1 not in a2
 40    auto result1 = set_difference( a1.cbegin(), a1.cend(),
 41       a2.cbegin(), a2.cend(), difference.begin() );
ESEMPIO di output 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	set_difference of a1 and a2 is: 1 2 3 9 10
Lines 40-41 use the set_difference algorithm to find the elements from the first set of sorted values that are not in the second set of sorted values (both sets of values must be in ascending order). The elements that are different are copied into the fifth argument (in this case the array difference)
---------------------------------------------------------------------
>> set_intersection algorithm 
[pag718 deitel]
 47    // determine elements in both a1 and a2
 48    auto result2 = set_intersection( a1.cbegin(), a1.cend(),
 49       a2.cbegin(), a2.cend(), intersection.begin() );
lines 48-49 use the set_intersection algorithm to determine the elements from the first set of sorted values that are in the second set of sorted values (both sets of values must be in ascending order). The elements common to both sets are copied into the fifth argument (in this case, array intersection).
ESEMPIO DI OUTPUT:
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a2 contains: 4 5 6 7 8
	set_intersection of a1 and a2 is: 4 5 6 7 8
-----------------------------------------------------------------------
>> set_symmetric_difference algorithm 
[pag718 deitel]
 55    // determine elements of a1 that are not in a2 and 
 56    // elements of a2 that are not in a1
 57    auto result3 = set_symmetric_difference( a1.cbegin(), a1.cend(),
 58       a3.cbegin(), a3.cend(), symmetric_difference.begin() );
Lines 57-58 use the set_symmetric_difference algorithm to determine the elements in the first set that are not in the second set and the elements in the second set that are not in the first set (both sets must be in ascending order). The elements that are different are copied from both sets into the fifth argument (the ar\ay symmetric_difference).
[detto in parole spicciole: ti riunisce tutti gli elementi appartenenti ai due insiemi/containers ma non all'intersezione dei  due insiemi/ containers]
ESEMPIO DI OUTPUT 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a3 contains: 4 5 6 11 15
	set_symmetric_difference of a1 and a3 is: 1 2 3 7 8 9 10 11 15
--------------------------------------------------------------------
>> set_union algorithm
[pag719 deitel]
 64    // determine elements that are in either or both sets
 65    auto result4 = set_union( a1.cbegin(), a1.cend(),
 66       a3.cbegin(), a3.cend(), unionSet.begin() );
Lines 65-66 use the set_union algorithm to create a set of all the elements that are in either or both of the two sorted sets (both sets of values must be in ascending order). The elements are copied from both sets into the fifth argument (in this case the array unionSet)
ESEMPIO DI OUTPUT 
	a1 contains: 1 2 3 4 5 6 7 8 9 10
	a3 contains: 4 5 6 11 15
	set_union of a1 and a3 is: 1 2 3 4 5 6 7 8 9 10 11 15
----------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> INCLUDE "" vs INCLUDE <> [pag66 moo book]
supponi di avere 
	#include "median.h"
	#include <vector>
Quando we use a #include directive with double quotes rather than angle brackets, surrounding the header name, we are saying that we want the compiler to copy the entire contents of the header file that correpsonds to that name into your program in place of the # include\81@\81@directive.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STRUCTURES VS CLASSES [deitel pag880]  + pag 160 moo book
The only differences between structures and classes in C++ is that 
	structures members default to public access and 
	class members default to private access 
when no access specifiers are used and that 
	structures default to public inheritance whereas
	classes default to private inheritance. 
The presentation you find at pag881 et seguenti are included for the benefit of those who will work with legacy C and C++ code 
note : >> legacy C = il C usato in precendenza. In ambito informatico >> legacy = utilizzato in precedenza. 
Nel capitolo trovi discussi 
>> bitwise operators that allow you to access and manipulate the individual bits in bytes of data.
>> bitfields = special structures that can be used to specify the exact number of bits a variable occupies in memory. 
These bit manipulation techinques are common in programs that interact directly with hardware devices that have limited memory. 
-------------
Structures Definitions 
Consider the following structure definition 
	struct Card
	{
		string face;
		string suit;
	}; // end struct Card
Keyword struct introduces the definition for structure Card. The identifier Card is the structure name and is sued in C++ to declare variables of the structure type. Card's definiton contain two string members "face" and "suit"
The following declarations :
	Card oneCard;
	Card deck [ 52 ];   // ricordo da Mike che il deck = mazzo di 52 carte appunto
	Card *cardPtr;
declare oneCard to be a structure variable of type Card, deck to be an array with 52 elements of type Card and cardPtr to be a pointer to a Card structure. Variables of a given structure type can also be declared by placing a comma separated list of the variable names between the closing brace of the structure definition and the semicolon that ends the structure definition. For example the preceding declarations could have been incorporated into the Card definition as follows:
 	struct Card
	{
		string face;
		string suit;
	}; oneCard, deck[ 52 ], *cardPtr;
As with classes, structures members are not necessarily stored in consecutive bytes of memory. Sometimes there are holes in a structure, because some computers store specific data types only on ceratin memory boundaries for performance reasons, such as half word, word or double word boudaries.
>> WORD = a word is a standard memory unit used to store data in a computer, usually two, four or eight bytes an typically eight bytes on today's (@2015 suppongo che per te che leggi sarai gia' al quantum computer :) popular 64bit
--------------------------------------------------------------------------------------------
>> typedef [deitel pag882]
keyword typedef provides a mechanism for creating synonyms (or >> aliases) for previously defined data types. Names for structure types are often defined with typedef to more readable type names. For example, the statement
	typedef Card *CardPtr;
defines the new type name CardPtr as a synonym for type Card *.
Creating a new name with typedef does not create a new type; typedef simply creates a new type name that can then be used in the program as an alias for an existing type name. 
>> typedef example from pag 53 jesse
// Demonstrates typedef keyword
#include <iostream>
  
typedef unsigned short int USHORT;   //typedef defined
  
int main()
{
  
   using std::cout;
   using std::endl;
  
   USHORT  Width = 5;   // e typare "USHORT" al posto di "unsigned short in" e' molto piu' comodo, veloce e meno error-prone
   USHORT Length;
   Length = 10;
   USHORT Area  = Width * Length;
   cout << "Width:" << Width << "\n";
   cout << "Length: "  << Length << endl;
   cout << "Area: " << Area <<endl;
   return 0;
}
//////////////////////////////////////////////////////////////////////////////////////
--------------------------------------------------------------------------------------------
>> BYTE = 8 bits
from pag 812 jesse: Because early computers could send eight bits at a time, it was natural to start writring code using 8-bit numbers called bytes.
TRICK se sei in dubbio su Byte 4 or 8 bits. 
Sono 8 bit di cui hai bisogno perche' per un buon bite (morso) hai bisogno di almeno 4 denti sopra e 4 denti sotto.
--------------------------------------------------------------------------------------------
>> BITWISE OPERATORS [deitel pag885] C++ provides extensive bit-manipulation capabilities for getting down to the so called bits and bytes level. Operating systems, test equipment software, networking software and many other kinds of software require that you communicate "directly with the hardware". The book introduce each of the bitwise operators, and discuss how to save memory using bit fields.
All data is represented internally by computers as sequences of bits. Each >> bit can assume the value 0 or the value 1. On most systems, a sequence of eight bits, each of which forms a >> byte (= 8 bits) the standard storage unit for a variable of type char. 
NOTE: bitwise data manipulations are machine dependent.
The bitwise operators are
	&
	|
	^
	<<
	>>
	~
where
	& = bitwise AND
	| = bitwise inclusive OR
	^ = bitwise exclusive OR
	<< = left shift
	>> = right shift
	~ = bitwise complement
The bitwise AND, bitwise inclusive OR and bitwise exclusive OR operators compare their two operand bit by bit.
	& bitwise AND operator sets each bit in the result to 1 if the corresponding bit in both operands is 1.
	| bitwise inclusive OR operator sets each bit in the result to 1 if the corresponding bit in either (or both) operand(s) is 1.
	^ bitwise exclusive OR operator sets each bit in the result to 1 if the corresponding bit in either operand (BUT NOT both) is 1.
	<< the left shift operator shifts the bits of its left operand to the left by the number of bits specified in its right operand.
	>> the right shift operator shifts the bits in its left operand to the rigth by the number of bits specified in its right operand
	~ the bitwise complement operator sets all 0 bits in its operand to 1 in the result and set all 1 bits in its operand to 0 in the result.
-------------------------------------------------------------------------------------------------------------- mettiamo  in forma le precedenti frasi in una tabella
OPERATOR    NAME                  DESCRIPTION
&           bitwise AND           the bits in the result are set to 1 if the corresponding bits in the 2 operands are both 1
|           bitwise inclusive OR  the bits in the result are set to 1 if one or both of the corresponding bits in the 2 operands is 1
^           bitwise exclusive OR  the bits in the result are set to 1 if exactly one of the corresponding bits in the 2 operands is 1
<<          left shift            shifts the bits of the first operand left by the number of gits specified by the second operand; fill from right with 0 bits
>>          right shift with sign extension     Shifts the bits of the first operand right by the number of bits specified by the second operand; the method of filling from the left is machine dependent
~           bitwise complement    all 0 bits are set to 1 and all 1 bits are set to 0
---------------------------------------------------------------------------------------------------------------
EXAMPLES 
>> BINARY REPRESENTATION PRINT OF INTEGRAL VALUE [pag886 deitel]
// Fig. 22.6: fig22_06.cpp
// Printing an unsigned integer in bits.
#include <iostream>
#include <iomanip>
using namespace std;

void displayBits( unsigned ); // prototype

int main()
{
   unsigned inputValue = 0; // integral value to print in binary

   cout << "Enter an unsigned integer: ";
   cin >> inputValue;
   displayBits( inputValue );
} // end main

// display bits of an unsigned integer value
void displayBits( unsigned value )
{
   const int SHIFT = 8 * sizeof( unsigned ) - 1;
   const unsigned MASK = 1 << SHIFT;      // >> MASK qui trovi un esempio di utilizzo di MASK [pag887deitel]: often the bitwise AND operator is used with an operand called a mask (= an integer value with specific bits set to 1). Masks are used to hide some its in a value while selecting other bits.

   cout << setw( 10 ) << value << " = ";

   // display bits
   for ( unsigned i = 1; i <= SHIFT + 1; ++i ) 
   {
      cout << ( value & MASK ? '1' : '0' );
      value <<= 1; // shift value left by 1

      if ( i % 8 == 0 ) // output a space after 8 bits
         cout << ' ';
   } // end for

   cout << endl;
} // end function displayBits
--------------------------------------------------------------------------------------------------
>> BITWISE ASSIGNMENT OPERATORS [pag893 deitel]
&= 	bitwise AND assignment operator
|=	bitwise inclusive OR assignment operator
^=	bitwise exclusive OR assignment operator
<<=	left shift assignment operator
>>=	right shift with sign extension assignment operator
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> protection labels [pag160 moo book]
Per protection labels si intendono le labels tipo 
	public:
o anche
	private:
Each protection label defines the accessibility of all the member that follow the label. Label can occur in any order within the class , and can occur in any order within the class, and can occur multiple times.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> struct [pag61-62 moo book]
Nell'esempio qui sotto trovi
	struct Student_info {
		string name;
		double midterm, final;
		vector<double> homework;
	};	// note the semicolon--it's required
This struct definition says that Student_info is a type, which has four data members. Because Student_info is a type, we can define objects of that type, each of which will contain an instance of these four data members.
Each object of Student_info type holds information about one student. Because Student_info is a type, we can use a vector <Student_info> object to hold information about an arbitrary number of students, just as we used a vector<double> object to hold an arbitrary number of nomework grades. [cioe' cosi' come di solito hai dei vettori di double, ora avrai un vettoeri con degli elementi di type custom, degli elementi ciascuno dei quali contiene multipli elementi. Se espandessi il tutto ti ritrovi di fatto con una matrice.]
ADDITIONAL OBSERVATION from pag 72 moo book
A structure is a type that contains zero or more members. Each object of the structure type contains its own instance of each of its members. Every structure msut have a corresponding definition:
	struct type-name {
		type-specifier member-name;
		...
	};   // note the semicolon
Like all definitions, a structure definition nay appear only once per source file, so it should normally appear in a aproperly guarded header file.
------------------------------------------------------------------------------------------------------------[full program from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main2.cc]
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

#ifdef _MSC_VER
#include "../minmax.h"
#else
using std::max;
#endif

using std::cin;
using std::cout;
using std::domain_error;
using std::endl;
using std::istream;
using std::ostream;
using std::setprecision;
using std::setw;
using std::sort;
using std::streamsize;
using std::string;
using std::vector;

struct Student_info {
	string name;
	double midterm, final;
	vector<double> homework;
};	// note the semicolon--it's required

// compute the median of a `vector<double>'
// note that calling this function copies the entire argument `vector'
double median(vector<double> vec)
{
#ifdef _MSC_VER
	typedef std::vector<double>::size_type vec_sz;
#else
	typedef vector<double>::size_type vec_sz;
#endif

	vec_sz size = vec.size();
	if (size == 0)
		throw domain_error("median of an empty vector");

	sort(vec.begin(), vec.end());

	vec_sz mid = size/2;

	return size % 2 == 0 ? (vec[mid] + vec[mid-1]) / 2 : vec[mid];
}

// compute a student's overall grade from midterm and final exam grades and homework grade
double grade(double midterm, double final, double homework)
{
	return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

// compute a student's overall grade from midterm and final exam grades
// and vector of homework grades.
// this function does not copy its argument, because `median' does so for us.
double grade(double midterm, double final, const vector<double>& hw)
{
	if (hw.size() == 0)
		throw domain_error("student has done no homework");
	return grade(midterm, final, median(hw));
}

double grade(const Student_info& s)
{
	return grade(s.midterm, s.final, s.homework);
}

// read homework grades from an input stream into a `vector<double>'
istream& read_hw(istream& in, vector<double>& hw)
{
	if (in) {
		// get rid of previous contents
		hw.clear();

		// read homework grades
		double x;
		while (in >> x)
			hw.push_back(x);

		// clear the stream so that input will work for the next student
		in.clear();
	}
	return in;
}

istream& read(istream& is, Student_info& s)
{
	// read and store the student's name and midterm and final exam grades
	is >> s.name >> s.midterm >> s.final;

	read_hw(is, s.homework);  // read and store all the student's homework grades
	return is;
}

bool compare(const Student_info& x, const Student_info& y)
{
	return x.name < y.name;
}

int main()
{
	vector<Student_info> students;
	Student_info record;
	string::size_type maxlen = 0;

	// read and store all the records, and find the length of the longest name
	while (read(cin, record)) {
		maxlen = max(maxlen, record.name.size());
		students.push_back(record);
	}

	// alphabetize the records
	sort(students.begin(), students.end(), compare);

#ifdef _MSC_VER
	for (std::vector<Student_info>::size_type i = 0;
#else
	for (vector<Student_info>::size_type i = 0;
#endif
	     i != students.size(); ++i) {

		// write the name, padded on the right to `maxlen' `+' `1' characters
		cout << students[i].name
		     << string(maxlen + 1 - students[i].name.size(), ' ');

		// compute and write the grade
		try {
			double final_grade = grade(students[i]);
			streamsize prec = cout.precision();
			cout << setprecision(3) << final_grade
			     << setprecision(prec);
		} catch (domain_error e) {
			cout << e.what();
		}

		cout << endl;
	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> insert element in sorted sequence. >> sorted sequence element insertion
>> lower_bound / >> upper_bound / >> equal_range
[pag719 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_11/fig16_11.cpp
>> lower_bound algorithm 
[pag721 deitel]
 19    // determine lower-bound insertion point for 6 in a
 20    auto lower = lower_bound( a.cbegin(), a.cend(), 6 );
 21    cout << "\n\nLower bound of 6 is element "
 22       << ( lower - a.cbegin() ) << " of array a";
line 20 uses the lower_bound algoirthm to find the first location in a sorted sequence of values at which the third argument could be inserted in teh sequence such that the sequence would still be sorted in ascending order. The first two iterator arguments must be at least forward iterators. The third argument is the vlue for which to determine the lower bound. The algorithm returns a forward iterator pointing to the position at which the insert can occur. [pretty koool!!] A second version fo lower_bound takes as fourth argument a binary predicate function indicating the order in which the elements were originally sorted. 
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8	
	Lower bound of 6 is element 5 of array a
Ciccio spiegazione spicciola 
	element position 0 1 2 3 4 5 6 7 8 9
	element value    2 2 4 4 4 6 6 6 6 8
Quindi la prima posizione in cui potrai inserire il valore 6 in modo che una volta inserito la sequenza sia ancora in ordine, e' la posizione 5.
-----------------------------------------------------------------------
>> upper_bound algorithm
 24    // determine upper-bound insertion point for 6 in a
 25    auto upper = upper_bound( a.cbegin(), a.cend(), 6 );
 26    cout << "\nUpper bound of 6 is element "
 27       << ( upper - a.cbegin() ) << " of array a";
Line 25 uses the upper_bound algorithm to find the last location in a sorted sequence of values at which the third argument could be inserted in the sequence such that the sequence would still be sorted in ascending order. The first two iteartor arguments must be at least forward itearators. The third argument is the value for which to determine the upper bound. The algorithm returns a forward iteartor pointing to the position at which the insert can occur. 
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8
	Upper bound of 6 is element 9 of array a
Ciccio spiegazione spicciola 
	element position 0 1 2 3 4 5 6 7 8 9
	element value    2 2 4 4 4 6 6 6 6 8
L'ultima posizione in cui puoi inserire un 6, in modo che la sequenza resti ancora sorted, e' la posizione 9
-----------------------------------------------------------------------
>> equal_range algorithm 
[pag721 deitel]
 29    // use equal_range to determine both the lower- and 
 30    // upper-bound insertion points for 6
 31    auto eq = equal_range( a.cbegin(), a.cend(), 6 );
 32    cout << "\nUsing equal_range:\n   Lower bound of 6 is element "
 33       << ( eq.first - a.cbegin() ) << " of array a";
 34    cout << "\n   Upper bound of 6 is element "
 35       << ( eq.second - a.cbegin() ) << " of array a";
 36    cout << "\n\nUse lower_bound to locate the first point\n"
 37       << "at which 5 can be inserted in order";
Line 31 uses the equal_range algorithm to return a pair of forwar iterators containing the results of performing both a lower_bound and an upper_bound operation. The first two argument must be at least forward iterators. The third is the value for which to locate the equal range. The algorithm returns a pair of forward iterators for the lower bound (eq.first) and upper bound (eq.second) respectively.
OUTPUT EXAMPLE:
	Array a contains:
	2 2 4 4 4 6 6 6 6 8
	Using equal_range:
	   Lower bound of 6 is element 5 of array a
	   Upper bound of 6 is element 9 of array a
--------------------------------------------------------------
Algorithms lower_bound, upper_bound and equal_range are often used to locate insertion points in sorted sequences. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> setfill 
[pag382 e esempio a pag381 line 35 deitel]
setfill is a stream manipulator useful to specify the fill character that's displayed when an integer is output in a field wider than the number of digits in the value.
Example 
   cout << setfill( '0' ) << setw( 2 ) << hour << ":" 
      << setw( 2 ) << minute << ":" << setw( 2 ) << second;
il setfill ('0') fa si' che un ora espressa in ore:minuti:secondi
- if the number being output fills the specified field, the fill character will not be displayed
	quindi per esempio 17:32:27 resta -> 17:32:27
- if the number being output do not fill the specified field allora verra' aggiunto uno zero visto che il fill character e' stato specificato to '0' . The fill characters appear to the left of the digits in the number, because the number is right alighed by default (for left aligned values the fill characters would appear to the right).
	quindi per esempio l'ora 7:08:9 diventa 07:08:09
NOTE: once the fill character is specified with setfill, it applies for all subsequent values that are displayed in fields wider than the value being displayed. setFill is a >> sticky setting . This in contrast to setw, which applied only to the next value displayed (setw is a non sticky setting)
NOTE2: each sticky setting (such as a fill character or floating point precision) should be restored to its previous setting when it's no longer needed. Failure to do so may result in incorrectly formatted ouput later in a program. 

>> setprecision 
[pag133deitel]
useful for formatting floating point number 
Example 
[from pag129deitel]
	cout << setprecision( 2 ) << fixed;
	cout << "Antigravitational field intensity is" << average << endl;
in tal modo la variabile average verra' printata con due cifre decimali dopo il punto decimale.
[nota come setprecision preceda la riga in cui compare la variabile di cui vuoi effettuare la formattazione]
A- Since setprecision requires a parameter (il due nelle parentesi) this call is referred as parameterized stream manipulator. Programs that use these calls must contain the proprocessing directive:
	#include <iomanip>
cioe l'       Input Output MANIPulator header
Manipulators come endl invece sono dei nonparameterized stream manipulator because it isn't followed by a value or expression in parentheses and does not required the <iomanip> header. 
B- the stream manipulator fixed indicates that floating-point values should be output on so-calledd fixed point format (ex: 127.76), as opposed to scientific notation (0.12776*10^3).
C- Specifying fixed-point formatting also forces the decimal point and trailing zeros to print, even if the value is a whole number amount, such as 76.00. Without the fixed-point formatting option, such a value prints in C++ as 88 without the trailing zeros and without the decimal point. When the stream manipulators fixed and setprecision are used in a program, the printed value is rounded to the number of decimal positions indicated by the value passed to setprecision, although the value in memory remains unaltered.
D- It is also possible to force a decimal point to appear by using stream manipulator showpoint. 
	showpoint
[pag133]
if showpoint is specified without fixed, then trailing zeros will not print.  

>> setw 
[pag167deitel]
example 
	cout << setw(4) << year << endl;
specifies that the next value output should appear in a field width of 4, i.e. cout prints the value with at least 4 character position wide
[ricorda un poco il -fN che si usava in gnuplot residuals per individuare il N-esimo field, solo che qui in sostanza cio' che si conta sono il numero di colonne a partire dal bordo sinistro.]
See also esempio pag 442deitel

>> sign / unsigned
Data types char, short, long and int can be either signed or unsigned. Signed  types can represent both positive and negative values, whereas unsigned types can only represent positive values (zero). 
ex
	unsigned short int NumberofStars;
	signed int MyAccountBalance;
NB if we do not specify either signed or unsigned most compiler settings will assume the type to be signed. 

>> SIGNATURE / FUNCTION SIGNATURE
[pag259deitel]
The portion of a function prototype that includes the name of the function and the type of its arguments is called the function signature (pag211deitel) or simply the signature.

>> .size()
utile per ottenere la lunghezza di una stringa ex 
	nomeParametroStringa.size()
[pag93deitel]
The C++ standard library's string class defines a member function size that returns the number of characters in a string object.  

>> short int = short integer, size 2 byte
signed: -32768 to 32767
unsigned: 0 to 65535

>> sizeof()
[pag350deitel]
This operator accepts one parameter, which can be either a type or a variable itself, and returns the size in bytes of that type or object; ex:
	a = sizeof (char);
this will assign the value 1 to a because char is a one-byte long type.
See also pag350deitel
the compile time unary operator sizeof determines the size in bytes of a built-in array or of any other data type, variable or constant during program compilation.
- when applied to a built-in array the sizeof operator returns the total number of bytes in the built-in array as a value of type size_t
- when applied to a pointer parameter in a function that receives a built-in array as an argument, the sizeof operator returns the size of the pointer in bytes, not the built-in array's size see fig8.13 pag351
ATTENTION: using the sizeof operator in a function to find the size in bytes of a built-in array parameter results in the size in bytes of a pointer, not the size in bytes of the built-in array.
EXAMPLE : determining the number of elements in a built-in array. Supponi di avere un built-in array "numbers", ne puoi determinare il numero di elementi usando il risultato di due sizeof operations:
	sizeof numbers / sizeof( numbers[ 0 ] )
the expression divides the number of bytes in "numbers" by the number of bytes in the built-in array's zeroth element resulting in the number of elements in "numbers". per esempio se "numbers" aveva 20 elementi => 8bytes * 20 = 160 bytes
sizeof "numbers" e' uguale a 160
mentre il size dell'elemento 0 di "numbers" e' pari 8bytes.
Quindi sizeof numbers / sizeof(numbers [ 0 ]) = 160 / 8 = 20
NOTE: PORTABILITY: the number of bytes used to store a particular data type may vary among systems. When writing programs that depends on data type sizes, always use "sizeof" to determine the number of bytes used to store the data types.
NOTE2: quand'e' che bisogna usare le parentesi con sizeof ? 
the parentheses used with sizeof are required only if a type name e.g. int is supplied as its operand. The parentheses used with sizeof are not required when sizeof's operand is an expression.
anche se riprendendo l'esempio sopra
	sizeof numbers / sizeof( numbers[ 0 ] )
non riesco al momento bene a capire, non sta usando le () con un espressione? itiaf

>> smooth function
http://jean-pierre.moreau.pagesperso-orange.fr/Cplus/smooth_cpp.txt
http://jean-pierre.moreau.pagesperso-orange.fr/c_signal.html


>> SOFTWARE ENGINEERING OBSERVATIONS 
- the most difficult part of solving a problem on a computer is developing the algorithm. Producing a working C++ program from the algorithm is typically straightforward. [pag118deitel]

>> SOURCE CODE vs OBJECT CODE
- what you write is the source code or program text 
extension : 
	*.cpp or *.h
- once the compiler translate your cpp into machine readable format you get the object code,  or executable with suffix 
	*.obj (in windows), or *.o (in Unix)

>> SORT 
	sort 
function to arrange the elements in an array into ascending order
[pag302deitel]
EXAMPLE pag 303
   const size_t arraySize = 7; // size of array colors
   array< string, arraySize > colors = { "red", "orange", "yellow",
      "green", "blue", "indigo", "violet" };
   // output original array
   cout << "Unsorted array:\n";
   for ( string color : colors )
      cout << color << " ";   
   sort( colors.begin(), colors.end() ); // sort contents of colors
[from file fig07_18.cpp]


>> split function / >> iterator adaptor example [pag103 moo book]
example in /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter06/split.cc
	#include <algorithm> // iterator adaptors are defined in <iterator>
	#include <cctype>
	#include <string>
	#include <vector>
	
	#include "split.h"
	
	using std::find_if;
	using std::string;
	using std::vector;
	
	#ifndef _MSC_VER
	using std::isspace;
	#endif
	
	// `true' if the argument is whitespace, `false' otherwise
	bool space(char c)
	{
		return isspace(c);
	}
	
	// `false' if the argument is whitespace, `true' otherwise
	bool not_space(char c)
	{
		return !isspace(c);
	}
	
	vector<string> split(const string& str)
	{
		typedef string::const_iterator iter;  // we sue typedef to abbreviate the iterator type, so that we can use "iter" instead of the longer "string::const_iterator " 
		vector<string> ret;
	
		iter i = str.begin();
		while (i != str.end()) {
	
			// ignore leading blanks
			i = find_if(i, str.end(), not_space);  // using the algorithm find_if
/*
>> find_if : this algorithm requires 3 arguments. Its first two arguments are iterators that denotes a sequence; the third is a predicate, which tests its argument and returns true or false. The find_if function calls the predicate on each element in the sequence, stopping when it finds an element for which the predicate yields true.
*/
	
			// find end of next word
			iter j = find_if(i, str.end(), space);
	
			// copy the characters in `[i,' `j)'
			if (i != str.end())
				ret.push_back(string(i, j));
			i = j;
		}
		return ret;
	}
////////////////////////////////////////////////////////////////////////////////////////////////

>> SPLIT LINE using whitespace as delimiter 
[http://stackoverflow.com/questions/236129/split-a-string-in-c]
	#include <vector>
	#include <string>
	#include <sstream>
	
	using namespace std;
	
	int main()
	{
	    string str("Split me by whitespaces");
	    string buf; // Have a buffer string
	    stringstream ss(str); // Insert the string into a stream
	
	    vector<string> tokens; // Create vector to hold our words
	
	    while (ss >> buf)
	        tokens.push_back(buf);
	}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STANDARD LIBRARY ALGORITHMS
[pag691 deitel]
The Standard Library provides over 90 algorithms [@2015]. [-> pag 731-732 deitel raccoglie una lista dei piu' essenziali]
The complete list can be found in Section 25 and 26.7 deitel of the C++ standard document and there are various online references where you can learn about each algorithm, such as 
	en.cppreference.com/w/cpp/algorithm
	msdn.microsoft.com/en-us/library/yah1y2x8.aspx
Most of them use iterators to access container elements. Various algorithms can receive a function pointer ( apointer to a function's code) as an argument. Such algorithm use the pointer to call the function (typically with one or two container elements as arguments).
--------------------------------
>> Minimum Iterator Requirements
With few exceptions, the Standard Library separates algorithms from containers. This makes it much easier to add new algorithms. An important part of every container is the type of iterator it supports. This determines which algorithms can be applied to the container. For example, bith vectors and arrays support random access iterators.
All Standard Library algorithms can operate on vectors and the ones that do not modify a container's size can also operate on arrays. 
Each Standard Library algorithm that takes iterator arguments requires those iterators to provide a minimum level of functionality. If an algorithm requires a forward iterator, for example, that algorithm can operate on any ocntainer that supports forward iterators, bidirectional iterators or random-access iterators.
OBSERVATION: standard library algorithms do not depend on the implementation details of the containers on which they operate. As long as a container's (or built-in array's) iterators satisfy the requirements of an algorithm, the algorithm can work on the container.
PORTABILITY: bacause standard library algorithms process containers only indirectly through iterators, one algorithm can often be used with many different containers.
OBSERVATION2: the standard library containers are implmented concisely. The algorithms are separted from the containers and operate on elements of the containers only indirectly through iterators. This separation makes it easier to write generic algorithms applicable to a variety of container classes
OBSERVATION3: using the "weakest iterator" that yields acceptable performance helps produce maximally resusable components. For example, if an algorithm requires only forward iterators, it can be used with any container that support forward iterators, bidirectional iterators or random-access iterators. However, an algorithm that requires random-access iterators can be used only with containers that have random-access iterators.
>> ITERATORS INVALIDATION / >> INVALIDATION ITERATORS / >> INVALID ITERATORS
[pag692 deitel]
Iteartors simply point to container elements, so it's possible for iterators to become invalid when certain container modifications occur. 
For example if you invoke clear on a vector, all of its elements are removed. Of a program had any iterators that pointed to that vector's elements before clear was called, those iterators would now be invalid 
Iterators are invalidated during insert and erase operations when:
1) when inserting into a : 
- vector : if the vector is reallocated, all iterators pointing to that vector are invalidated. Otherwise, iterators from the insertion point to the end of the vector are invalidated. 
- deque : all iteartors are invalidated
- list or forward_list : all iterators remain invalid.
- ordered associative container : all iterators remain invalid 
- unordered associative container : all iterators are invalidated if the container need to be reallocated. 
2) when erasing from a container, iterators to the erased elements are invalidated. in addition 
- vector : iteratos from the erased element to the end of the vector are invalidated
- deque : if an element in the middle of he deque is erased, all iterators are invalidated. 
Qui di seguito ti scrivo gli algoritmi presentati nelle pagine 693 deitel e segg. 
--------------------------------------------------------------------------------
>> fill / >> fill_n / >> generate / >> generate_n 
[pag 693 deitel]
Algorithms fill and fill_n set every element in a range of container elements to a specific value. 
Algorithms generate and generate_n use a >> generator function to create values for every element in a range of container elements. 
The generator function takes no arguments and returns a value that can be placed in an element of the container.
example in /home/dia/Deitel-Code_Examples/ch16/fig16_01/fig16_01.cpp
- Nell'esempio si crea un array di 10 elementi char e quindi li si sostituisce (usando fill) ciascun elemento con l'elemento char "5".
	fill( chars.begin(), chars.end(), '5' ); // fill chars with 5s 
- fill_n algorithm usato per specificare il numero di carattere da sostituire
	fill_n( chars.begin(), 5, 'A' );
la precedente line uses the fill_n algorithm to place the character "A" in the first five elements of chars. The iterator supplied as the fist argument must be at least an output iterator (i.e. it can be used to write into a container in the forward direction). The second argument specifies the number of elements to fill. The third argument spedicies the value to place in each element.
---------------------------------------------------------------------------------
A note about reading standard library algorithm documentation / >> DOCUMENTATION ALGORITHM NOTE / >> ALGORITHMS DOCUMENTATION NOTE / >> ALGORITHM DOCUMENTATION NOTE
[pag695 deitel]
When you look at the standard library algorithms documentation for algorithms that can receive function pointers as arguments, you'll notice in the documentation that the corresponding parameters do not show pointer delcarations. Such parameters can actually receive as arguments function pointers, function objects or lambda expressions. For this reason, the Standard Library declares such parameters using more generic names. 
For example the generate algorithm's prototype is listed in teh C++ standard document as 
	template<class ForwardIterator, class Generator>
	void generate(ForwardIterator first, ForwardIterator last,
		Generator gen);
indicating that generate expects as arguments ForwardIterators representing the range of elements to process and a Generator function. The standard explains that the algorithm calls the Generator function to obtain a value for each element in the range specified by the ForwardIterators. The standard also specifies that the Generator must take no arugments and return a value of teh element type. 
Similar documentation is provided for each algorithm that can receive a function pointer, function object or lambda expression. 
----------------------------------------------------------------------------------
>> equal / >> mismatch / >> lexicographical_compare
[pag695 deitel]
example /home/dia/Deitel-Code_Examples/ch16/fig16_02/fig16_02.cpp
>> equal algorithm to compare two sequences of values for equality. The second seqeunce must contain at least as many elements as the first (equal returns false if the sequences are not of the same length). The == operator (whether built-in or overloaded) performs the element comparisons.
Another version of equal takes a binary predicate function as a fourth parameter. The binary predicate function receives the two elements being compared and returns a bool value indicating whether the elements are equal. This can be useful in sequences that store objects or pointers to values rather than actual values, because you can define one or more comparisons. 
>> mismatch Algorithm [pag697 deitel]
Use mismatch algorithm to compare two sequences of values. The algorithm returns a pair of iterators indicating the location in each sequence of the mismatched elements. If all the elements match, the two iterators in the pair are equal to the end iterator for each sequence. The three iterator arguments must be at least input iterators.
   // check for mismatch between a1 and a3    
   // home/dia/Deitel-Code_Examples/ch16/fig16_02/fig16_02.cpp                  
   auto location = mismatch( a1.cbegin(), a1.cend(), a3.cbegin() );
   cout << "\nThere is a mismatch between a1 and a3 at location "
      << ( location.first - a1.begin() ) << "\nwhere a1 contains " 
      << *location.first << " and a3 contains " << *location.second  
      << "\n\n";
>> lexicographical_compare algorithm [pag697 deitel]
Use the lexicographical_compare algorithm to compare the contents of the two char built-in arrays. This algorithm's four iterator arguments must be at least input iterators. 
The first two iterators arguments specify the range of locations in the first sequence. The last two specify the range of locations in the second sequence. We use the C++11 begin and end functions to determine the range of elements for each built-in array. While iterating through the sequences, the lexicographical_compare checks if the element in the first sequence is less than the corresponding element in the second sequence. If so, the algorithm returns true. If the element in the first sequence is greater than or equal to the element in the second sequence, the algorithm returns false. This algorithm can be used to arrange sequences lexicographically. Typically, such sequences contain strings.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STL / >> standard template library or STL 
[639 deitel] also pag109 mike game programming.
THe STL was developed by Alexander Stepanov and Meng Lee [gia' allora funzionava bene il famoso asse sino-sovietico] at Hewlett-Packard and is based on their generic programming research, with significant contribution from David Musser [si Germany pure]
We'll occasionally refer to these features as the STL. In the C++ standard document, these features are simply referred to as part of the C++ Standard Library.
Three key components of the Standard Library are :
1) containers = data structures capable of storage objecdts of almost any data type
		there are 3 types of containers
		- first class containers 
		- container adapter 
		- near containers 
2) iterators
	Iterators have properties similar to those of pointers. They are used to manipulate container elements. Built-in arrays also can be manipulated by Standard Library algorithms, using pointers as iterators. Manipulating containers with iterators is convenient and provides tremendous expressive power when combined with Standard Library algorithms, in some cases reducing many lines of code to a single statement.
3) algorithms
	Standard library algorithms are function templates that performs such commondata manipulations as searching, sorting, and comparing elements or entire containers. Most of these algorithms use iterators to access container elements. Iterators encapsulate the mechanisms used to access container elements. This encapsulation enables many of the algorithms to be applied to various containers independently of the underlying container implementation. This also enables you to create new algorithms that can process the elements of multiple container types.
SUSUME: 
- avoid reinventing the wheel; program with teh components of the C++ Standard library
- the prepackaged, templatized Standard Library containers are sufficient for most applications. Using the Standard Library helps you reduce testing and debugging time
- the standard library was conceived  and designed for performance and flexibility
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STANDARD LIBRARY CONTAINER CLASSES AND CONTAINER ADAPTERS / >> CONTAINERS
[pag 640 deitel]
the standard library container types are divided into four major categories 
A) SEQUENCE CONTAINERS
B) ORDERED ASSOCIATEIVE CONTAINERS
C) UNORDERED ASSOCIATIVE CONTAINERS 
D) CONTAINER ADAPTERS
------------------------------------------
A) SEQUENCE CONTAINERS [= represent linear data structures, all their elements are conceptually lined up in a row]
	array              : fixed size. Direct access to any element. 
    deque              : rapid insertions and deletions at front or back. Direct access to any element
	forward_list       : singly linked list, rapid insertion and deletion anywhere. from C++11 and up
	list               : doubly linked list, rapid insertion and deletion anywhere
	vector             : rapid insertions and deletion at back. Direct access to any element.
B) ORDERED ASSOCIATIVE CONTAINERS 
	set                : rapid lookup, no duplicates allowed
	multiset           : rapid lookup, duplicates allowed
	map                : one to one mapping, no duplicates allowed, rapid key based lookup
	multimap           : one to many mapping, duplicates allowed, rapid key-based lookup
C) UNORDERED ASSOCIATIVE CONTAINERS 
	unordered_set      : rapid lookup, no duplicates allowed
	unordered_multiset : rapid lookup, duplicates allowed
	unordered_map      : one to one mapping no duplicates allowed, rapid keybased lookup
	unordered_multimap : one to many mapping duplicates allowed, rapid key based lookup
D) CONTAINER ADAPTERS
	stack              : last-in, first-out (LIFO)   [>> LIFO tag]
	queue              : first-in, first out (FIFO)  [>> FIFO tag]
	priority_queue     : highest priority element is always the first element out
NOTE: 
- Sequence containers represent linear data structures, all their elements are conceptually lined up in a row
- Associative containers are nonlinear data structures that typically can locate elements stored in the containers quickly. 
per >> key value pairs / >> first class containers / >> container adpaters / >> near containers
see pag 641 deitel
>> TABLE COMMON MEMBER FUNCTIONS FOR MOST STANDARD LIBRARY CONTAINERS / >> STANDARD LIBRARY CONTAINERS COMMON MEMBER FUNCTIONS
ti scrivo qui giusto le parole chiave : per la loro definizione vedi pag 642 deitel
>> default constructor 
>> copy constructor
>> move constructor
>> destructor
>> empty 
>> insert 
>> size 
>> size 
>> copy operator=
>> move operator=
>> operator<
>> operator<=
>> operator>
>> operator>=
>> operator==
>> operator!=
>> swap
>> max_ size        : returns the maximum nuber of elements for a container
>> begin 
>> end 
>> cbegin
>> cend
>> rbegin
>> rend
>> crbegin
>> crend
>> erase            : removes one or more elements from the container
>> clear            : removes all elements from the container
[pag 642 deitel]
>> FIRST CLASS CONTAINER NESTED TYPES / >> NESTED TYPES FIRST CLASS CONTAINER
[pag 643 deitel]
comon first class container nested = types defined insdie each container class definition. For example value_type in each container always repreesnts the type of elements stored in the container.
riferisciti alla pagina 643 deitel per il significato dei seguenti nested types:
>> allocator_type
>> value_type
>> reference 
>> const_reference
>> pointer
>> const_pointer
>> iterator
>> const_iterator
>> reverse_iterator
>> const_reverse_iterator
>> difference_type
>> size_type
//////////////////////////
>> ITERATORS / >> INTRODUCTION TO ITERATORS 
[pag644 deitel]
Iterators have many similarities to pointers and are used to point to first class containers elements and for other purposes.
An object of a container's iterator type referes to a container element that can be modified. An object of a container's const_iterator type refers to a container element that cannot be modified.
Keywords explained @ pages 644 645 deitel
>> begin = function that the returns an iterator pointing to the first element of the container 
>> end = function that returns an iterator pointing to the first element past the end of the container.
>> istream_iterator
>> ostream_iterator  [a si' quello che abbiamo usato nel NEC feaMapper per far l'output in ascii delle coordinate]
>> sequences also called >> ranges
NOTE: istream_iterator and ostream_iterator can be used with the Standard Library algorithms to create powerful statements. For example, you can use an ostream_iterator with the copy algorithm to copy a container's entire contnets to the standard output stream with a single statement.
pag 645 deitel : example of >> dereference an iterator 
NOTE pag 646: notice that we use the dereferenced outputInt iterator as an lvalue in the assignment statement. If you want to output another value using outpuInt, the iterator must be incremented with ++ first. Either the prefix or postfix increment can be used (we use the prefix form for performance reasons becuase it does not create a temporary object.)
>> ITERATOR CATEGORY [pag646 deitel]
        random access
			 |
        bidirectional
		     |
		  forward
        |        |
      input     output
where the random access is the most powerful iterator type, input and output the weakest iterator type. In fact in the above hierarchy scheme, each iterator category supports all the functionality of the categories below. [cioe' random access supportera' tutte le funzionalita' del bidirectional iterator]
Category               Description 
-  random access       combines the capabilities of a bidirectional iterator with the ability to directly access any elment of the container, i.e. to jump forward or backward by an arbitrary number of elements. 
- bidirectional        combines the capabilities of a forward iterator with the ability to move in the backward direction (i.e. from the end of the container toward the beginning)
- forward              combines the capabilities of input and output iterators and retains their position in the container (as state information). Such iterators can be used to pass through a sequence more than once (for so called >> multipass algorithm)
- output               used to write an elmeent to a container. An output iterator can move only in the forward direction one element at a time. output iterators support only one-pass algorithms (the same output iterator cannot be used to pass through a sequence twice) 
- input                used to read an lement from a container. An input iterator can move only in the forward direction (i.e. from the beginning of the container to the end). one element at a time. Input iterators support only one-pass algorithms (the same input iterator cannot be used to pass through a sequence twice) 
>> ITERATOR TYPES SUPPORTED by EACH CONTAINER [table pag 647deitel]
The iterator category that each container supporta determines whether that container can be used with specific algorithms. Containers that support random access iterators can be used with all Standard Library Algorithms.
- Seuqence containers (first class)
vector         random access 
array          random access
deque          random access
list           bidirectional
forward_list   forward
- Ordered associative containers (first class) 
set            bidirectional
multiset       bidirectional
map            bidirectional
multimap       bidirectional
- Unordered associative containers (first class)
unordered_set  bidirectional
unordered_multiset bidirectional
unordered_map  bidirectional
unordered_multimap bidirectional
- Container adapters
stack          none
queue          none 
priority_queue none
-----------------------------------
>> ITERATOR typedef / >> predefined iterator typedef
[pag 647deitel]
Predefined typedefs for iterator types    Direction of ++     Capability
iterator                                  forward             read/write
const_iterator                            forward             read
reverse_iterator                          backward            read/write
const_reverse_iterator                    backward            read
\\\\\\\\\\\\\\\\\\\\\\\\
>> Iterator Operations
[pag 648 deitel]
> All iterators
++p             preincrement an iterator
p++             postincrement an iterator
p = p1          assign one iterator to another
> Input iterators 
*p              dereference an iterator as an rvalue
p->m            use the iterator to read the element m
p == p1         compare iterators for equality
p != p1         compare iterators for inequality
> Output iterators
*p              dereference an iterator as an lvalue
p = p1          assign one iterator to another
> Forward iterators
Forward iterators provide all the functionality of both input iterators and output iterators.
> Bidirectional iterators
--p             predecrement an iterator
p--             postdecrement an iterator
> Random-access iterators
p += i          increment the iterator p by i positions
p -= i          decrement the iterator p by i positions
Per la spiegazione delle seguenti operations ti rimando direttamente a pagina649deitel
	p + i or i + p
	p - i
	p - p1
	p[ i ]
	p < p1
	p <= p1
	p > p1
	p >= p1
--------------------------------------------------------------------------------------
>> CONTAINER [pag 109 mike game programming]
Containers let you store and access collections of values of the same type. Arrays let you do the same thing, but the STL containers offer more flexibility and power than an simple but trusty array. The algorithms defined in the STL work with its containers. 
The >> algorithms are common functions that game programmers find themselves repeatedly applying to groups of values. They include algorithms for sorting, searching, copying, merging, inserting, and removing container elements. The cool thing is that the same algorithm can work its magic on many different container types.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> searching and sorting algorithm / >> sorting algorithm / >> algorithm sorting / >> algorithm search / >> search algorithm / >> sort algorithm
[pag706 deitel]
example in /home/dia/Deitel-Code_Examples/ch16/fig16_06/fig16_06.cpp
>> find algorithm
	 20    // locate first occurrence of 16 in a
	 21    auto location = find( a.cbegin(), a.cend(), 16 );
line 21 uses the find algorithm to locate the value 16 in the range from a.cbegin() up to, but not including a.cend(). 
>> find_if
	 36    // locate first occurrence of value greater than 10 in a
	 37    location = find_if( a.cbegin(), a.cend(), greater10 );
line 37 uses the find_if algorithm (a linear search) to locate the first value in the range from a.cbegin() up to, but not including a.cend() for which the unary predicate function greater10 returns true. greater10 altri non e' che una funzione che viene definita nelle righe 93-96
	 92 // determine whether argument is greater than 10
	 93 bool greater10( int value )
	 94 {
	 95    return value > 10;
	 96 } // end function greater10
Nota come le righe 36 37 doneranno in output:
	The first value greater than 10 is 17
	found at location 2   
(cioe' la terza posizione, si conta a partire da zero)
///////////////////////////////////////////////////////////////////////////////
>> sort algorithm 
[pag 709 deitel]
 45    // sort elements of a
 46    sort( a.begin(), a.end() );
 47    cout << "\n\narray a after sort: ";
Line 46 use sort algorithm to arrange the lements in the range from a a.bing() up to, but not including a.end() in ascending order. The algorithm requires its two iterator arguments to be random-acess iterators. 
///////////////////////////////////////////////////////////////////////////////
>> binary_search algorithm
[pag 709 deitel]
	 50    // use binary_search to locate 13 in a
	 51    if ( binary_search( a.cbegin(), a.cend(), 13 ) )
	 52       cout << "\n\n13 was found in a";
	 53    else
	 54       cout << "\n\n13 was not found in a";
Line 51 uses the binary_search algorithm to determine whether the value 13 is in the range from a.cbegin() up to , but not including a.cend(). The values must be sorted in ascending order. 
>> all_of algorithm
[pag 709 deitel]
	 62    // determine whether all of the elements of a are greater than 10
	 63    if ( all_of( a.cbegin(), a.cend(), greater10 ) )
	 64       cout << "\n\nAll the elements in a are greater than 10";
line 63 uses the all_of algorithm to determine whether the unary predicate function greater10 [definita nelle righe 93 96 del programma] returns true for ALL the elements in the range from a.cbegin() up to, but not including a.cend(). Algorithm all_of requires its two iterator arguments to be at least input iterators.
>> any_of
	 68    // determine whether any of the elements of a are greater than 10
	 69    if ( any_of( a.cbegin(), a.cend(), greater10 ) )
	 70       cout << "\n\nSome of the elements in a are greater than 10";
line 69 uses the any_of algorithm to determine whether the unary predicate function greater10 returns true for AT LEAST ONE of the elements in the range from a.cbegin() up to, but not including a.cend(). Algorithm any_of requires its two iterator arguments to be at least input iterators.
>> none_of
	 74    // determine whether none of the elements of a are greater than 10
	 75    if ( none_of( a.cbegin(), a.cend(), greater10 ) )
	 76       cout << "\n\nNone of the elements in a are greater than 10";
Line 75 uses the none_of algorithm to determine whether the unary predicate function greater10 (user function definita nel programma) returns false for ALL of the elements in the range from a.cbegin() up to but not including a.cend(). Algorithm none_of requires its two iterator arugments to be at least input iterators.
>> find_if_not
[pag710 deitel]
	 80    // locate first occurrence of value that's not greater than 10 in a
	 81    location = find_if_not( a.cbegin(), a.cend(), greater10 );
Line 81 uses the find_if_not algorithm to locate the first value in the range from a.cbeing() up to, but not including a.cend() for which the unary predicate function greater10 returns false. Algorithm find_if requires its two iterator arguments to be at least input iterators. The algorithm returns an input iterator that either is positioned at the first element containing a value for which the predicate function returns false or indicates the end of the sequence. 
----------------------------------------------------
PROGRAM output /home/dia/Deitel-Code_Examples/ch16/fig16_06/fig16_06.cpp
	array a contains: 10 2 17 5 16 8 13 11 20 7	
	Found 16 at location 4
	100 not found
	The first value greater than 10 is 17
	found at location 2
	array a after sort: 2 5 7 8 10 11 13 16 17 20
	13 was found in a
	100 was not found in a
	Some elements in a are not greater than 10
	Some of the elements in a are greater than 10
	Some of the elements in a are greater than 10
	The first value not greater than 10 is 2
	found at location 0
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> Searching and >> sorting
[pag823 deitel] 
Searching data involves determining whether a value (referred to as the search key) is present in the data and, if so, finding the value location.
Two popular search algorithm are the 
	>> linear search  deitel pag824
		the program must compare the search key to every array element. Linear search works well for small or unsorted arrays. However for large arrays, linear searching is inefficient. If the array is sorted you can use the high-speed binary search tehcnique.
	>> binary search  deitel pag827 -> much more effcient (rispetto alla linear search) but more complex to implement
Sorting places data in ascending or descending order, based on one or more >> sort keys.
>> SORTING ALGORITHM / >> ALGORITHM SORT deitel pag831 // >> sorting algorithm pag 128 mike programming 
sort() algorithm sorts the elements of a sequence in ascending order.
example from mike programming game
	sort(scores.begin(), scores.end());
in the previous line we passed the iterators returned by scores.begin() and scores.end(). These two iterators indicate that we want to sort all of the elements in "scores"
NOTE: per ascending order significa dal piu' piccolo al piu' grande
example from the program Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter04/high_scores.cpp
	Randomizing scores.
		High Scores:
		3500
		7500
		1500
	After applying the sort() algorithm:
		High Scores:
		1500
		3500
		7500
	>> INSERTION SORT deitel pag832
	>> SELECTION SORT deitel pag834
	>> MERGE SORT  deitel pag837
	>> BIG O NOTATION deitel pag824 e  seguenti
		used to describe and quantify the amount of effort an algorithm requires to complete a search.
		>> O(1)   constant runtime = the algorithm is indipendent of the number of array elements. 
			>> O(1) is usually pronounced "on the order of 1" or more simply "order 1"
			>> O(n) = linear runtime. deitel pag825
			>> quadratic runtime deitel pag826  order n squared
			>> O(n^2) performance -> sentirai la degradazione di performance when n starts to become big.
	>> BINARY SEARCH deitel pag827
		the binary search algorithm is more efficient than the linear search algorithm, but it requires that the array first be sorted. 
		il concetto e' semplice : supponi di avere dei numeri alla rinfusa e devi cercare se tra di essi e' presente il numero 54. 
		1) ordini i numeri in ordine crescente quindi checki se l'elemento che sta nella meta' dell'array ordinato e' uguale a 54. Se lo e' la ricerca e' finita
		2) se non lo e' due le possibilita': o il numero che sta' a meta' e piu' grande di 54, allora continuerai a cercare nella prima meta' dell'array.
		3) oppure il numero in mezzo e' piu' piccolo di 54 ed allora cercherai nella seconda meta' dell'array.
		NOTE: se il numero di elementi e' pari non e' ovvio quale sia l'elemento in mezzo. The middle lies between two elements. Allora we implement the algorithm to choose the element with the higher index number
--------------------------------------------------------------------------
>> SORT INSERTION ALGORITHM / >> INTERTION SORT ALGORITHM 
[pag 832 deitel]
this is a simple but inefficient sorting algorithm
>> SELECTION SORT  pag834 deitel is another easy-to-implement but inefficient algorithm. 
>> MERGE SORT algorithm (a recursive implementation) pag837 deitel
	the merge sort implementation is recursive. THe recursion step splits an array of two or more elements into two equal sized sub-arrays, recursively sorts each sub-array [see pag840 per una visualizzazione dinamica del suo funzionamento o lancia il programma MergeSort.cpp from deitel book], then merges them into one larger, sorted array. 
-------------------------------
>> Sorting Algorithm Efficiencies
[pag842deitel]
Linear Search   O(n) 
Binary Search   O(log n)
Recursive linear Search		O(n)
Recursive binary Search 	O(log n)
Insertion sort		O(n^2)
Selection sort		O(n^2)
Merge sort       O(n log n)       -> this is a far more efficient algorithm than either insertion sort or selection sort
Bubble sort      O(n^2)
Quicksort        worst case -> O(n^2) ;    average case -> O(n log n)
where
preso se n = 2^10          -> O(log n) = 10 
                           -> O(n) = 2^10
						   -> O(n log n) = 2^10*10
						   -> O(n^2) = 2^20
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> search function [pag109 moo book]
This function takes two pairs of iterators:
- the first pair denotes the sequence in which we are looking, and the second pair denotes the sequence that we wish to locate. If search fails, it returns the second iterator. 

>> ADD FUNCTION EXAMPLE from jesse book pag 37
#include <iostream>
int Add (int first, int second)
{
    std::cout << "In Add(), received " << first << " and " << second << "\n";
    return (first + second);
}
  
int main()
{
    using std::cout;
    using std::cin;
  
  
    cout << "I'm in main()!\n";
    int a, b, c;
    cout << "Enter two numbers: ";
    cin >> a;
    cin >> b;
    cout << "\nCalling Add()\n";
    c=Add(a,b);
    cout << "\nBack in main().\n";
    cout << "c was set to " << c;
    cout << "\nExiting...\n\n";
    return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> ALGORITHM stl / >> STL ALGORITHMS / >> Standard Template Library Algorithms [pag126 mike programming game]
in order to use the STL algorithms we need to include
	#include <algorithm>
	using namespace std;   // this line to allow to refer to algorithms without having to precede them with std::
>> FIND ALGORITHM 
	iter = find(scores.begin(), scores.end(), score);
find() STL algorithm searches a specified range of a container's elements for a value. It returns an iterator that references the first matching element. 
NOTE: you must pass the starting point as an iterator, the ending point as an iterator, and a value to find. 
NOTE: the algorithm searches from the starting iterator up to but not including the ending iterator. [e visto che come spiegato a pagina 121 mike programming game, .end() porta l'iteratore a puntare all'elemento DOPO l'ultimo elemento del vettore, significa che tutti gli elementi fino all'N ultimo elemento del vettore verranno searchati]
NOTE: if no match is found, it returns an iterator to the end of the range.
>> RANDOM SHUFFLE ALGORITHM [pag127 mike programming game]
	srand(static_cast<unsigned int>(time(0)));   // [questa stessa linea veniva usata in Deitel book dove veniva scritto "this causes the computer to read its clock to obtain the value for the seed. Function time with the argument 0 as written in the preceding statement typically returns the current time as the number of seconds since January 1, 1970, at midnight reenwich Mean Time (GMT)."]
    random_shuffle(scores.begin(), scores.end());
NOTE: we seed the random number generator before calling random_shuffle(), so the order of results might be different each timewe run the program
NOTE: random_shuffle() is a valuable algorithm for games. You can use it for everything from shuffling a deck of cards to mixing up the order of the enemies a player will encounter in a game level.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> STREAM INPUT 
[pag569deitel]
>> get = getmember function with no arumgents input one character from the designated stream (including white-space characters and other nongraphic characters, such as the key sequence that represents end-of-file) and returns it as the value of the function call. This version of "get" returns EOF when end-of-file is encountered on the stream.
(NOTE: recall that EOF is represented as a int)
The get member function with a character reference argument inputs the next character from the input stream (even if this is white-space character)  and stores it in the character argument. 
A third version of get (pag570deitel) takes three arguments 
	1) a built in array of chars
	2) a size limit 
	3) a delimiter (with default value '\n')
This version reads characters from the input stream. It either reads one fewer than the specified maximum number of characters and terminates or terminates as soon as the delimiter is read. A null character is inserted to terminate the input string in teh carachter array used as a buffer by the program. The delimiter is not placed in teh character array but does remain in the input stream (the delimiter will be the next character read). Thus the result of a second consecutive get is an empty line, unless the delimiter character is removed from the input stream (possibly with cin.ignore())
>> getline member function pag571 deitel 
also spiegato a pag 91 moo book in cui trovi l'esempio 
	while (getline(cin, s)) { ... } return 0;
The getline function takes two arguments. The first is the istream from which to read. The second is a reference to the string into which to store what is read.
-----------------------------------
>> eof member function pag569 deitel
+ pag 604 deitel
	NOTE : the keyboard combination for entering end-of-file for various computer systems
		CTRL + d    per linux/mac
		CTRL + z    per windows
The user enters end-of-file to inform the program to process no additional data. The end-of-file indicator is set when the user enters the end-of-file key combination.
>> put member function pag569 deitel
//////////////
Alcune utili istream meber functions sono 
	>> peek [pag572deitel]
the peek member function returns the next character from an input stream but does not remove the character from the stream.
	>> putback [pag572deitel] // >> searching tool
the putback member function places the previous character obtained by a get from an input stream back into that stream. This function is useful for applications that scan an input stream looking for a field beginning with a specific character. When that character is input, the application returns the character to the stream, so the character can be included in the input data.
	>> ignore [pag572deitel]
The ignore member function of istream reads and discards a designated number of characters (the default is one) or terminates upon encountering a designated delimiter (the default is EOF, which causes ignore to skip to the end of the file when reading from a file).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LIST print element 
	// with a list we cannot index by integer so let's copy the element of the list into a vector
	std::vector<const char *> vv{ std::begin(xDuplicates), std::end(xDuplicates) };	
	
	//std::cout << "dear vector element are you there?: " << vv[15]; // OK it getting the correct element
	//std::cout << '\n';	
	
	int counter = 0;     
	while(counter < numberElem)    
	{ 
	  std::cout << "the element number : " << counter << " is " << vv[counter];
	  std::cout << '\n';	  
	  counter++;        
	}	    		
[ciccio courtesy inspired from https://stackoverflow.com/questions/5218713/one-liner-to-convert-from-listt-to-vectort/5218738]	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LIST / >> COUNT DUPLICATE / >> ELIMINATE DUPLICATE from LIST
full program tested in /home/serena/edylab/ListSortAndDelDuplicateWithCountElement/    [centOS7 extended]
back up in ListSortAndDelDuplicateWithCountElement.tar.gz/run/media/alseny/BLACKBIRD/OF_FilesUtili/
and in /home/alseny/edylab/CPlusPlusPlayGround/CiccioProductions/ListSortAndDelDuplicateWithCountElement.tar.gz
/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2011-2016 OpenFOAM Foundation
     \\/     M anipulation  | Copyright (C) 2017 OpenCFD Ltd.
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Application
    ListSortAndDelDuplicateWithCountElement

Description
    Demonstrate the sorting of a List. After giving the count of the duplicate elements it deletes them to get a list without duplicates.

See also
    Foam::List

\*---------------------------------------------------------------------------*/

#include "OSspecific.H"
#include "argList.H"
#include "wordRes.H"

#include "IOstreams.H"
#include "StringStream.H"
#include "scalar.H"
#include "vector.H"

#include "labelRange.H"
#include "scalarList.H"
#include "SortableList.H"
#include "ListOps.H"
#include "HashSet.H"
#include "stringOps.H"
#include "SubList.H"

#include <list>
#include <numeric>
#include <functional>
#include <iostream>
#include <algorithm> 
#include <array>
#include <iterator>
#include <utility>
#include <string>
#include <vector>
#include <map>

using namespace Foam;
using namespace std;

bool myfunction (int i, int j) {
  return (i==j);
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
//  Main program:

int main(int argc, char *argv[])
{
 
    Info<<"  ";
    Info<< nl;
 
        Info<<"Lists INPUT:";
    Info<< nl;   
    // processor0
    List<const char *> processor0 = {"a", "a", "b", "a", "c", "b"}; // create list of characters for processor0
        Info<<"Processor0 List:";
        forAllConstIters(processor0, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   
       
    // processor 1
    List<const char *> processor1 = {"b", "c", "b"}; // create list of characters for processor1
        Info<<"Processor1 List:";
        forAllConstIters(processor1, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   
   
    // processor 2
    List<const char *> processor2 = {"c", "a", "a", "c", "a"}; // create list of characters for processor2
        Info<<"Processor2 List:";
        forAllConstIters(processor2, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   
   
    // processor 3
    List<const char *> processor3 = {"d", "b"}; // create list of characters for processor3
        Info<<"Processor3 List:";
        forAllConstIters(processor3, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;


    Info<<"  ";
    Info<< nl;
   
    // collector list
    List<const char *> collectorList; // create list to collect all the above processor list and then sort and eliminate all the duplicates.

    // using the member function append to collect all the processors list in a single List:
    collectorList.append(processor0);
    collectorList.append(processor1);
    collectorList.append(processor2);
    collectorList.append(processor3);
   
        Info<<"collector List before sorting and deleting duplicates:";
        forAllConstIters(collectorList, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;     
   
    // sorting the element   [more info at http://www.cplusplus.com/reference/algorithm/sort/]
    sort(collectorList, stringOps::natural_sort());


        Info<<"collector List after sorting the elements            :";
        forAllConstIters(collectorList, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;
   
       
    // deleting the duplicate elements
    // since I am not able to use unique() function with OpenFOAM List -> I copy its contents to a normal list
    // http://en.cppreference.com/w/cpp/container/list/unique
    std::list<const char *> x;
    for (auto val : collectorList)
      x.push_front(val);
   
    x.sort(stringOps::natural_sort());
   
    // back up x with duplicates
    std::list<const char *> xDuplicates;
       
    xDuplicates = x;
    int numberElemDuplicates;
    numberElemDuplicates = xDuplicates.size();
    std::cout << "total number of elements: " << numberElemDuplicates;
    std::cout << '\n';

    // deleting duplicate elements
    x.unique();
    int numberElem;
    numberElem = x.size();   
////////////////////////////////////////////////////////////////////////////////////////////////////// COUNTING DUPLICATES   
    std::cout << '\n';       
    // with a list we cannot index by integer so let's copy the element of the list into a vector
    std::vector<const char *> v{ std::begin(x), std::end(x) };  // to print the element under check
    std::vector<const char *> vv{ std::begin(xDuplicates), std::end(xDuplicates) };    // to compare the element
   
    //std::cout << "dear vector element are you there?: " << vv[15]; // OK it getting the correct element
    //std::cout << '\n';   
   
    int counter = 0;
    int counter2 = 0;
    int frequency = 0;
    while(counter < numberElem)   
    {
      std::cout << "The element " << v[counter] << " is present " ;
      while(counter2 < numberElemDuplicates)
      { 
        if (v[counter] == vv[counter2]){
          frequency++;
        }
        counter2++;
      }      
      std::cout << frequency << " times." << '\n';       
      counter2 = 0;
      frequency = 0;     
      counter++;     
    }               
////////////////////////////////////////////////////////////////////////////////////////////////////// COUNTING DUPLICATE ENDS   
   
   
    // copying back to OpenFOAM's List
    collectorList.clear();
    for (auto val : x)
      collectorList.append(val);   
   

////////////////////////////////////////////////////////////////////////////////////////////////////// OUTPUT   
    // clearing the original lists and assigning the ordered and duplicate free list:
    Info<<"  ";
    Info<< nl;   
        Info<<"Lists OUTPUT: ";
    Info<< nl;   
    processor0.clear();
    processor0.append(collectorList);
        Info<<"Processor0 List:";
        forAllConstIters(processor0, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   

    processor1.clear();
    processor1.append(collectorList);
        Info<<"Processor1 List:";
        forAllConstIters(processor1, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   
   
    processor2.clear();
    processor2.append(collectorList);
        Info<<"Processor2 List:";
        forAllConstIters(processor2, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;   

    processor3.clear();
    processor3.append(collectorList);
        Info<<"Processor3 List:";
        forAllConstIters(processor3, iter)
        {
            Info<<" " << *iter;
        }
        Info<< nl;       
       
    Info<<"  ";
    Info<< nl;
   
    return 0;
}

// ************************************************************************* //
READ ME:
To compile
# enter the directory
cd ListSortAndDelDuplicateWithCountElement
# clean
wclean
# compile
wmake

# to launch the program type
ListSortAndDelDuplicateWithCountElement

you will get the following output :
 
Lists INPUT:
Processor0 List: a a b a c b
Processor1 List: b c b
Processor2 List: c a a c a
Processor3 List: d b
 
collector List before sorting and deleting duplicates: a a b a c b b c b c a a c a d b
collector List after sorting the elements            : a a a a a a b b b b b c c c c d
total number of elements: 16

The element a is present 6 times.
The element b is present 5 times.
The element c is present 4 times.
The element d is present 1 times.
 
Lists OUTPUT:
Processor0 List: a b c d
Processor1 List: a b c d
Processor2 List: a b c d
Processor3 List: a b c d

tested with OF1712.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> left associative [pag 4 moo book] = means that when the operator appears twice or more  in the same expression, each operator will use as much of the expression as it can for its left operand, and as little of it as it can for its right operand. 
example "<<" operator is left associative: std::cout << s << t means the same as (std::cout << s) << t
For example the operator >> takes two operands. 
		std::cout << "Hello, world!" << std::endl;
and is left associative -> kuwashiku hanashi see pag 4 moo book


>> STREAM MANIPULATORS / >> STREAM FORMAT STATES 
[pag578 deitel]
alcuni esempi:
	>> skipws = skip white-space characters on an input stream. 
	>> left = left justify ouput in a field. Padding characters appear to the right if necessary
	>> right =  right justify output in a field. Padding characters appear to the left if necessary
	>> boolalpha = specify that bool values should be displayed as the word true or false. The manipulator noboolalpha sets the stream bakc to displaying bool values as 1 (true) or 0 (false) see omonima voce boolalpha per maggiori informazioni.
	>> showpoint = specify that floating point numbers should be ouput with a decimal point. This is used normally with "fixed" to guarantee  a certain number of digits to the right of the decimal point, even if they're zeros. This setting is reset with stream manipulator "noshowpoint". 
	>> showbase = forces the base of an integral value to be output.[see example pag 583 deitel]
	>> scientific = specify output of a floating point value in scientific notation 
see example pag 584 deitel [ >> scientific format]
/////////////
	  cout << "\nDisplayed in scientific format:" << endl
      << scientific << x << '\t' << y << endl;
/////////////
	>> fixed = specify output of a floating point value in fixed point notation with a specific number of digits (as specified by member function precision or stream manipulator setprecision) to the right of the decimal point.
NOTE: showpoint is a sticky setting that forces a floating-point number to be output with its decimal point and trailing zeros. 
/////////////////////////
>> user-defined output stream manipulators
[]pag577 deitel]
>> showpos = pag 581 deitel
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> SRAND vs RAND
[pag217deitel]
function rand actually generates pseudorandom numbers. Repeatedly calling rand produces a sequence of numbers that appears to be random. However, the sequence repeats itself each time the program executes. Questo e' desiderabile nella fase di debug di un simulation program, this repeatability is essential for proving that corrections to the program work properly. 
Once a program has been thoroughly debugged, it can be conditioned to produce a different sequence of random numbers for each execution. This is called randomizing and is accomplished with the X++ standard library function srand. Function srand takes an unsigned integer argument and seeds the rand function to produce a different sequence of random numbers for each execution. C+11 provies addition random number capabilities that can produce nondeterministic random numbers (= a set of number that cannot be predicted). Such random number generators are used in simulations and security scenarios where predictability is undesirable. [FASCINATING!! the generation of the randomness from a deterministic machine]
see example pag218 fig06_10.cpp
NB: the program produces a different sequence of random numbers each time it executes, provided that the user enters a different seed. But if we used the same seed the same series of numbers will be displayed in each of the outputs. 
SEEDING the RANDOM NUMBER GENERATOR with the CURRENT TIME
to randomize without having to enter a seed each time, we may use a statement like 
	srand( static_cast<unsigned int>( time( 0 ) ) );
[pag219deitel]
this causes the computer to read its clock to obtain the value for the seed. Function time with the argument 0 as written in the preceding statement typically returns the current time as the number of seconds since January 1, 1970, at midnight reenwich Mean Time (GMT).

>> STACK 
[pag231 deitel]
Stack is a data structure analogous to a pile of dishes. When a dish is placed on the pile, it's normally placed at the top (= referred to as pushing the dish onto the stack). Similarly, when a dish is removed from the pile, it's normally removed from the top (= referred to as popping the dish off the stack). Stacks are known as LIFO data structures.
LIFO 
	= Last In First Out
in LIFO data structure the last item pushed (inserted ) on the stack is the first item popped (removed) from the stack. 
LIFO behavior is exactly what a function needs in order to return to the function that called it. 
See also >> Function-Call Stack 
-------------------------------
>> STACK 
[pag794 deitel]
Nodes can be added to a stack and removed from a stack only at its top, so a stack is referred  to as a last-in, first-out (>> LIFO) data structure. 
The primary member functions used to manipulate a stack are push and pop.
Function >> push = inserts a new node at the top of the stack. 
Function >> pop = removes a node from the top of the stack, stores the popped value in a reference variable that's passed to the calling function and returns true if the pop operation was successful (false otherwise)
Applications of Stacks
1) Function calls: when a function call is made, the called function must know how to return to its caller, so the return addres is pushed onto a stack. If a series of function calls occurs, the successive return values are pushed onto the stack in last-in, first-out order, so that each function can return to its caller. Stack support recursive function calls in the same manner as conventional nonrecursive call.
2) Stacks provide the memory for, and store the values of , automatic variables on each invocation of a function. 
When the function returns to its caller or throws an exception, the destructor (if any) for each local object is called, the space for that functions' automatic variables is popped off the stack and those variables are no longer known to the program.
3) Stacks are used by compilers in the process of evaluating expressions and generating machine-language code.
NOTE: gli stack si possono implementare via private inheritance from the List class template.
>> DELEGATION = pag795 deitel
>> dependent name = is an identifier that depends on a template parameter.

>> STACK OVERFLOW 
[pag232deitel]
Since the amount of memory of a computer is finite, only a certain amount of memory can be used to store activation records on the function call stack. If (number function calls) > (number of activation records that can be stored on the function call stack), a fatal error known as stack overflow occurs.
In sostanza uno stack overflow error, significa che il numero massimale di stack frames (contenenti l'indirizzo di ritorno per sapere dove rincasare una volta che la funzione chiamata ha svolto il suo compito) e' stato raggiunto, se volessi chiamare un'altra funzione non avresti piu' lo spazio in memoria per ricordare l'indirizzo della funzione chiamante. Lo stack e' stato appunto overflow. 

>> STACK FRAME
[pa232deitel]
e' anche chiamato "activation record". It contains the return address that the called function needs in order to return to the calling function.
pag 233deitel trovi un bell'esempio di function call stack in action

>> STATIC type variable / static is a >> type modifier [pag 121 moo book]
	static type variable;
For local declarations, declares "variable" with static storage class. The value of "variable" persists across executions of this scope and is guaranteed to be initialized before the variable is used for the first time. When the program exits from the scope, the variable keeps its value until the next time the program enters that scope. 

>> STATIC CAST OPERATOR 
[pag132deitel]
used to convert explicitly a variable 
example divisione di due numeri interi 
	int total = 7;
	int players = 4;
	double average = total / players;
it will truncate the value of the division since it is performed between two numbers.
Instead we can do 
	double average = static_cast< double >( total ) / players;
the static_cast operator creates a temporary floating point copy of its operands in parentheses (cioe' total nell'esempio precedente).  Using a casting operator in this manner is called explicit conversion.
Una volta che "total" diventa temporaneamente double, allora per effettuare la divisione, visto che il compiler sa evaluate only expression in which the operands are identical, allora the compiler performs an operation called PROMOTION (also called implicit conversion) on selected operands. 
OBSERVATIONS
- the static_cast operator is a unary operator (= an operator that takes only one operand)
-  cast operators have higher precedence than other unary operators such as + and - (che usi davanti ai numeri per indicare se sono positivi o negativi).
- hanno una precedence that is higher than that of multiplicative operators *, / and % and lower than that of parenthesis.
- osservazioni aggiuntive pag 212: converting values to lower fundamental types can result in incorrect values. Therefore a value can be converted to a lower fundamental type only by explicitly assigning the value to a variable of lower type, or by using a cast operator.

>> STATIC DATA MEMBERS / also knows as >> CLASS VARIABLES
[see bella discussione pag299-300deitel]
see also pag 418deitel
There is an important exception to the rule that each object of a class has its own copy of all the data members of the class. In certain cases, only one copy of a variable should be shared by all the objects of a class. A "static data member" is used for these and other reasons. Such a variable represents "class-wide" information, i.e. data that is shared by all instances and is not specific to any one object of the class. 
ADVICE PERFORMANCE : use static data members to save storage when a single copy of the data for all objects of a class will suffice.
pag 418deitel: un bell'esempio di perche' usare uno static class-wide data conviene quando un certo dato (data member) dev'essere conosciuto da molteplici oggetti. Al posto di fare multiple copie del data member e di dover poi aggiornare ciascuna delle copie per ciascuno degli oggetti (sprecando spazio e risorse) si puo' dichiarare il data member as "static", in tal modo tutti gli oggetti possono accedere al data member e solo una copia dev'essere mantenuta nel programma (per la piu' lunga e sintatticamente dettagliata spiegazione in inglese ti riferisco a pagina 418deitel) 
>> STATIC DATA MEMBER INITIALIZATION / >> INITIALIZE STATIC DATA MEMBER
[pag419 deitel]
A class's static data members have class scope. A static data member must be initialized exactly once.
Fundmental type static  dta members are initialized by default to 0. Prior to C++11 a static const data member of "int" or "enum" type could be initialized in its declaration in the class definition and all other "static" data member had to be defined and initialized at >> global namespace scope (= outside the body of the class definition). Again C++11's in class initializers also allow you to initialize these variables  where they're declared in the class definition. If a "static" data member is an object of a class that provides a default constructor, the "static" data member need not to be initialized because its default constructor will be called. 
>> STATIC DATA MEMBER ACCESS / >> ACCESS STATIC DATA MEMBER
[pag419 deitel]
A class's "privite" and "protected static" members are normally accessed through the calss's public member functions or "friends". A class's "static" members exist even when no objects of that class exist.
To access a "public static" class member when no objects of the class exist, simply prefix the class name oand the scope resolution operator (::) to the name of the data member. For example, if our preceding (pag418deitel) variable "martianCount" is public, it can be acessed with the expression "Martian::martianCount" (martianCount era il data member dichiarato static in modo da poter essere sharato tra tutti gli objects Martian), even when there are no Martian objects. (Of coarse, using "public" data is discouraged).
To access a private or protected static class member  when no objects of the class exist, provide a public static member function and call the function by prefixing its name with the class name and scope resolution operator. A static member function is a service of the class, not of a specific object of the class.
NOTE: [pag 422 deitel] a member function should be declared static if it does not access non-static data members or non-static member functions of the class (cioe' detto in parole spicciole :  una member function va dichiarata static solo se si limita ad accedere static data member or static member functions of the class). Unlike non-static member functions, a static member function does not have a "this" pointer, because static data members and static member functions exist independently of any objects of a class. The "this" pointer must refer to a specific object of the class, and when a static member function is called there might not be any objects of its class in memory.
COMMON ERRORS
- using the "this" pointer in a static member function is a compilation error
- declaring a "static" member function "const" is a compilation error. The "const" qualifier indicates that a function cannot modify the contents of the object on which it operates, but "static" member funtions exist and operate independently of any objects of the class.
CONCLUDENDO: a class's static data members and "static" member functions exist and can be used even if no objects of that class have been instantiated.
EXAMPLES see programs  /home/dia/Deitel-Code_Examples/ch09/fig09_27_29/fig09_29.cpp  et pag 419 deitel 
Trovi un utile esempio di >> count number of objects instantiated / >> NUMBER OBJECTS INSTANTIATED COUNT / >> number of objects of a class tracking with static data member 
////////////////////////////////////////////////

>> STATIC DATA MEMBERS AND MEMBER FUNCTIONS [pag254 mike game programming]
IN SHORT 
STATIC DATA MEMBER used to STORE A SINGLE VALUE FOR AN ENTIRE CLASS.
IN LONG 
What if you want to store some information about an entire class, such as the total number of instances that exist? You might want to do this if you've created a bunch of enemies and you want them to fight the player based on their total number. For example, if their total number is below a certain threshold, you might want the enemies to run away. You need to store a single value for an entire class. You can do this with a static data member.  
FULL EXAMPLE from 
----------------------------------------------------- FULL EXAMPLE START
	//Static Critter
	//Demonstrates static member variables and functions
	
	#include <iostream>	
	using namespace std;
	
 	// start of the class Critter definition
	class Critter
	{
	public:
	    static int s_Total;     //>> static member variable declaration / >> static declaration 
	                            //s_Total is a static member variable that will display the total number of Critter objects in existence
	    // NOTE >> CONVENTION STATIC DATA: prefixed the variable name with s_ so it would be instantly recognizable as a static data member.

	    Critter(int hunger = 0); // in the beginning (detto stile princess Fantasia) ... there are zero Critters.
// >> STATIC MEMBER FUNCTIONS [pag257 mike game programming]
	    static int GetTotal();  //static member function prototype
	    
	private:
	    int m_Hunger;
	}; // fine della class Critter definition 

// outside the class definition we initialize the static data member to 0	
	int Critter::s_Total = 0;   //static member variable initialization
// NOTE: (>> QUALIFY DATA MEMBER) nella linea di codice precedente we >> qualified the data member name with Critter:: 
// Outside of its class definition, you must quality a static data member with its class name.
// HINT: you can declare a static variable in non class functions too. The static variable maintains its value between function calls.	

    
	Critter::Critter(int hunger): 
	    m_Hunger(hunger)
	{
	    cout << "A critter has been born!" << endl;
// incrementing s_Total:
	    ++s_Total; // every time a new object is instantiated, s_Total is incremented
// note: we did not quality s_Total with Critter::. Just as with nonstatic data members, we don't have to qualify a static data member with its class name inside its class. [una maniera semplice di vedere le cose: visto che Critter:: c'e' gia' all'esterno del blocco {} non e' piu' necessario ripeterlo dentro]
// NOTE: here we made the static data member public, but you can also make a static data member private. But then like any other data member, you can only access it in a class member function.
	}

// >> STATIC MEMBER FUNCTION DEFINITION 	
	int Critter::GetTotal()     //static member function definition
	{
	    return s_Total; // this static member function GetTotal() returns the value of the static data member s_Total
	}
// NOTE: a static member function definition is much like the non static member function definition you've seen so far. The major difference is that a static member function cannot access non static data members. This is because a static member function exists for the entire class and is not associated with any particular instance of the class.	


	int main()
	{
	    cout << "The total number of critters is: ";
// >> ACCESS STATIC DATA MEMBERS / >> STATIC DATA MEMBER ACCESS [pag256 mike game programming]
	    cout << Critter::s_Total << "\n\n"; // questa linea mostra un esempio concreto of how to access a public static data member.
// You can accesss a public static data member anywhere in your program. Basta far precedere il nome dello static data member dal nome della classe in cui e' stato creato
// Un alternativa equivalente a "Critter::s_Total" is to access a static data member through any object of the class. 
// Assuming that crit1 is a "Critter" object, we could display the total number of critters using :   
// cout << crit1.s_Total << "\n\n";
	     
	    Critter crit1, crit2, crit3;
	      
	    cout << "\nThe total number of critters is: ";
// >> CALL STATIC MEMBER FUNCTION [pag257 mike game programming]
	    cout << Critter::GetTotal() << "\n";
// NOTE: to properly identify the static member function, we have to qualify it with Critter::
// To call a static member function from outside of its class, you must qualify it with its class name. ]
// HINT: you can also access a static member function through any object of the class. Assuming that crit1 is a Critter object, we could display the total number of critters with 	
// cout << crit1.GetTotal() << "\n\n";    
	    return 0;
	}
// NOTE: because static member functions exist for the entire class, you can call a static member function without any instances of the class in existance. And just as with private static data members, private static member functions can only be accessed by other member functions of the same class.
----------------------------------------------------- FULL EXAMPLE END
OUTPUT of the program 
	The total number of critters is: 0
	A critter has been born!
	A critter has been born!
	A critter has been born!
	The total number of critters is: 3
////////////////////////////////////////////////////////////////////////////////////////

>> STATIC storage class specifier [pag107 moo book]
Local variables that are declared to be static are preserved across invocations of the function.

>> CRITTER CARETAKER GAME [pag258 mike game programming]
uml for the critter class 

	                        -----------------------------
	                        |                           |
	nome della classe       |          Critter          |       
	                        -----------------------------
	                        |                           |
	                        |      -m_Hunger:int        |
	data members            |      -m_Boredom:int       |
	                        |                           |
	                        -----------------------------     
	                        |                           |
	                        |      +Talk()              |
	                        |      +Eat()               |       
	member functions        |      +Play()              |
	                        |      -PassTime()          |
	                        |                           |
	                        -----------------------------      

- means private and + means public
---------------------------------------------------------------- FULL EXAMPLE CRITTER CARETAKER GAME
[from /home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter08/critter_caretaker.cpp]
	//Critter Caretaker
	//Simulates caring for a virtual pet
	
	#include <iostream>
	
	using namespace std;
	
	class Critter  // class definition start
	{
	public:          
	    Critter(int hunger = 0, int boredom = 0); 
	    void Talk();
	    void Eat(int food = 4);
	    void Play(int fun = 4);
	
	private:
	    int m_Hunger;
	    int m_Boredom;
	
	    int GetMood() const;
	    void PassTime(int time = 1);
	
	};    // class definition end
	
	Critter::Critter(int hunger, int boredom):   // >> class constructor
	    m_Hunger(hunger),
	    m_Boredom(boredom)
	{}    // class constructor end
	
	inline int Critter::GetMood() const  // getMood() member function definition
	{
	    return (m_Hunger + m_Boredom);
	}
	// note : this member function is private because it should only be invoked by another member function of the class.
	// come scriveva precedentemente mike: "member access is private by default. Until you specify an access modifier, 
    // any class members you declare will be private."

	void Critter::PassTime(int time)
	{
	    m_Hunger += time;
	    m_Boredom += time;
	}
	
	void Critter::Talk()
	{
	    cout << "I'm a critter and I feel ";
	
	    int mood = GetMood();
	    if (mood > 15)
		{
	        cout << "mad.\n";
		}
	    else if (mood > 10)
		{
	        cout << "frustrated.\n";
		}
	    else if (mood > 5)
		{
	        cout << "okay.\n";
		}
	    else
		{
	        cout << "happy.\n";
		}
	
	    PassTime();
	}
	
	void Critter::Eat(int food) 
	{
	    cout << "Brruppp.\n";
	
	    m_Hunger -= food;
	    if (m_Hunger < 0)
		{
	        m_Hunger = 0;
		}
	
	    PassTime();
	}
	
	void Critter::Play(int fun)
	{
	    cout << "Wheee!\n";
	
	    m_Boredom -= fun;
	    if (m_Boredom < 0)
		{
	        m_Boredom = 0;
		}
	
	    PassTime();
	}
	
	int main()
	{
		Critter crit;
		crit.Talk();
	
		int choice;
		do
	    {
	        cout << "\nCritter Caretaker\n\n";
	        cout << "0 - Quit\n";
	        cout << "1 - Listen to your critter\n";
	        cout << "2 - Feed your critter\n";
	        cout << "3 - Play with your critter\n\n";
	
	        cout << "Choice: ";
	        cin >> choice;
	
	        switch (choice)
	        {
				case 0:	
					cout << "Good-bye.\n";
					break;
				case 1:	
					crit.Talk();
					break;
				case 2:	
					crit.Eat();
					break;
				case 3:	
					crit.Play();
					break;
				default:
					cout << "\nSorry, but " << choice << " isn't a valid choice.\n";
	        }
		} while (choice != 0);
	
	    return 0;
	}
	

---------------------------------------------------------------- END FULL EXAMPLE CRITTER CARETAKER GAME 
OUTPUT of the PROGRAM 
	I'm a critter and I feel happy.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 1
	I'm a critter and I feel happy.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 2
	Brruppp.
	
	Critter Caretaker
	
	0 - Quit
	1 - Listen to your critter
	2 - Feed your critter
	3 - Play with your critter
	
	Choice: 3
	Wheee!
////////////////////////////////////////////////////////////////////////////////////////

>> STATIC LOCAL ARRAY
[pag291deitel]
We can apply static to a local array declaration so that it's not created and initialized each time the program calls the function and is not destroyed each time the function terminates. This can improve performance, especially when using large arrays.

>> STATIC STORAGE DURATION 
[pag227deitel]
Variables with static storage duration exist in memory from the point at which the proram begins execution and until the program terminates.
There are two types of identifiers with static storage duration:
1) global variables
2) static local variables 
	1) Global variables are created by placing variable declarations outside ay class or function definition. Global variables retain their values throughout a program's execution. Global variables and global functions can be referenced by any function that follows their declarations or definitions in the source file.
WARNING: declaring a variable as a global rather than local allows unintended side effects to occur when a function that does not need access to the variable accidentally or maliciously modifies it. In general, except for truly global resources such as cin and cout, the use of global variables should be avoided unless there are unique performance requirements.
	2) Local variables declared static are still known only in the function in which they're declared, but, unlike automatic variables, static local variables retain their values when the function return to its caller. The next time the function is called, tha static local variables contain the values they had when the function last completed execution. 
Example :
	static unsigned int count = 1;
the previous statement declares local variables count to be static and to be initialized to 1:
All numeric variables of static storage duration are initialized to zero by default, but it's nevertheless a good practice to explicitly initialize all variables.

>> std::
the notation std::cout specifies that we are using a name, in this case cout, that belongs to namespace std.
Remember to include std:: before each mention of cout, cin, and cerr in a program. 
Se introduci la "using" declaration and "using" directive you can omit "std::" before each use of a name in the std namespace  
example
	#include <iostream>  // allows program to perform input and output
	using std::cout; // program uses cout
	using std::cin;  // program uses cin
	using std::endl; // program uses endl
	int main()
	{
		cout << "enter two integers to compare: ";  
// non devi piu' far precedere cout da std
		cin >> number1 >> number2; 
// nota come possiamo leggere due numeri da tastiera usando due >> nella stessa riga
	}
NB: al posto delle tre righe 
	using std::cout; // program uses cout
	using std::cin;  // program uses cin
	using std::endl; // program uses endl
puoi piu' sinteticamente giusto scrivere
	using namespace std;
which enables a program to use all the names in any standard C++ header (such as <iostream>) that a program may include.	
[pag42deitel example @54deitel]
NOTE from pag 34 mike: std namespace includes elements from the standard library. To access an element from the namespace, you need to prefix the element with the std:: or employ using.
///////////////////////////////////////////////////////////////////

>> STANDARD INPUT (CIN)
The standard input device is usually the keyboard 
In C++ the operator of extraction is used >>
ex
	int age;
	cin >> age;
The fisrt statement declares a variable of int called age, and the second one waits for an input from cin (the keyboard) in order to store it in this integer variable. 
NB
- cin can only process the input from the keyborad once the RETURN key has been pressed.  
	cin >> a >> b;
is equivalent to:
	cin >> a;
	cin >> b;
- you must always consider the type of the variable that you are using as a container with cin extractions. If you request an integer you will get an integer, if you request a character you will get a character and if you request a string of character you will get a string of charaters. 
EX
	// i/o example 
	#include <iostream>
	using namespace std;
	int main ()
	{
	int i;
	cout << "Please enter an integer value: ";
	cin >> i;
	cout << "The value you entered is " << i;
	cout << " and its double is " << i*2 << ".\n";
	return 0;
	}
Donera' su schermo:
Please enter an integer value: 127
The value you entered is 127 and its double is 254.
- cin and strings: we can use cin to get strings with the extraction operator (>>) 
	cin >> mystring;
however, cin extraction stops reading as soon as if finds any blank space character, so we will be able to get just onw word for each extraction. To extract entire lines it is more recommendable to use "getline"	
EX
	// cin with strings
	#include <iostream>
	#include <string>
	using namespace std;
	int main ()
	{
	string mystr;
	cout <<"What's your name? ";
	getline (cin, mystr);
	cout << "Hello " << mystr << ".\n";
	cout << "What is your favorite team? ";
	getline (cin, mystr);
	cout << "I like " << mystr << " too!\n";
	return 0;
	}  
In Fuji pascon abbiamo dovito modificare le version precedente nel seguente modo (aggiungere due righe) altrimenti non ci memorizzava la risposta a what's your name
	// cin with strings
	#include <iostream>
	#include <string>
	using namespace std;
	int main ()
	{
	string mystr;
	// ecco le due seguenti righe che aggiungiamo
	cout <<"";
	getline (cin, mystr);
	cout <<"What's your name? ";
	getline (cin, mystr);
	cout << "Hello " << mystr << ".\n";
	cout << "What is your favorite team? ";
	getline (cin, mystr);
	cout << "I like " << mystr << " too!\n";
	return 0;
	}  
// ==============================================
// ==============================================
// ==============================================

>> STRING INIZIALIZATION 
#include <iostream>
#include <string>
using namespace std;
int main()
{
	string choice;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> string inizialization examples from pag14 moo book
	std::string s;
		Defines s as a variable of type std::string that is initially empty
	std::string t = s;
		Define t as a variable of type std::string that initially contains a copy of the characters in s, where s can be either a string or a string literal
	std::string z(n, c);
		Define z as a varaible of type std::string that initially contains n copies of the character c. Here,c c must be a char, not a string or a string literal.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

>> self assignement string / >> string self assignment
[pag438deitel]
   // test overloaded copy assignment (=) operator with self-assignment
   string s4(" nostromo-cargo ");	
   cout << "assigning s4 to s4" << endl;
   s4 = s4;  
   cout << "s4 = " << s4 << endl;
///////////////////////////////////////////////////

>> STANDARD LIBRARY HEADERS LIST / C++ STANDARD LIBRARY HEADERS LIST
see section 6.6 deitel pag213-214 
- <iostream> contains function prototypes for the C++ standard input and output
- <iomanip>  contains function prototypes for stream manipulators that format streams of data.
- <cmath>    contains function prototypes for math library functions
- <cstdlib>  contains function prototypes for conversions of numbers to text, text to numbers, memory allocation, random numbers and various other utility functions.
- <ctime>    contains function prototypes and types for manipulating the time and date
- <array>---------|
  <vector>        |
  <list>          |
  <forward_list>  |
  <deque>         |
  <queue>         |----> these headers contain classes 
  <stack>         |      that implement the C++ standard library 
  <map>           |      containers [anche qui navi portacontainers]. 
  <unordered_map> |      Containers store data during program execution.
  <unordered_set> |
  <set>           |
  <bitset> -------|          
- <cctype>     contains function prototypes for functions that test characters for certain properties (such whether the character is a digit or a punctuation) and function prototypes for functions that can be used to convert lowercase letters to uppercase letters and vice versa.
- <cstring>    contains function prototypes for C-style string-processing functions.
- <typeinfo>   contains classes for runtime type identification (determining data types at execution time)
- <exception>  |    
  <stdexcept>  |---------> these headers contain classes that are used for exception handling
- <memory>     contains classes and functions used by the C++ standard library to allocate memory to the C++ standard library containers.
- <fstream>    contains function prototypes for functions that perform input from and output to files on disk
- <string>     contains the definition of class string from the C++ standard library
- <sstream>    contains function prototypes for functions that perform input from strings in memory and output to strings in memory
- <functional> contains classes and functions used by C++ standard library algorithms
- <iterator>   contains classes for accessing data in the C++ standard library containers
- <algorithm>  contains functions for manipulating data in C++ standard library containers
- <cassert>    contains macros for adding diagnostics that aid program debugging see Appendix E, prepocessor pag992
- <cfloat>     contains the floating-point size limits of the system
- <climits>    contains the integral size limits of the system
- <cstdio>     contains function prototypes for the C-style standard input/output library functions
- <locale>     contains classes and functions normally used by stream processing to process data in the natural form for different languages (e.g monetary formats, sorting strings, character presentation, etc)
- <limits>     contains classes for defining the numerical data type limits on each computer platform
- <utility>    contains classes and functions that are used by many C++ Standard Library headers.


>> STANDARD LIBRARY HEADERS Observations / C++ STANDARD LIBRARY HEADERS Observations 
- the C++ Standard Library is divided into many portions, each with its own header. 
The HEADERS -----contains -->| the             | for the
                           �@ | functions  ---> | related
�@�@�@�@�@�@�@�@�@�@�@�@�@�@�@�@ �@�@�@�@�@�@   �@| prototypes      | functions that form each portion of the library. 
The headers also contain 
- definitions of various class types and functions, 
- as well as constants needed by those functions. 
A header "instructs" the compiler on how to interface with library <-and-> user-written components.                 


>> STANDARD OUTPUT
By default the standard output of a program is the screen, and the C++ stream object defined to access it is "cout"
cout is used in conjunction with the insertion operator, which is written as <<
ex:
	cout << "Output Sentence"; // prints Output sentence on screen
	cout << "Hello"; // prints "Hello" on screen
	cout << Hello;   // prints the content of the Hello variable
The insertion operator << may be used more than once in a single statement (useful when we want to print out a combination of variables and constants or more than one variable)
	cout << "Hello,I am " << age << " years old and my zipe code is " << zipcode;
Notice that cout does not add a line break after its output unless we explicitly indicate it. 
In order to perform a line break : \n (backlash n)
ex1
	cout << "Ciao!";
	cout << "Salut!";
otterrai : 
	Ciao!Salut!
ex2
	cout << "Ciao!\n ";
	cout << "Salut!\nHello!";
otterrai:
	Ciao!  
	Salut!
	Hello!
- Alternativamente si puo' anche usare l'end manipulator 
ex3
	cout << "First sentence." << endl;
	cout << "Second sentence " << endl;
ed otterrai: 
	First sentence. 
	Second sentence.
[NB: the end1 manipulator produces a newline character , exactly as the insertion of '\n' does but it also have an additional behavior when it is used with buffered streams (see buffered stream def for more info): the buffer is flushed (cioe' e' inviato dal buffer (temporary storage area) into the computer's permanent memory con una perdita di performance). Anyway , cout will be an unbufferred stream in most cases so you can generally use both the \n escape character and the endl manipulator in order to specify a new line withou any difference in its behavior.]
// ==============================================
// ==============================================
// ==============================================



>> string : variables that can store non-numerical values that are longer than one single character ex: 
	string mystring = "This is a string";
[o anche 
	string mystring ("This is a string");]
NB: in order to declare and use these objects it is necessary to add the following line 
	#include <string>
quindi il beginning del source code sara' del tipo:
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
		{ ect
- Strings can also being declared without an initial value and being assigned values during execution
ex:
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
	{
		string mystring;
	mystring = "This is the initial string content";
	cout << mystring << endl; // endl = vai a capo
	mystring = "This is a different string content";
	cout << mystring << endl;
		return 0;
	}
// ==============================================
// ==============================================
// ==============================================

>> STRING ALL'INTERNO DI UNA FUNCTION / >> STRING INSIDE FUNCTION 
bisogna prima far precedere la string dal nome della library in cui e' definita
	std::string TitleCiccio = "Eri and Yui Queens of Prairies";
usare solo string TitleCiccio non funziona.

>> STRING EXAMPLES / >> STRING CLASS TEST PROGRAM
pag 435 deitel /home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
// Fig. 10.1: fig10_01.cpp
// Standard Library string class test program.
	#include <iostream>
	#include <string>
	using namespace std;
	int main()
	{
	   string s1( "happy" );
	   string s2( " birthday" );
	   string s3;
	
	   // test overloaded equality and relational operators
	   cout << "s1 is \"" << s1 << "\"; s2 is \"" << s2
	      << "\"; s3 is \"" << s3 << '\"' 
	      << "\n\nThe results of comparing s2 and s1:"
	      << "\ns2 == s1 yields " << ( s2 == s1 ? "true" : "false" )
	      << "\ns2 != s1 yields " << ( s2 != s1 ? "true" : "false" )
	      << "\ns2 >  s1 yields " << ( s2 > s1 ? "true" : "false" ) 
	      << "\ns2 <  s1 yields " << ( s2 < s1 ? "true" : "false" )
	      << "\ns2 >= s1 yields " << ( s2 >= s1 ? "true" : "false" )
	      << "\ns2 <= s1 yields " << ( s2 <= s1 ? "true" : "false" );
	      
	   // test string member function empty 
	   cout << "\n\nTesting s3.empty():" << endl;
	
	   if ( s3.empty() )
	   {
	      cout << "s3 is empty; assigning s1 to s3;" << endl;
	      s3 = s1; // assign s1 to s3
	      cout << "s3 is \"" << s3 << "\"";
	   } // end if
	
	   // test overloaded string concatenation operator
	   cout << "\n\ns1 += s2 yields s1 = ";
	   s1 += s2; // test overloaded concatenation
	   cout << s1;
	
	   // test overloaded string concatenation operator with a C string
	   cout << "\n\ns1 += \" to you\" yields" << endl;
	   s1 += " to you";  
	   cout << "s1 = " << s1 << "\n\n";
	
	   // test string member function substr
	   cout << "The substring of s1 starting at location 0 for\n"
	      << "14 characters, s1.substr(0, 14), is:\n"
	      << s1.substr( 0, 14 ) << "\n\n";
	
	   // test substr "to-end-of-string" option
	   cout << "The substring of s1 starting at\n"
	      << "location 15, s1.substr(15), is:\n"
	      << s1.substr( 15 ) << endl; 
	
	   // test copy constructor
	   string s4( s1 );  
	   cout << "\ns4 = " << s4 << "\n\n";
	
	   // test overloaded copy assignment (=) operator with self-assignment
	   cout << "assigning s4 to s4" << endl;
	   s4 = s4;  
	   cout << "s4 = " << s4 << endl;
	
	   // test using overloaded subscript operator to create lvalue
	   s1[ 0 ] = 'H';      
	   s1[ 6 ] = 'B';
	   cout << "\ns1 after s1[0] = 'H' and s1[6] = 'B' is: "
	      << s1 << "\n\n";
	
	   // test subscript out of range with string member function "at"
	   try                                                               
	   {                                                                 
	      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
	      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
	   } // end try                                                      
	   catch ( out_of_range &ex )                                        
	   {                                                                 
	      cout << "An exception occurred: " << ex.what() << endl;        
	   } // end catch                                                    
	} // end main
	/**************************************************************************
	 * (C) Copyright 1992-2014 by Deitel & Associates, Inc. and               *
	 * Pearson Education, Inc. All Rights Reserved.                           *
	 *                                                                        *
	 * DISCLAIMER: The authors and publisher of this book have used their     *
	 * best efforts in preparing the book. These efforts include the          *
	 * development, research, and testing of the theories and programs        *
	 * to determine their effectiveness. The authors and publisher make       *
	 * no warranty of any kind, expressed or implied, with regard to these    *
	 * programs or to the documentation contained in these books. The authors *
	 * and publisher shall not be liable in any event for incidental or       *
	 * consequential damages in connection with, or arising out of, the       *
	 * furnishing, performance, or use of these programs.                     *
	 **************************************************************************/
////////////////////////////////////////////////////////////
NOTE: il precedente programma una volta compilato via g++ on ubuntu 12 ci donava il seguente errore:
	[2025 fig10_01] >> g++ fig10_01.cpp -o edyProgram10-01
	fig10_01.cpp: In function ?eint main()?f:
	fig10_01.cpp:75:12: error: expected type-specifier before ?eout_of_range?f
	fig10_01.cpp:75:25: error: expected ?e)?f before ?e&?f token
	fig10_01.cpp:75:25: error: expected ?e{?f before ?e&?f token
	fig10_01.cpp:75:26: error: ?eex?f was not declared in this scope
	fig10_01.cpp:75:29: error: expected ?e;?f before ?e)?f token
SOLUTION abbiamo commentato tutta la guilty section :
	/*
   // test subscript out of range with string member function "at"
   try                                                               
   {                                                                 
      cout << "Attempt to assign 'd' to s1.at( 30 ) yields:" << endl;
      s1.at( 30 ) = 'd'; // ERROR: subscript out of range            
   } // end try                                                      
   catch ( out_of_range &ex )                                        
   {                                                                 
      cout << "An exception occurred: " << ex.what() << endl;        
   } // end catch                                                    
   */
//////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

>> STRING MANIPULATORS
[pag573 deitel]
C++ provides various stream manipulators that perform formatting tasks. The strea manipulators provide capabilities  such as 
	- setting field widths
	- setting precision
	- setting and unsetting format state
	- setting the fill character in fields, 
	- flushing streams
	- inserting a new line into the output stream
	- inserting a null character into the output stream and skipping white space in the input stream. 
a pagina 574 trovi spiegati 
	>> hex = manipulator to set the base to hexadecimal (base 16)
	>> oct = manipulator to set the base to octal (base 8)
	>> dec = usato per reset the stream base to decimal. 
Integers are interpreted normally as decimal (base 10) values. To change the base in which integers are interpreted on a stream, inset the hex manipulator to set the base to hexahedral. or insert the oct manipulator to set the base to octal.
These are all sticky manipulators.
A stream's base also may be changed by the setbase stream manipulator, which tkes an int argument of 10, 8, or 16  to set the base to decimal, octal or hexadecimal, respectively. Because setbase takes an argument, it's called a >> parameterized stream manipulator. 
Parameterized stream manipulators like setbase, require the header <iomanip>. The stream base value remains the same until changed explicitly; setbase settings are sticky.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> string size [pag22 moo book]
Whenever we need a local variable to contain the size of a string, we should use std::string::size_type as the type of the variable
Example
	const string::size_type nomeVariabile = nomeStringa.size();
[from program /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter02/frame.cc]
NOTE perche' complicarsi la vita ad usare "const string::size_type nomeVariabile" al posto del piu' semplice "const int nomeVariabile
It's for ensuring that nomeVariabile is capable of containing the number of characters in nomeStringa, no matter how large that number might be. We could simply have said that "nomeVariabile" has type int, and indeed, doing so would probably work. However, the value of nomeVariabile depends on the size of the input to our program, and we have no control over how long that input might be. It is conceivable that someone might give our program a string so long that an int is insufficient to contain its length.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> STORAGE DURATION 
[pag 225deitel]
in the programs we use identifiers for variable names and functions. The attributes of variables include name, type, size and value. each identifier in a program also has other attributes, like storage duration, scope and linkage
STORAGE DURATION : an identifier storage duration determines the period during which that identifier exists in memory. Some exist briefly, some are repeatedly created and distroyed and others exist for a program's entire execution. 
The storage-class specifiers can be split into four storage durations: automatic, static, dynamic and thread.
You can request additional memory in your program during the program's execution - so called dynamic memory allocation. Variables allocated dynamically have dynamic storage duration.
- Variable with automatic storage duration include:
	local variables declared in functions
	function parameters
	local variables or function parameters declared with register
Such variables are created when program execution enters the block in which they're defined, they exist while the block is active and they're destroyed when the program exist the block. An automatic variable exists only in the nearest enclosing pair of curly braces within the body of the function in which the definition appears, or for the entire function body in the case of a function parameter. Local variables are of automatic storage duration by default. For the remainder of the text, we refer to variables of automatic storage duration simply as automatic variables.
Performance tip: automatic storage is a means of conserving memory, because automatic storage duration variables exist in memory only when the block in which they're defined is executing.  
 

>> STRING LITERAL string literal = is when you have "" surrounding the literal text "Hello Fede!" is a string literal

>> string concatenation using +=
example from /home/dia/Deitel-Code_Examples/ch10/fig10_01
   string s1( "happy birthday" );
   // test overloaded string concatenation operator with a C string
   cout << "\n\ns1 += \" to you\" yields" << endl;
   s1 += " to you";  
   cout << "s1 = " << s1 << "\n\n";

>> string copy constructor 
[pag438deitel]
   // test copy constructor
   string s4( s1 );  
   cout << "\ns4 = " << s4 << "\n\n";
With the line string s4( s1 );  we create a string object s4 and initializes it with a copy of s1. This results in a call to class string's "copy constructor".  

>> STRINGSTREAM
stringstream is useful to perform extraction or insertion operations from/to strings,We convert  strings to numerical values and viceversa. 
EX
	string mystr;	
	int quantity=0;
	cout << "Enter quantity: ";
    getline (cin, mystr);
	stringstream(mystr) >> quantity; 	
	/* in tal modo la variabile quantity contiene 	
	ora il valore numerico che hai inserito in 
	formato stringa attraverso la tastiera.*/  
[NB: Per poter usare stringstream devi inserire nell'header 
	#include <sstream>
]
// ==============================================
// ==============================================
// ==============================================

>> STRING Assignment and concatenation 
[pag850 deitel]
The class template basic_string provides typical string manipulation operations such as copyoing searching, etc. The template definition and all support facilities are defined in namespace std; these include the typedef statement
	typedef basic_string< char > string;
that creates the alias type string for basic_string<char>. 
>> string initialization / >> initializing string / >> initialization string [pag850 deitel]
Example 1
	string text("Hello");  // creates a string from a const char *
Example 2 (with two constructor arguments)
	string name(8, 'x'); // string of 8 'x' characters
which creates a string containing eight 'x' characters.
Example 3 puoi anche initializzarla con
	string month = "Month"; // same as :   string month("March");
>> string length [pag851 deitel]
the length of a string can be retrieved with member function "size" and with member function length. The subscript operator, [] (which does not perform bounds checking) can be used with strings to access and modify individual characters. A string object has a first subscrit of 0 and a last subscript of size() -1
>> string I/O [pag851]
The stream extraction operator (>>) is overloaded to support strings. The statements
	string stringObject;
	cin >> stringObject;
declare a string object and read a string from cin. INput is delimited by whitespace characters. When a delimiter is encountered, the input operation is terminated. Function 
	getline
also is overloaded for strings. Assuming string1 is a string, the statement
	getline( cin, string1 );
reads a string from the keyboard into string1. Input is delimited by a newline ('\n'), so getLine can read a line of text into a string object. You can specify an alternate delimiter as  the optional third argument to getline.
EXAMPLE 
// Fig. 21.1: fig21_01.cpp
// Demonstrating string assignment and concatenation.
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "cat" );
   string string2; // initialized to the empty string
   string string3; // initialized to the empty string

   string2 = string1; // assign string1 to string2
   string3.assign( string1 ); // assign string1 to string3
/*
note: the previous line uses member function assign to copy string1 into string3. A separate copy is made (cioe' string1 and string3 are indepedent objects). Class string also provides an overloaded version of member function assign that copies a specified number of characters, as in 
	targetString.assign( sourceString, start, numberOfCharacters );
where sourceString is the string to be copied, start is the starting subscript and numberOfCharacters is the number of characters to copy.
*/	 
   cout << "string1: " << string1 << "\nstring2: " << string2
      << "\nstring3: " << string3 << "\n\n";

   // modify string2 and string3 
   string2[ 0 ] = string3[ 2 ] = 'r';

   cout << "After modification of string2 and string3:\n" << "string1: " 
      << string1 << "\nstring2: " << string2 << "\nstring3: ";
/*
il precedente dona:
	string1: cat
	string2: cat
	string3: cat
	After modification of string2 and string3:
	string1: cat
	string2: rat
	string3: car
*/
// >> CONCATENATION EXAMPLE 
   // demonstrating member function at
   for ( size_t i = 0; i < string3.size(); ++i ) 
      cout << string3.at( i ); // can throw out_of_range exception

   // declare string4 and string5
   string string4( string1 + "apult" ); // concatenation
   string string5; // initialized to the empty string

   // overloaded +=                               
   string3 += "pet"; // create "carpet"           
   string1.append( "acomb" ); // create "catacomb"

   // append subscript locations 4 through end of string1 to
   // create string "comb" (string5 was initially empty)
   string5.append( string1, 4, string1.size() - 4 );
                                 
   cout << "\n\nAfter concatenation:\nstring1: " << string1 
      << "\nstring2: " << string2 << "\nstring3: " << string3 
      << "\nstring4: " << string4 << "\nstring5: " << string5 << endl;
/*
il codice precedente dona:
	After concatenation:
	string1: catacomb
	string2: rat
	string3: carpet
	string4: catapult
	string5: comb
*/
--------------------------------------------------------------------
>> at member function pag852 deitel
using the member function "at" you can output the contents of a string one character at a time. The member function "at" provides >> checked access ( or >> range checking )
On the contrary the subscript operator [] does not provide checked access. 
Accessing an elment beyond the size of the string using the subscript operator is an unreported logic error.

>> ARGUMENT mike pag66
Function can also take values to use in their work. You provide these values by placing them between the prentheses after the function name, separated by commas. These values are called arguments, and when you provide them, you pass them to the function. 
example 
	string1.insert( 10, string2 );
NOTE: >> ARGUMENT vs PARAMETER [pag175 mike programming game] : an arugment is what you use in a function call to pass a value to a function. A parameter is what you use in a function definition to accept values passed to a function.
////////////////////////////////////////////////////////////////////////////////////////////////////

>> comparing string / >> string comparison 
[pag853 deitel]
if (string1 == string2)
	...
else if (string 1 > string2)
	...
else
---------------------------------------------------------------------
>> lexicographically GREATER than [pag855 deitel]
[pag855deitel]
ex T is considered lexicographically greater than H
----------------------------------------------------------------------
>> substrings [deitel pag856 deitel] / >> substr [deitel pag856 deitel] / >> extract portion of a string
Clas string provides member function substr for retreiving a substring from a string. 
// Fig. 21.3: fig21_03.cpp
// Demonstrating string member function substr.
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "The airplane landed on time." );

   // retrieve substring "plane" which
   // begins at subscript 7 and consists of 5 characters
   cout << string1.substr( 7, 5 ) << endl;
} // end main
-----------------------------------------------------------------------
>> swapping strings / >> string swap [pag 856 deitel]
	// Fig. 21.4: fig21_04.cpp
	// Using the swap function to swap two strings.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   string first( "one" ); 
	   string second( "two" );
	
	   // output strings
	   cout << "Before swap:\n first: " << first << "\nsecond: " << second;
	
	   first.swap( second ); // swap strings
	
	   cout << "\n\nAfter swap:\n first: " << first
	      << "\nsecond: " << second << endl;
	} // end main
///////////////// Result
	Before swap
	 first: one
	second: two
	
	After swap:
	 first: two
	second: one
----------------------------------------------------------------
>> string characteristcs / >> string size / >> string length / >> string capacity / >> string maximum length [pagdeitel 857]
>> substring find in string / >> characters in a string find [deitel pag859]
alcune funzioni utili 
	>> find 
		ex. string1.find( "is" )     -> ricerca la substring "is" all'interno di string1: if "is" is found the subscript location is returned.
[>> find algorithm vedi anche esempio pag 107 moo book]
	>> rfind = to search a string backward
		ex. string2.rfind ("is")     -> = Reverse find ricerca la substring "is" all'interndo di string2  from right to left
	>> find_first_of  to locate the first occurrence in nomeString of any of the characters contained between the "" of the argument
		ex. string1.find_first_of( "abc" );     -> appena trova in string1 la lettera a, o la lettera b o la lettera c ti indica la location all'interno della stringa, cioe' appena trova una delle tre, della prima che trova ti dona la location. 
	>> find_last_of to find the last occurrence in string1 of any character contained in " "
		ex string1.find_last_of( "abc" );
	>> find_first_not_of  : is a member function used to find the first character not contained in " " argument
		ex location = string1.find_first_not_of( "noi spm" );
note: [>> argument] piu' che dire "input passato a una funzione" e meglio dire "argument passed to a function" cioe' i parametri che inserisci tra le parentesi tonde della member function.
------------------------------------------------------------
>> replace characters in string / >> replace character in string / >> erase character from string / >> subtitution in string 
[deitel861]
1)	string1.erase( 62 );   -> erase everything from (and including) the character in position 62 to the end of the string1. Note: each newline character occupies one character in the string.
2) substitution example 
	   size_t position = string1.find( " " ); // find first space
	
	   // replace all spaces with period
	   while ( position != string::npos )    // nota: member function "find" returns string::npos when the search character is not found. Cio' significa che se position == not found allora tutte le sostituzioni sono state effettuate, e si esce dal ciclo while
	   {
	      string1.replace( position, 1, "." );
	      position = string1.find( " ", position + 1 );
	   } // end while
------------------------------------------------------------------ esemplification
	// Fig. 21.7: fig21_07.cpp
	// Demonstrating string member functions erase and replace.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   // compiler concatenates all parts into one string
	   string string1( "The values in any left subtree"
	      "\nare less than the value in the"
	      "\nparent node and the values in"
	      "\nany right subtree are greater"
	      "\nthan the value in the parent node" );
	   
	   cout << "Original string:\n" << string1 << endl << endl;
	
	   // remove all characters from (and including) location 62 
	   // through the end of string1
	   string1.erase( 62 );
	
	   // output new string
	   cout << "Original string after erase:\n" << string1
	      << "\nAfter first replacement:\n";
	             
	   size_t position = string1.find( " " ); // find first space
	
	   // replace all spaces with period
	   while ( position != string::npos ) 
	   {
	      string1.replace( position, 1, "." );
	      position = string1.find( " ", position + 1 );
	   } // end while
	    
	   cout << string1 << "\nAfter second replacement:\n";
	   
	   position = string1.find( "." ); // find first period
	
	   // replace all periods with two semicolons
	   // NOTE: this will overwrite characters
	   while ( position != string::npos )
	   {
	      string1.replace( position, 2, "xxxxx;;yyy", 5, 2 );
	      position = string1.find( ".", position + 1 );
	   } // end while
	
	   cout << string1 << endl;
	} // end main

OUTPUT 
Original string:
The values in any left subtree
are less than the value in the
parent node and the values in
any right subtree are greater
than the value in the parent node

Original string after erase:
The values in any left subtree
are less than the value in the

After first replacement:
The.values.in.any.left.subtree
are.less.than.the.value.in.the

After second replacement:
The;;alues;;n;;ny;;eft;;ubtree
are;;ess;;han;;he;;alue;;n;;he
------------------------------------------------------------
>> INSERT CHARACTERS INTO A STRING [pag863 deitel]

Example : [/home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_08/]
The program declares initializes hen outputs strings string1, string2, string3, string4. Then uses function insert to insert string2's content before element 10 of string 1
	string1.insert( 10, string2 );
The line 
	string3.insert( 3, string4, 0, string::npos );
uses insert to insert string2 before string3's element 3. The last two argument specify the starting and last element of string4 that should be inserted. Using string::pos causes the entire string to be inserted. 
Ecco il programma completo:
	// Fig. 21.8: fig21_08.cpp
	// Demonstrating class string insert member functions.
	#include <iostream>
	#include <string>
	using namespace std;
	
	int main()
	{
	   string string1( "beginning end" );
	   string string2( "middle " );
	   string string3( "12345678" );
	   string string4( "xx" );
	
	   cout << "Initial strings:\nstring1: " << string1
	      << "\nstring2: " << string2 << "\nstring3: " << string3
	      << "\nstring4: " << string4 << "\n\n";
	
	   // insert "middle" at location 10 in string1
	   string1.insert( 10, string2 );
	
	   // insert "xx" at location 3 in string3
	   string3.insert( 3, string4, 0, string::npos );
	
	   cout << "Strings after insert:\nstring1: " << string1
	      << "\nstring2: " << string2 << "\nstring3: " << string3
	      << "\nstring4: " << string4 << endl;
	} // end main
OUTPUT --;------------
	Initial strings:
	string1: beginning end
	string2: middle
	string3: 12345678
	string4: xx
	
	Strings after insert:
	string1: beginning middle end
	string2: middle
	string3: 123xx45678
	string4: xx
------------------------------------------------------------------
>> pointer based string conversion /  from string to pointer based string. [deitel pag864]
------------------------------------------------------------------
>> ITERATORS [pag865 deitel]
Class string provides iterators  for forward and backward traversal of strings. Iterators provide access to individual characters with a syntax that's similar to pointer operations. Iterators are not range checked.
Example /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_10/
-------------------------------------------- start example
#include <iostream>
#include <string>
using namespace std;

int main()
{
   string string1( "Testing iterators" );
   string::const_iterator iterator1 = string1.begin();

   cout << "string1 = " << string1
      << "\n(Using iterator iterator1) string1 is: ";

   // iterate through string
   while ( iterator1 != string1.end() ) 
   {
      cout << *iterator1; // dereference iterator to get char [note: each element is printed by dereferencing the iterator much as you'd dereference a pointer, and the iterator is advanced one position using operator ++]
      ++iterator1; // advance iterator to next char
   } // end while

   cout << endl;
} // end main
------------------------------------------- end example
NOTE : from C++ 11 the lines 
   while ( iterator1 != string1.end() ) 
   {
      cout << *iterator1; // dereference iterator to get char
      ++iterator1; // advance iterator to next char
   } // end while
possono essere sostituite con il piu' compatto
	for (char c : string1 )
		cout << c;
Class string provides member functions >> rend and >> rbegin for accessing individual string chracters in reverse from the end of a string toward the beginning. Member functions rend and rbegin return >> reverse_iterators or >> const_reverse_iterators (based on whether the string is non-const or const). 
NOTE2 : when the operations involving the iterator should not modify the data being processed, use a const_iterator. This is another example of emplying the principle of lest privilege. 
----------------------------------------------------------------------
.......................................
>> STRING STREAM PROCESSING [pag867 deitel]
In addition to standard stream I/O and file stream I/O, C++ stream I/O includes capabilities for inputting from, and outputting to, strings in memory. Theses capabiliteis often are referred to as >> in memory I/O or >> string stream processing.
	- Input from a string is supported by class >> istringstream
NOTE: an isctrings stream object inputs data from a string in memory to program variables. Data is sotred in an sitringstream object as characters. Input from the istringsstrem object works identicallyy to input from any file. The end of the string is interpreted by the istringstream object as end-of-file. see example /home/dia/Documents/Deitel-CppWebResources/Code_Examples/ch21/fig21_12/ [riportato anche poco qui sotto]
	- Output from a string is supported by class >> ostringstream
see example + nostre note pag 868 deitel
 Class templates basic_istringstream and basic_ostringstream provide the same functionality as classes istream and ostream plus other member functions specific to >> in memory formatting. Programs that use in memory formatting must include the <sstream> and <iostream> headers.
	One application of these techniques is >> data validation. A program can read an entire line at a time from the input stream into a string. Next, a validation routine can scrutinize the contents of the string and correct (or repair) the data, if necessary. Then the program can proceed to input from the string, knowing that the input data is in the proper format.
	To asist wth data validation, C++ 11 prvides powerful regular expression capabilities. For example, if a program requires a user to enter a Japanese format telephone number (e.g. (080) 2689-0127), you can use a regular expression patter to confirm that the user's input matches the expected format. Many website provdie reular expressions for validating email addresses, URLSs, phone numbers, addresses and other popular kinds of data. 
	Outputting to a string is a nice way to take advantage of the powerful output formatting capabilities of C++ streams. Data can be prepared in a string to mimic the edited screen format. That string could be written to a disk file to preserve the screen image.
--------------------------------------
#include <iostream>
#include <string>
#include <sstream> // header for string stream processing
using namespace std;

int main()
{
   ostringstream outputString; // create ostringstream instance

   string string1( "Output of several data types " );
   string string2( "to an ostringstream object:" );
   string string3( "\n        double: " );
   string string4( "\n           int: " );
   string string5( "\naddress of int: " );

   double double1 = 123.4567;
   int integer = 22;

   // output strings, double and int to ostringstream outputString         
   outputString << string1 << string2 << string3 << double1  
      << string4 << integer << string5 << &integer;

   // call str to obtain string contents of the ostringstream
   cout << "outputString contains:\n" << outputString.str();

   // add additional characters and call str to output string
   outputString << "\nmore characters added";
   cout << "\n\nafter additional stream insertions,\n"
      << "outputString contains:\n" << outputString.str() << endl;
} // end main
////////////////////////////////////////////////////////////////////////////////
--------------------------------------------------------- istringstream EXAMPLE
int main()
{
   string input( "Input test 123 4.7 A" );   // the string input contains the data Input test 123 4.7 A which when read as input to the program, consist of two string ("Input" and "test"), and int (123), a double(4.7) and a char ('A'). These characters are extracted to variables string1, string2, integer, double1 and character in line @STARTag@
   istringstream inputString( input );
   string string1;
   string string2;
   int integer;
   double double1;
   char character;

   inputString >> string1 >> string2 >> integer >> double1 >> character;   // @STARTag@

// quindi the data is output in the following 4 lines:
   cout << "The following items were extracted\n"
      << "from the istringstream object:" << "\nstring: " << string1
      << "\nstring: " << string2 << "\n   int: " << integer
      << "\ndouble: " << double1 << "\n  char: " << character;

   // attempt to read from empty stream
   long value;
   inputString >> value;

   // test stream results        // interessante this if condition uses function "good" to test if any data remains. Because no data remains, the function returns false and the part of the if...else statement is executed.
   if ( inputString.good() )
      cout << "\n\nlong value is: " << value << endl;
   else
      cout << "\n\ninputString is empty" << endl;
} // end main
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> STRUCTURED PROGRAMMING SUMMARY / >> STRUCTURED PROGRAMS
pag 186deitel
Rules for forming structured programs
1) begin with the "simplest activity diagram"
2) any action state can be replaced by two action states in sequence [stacking rule cioe' connetti control statement in sequence]
3) any action state can be replaced by any control statement (sequence, if, if...else, switch, while, do...while or for) [nesting rule]
4) rules 2 and 3 can be applied as often as you like and in any order.
----------------------------------------------------------------------
The beauty of the structured programs is that we use only SEVEN simple single-entry/single-exit control statement 
(1 sequence 
2 if        |
3 if...else |  ---> selection
4 switch    |
5 while        |
6 do...while   |   ---> repetition
7 for)         |
and assemble them in only TWO simple ways (stacking or nesting)
Possiamo semplificare ancora di piu'
It is straightforward to proof that the 
	if statement is sufficient to provide any form of selection : qualunque selection done with if else e switch puo' essere implementata (anche se non in maniera ugualmente chiara ed efficiente) combining if statements
	any repetition puo' essere implementata usando una combinazione di cicli while (anche se non sempre cosi' smoothly)
in conclusione (gli spartani lo avrebbero adorato un linguaggio del genere!) any form of control ever needed in C++ program can be expressed in terms of the following:
- sequence
- if statement (selection)
- while statement (repetition)
and that these control statement can be combined in only two ways: stacking and nesting.


>> SU [this is just an UBIK tag per sorvolare la lunga serie di >> ST]

>> SUBTITUTE CHARACTER IN STRING
[pag438 deitel]
?@?@?@s1 = string ("happy birthday to you"); 
   // test using overloaded subscript operator to create lvalue
   s1[ 0 ] = 'H';      
   s1[ 6 ] = 'B';
   cout << "\ns1 after s1[0] = 'H' and s1[6] = 'B' is: "
      << s1 << "\n\n";
Donera in output:
	s1 after s1[0] = 'H' and s1[6] = 'B' is: Happy Birthday to you
in effetti se conti la posizione dei primi sei caratteri della stringa s1 [NOTE: si conta a partire da zero!!!]
	0123456
	happy birthday
quindi si comprende perche' s1[0] = 'H' fara' diventare la h maiuscola e s1[6] = 'B' fara' diventare la B maiuscola.
ATTENTION! ACHTUNG! 
Class string's overloaded [] operator does not perform any bounds checking. Therefore, you must ensure that operations using standard class "string's" overload [] operator do not accidentally manupulate elements outside the bounds of the string.
//////////////////////////////////////////////////////////////////////////////////

>> substr
[pag95 deitel, exampio pratico in pag94deitel + pag 435 deitel] [also pag 90 moo book]
substr (short for substring) is a member function of the standard class string. It returns a new string object created by copying part of an existing string object. 
Example 
	 nomeAbbreviato = name.substr( 0 , 25 );
this call passes to integers (0 and 25) to "name" 's member function substr. The first argument specifies the starting position in the original string from which characters are copied (the first character in every string is considered to be at position 0). The second argument specifes the number of characters to copy. Therefore 
	name.substr( 0 , 25 );
returns a 25-character substring of "name" starting at position 0 (that is, the first 25 characters).
Example pag435
/home/dia/Deitel-Code_Examples/ch10/fig10_01/fig10_01.cpp
line 47
   // test string member function substr
   cout << "The substring of s1 starting at location 0 for\n"
      << "14 characters, s1.substr(0, 14), is:\n"
      << s1.substr( 0, 14 ) << "\n\n";
the previous line gives a 14 character substring (specified by the second argument "14") of s1 starting from position 0 (specified by the first argument)
line 54
   // test substr "to-end-of-string" option
   cout << "The substring of s1 starting at\n"
      << "location 15, s1.substr(15), is:\n"
      << s1.substr( 15 ) << endl; 
NOTE: when the second argument is not specified (come nella riga precedente) substr return the remainder of the string on which it's called. Cioe' detto in parole spicciole s1.substr( 15 ) gives a substring starting from position 15 of s1.
///////////////////////////////////////////////////////////////////

>> SUM ELEMENTS ARRAY / OPERATION on ARRAY ELEMENTS / SUM ARRAY ELEMENTS
[pag280deitel]
To print the sum of the values contained in the first three elements of array c, we'd write:
	cout << c[ 0 ] + c[ 1 ] + c[ 2 ] << endl;
To divide the value of c[6] by 2 and assign the result to the variable x, we would write 
	x = c[ 6 ] / 2;

>> SWITCH MULTIPLE SELECTION STATEMENT[mike pag48]
The generic form of the switch statement is :
switch (choice)
{
	case value1:
		statement1;
		break;
	case value2:
		statement2;
		break;
	case value3:
		statement3;
		break;
         .
         .
         .
	case valueN:
		statementN;
		break;
	default:
		statementN+1;
}
////////////////////
The statement tests choice against the possible values (value1, value2, and value3) in order. If choice is equal to a value, then the program executes the corresponding statement. When the program hits a break statement, its exist the switch structure. If choice doesn't match any value, then the statement associated with the optional default is executed.
The use of break and default are optional. If you leave out a break, however, the program will continue through the remaining statements until it hits a break or a default or until the switch statement ends. Usually you want to break statement to end each case.
NOTE1: although a default case isn't required, it's usually a good idea to have one as a cathall.
NOTE2: (idea to test) penso che questo possa essere un buon strumento di >> DEBUG. quando per esempio in FOAM la compilazione viene ma poi il test case arresta l'esecuzione senza nessun messaggio chiaro, possiamo usare i nostri strumenti Info<< and accerchiare la porzione di programma che pare essere l'origine dell'eccezione in modo da catchare l'eccezione e cercare di ottenere qualche ulteriore informazione sul tipo di crash.
Here's an example to cement the ideas. Suppose choice is equal to value2. The program will first test choice against value1. Because they're not equal, the program will continue. Next, the program will test choice against value2. Because they are equal, the program will execute statement2. Then the program will hit the break statement an exit the switch structure.
NOTE3: you can use the switch statement only to test an int (or a value that can be treated as an int, such as a char or an enumerator). A switch statement won't work with any other type.
Example : menu chooser program presents the user with a menu that lists three difficulty levels and asks him to make a choice. If the user enters a number that correponds to a listed choice, then he is shown a message confirming the choice. If the user makes some other choice, he is told the choice is invalid [gia' questa tipologia di programma quante volte che sara' stato utilizzato all'interno di macchinette ATM and company!].
Example :
///
// Menu Chooser
// Demonstrates the switch statement

#include <iostream>
using namespace std;

int main() 
{
	cout << "Difficulty Levels\n\n";
	cout << "1 - Easy\n";
	cout << "2 - Normal\n";
	cout << "3 - Hard\n\n";

	int choice;
	cout << "Choice: ";
	cin >> choice;

	switch (choice)
	{
		case 1:	
			cout << "You picked Easy.\n";
			break;
		case 2:	
			cout << "You picked Normal.\n";
			break;
		case 3:	
			cout << "You picked Hard.\n";
			break;
		default:
			cout << "You made an illegal choice.\n";
	}

    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////
-------------------------------------------------------
[pag169deitel]
esempio pratico pag172deitel
Observations from pag 174deitel
1) ...
switch ( expression )  // this is called the controlling expression.
{
2) the "switch" statement compares the value of the controlling expression with each case label.
3) the "break" statement causes program control to proceed with the first statement after the switch.
4) without break statements, each time a match occurs in the switch, the statements for that case and subsequent cases execute until a break statement or the end of the switch is encountered. 
5) switch UML activity diagram pag177deitel 
///////////////////////////////////////////////////////////////////////////////////


>> SWAP / >> algorithm swap / >> iter_swap / >> swap_ranges 
[pag710 deitel]
swap, iter_swap and swap_ranges are used for swapping elements
EXAMPLE /home/dia/Deitel-Code_Examples/ch16/fig16_07/fig16_07.cpp
output of the program:
	Array a contains:
	   1 2 3 4 5 6 7 8 9 10
	Array a after swapping a[0] and a[1] using swap:
	   2 1 3 4 5 6 7 8 9 10
	Array a after swapping a[0] and a[1] using iter_swap:
	   1 2 3 4 5 6 7 8 9 10
	Array a after swapping the first five elements
	with the last five elements:
	   6 7 8 9 10 1 2 3 4 5
>> swap algorithm 
	 18    swap( a[ 0 ], a[ 1 ] ); // swap elements at locations 0 and 1 of a
line18 uses the swap algorithm to exchange two values. In this example, the first and second elements of array "a" are exchanged. The function takes as arguments references to the two values being exchanged.
>> iter_swap algorithm 
	 23    // use iterators to swap elements at locations 0 and 1 of array a
	 24    iter_swap( a.begin(), a.begin() + 1 ); // swap with iterators 
line24 uses function iter_swap to exchange the two elements. The function takes two forward iterator arguments (in this case, iterators to elements of an array) and exchanges the values in the elements to which the iterators refer.
>> swap_ranges algorithm 
[pag711 deitel]
	 28    // swap elements in first five elements of array a with
	 29    // elements in last five elements of array a 
	 30    swap_ranges( a.begin(), a.begin() + 5, a.begin() + 5 );
line30 uses function swap_ranges to exchange the elements from a.begin() up to, but not including a.begin()+5?@with the elements beginning at position a.begin()+5.
Il risultato (vedi output riportato sopra) e' che nel vettore di 10 elementi dell'esempio sopra, i primi cinque elementi del vettore diventano gli ultimi 5, e gli ultimi cinque diventano i primi cinque.
The first two arguments specify the range of elements in the first sequence that will be exchanged with the elements in the second sequence starting from the iterator in the third argument.
In this example, the two sequences of values are in the same array, but the sequences can be from different arrays or containers. 
The sequences must not overlap. The destination sequence must be large enough to contain all the elements of the ranges being swapped.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TTTTTTT

>> TEMPLATES [pag 660 jesse]
A powerful tool for C++ programmers is "parametrized types" or templates. Templates are so useful that a library containing a number of routing using templates has been adopted into the definition of the C++ language. 
In this lesson you will learn: 
	- what a template is and how templates can be used
	- how to create class templates
	- how to create function templates 
	- what the Standard Template Library (STL) is and how to use some of the templates within it. 
Templates are useful when you want to create a family of related classes, whose only difference is the type of the thing that they operate on; so that you can have only one place to make changes to that class so that your maintenance effor can be kept low. Although templates were not a part of the original C++ language, they are now a part of the standard and an integral  part of the language. Like all of C++ , they are type-safe and very flexible. They can, however, be intimidating to the newer C++ programmer. After you understand them, however, you will see that they are a powerful feature of the language.
Templates enable you to create a class that can have the type of the things it works on be changed. For example, you can use them to  show the compiler how to make a list of any type of thing, rather than creating a set of type-specific lists. With templates, the type of the thing on the list becomes a parameter to the definition of the class. You can create a family of classes from the template, each of which is set up to work on a different type of thing. 
A common component of virtually all C++ libraries is an array class. You know it would be tedious and inefficient to create one array class for integers, another for doubles, and yet another for an array of Animals. Templates let you declare a single, parametrized array class. You can then specify the type that the object will be for each instance of the array. Although the Standard Template Library provides a standardized set of container classes, including arrays, and so forth, the best way to learn about templates is to create your own! In the next few sections, you'll explore what it takes to write your template class so that you fully understand how templates work. In a commercial program, however, you wuold almost certainly use teh STL classes for this purpose rather than creating your own. On the other hand, you will want to create templates for your own applications and leverage this powerful capability. 
>> INSTANTIATION is the act of creating a specific type from a template. The individual classes are called instances of the template.
>> INSTANCES TEMPLATE vs INSTANCES OBJECTS [pag661 jesse] Instances of template are distinct from instances of objects created using the template. Most commonly, "instantiation" is used to refer to creating an instance (object) from a class. Be certain to be clear about the context when using or reading the word "instantiation". 
>> Parameterized templates provide you with the ability to create a general class and pass types as parameters to that class to build specific instances. Before you can instantiate a template, however, you need to define one. 
----------------------------------------------------------------------------------------------------------------------------------------------------------
>> TEMPLATE DEFINITION BUILDING  / >> BUILDING TEMPLATE DEFINITION [pag661 jesse] 
You begin the basic declaration of a template using the template keyword followed by a parameter for the type. The format of this is : 
	template <class T>
In this case, "template" and "class" are keywords that you use. T is a placeholder, like a variable name. As such, it can be  any name you desire; however, either T or Type is generally used. The value of T will be a data type. 
[>> typename] Because the keyword "class" can be confusing whe used in this context, you can alternatively use the keyword "typename":
	template <typename T>
In today's lesson, you will see the keyword "class" used because it is what you will see more oftein in programs that have already been created. The keyword "typename", however, is clearer at indicating what you are defining when the parameter is a primitive type rather than a class. 
Going back to the example of your own array list, you can use the template statement to declare a parametrized type for the Array class; you can use this to create a template for an array as shown here:
	template <class T>   // declare the template and teh parameter
	class Array   // the class being parametrized
	{
		public:
			Array();
		// full class declaration here 
	};
This code is the basics for declaring a template class called Array. The keyword template is used at the beginning of every declaration and definition of a "template" class. Like with functions, the parameters are the things that will change with each instance. In the array template being created in the preceding example, you want the type of the objects stored in the array to be changeable. One instance might store an array of integers and another might store an array of Animals. 
In this example, the keyword class is used, followed by the identifier T. As stated before the keyword "class" indicates that this parameter is a type. The identifier T is used throughout the rest of the template definition to refer to the parameterized type. Because this class is now a template, one instance could substitute "int" for "T" and one could substitute the type "Cat". If written correctly, the template should be able to accept any valid data type (or class) as the value for T. 
You set the type for your template when you declare a variable that will be an instance of it. This can be done using the following format: 
	className<type> instance;
In this case, className is the name of your template class. "instance" is the name of the instance, or object, you are creating. "type" is the data type you want to use for  the instance you are creating. 
For example, to declare an "int" and an "Animals" instance of the parameterized Array class, you would write: 
	Array<int> anIntArray;
	Array<Animal> anAnimalArray;
The object "anIntArray" is of the type array of integers; the object anAnimalArray is of the type "array of Animals".  You can now use the type Array<int> anywhere you would normally use a type (as the return value from a function, as a parameter to a function, an so forth  - cioe' puoi utilizzare Array<int> nello stesso modo e posizioni in cui utilizzi per esempio il type "int" ). The following Listing 19.1 provides the full declaration of the stripped down Array template. Be aware that this isn't a complete program, rather a listing focused on how the template is defined. 
--------------------------------------------------------------------------------------------------------------------------- Listing 19.1 starts
	//Listing 19.1 A template of an array class
	#include <iostream>
	using namespace std;
	const int DefaultSize = 10;

	template <class T>  // declare the template and the parameter; alternativamente avresti anche potuto scrivere "template <typename T>"
	// you should use whichever word is clearer for you, although it is recommended to use class when the type is class and typename when it is not a class. 
	class Array            // the class being parameterized
	{                            // from here until the end of the template, the rest of the declaration is like any other class declaration. The only difference is that wherever the type of the object would normally appear , the identifier T is used instead. 
	  public:
		 // constructors
		Array(int itsSize = DefaultSize);
		Array(const Array &rhs);
		~Array() { delete [] pType; }
	  
		// operators
		Array& operator=(const Array&);
		T& operator[](int offSet) { return pType[offSet]; } 
		// accessors
		int getSize() { return itsSize; }
	  
	  private:
		T *pType;
		int  itsSize;
	};
--------------------------------------------------------------------------------------------------------------------------- Listing 19.1 ends
There is no output, because this is not a complete program. Rather, this is the definition of a scaled-down template.
About the line 
		T& operator[](int offSet) { return pType[offSet]; }  
Qui tocchi con mano il vantaggio del template. Se fosse stata una normal class operator[] would be expected to return a reference to an object in the array, here, being a template it is declared to return a reference to T, in questo modo e' piu' generale, non vincoli la tipologia di dati su cui operi. Per esempio when an instance of an integer array is defined, T is replaced with an integer, so the "operator=" that is provided  to that array returns a reference to an integer. This is equivalent to the following:
	int& operator[](int offSet) { return pType[offSet]; } 
When an instance of an Animal array is declared, the operator = provided to the Animal array returns a reference to an Animal:
	Animal& operator[](int offSet) { return pType[offSet]; } 
In a way, this is very much like how a macro works, and, in fact, templates were created to reduce the need for macros in C++.
USING the name 
Within the class declaration, the word Array can be used without further qualification. Elsewhere in the program, this class is referred to as Array<T>. For example, if you do not write the constructor within the class declaration, then when you declare this function, you must write: 
	template <class T>  // because this is part of a template, the declaration on this first line of this code fragment is required to identify the type for the function (class T). 
	Array<T>::Array(int size): // in this line you see that the template name is Array<T> and the function name is "Array(int size)" . In addition you see that the function takes an integer parameter.
	itsSize = size // the remainder of the function (il resto della funzione) is the same as it would be for a nontemplate function, except that anywhere the array type would be used, the parameter T is used.   
	{
		pType = new T[size]; // instead of using the array type the parameter T is used. 
		for (int i = 0; i < size; i++)
		pType[i] = 0;
	}
---------------------------------------------------------------------------------------------------------------------------
TIP :  It is a commond and preferred method to get the class and its functions working as a simple declaration before turning into a template. This simplifies development, allowing you first to concentrate on the programming objective, and then later to generalize the solution with templates. 
Also you must define templates functions in the file where the template is declared. Unlike other classes, where the declaration of a class and its member functions and the necessary member function definitons can be split between a header and a .cpp file, templates require both to be in either a header or .cpp file. If you are sharing the template with other parts of your project, it is common to either define the member function inline to the template class declaration, or to define them below the class declaration in the header file. 
---------------------------------------------------------------------------------------------------------------------------
>> TEMPLATE IMPLEMENTATION / >> IMPLEMENTATION TEMPLATE [pag665 jesse]
After you hav a template defined, you'll want to use it. The full implementation of the Array template class requires implementation of the copy constructor, operator=, and so forth. The Listing 19.2 (SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1902.cpp) provides the code for your Array template as well as a simple driver program that uses the template. 
In this program an Array template is defined 
	template <class T>  // declare the template and the parameter
	class Array            // the class being parameterized
	{
    [...]
and then used to instantiate to "Array" objects of types int and Animal : 
	   Array<int> theArray;      // an array of integers
	   Array<Animal> theZoo;     // an array of Animals
NOTE about line 53 e seguenti :

	// implementations follow...

	// implement the Constructor
	template <class T>   // line 54
	Array<T>::Array(int size):  // line 55
	itsSize(size)  // line 56
	{
	pType = new T[size]; // line 58
	// the constructors of the type you are creating
	// should set a default value
	}

In these lines you can see the code for the implementation of some of the member functions from your template class. Because these are defined outside of the primary class definition, you must once again state that these are part of the template. You do this with the same statement "template <class T>" you placed before the class. You also indicate that the Array is a template class by then including the type parameter after the class name. You have declared your type parameter to be T on line 54 (see estratto di codice above) so for the Array class, you use Array<T> with your member functions. You see this on line 55. Within the member function, you can then use the T parameter anywhere you would have ordinarily used the type of the array. For example, on line 58 the class' pointer, pType, is set to point to a new array of items (pType = new T[size]; ). The items will be of type T, which is the type you declare when instantiating an object with this template class. When each item of a given type is created, its construction should initialize it.
Your Array template class is actually used on line 90 
	Array<int> theArray;      // here it is used to instantiate an object called theArray that uses the template with ints.
and line 91
	Array<Animal> theZoo;     // the Zoo is instantiated to be an Array of type Animal. 
--------------------------------------------------------------------------------------------------
>> PASS INSTANTIATED TEMPLATE OBJECTS TO FUNCTIONS / >> TEMPLATE OBJECT PASS TO FUNCTIONS [pag 669 jesse]
If you want to pass an Array object to a normal function, you must pass a particular instance of the array, not a template. To create a function that can receive a specific instance of an Array, you declare the type as follows: 
	void SomeFunction(Array<theType>&);
where "SomeFunction" is the name of the function you are passing the "Array" object to, and "theType" is the type of the object you are creating. Therefore, if SomeFunction() takes an integer array as a parameter, you can write 
	void SomeFunction(Array<int>&);   // OK!
but you cannot write 
	void SomeFunction(Array<T>&);   // error!
because there is no way to know what a T& is. You also cannot write
	void SomeFunction(Array &);    // error!
because there is no class "Array", only the template and the instances. 
To create nonmember functions that have some of the advantages of templates, you can declare a >> template function. This is accomplished in a similar manner to declaring a template class and defining a template member function: First you indicate that your function is a template, and then you use the template parameter where you otherwise would have used a type or class name: 
	template <class T>   // dichiari una template class in modo da indicare che la funzione e' un template
	void MyTemplateFunction(Array<T>&);   // definisci a template member function in cui utilizzi the template parameter la' dove in a normal function avresti usato un type
In this example the function MyTemplateFunction() is declared to be a template function by the declaration on the top line. Note that template functions can have any name, the same as other functions can. 
Template functions can also take instances of the template in addition to the parametrized form. The following is an example 
	template <class T>
	void MyTemplateFunction(Array<T>&, Array<int>&);  // OK 
where 
	Array<T> is an example of >> parametrized array, in cui cio' non scrivi espressamente il type, utilizzi il generico parametro/typename T 
	Array<int> is an array of interger, example of "istance of the template"
Note that this function takes two arrays: a parametrized array and an array of integers. The former (= parametrized array) can be an array of any object, but the latter is always an array of integers. A little bit later in thi lesson, you will see a template function in action.  
---------------------------------------------------------------------------------------------------------------------------------------------------------
>> FRIENDS TEMPLATE / >> TEMPLATES and FRIENDS [pag670 jesse]
You learned about friend on lesson16 "Advanced inheritance". Template classes can declare three types of friends:
	- a non template friend class or function 
	- a general template friend class or function 
	- a type-specific template friend class or function 
The following sections cover the first two of these. 
>> Nontemplate friend classes and functions [pag670 jesse]
It is possible to declare any class or function to be a friend to your template class. Each instance of the class willl treat the friend properly, as if the declaration of friendship had been made in that particular instance. 
The Listing
SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1903.cpp
adds a trivial friend function Intrude(), to the template definition of the Array class. The driver program then invokes Intrude.
Because Intrude() is a friend, it can then access the private data of the Array. Because Intrude() is not a template function, it can only be passed Arrays of type int.
Potrai notare nel codice all'interno della Class Array  le righe 47-48 
	class Array 
	{
	    // friend function  
	    friend void Intrude(Array<int>);  // line 48 : with this line we declare that every instance of an int Array considers Intrude() to be a friend function. Thus, Intrude() has access to the private member data and functions of the Array instance. 
	[...]
	}
	// friend function. Not a template, can only be used
	// with int arrays! Intrudes into private data.
	void Intrude(Array<int> theArray)         
	{
   cout << endl << "*** Intrude ***" << endl; // in these lines we define the Intrude() function. 
   for (int i = 0; i < theArray.itsSize; i++)  // you can see that Intrude() can access itsSize directly
      cout << "i: " <<    theArray.pType[i] << endl;
   cout << endl;
	}
-----------------------------------------------------------------------------------------------------------------------------
>> GENERAL TEMPLATE FRIEND CLASS or FUNCTION  / >> TEMPLATE FRIEND CLASS [pag674 jesse]
It would be helpful to add a display operator to the Array class so that values could be sent to an output steam and treated appropriately based on their type. One approach is to declare a display operator for each possible type of Array, but this undermines the whole point of having made Array a template. 
What is needed is an insertion operator that works for any possible type of Array: 
	ostream& operator<< (ostream&, Array<T>&);
To make this work, operator<< needs to be declared to be a template function: 
	template <class T>
	ostream& operator<< (ostream&, Array<T>&);
Now that operator<< is a template function, you need only to provide an implementation. The listing 
SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1904.cpp	 
shows the Array template extended to include this declaration and provides the implementation for the operator<<
Punti notevoli del programma: 
    template <class T> // line 42
    friend ostream& operator<< (ostream&, Array<T>&); // line 43
On line 43 the function template operator<< () is declared to be a friend of the Array class template. Because operator<<() is implemented as a template function, every instance of this parameterized array type automatically has an operator<<().
The implementation for this operator starts on line 50.
	template <class T>   // line 50
	ostream& operator<< (ostream& output, Array<T>& theArray)
	{
	   for (int i = 0; i < theArray.itsSize; i++) // using a simple loop every member of an array is called in turn. 
	   {
		  output << "[" << i << "] " << theArray[i] << endl;
	   }
	   return output;
	}
----------------------------------------------------------------
>> TEMPLATE ITEMS  / >> using template items / >> TEMPLATE OBJECT PASSING TO and FROM functions / >> pass template objects to and from functions [jesse pag678]
You can treat template items as you would any other type. You can pass them as parameters, either by reference or by value, and you can return them as the return values of functions, also by value or by reference. The Listing 
SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1905.cpp
demonstrates how to pass template objects. 
Punti notevoli del programma 
- All'interno della Animal class abbiamo la linea 
	friend ostream& operator<< (ostream&, const Animal&); 
in modo che la Animal class has its own insertion operator to allow the printing of Animals. 
The definition of this insertion operator is on line 27-32 and it simply prints the current weight of the Animal : 
	// extraction operator for printing animals
	ostream& operator<<    // line 27
	(ostream& theStream, const Animal& theAnimal)
	{
	   theStream << theAnimal.GetWeight();
	   return theStream;
	}   // line 32
[...]
void IntFillFunction(Array<int>& theArray); // line 103 : the function IntFillFunction()  is declared. The prototype indicates that this function takes an integer Array. Note that this is not a template function. IntFillFunction() expects only one type of an Array, an integer array.
- in the lines 34-50 trovi le implementation dei constructors e deconstructors di "Animal"
	Animal::Animal(int weight):
	itsWeight(weight)
	{
	   // cout << "Animal(int)" << endl;
	}
	Animal::Animal():
	itsWeight(0)
	{
	   // cout << "Animal()" << endl;
	}
	Animal::~Animal()
	{
	   // cout << "Destroyed an animal..." << endl;
	}
If you uncomment those "// cout" lines so that you can print the statements in each of the contructors and deconstructor, you'll find unanticipated extra constructions and destructions of Animals [ci abbiamo provato ma ottevamo un errore dal programma "List1905.cpp:67:15: error: declaration of ‘class T’" ]
When an object is added to an array, the object's default constructor is called. The Array constructor, however goes on to assign 0 to the value of each member of the array as shown in the lines 89 and 90 of the Listing 19.5:
	itsSize(size)
	{
	   pType = new T[size];
	   for (int i = 0; i < size; i++)
			pType[i] = 0; //line 90 mi riferisco al listato del libro, quello dei source code downloadati e' un tantino diverso.
	}
When you write someAnimal = (Animal) 0; , you call the default operator = for Animal. This causes a temporary Animal object to be created, using the constructor, which takes an integer (zero). That temporary is used as the right hand side of the operator= and then is destroyed.
This is an unfortunate waste of time because the Animal object was already properly initialized. However, you can't remove this line because integers are not automatically initialized to a value of 0. The solution is to teach the template not to use this constructor for Animals, but to use a special Animal constructor. 
You can provide an explicit implementation for the Animal class, as indicated in Listing 19.6. This type of specification is called >> specialization of the template [>> specialized function use/ using specialized functions].
SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1906.cpp
passaggi salienti:
On lines 75-82 the template behaviour of an Array constructor is declared:
[usiamo vi  and :set number per poter pastare insieme anche il numero delle righe]
	 75 template <class T>
	 76 Array<T>::Array(int size = DefaultSize):
	 77 itsSize(size)
	 78 {
	 79    pType = new T[size];
	 80    for (int i = 0; i < size; i++)
	 81       pType[i] = (T)0; 
	 82 } 
On lines 116-120 the specialized constructor for an Array of Animals is demonstrated. 
	116 Array<Animal>::Array(int AnimalArraySize):
	117 itsSize(AnimalArraySize)
	118 {
	119    pType = new Animal[AnimalArraySize];
	120 }
Note that in this special constructor, the default constructor is allowed to set the initial value for each Animal, and no explicit assignment is done.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> STATIC MEMBERS and TEMPLATES [pag689 jesse]
A template can declare static data members. A unique set of static data is created for each class type that can be created from the template. That is, if you add a static member to the Array class (for example, a counter of how many arrays have been created), you have one such member per type: one for all the arrays of Animals and another for all the arrays of integers. 
The listing 
SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1907.cpp
adds a static member and a static function to the Array class. 
Punti salienti del programma:
- in the Array class :
	 51 class Array          // the class being parameterized
	 52 {
	[...]
	 66     static int GetNumberArrays() { return itsNumberArrays; }
	 67     
	 68     // friend function
	 69     friend ostream& operator<< (ostream&, const Array<T>&);
	 70     
	 71   private:
	 72     T *pType;
	 73     int  itsSize;
	 74     static int itsNumberArrays;
	 75 }; 
you can notice that on line 74 the static variable itsNumberArrays has been added. And because this data is private, the static public access GetNumberArrays() was added on line 66.  
- Initialization of the statci data is accomplished with a full template quailifaction, as shown in lines 77 and 78. The constructors of Array and the destructor are each modified to keep track of how many arrays exist at any moment: 
	 77 template <class T>
	 78 int Array<T>::itsNumberArrays = 0;
- Accessing the static members is the same as accessing the static members of any class: you can do so with an existing object, as shown on lines 134 and 135:
	134    cout << Array<int>::GetNumberArrays() << " integer arrays\n";
	135    cout << Array<Animal>::GetNumberArrays();
or by using the full class specification, as shonw on lines 128 and 129:
	128    cout << intArray.GetNumberArrays() << " integer arrays\n";
	129    cout << animalArray.GetNumberArrays();
Note that you must use a specific type of array when accessing the static data. One variable exists for each type.
-------------------------------------------------------------------------------------------------------------------------------------
DO 
	- DO use templates whenever you have a concept that can operator across objects of different classes or across different primitive data types.
	- DO use the parameters to template functions to narrow their instances to be type-safe.
	- DO use statics with templates as needed. 
	- DO specialize template behviour by overriding template functions by type. 
DON'T
	- DON'T stop learning about templates. The present lesson has covered only some of what you can do with templates. Detailed coverage of templates is beyond the scope of this book. 
	- DON'T fret if you don't yet fully understand how to create your own templates. It is more immediately important to know how to use them. As you'll see in the next section, there are lots of existing templates for you to use in the STL.
----------------------------------------------------------------------------------------------------------------------------------------
>> STL / >> STANDARD TEMPLATE LIBRARY [pag693 jesse]
As it is said, there is no point in reinventing the wheel. The same is true in creating programs with C++. This is why the Standard Template Library (STL) became popular. As with other components of the Standard C++ Library, the STL is portable between various operating system. 
All the major compiler vendors now offer the STL as part of their compilers. The STL is a library of template-based container classes, including vectors, lists, queues, and stacks. The STL also includes a number of common algorithms, including sorting and searching. 
The goal of the STL is to give you an alternative to reinventing the wheel for these common requirements. The STL is tested and debugged, offers high performance and is free. Most important, the STL is reusable; after you understand how to use an STL container, you can use it in all your programs without reinventing it.
>> USING CONTAINERS / >> CONTAINERS [pag693 jesse]
A container is an object that holds other objects. The Standard C++ Library provides a series of container classes that are powerful tools that help C++ developers handle common programming tasks.
>> SEQUENCE containers vs >> ASSOCIATIVE containers [pag693 jesse]
Two types of Standard Template Library container classes are sequence and associative. Sequence containers are designed to provide sequential and random access to their members, or elements. Associative containers are optimized to access their elements by key values. All of the STL container classes are defined in namespace std. 
>> SEQUENCE CONTAINERS [pag694 jesse]
The standard Template Library sequence containers provide efficeint sequential access to a list of objects. The Standard C++ Library provides five sequence containers 
	1) vector 
	2) list
	3) stack 
	4) deque
	5) queue
>> VECTOR CONTAINER [pag694 jesse book]
You often use arrays to store and access a number of elements. Elements in an array are of the same type and are accessed with an index. The STL provides a container class "vector" that behaves like an array but that is more powerful and safer to use than the standard C++ array. 
A vector is a container optimized to provide fast access to its elements by an index. The container class "vector" is defined in the header file <vector> in namespace std. 
A vector can grow itself as necessary. Suppose that you have created a vector to contain 10 elements. After you have filled the vector with 10 objects, the vector is full. If you then add another object to the vector, the vector automatically increases its capacity so that it can accomodate the eleventh object.  Here is how the vector class is defined : 
	template <class T, class Allocator = allocator<T>> class vector 
	{
		// class members 
	}
The first argument "class T" is the type of the elements in the vector. 
The second argument "class Allocator" is an allocator class. >> ALLOCATORS are memory managers responsible for the memory allocation and deallocation of elements for the containers. The concept and implementation of allocators are advanced topics that are beyond the scope of this book. 
By default, elements are created using the operator new() and are freed using the operator delete(). That is, the default constructor of class T is called to created a new element. This provides another argument in favor of explicitly defining a default constructor for your own classes. If you do not, you cannot use the standard vector container to hold a set of instances of your class.
You can  define vectors that hold integers and floats as follows : 
	vector<int> vInts; // vector holding int elements 
	vector<float> vFloats; // vector holding float elements 
Usually, you would have some idea as to how many elements a vector will contain. For instance, suppose that in your school, the maximum number of students is 50. To create a vector of students in a class, you will want the vector to be large enough to contain 50 elements. The standard vector class provides a constructor that accepts the number of elements as its parameter. So, a vector of 50 students can be defined as follows:
	vector<Student> MathClass(50);
A compiler allocates enough memory spaces for 50 students; each element is created using the default constructor Student::Student(). 
The number of elements in a vector can be retrieved using a member function size(). For the Student vector MathClass that was just defined, Student.size() returns 50. 
- Another member function >> capacity() tells us exactly  how many elements a vector can accommodate before its size needs to be increased. You will see more on this later. 
- A vector is said to be empty if no element is in a vector; that is, the vector's size is zero. To make it easier to test whether a vector is empty, the vector class provides a member function empty() that evaluates to true if the vector is empty. 
- To assign a Student object Harry to the MathClass, the >> subscripting operator "[]" is used: 
	MathClass[5] = Harry;  // little Harry is here, Big Lebowsky
The subscript starts at 0. As you might have notived, the overloaded assignment operator of the Student class is used here to assign Harry to the sixth element in MathClass. Similarly, to find out Harry's age, access his record using:
	MathClass[5].GetAge();
As mentioned earlier, vectors can grow automatically when you add more elements than they can handle. For instance, suppose one class in your school has become so popular that the number of students exceeds 50. Well it might not happen to our math class, but who knows, strange things do happen. When the firty-first student, Sally, is added to the MathClass, the vector can expand to accommodate her. 
[>> ADD ELEMENT to vector ] You can add an element into a vector in several ways; one of  them is push_back():
	MathClass.push_back(Sally);
This member function appends the new Student object Sally to the end of the vector MathClass. Now, MathClass has 51 elements and Sally is palced at MathClass[50].
For this function to work, our Student class must define a copy constructor. Otherwise, this push_back() function will not be able to make a copy of object Sally. 
STL does not specify the maximum number of elements in a vendor; the compiler vendors are in better positions to make this decision. The vector class provides a member function that tells you what this magic number is in your compiler: 
	max_size()
The listing 
	SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1908.cpp
demonstrates the members of the vector class that have been discussed so far. You will see that the standard string class is used in this listing to simplify the handling of strings.
----------------------------------------------------------------------------------------
Punti salienti del programma: 
from line 115-128 you find the definition of the template function ShowVector() that demonstrates the usage of some of the vector member functions: max_size(), size(), capacity() and empty(). 
	116 template<class T>
	117 void ShowVector(const vector<T>& v)
	118 {
	119    cout << "max_size() = " << v.max_size();
	120    cout << "\tsize() = " << v.size();
	121    cout << "\tcapacity() = " << v.capacity();
	122    cout << "\t" << (v.empty()? "empty": "not empty");
	123    cout << endl;
	124 
	125    for (int i = 0; i < v.size(); ++i)
	126       cout << v[i] << endl;
	127 
	128    cout << endl;
	129 }
As you can see from the output below, the maximum number of Student objects a vector can accommodate is  1,152,921,504,606,846,975 in our gcc linux compiler (cioe' circa un miliardo di miliardo di oggetti).
On line 90 a vector of three Student objects is defined. Its size and capcity are both three.
	 90    SchoolClass GrowingClass(3);
	 91    cout << "GrowingClass(3):" << endl;
	 92    ShowVector(GrowingClass);
	 93    
	 94    GrowingClass[0] = Harry;
	 95    GrowingClass[1] = Sally;
	 96    GrowingClass[2] = Bill;
 Elements in the GrowingClass are assigned with the Student objects on lines 94-96 using the subscripting operator [].
The fourth student, Peter Parker, is added to the vector on line 100
	100    GrowingClass.push_back(Peter);
This increases the size of the vector to four. Interestingly, its capacity is now set to six. This means that the compiler has allocated enough space for up to six Student objects. Because vectors must be allocated to a continouous block of memory, expanding them requires a set of operations: 
1) First, a new block of memory large enough for all four Student objecst is allocated. 
2) Second, the three elements are copied to this newly allocated memory and the fourth element is appended after the third element. 
3) Finally, the original memory block is returned to memory. 
When a large number of elements are in a vector, this deallocation and reallocation process can be time-consuming. Therefore, the compiler employs an optimization strategy to reduce the possibility of such expensive operations. In this example, if you append one or two more objects to the vector, no need exists to deallocate and reallocate memory. 
----------------------------------------------------------------------------------------
OUTPUT 
	[1087 Day19] >> g++ -std=c++11 -o List1908.exe List1908.cpp 
	[1088 Day19] >> ./List1908.exe 
	EmptyClass:
	max_size() = 1152921504606846975	size() = 0	capacity() = 0	empty

	GrowingClass(3):
	max_size() = 1152921504606846975	size() = 3	capacity() = 3	not empty
	New Student is 16 years old
	New Student is 16 years old
	New Student is 16 years old

	GrowingClass(3) after assigning students:
	max_size() = 1152921504606846975	size() = 3	capacity() = 3	not empty
	New Student is 16 years old
	Sally is 15 years old
	Bill is 17 years old

	GrowingClass() after added 4th student:
	max_size() = 1152921504606846975	size() = 4	capacity() = 6	not empty
	New Student is 16 years old
	Sally is 15 years old
	Bill is 17 years old
	Peter is 16 years old

	GrowingClass() after Set
	:max_size() = 1152921504606846975	size() = 4	capacity() = 6	not empty
	Harry is 18 years old
	Sally is 15 years old
	Bill is 17 years old
	Peter is 16 years old 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DO 
	DO define a default constructor for for a class if its instances are likely to be held in a vector. 
	DO define a copy constructor for such a class
	DO define an overloaded assignment operator for such a class. 
DON'T
	DON'T create your own vector class! You can use the one in the STL. Because this is a part of the C++ standard, any standard compliant compiler should have this class! 
The vector container class has other member functions. For example 
>> front() function returns a reference to the first element in a list 
>> back() function returns a reference to the last element 
>> at() function works like the subscript operator []. It is safer than the vector implementation of [], because it checks whether the subscript passed to it is within the range of available elements (although , of course, you could code a subscript operator to perform the same check). If the index is out of range, it throws an out_of_range exception. 
>> insert() function inserts one or more nodes into a given position ina vector. 
>> pop_back() function removes the last element from a vector 
>> remove() function removes one or more elements from a vector.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> LIST CONTAINER [jesse book 701]
A list container designed to be optimal when you are  frequently inserting and deleting elements. The list STL container class is defined in the header file <list> in the namespace std. The "list" class is implemented as a doubly linked list, where each node has links to both the previous node and the next node in the list.   
The list class has all member functions provided by the vector class. You can traverse a list by following the links provided in each node. Typically, the links are implemented using pointers. The standard list container class uses a mechanism called the iterator for the same purpose. 
An >> iterator is a generalization of a pointer and attempts to avoid some of the dangers of a pointer. 
You can dereference an iterator to retrieve the node to which it points. The following listing 19.9 demonstrates the use of iterators in accessing nodes in a list: 
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <list> // so that we can use the list template
using namespace std;
  
typedef list<int> IntegerList; // We use the typedef command. In this case, instead of using list<int> throughout the listing, the typedef lets you use IntegerList. This is much  easier to read. (cioe' usiamo il typedef command in modo che al posto di dover scrivere "list<int>" all'interno del programma, possiamo scrivere IntegerList, piu' semplice e chiaro da leggere.)
  
int main()
{
   IntegerList   intList; // intList is defined as a list of integers using the typedef that was just created. 
  
   for (int i = 1; i <= 10; ++i)
      intList.push_back(i * 2);  // adding the first 10 even numbers (numeri pari) to the list using the push_back() function
  
   for (IntegerList::const_iterator ci = intList.begin(); //  each node of the list is accessed using a constant iterator "const_iterator ci". This indicates that there is no intent to change the nodes with this iterator. If you want to change a node pinted to be an iterator, you need to use a non-const iterator instead like "intList::iterator".  "intList.begin()" ni tsuite: the begin() member function returns an iterator pointing to the first node of the list.  
                      ci != intList.end();  // >> end() member function is kind of strange, it returns an iterator pointing to one pass last node of a list. You must be certain that your iterator doesn't reach end()! 
          ++ci)  
      cout << *ci << " "; // the iterator is derefenced the same as a pointer, to return the node pointed to.
 
   return 0;
}
--------------------------------------------------------------------------------------------------------------------
OUTPUT : 
[1091 Day19] >> g++ -std=c++11 -o List1909.exe List1909.cpp 
[1092 Day19] >> ./List1909.exe 
2 4 6 8 10 12 14 16 18 20
---------------------------------------------------------------------------------------------------------------------
OBSERVATION: although iterators are introduced here with the list class, the vector class also provides iterators. In addition to functions introduced in the vector class, the list class also provides the push_front()  and pop_front() functions that work just like push_back() and pop_back(). Instead of adding and removing elements at the back of the list, they add and remove elements in the front of the list. 
>> push_front() = member function that adds element in the front of a list 
>> pop_front() = member function that removes element in the front of a list
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> STACKS container [pag 702 jesse]
One of the most commonly used data structures in computer programming is the stack. The stack however, is not implemented as an independent container class. Instead it is implemented as a wrapper of a container. The template class stack is defined in the header file <stack> in the namespace std. 
A stack is a continously allocated block that can grow or shrink at the back end. Elements in a stack can only be accessed or removed from the back. You have seen similar characteristics in the sequence containers, notable vector and deque. In fact, any sequence container that supports the back(), push_back(), and pop_back() operations can be used to implement a stack. Most of the other container methods are not required for the stack and are, therefore, not exposed by the stack. The STL stack template class is designed to contain any type of objects. The only restriction is tha all elements must be of the same type. 
A stack is a >> LIFO (last in, first out) structure. The classic analogy for a stack is this : A stack is like a stack of dishes at a salad bar. You add to the stack by placing a dish on top (pushing the stack down) and you take from the stack by popping the top dish (the one most recently added to the stack) off the top. 
By convention the open end of a stack is often called the top of the stack, and operations carried out to a stack are often called push and pop [proprio come l'immagine fisica di una colonna di piatti con una molla sotto: devi premere verso il basso, push per aggiungere un nuovo piatto, e quando devi togliere un piatto dalla sommita' lo pop-ppi verso l'alto.]. The stack class inherits these conventional terms. 
NOTE: the STL stack class is not the same as the stack mechanism used by compilers and operating systems, in which the stacks can contain different types of objects. The underlying functionality, however, is very similar. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> DEQUE container [pag703 jesse]
 A deque is like a double-ended vector, it inherits the vector container class's efficiency in sequencial read and write operations. But in addition, the deque container class provides optimized front-end and back-end operations. These operations are implemented similarly to the list container class, where memory allocations are engaged only for new elements. This feature of the deque class eliminates the need to reallocate the whole container to a new memory location, as the vector class has to do. Therefore, deques are ideally suited for applications in which insertions and deletions take place at either one or both ends, and for which sequential access of elements is important. An example of such an application is a train-assembly simulator, in which carriages can join the train at both ends.  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> QUEUES CONTAINER [pag703 jesse]
A queue is another commonly used data structure in computer programming. Elements are added to the queue at one end and taken out at the other. A queue is like a line at the theather. You enter the queue at  the back, and you leave the queue at the front. This is known as a >> FIFO (= first in first out) structure; a stack is a > LIFO (= last in, first out) structure. Of course every once in a while, you're second to last in a long line at the supermarket when someone opens a new register and grabs the last person in line (turning what should be a FIFO queue into a LIFO stack, and making you grind your teeth in fustration).
Like the stack, the queue is implemented as a wrapper class to a container. The container must support front(), back(), push_back() and pop_front() operations.  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> ASSOCIATIVE CONTAINERS [pag704 jesse]
You have seen that a vector is like an enhanced version of an array. It has all the characteristics of an array and some additional features. Unfortunately, the vector also suffers from one of the significat weaknesses of arrays. You cannot find an element using any index other than its offset in the container. Associative containers, on the other hands, provide fast random access based on keys that are associated with values. 
The sequence containers are designed for sequential and random access of elements using the index or an iterator, the associative containers are designed for fast random access of elements using keys. The standard C++ library provides five associative containers : 
	- map
	- multimap
	- set 
	- multiset
	- bitset
>> MAP CONTAINER 
The first associate container you will learn about is the map. The name comes from the idea that they contain "maps", which are the key to the associated value, just as a point on a paper map corresponds to a real place on earth. In the listing 
	/home/alseny/edylab/CPlusPlusPlayGround/SAMS-TeachYourselfCpp-Jesse-5thedition/sourceCode-SAMS-Jesse-5th-edition/Day19/List1910.cpp
a map is used to implement the school class example that was shown in listing 19.8 
[tra l'altro non riusciamo a compilare questo programma nel nostro redhat7]
In this program a class is created and four students are added. The list of students is then printed. After printing this list, Bill is printed along with his age; however, rather than using a numeric indexer like previous example, Bill's name is used to find his age. This is made possible using the map template.
PUNTI SALIENTI DEL PROGRAMMA: 
- per poter usare map devi includere  the header file <map> :
	  #include <map>
so that you can use the standard map container class. 
- on line 73 you can see that a prototype is provided for the ShowMap function. You can also see that this is a template function. It is used to display the elements in a map. 
	73 template<class T, class A>
	74 void ShowMap(const map<T, A>& v);    // display map properties
- on line 76 typedef is used to define SchoolClass as a map of elements; each consists of a (key, value) pair:
	76 typedef map<string, Student>   SchoolClass;
The first value in the pair is a string that is the key value. In this example, for SchoolClass, the students' names are this key value. The key value of elements in the map container must be unique; that is, no two elements can have the same key value. The second value in the pair is the actual object, a Student object in the example. The pair data type is implemented in the STL as a "struct" of two member: namely "first" and "second" (che trovi nella linea di codice 108). These members can be used to access a node's key and value. 
You can take a look at the ShowMap() function on lines 103-111. The ShowMap() function uses a constant iterator to access a map object. The Showmap() function uses a constant iterator to access a map object. 
	103 template<class T, class A>
	104 void ShowMap(const map<T, A>& v)
	105 {
	106    for (map<T, A>::const_iterator ci = v.begin();
	107                ci != v.end(); ++ci)
	108       cout << ci->first << ": " << ci->second << endl; // ci->first points to the key, or a student's name, ci->second points to the Student object
	109 
	110    cout << endl;
	111 }
All that remains to review in this listing is the main() function on lines 78-98. Back on lines 80-83 four students objects are created. 
	 80    Student Harry("Harry", 18);
	 81    Student Sally("Sally", 15);
	 82    Student Bill("Bill", 17);
	 83    Student Peter("Peter", 16);
The MathClass is defined as an instance of our SchoolClass on line 85
	 85    SchoolClass   MathClass;
On line 86-89  the four students (actually the Student objects) are added to the MathClass using the following syntax: 
	          map_object[key_value] = object_value;
	 86    MathClass[Harry.GetName()] = Harry;
	 87    MathClass[Sally.GetName()] = Sally;
	 88    MathClass[Bill.GetName()] = Bill;
	 89    MathClass[Peter.GetName()] = Peter;
On line 86 you can see that the key_value being used is the name from a Student object. This name is obtained using the GetName() method from the Student object. The object_value is a Student object. The push_back() or insert() functions could also have been used to add a (key,value) pair to the map; you can look up your compiler's documentation for more details. After all Student objects have been added to the map, you can access any of them using their key values. On lines 94-96 MathClass["Bill"] is used to retrieve Bill's record: 
	 94    cout << "We know that " << MathClass["Bill"].GetName()
	 95         << " is " << MathClass["Bill"].GetAge()
	 96         << " years old" << endl;
You could just as easily have used any of other student's names to access their records. 
[lovely made, venuto presto, combattuto coi corvi di denenchoufu, arrivato a shinjuku, salito in cielo al 28F e from 6:00am to 8:00 studying containers, clean, clear with just our computers and the small notepad of the work shut down to be internet free. Free of news, free of unnecessary inputs. Let's study hard to get our 3D scientific papers visualizer done, get expert in gravitation and build a flying machine. We will be an eagle in the skies]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> MULTIMAP CONTAINER [pag708 jesse]
The multimap container class is a map class without the restriction of unique keys. More than one element can have the same key value. The set container class is also similar to the map class. The only difference is that its elements are not (key, value) pairs. An element is only the key. The multiset container class is a set class that allows duplex key values. 
Finally the  
>> BITSET / >> bitset container class is a template for storing a sequence of bits. 
-----------------------------------------------------------------------------------------------
>> WORKING WITH THE ALGORITHM CLASSES / >> ALGORITHM CLASSES [pag708 jesse]
A container is a useful place to store a sequence of elements. All standard containers define operations that manipulate the containers and their elements. Implementing all these operations in your own seqeunces, however, can be laborious and prone to error. Because most of those operations are likely to be the same in most sequences, a set of generic algorithms can reduce the need to write your own operations for each new container. The standard library provides approximately 60 standard algorithms that perform the most basic and commonly used operations of containers. 
Standard algorithms are defined in <algorithm> in namespace std. 
To understand how the standard algorithms work, you need to understand the concept of function objects. A function object is an instance of a class that defines the overloaded operator () [questa frase un poco sibillina te la spiego con il listato qui sotto]. Therefore, it can be called as function. Listing  19.11 demonstrates a function object. 
Con l'esempio puoi comprendere meglio la frase A function object is an instance of a class that defines the overloaded operator () [cioe' indichi il significat delle parentesi () ]
the function object DoPrint (line 16) is an instance of the class Print (line 4) inside which (lines 8-11) the overload operator () is defined. And as a function object you can call DoPrint just like you do with a function (line 18)
------------------------------------------------------------------------------------------
  1 #include <iostream>
  2 using namespace std;
  3 
  4 template<class T>
  5 class Print  // defining a standard template class.
  6 {
  7   public:
  8      void operator()(const T& t) // the operator "()"  is overloaded to take an object and outputs it to the standard output. 
  9      {
 10         cout << t << " ";
 11      }
 12 };
 13 
 14 int main()
 15 {
 16     Print<int> DoPrint; // DoPrint is defined as an instance of the Print class using an "int" value
 17     for (int i = 0; i < 5; ++i)
 18        DoPrint(i); // as a function object you can call DoPrint just like you do with a function.
 19     return 0;
 20 }
------------------------------------------------------------------------------------------
OUTPUT 
[1103 Day19] >> g++ -o List1911.exe List1911.cpp 
[1104 Day19] >> ./List1911.exe 
0 1 2 3 4

>> NONMUTATING SEQUENCE OPERATIONS / >> NON MUTATING SEQUENCE OPERATIONS [pag709 jesse]
Non mutating sequence operations are components from the algorithm library that perform operations that don't change the elements  in a sequence. These includes operators such as for_each(), find(), search(), and count(). Listing 19.12 shows how to use a function object and the for_each algorithm to print elements in a vector. 
Nota come alla linea 25
	 25    for_each(vInt.begin(), vInt.end(), DoPrint);
the for_each() function is called to go through each element in the vector vInt. For each element in the vector, it invokes the DoPrint function object and passes the element to DoPrint.operator(). This results in the value of the element to be printed on the screen. 
-------------------------------------------------------------------------------------------
  1 #include <iostream>
  2 #include <vector>
  3 #include <algorithm>
  4 using namespace std;
  5 
  6 template<class T>
  7 class Print
  8 {
  9   public:
 10      void operator()(const T& t)
 11      {
 12         cout << t << " ";
 13      }
 14 };
 15 
 16 int main()
 17 {
 18    Print<int>   DoPrint;
 19    vector<int>   vInt(5);
 20 
 21    for (int i = 0; i < 5; ++i)
 22       vInt[i] = i * 3;
 23 
 24    cout << "for_each()" << endl;
 25    for_each(vInt.begin(), vInt.end(), DoPrint);  
 26    cout << endl;
 27 
 28    return 0;
 29 }
-------------------------------------------------------------------------------------------
OUTPUT program :
[1109 Day19] >> g++ -o List1912.exe List1912.cpp 
[1110 Day19] >> ./List1912.exe 
for_each()
0 3 6 9 12

>> MUTATING SEQUENCE OPERATIONS [pag710 jesse]
Mutating sequence operations perform operations that change the elements in a sequence, including operations that fill or reorder collections. The listing 19.13 below shows the fill() algorithm. 
The >> fill algorithm fill the elements  in a sequence with a given value. 
Nel listato sotto puoi notare le linee :
- usa fill per attribuire a tutti gli elementi da vInt.begin() a vInt.begin() + 5 [= i primi 5 elementi di vInt] il valore 1
	 21    fill(vInt.begin(), vInt.begin() + 5, 1); 
- usa fill per attribuire a tutti gli elementi da vInt.begin() + 5 a vInt.end() [= gli ultimi 5 elementi di vInt] il valore 2
	 22    fill(vInt.begin() + 5, vInt.end(), 2); 
----------------------------------------------------------------------------------------
  1 #include <iostream>
  2 #include <vector>
  3 #include <algorithm>
  4 using namespace std;
  5 
  6 template<class T>
  7 class Print
  8 {
  9   public:
 10      void operator()(const T& t)
 11      {
 12         cout << t << " ";
 13      }
 14 };
 15 
 16 int main()
 17 {
 18    Print<int>   DoPrint;
 19    vector<int>  vInt(10); // creiamo un vettori di 10 elementi, di type int.
 20 
 21    fill(vInt.begin(), vInt.begin() + 5, 1); // using fill() algorithm to assigns an integer value 1 to the first five elements in vInt. 
 22    fill(vInt.begin() + 5, vInt.end(), 2); // using fill() algorithm to assigns an integer value 2 to the last five elements of vInt. 
 23 
 24    for_each(vInt.begin(), vInt.end(), DoPrint);
 25    cout << endl << endl;
 26 
 27    return 0;
 28 }
----------------------------------------------------------------------------------------
OUTPUT  : 
[1113 Day19] >> g++ -o List1913.exe List1913.cpp 
[1114 Day19] >> ./List1913.exe 
1 1 1 1 1 2 2 2 2 2
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>> SORTING ALGORITHMS / >> SORTING AND RELATED OPERATIONS [pag711 jesse]
The third category of algorithms is the sorting and related operations subclass. Within  this set of operations you find merging, partial sorts with copying, binary searches, lower and upper bounds checks, set intersections, set differencing, minimus, maximums, permutations, and more. You can check you compiler's documentation  or the C++ standards documentation for specific information on each of these operations. You can check you compiler's documentation or the C++ standards documentation for specific information on each of these operations. 
SUMMARY : in this lesson you learned how to create and use templates. Templates are a key part of the C++ standard and a built in facility of C++. Templates are used to create parametrized types (= types that change their behaviour based on parameters passed in at creation). They are a way to reuse codee safely and effectively. 
The definition of the template determines the parametrized type. Each instance of the template is an actual object, which can be used like any other object, as a parameter to a function, as a return value and so forth. 
Template classes can also declare three types of friend functions: 
- non template
- general template
- type specific template
A template can declare static data members, in which case each instance of the template has its own set of static data
If you need to specialize behaviour for some template functions based on the actuale type, you can override a template function with a particular type. This works for member functions as well. 
-----------------------------------------------------------------------------
Q&A 
	Q Why use templates when macros will do?
Templates are type-safe and built into the language, so they are checked by the compiler at least when you instantiate the class to create a particular variable. 
	Q What is the difference between the parameterized type of a template function and the parameters to a normal function?
A regular function (nontemplate) takes parameters on which it can take action. A template function enables you to parameterize the type of a particular parameter  to the function. That is you can pass an Array of Type to a function and then have the Type determined by the definition of the variable that is an instance of the class for a specific type. 
	Q When do I use templates and when do I use inheritance. 
Use templates when all the behaviour, or virtually all the behaviour is unchanged, expect in regard to the type of the item on which your class acts. If you find yourself copying a class and changing only the type of one or more of its members, it might be time to consider using a template. Also use a template when you are tempted to change a class to operate on a higher-level ancestor class (reducing type safety) of its operands, or to make two unrelated classes share a common ancestor so that your class can work with both of them (again reducing type-safety)
	Q When do I use general template friend classes?
When every instance, regardless of type, should be a friend to this class or function 
	Q When do I use type-specific template friend classes or functions?
When you want to establish a one-to-one relationship between two classes. For example, array<int> should match iterator<int>, but not iterator<Animal>.
-----------------------------------------------------------------------------------------------------------------------------------------------------
	Q1 What is the difference between a template and a macro?
Templates are built in to the C++ language and are type-safe. Macros are implemented by the preprocessor and are not type-safe.
	Q2 What is the difference between the parameter in a template and the parameter in a function?
The parameter to the template creates an instance of the template for each type. If you create six template instances, six different classes or functions are created. The parameters to the function change th behaviour or data of the function, but only one function is created.
	Q3 What is the difference between a type-specific template friend class and a general template friend class?
The general template friend function creates one function for every type of the parameterized class; The type-specific function creates a type-specific instance for each instance of the parameterized class.
	Q4 Is it possible to provide special behaviour for one instance of a template but not for other instances?
Yes create a specialized function for the particular instance. In addition to creating Array<t>::SomeFunction(), also create Array<int>::SomeFunction() to change the behaviour for integer arrays.
	Q5 How many static variables are created if you put one static member into a template class definition?
Once for each instance type of the class. 
	Q6 What attributes must your class have to be used with the standard containers?
The class must define a default constructor, a copy constructor, and an overloaded assignment operator.  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> tie 
[pag 590 deitel]
Interactive applications generally involve an istream for input and an ostream for outputs.
The prompt needs to appear before the input operation proceeds. 
C++ provides member function "tie" to synchronize (= tie together) the operation of an istream and an ostream to ensure that outputs appear before their subsequent inputs.

>> try / >> catch example from pag 59-60 moo book
try tries to execute the statements in {} that follow the try keyword. If a domain_error exception occurs anywhere in these statements, then it stops executing them and continues with the other set of {} enclosed statements. These statements are part of a catch clause, which begins with the catch and indicates the type of exception it is catching.
If the statements between try and catch complete without thrwoing an exception, then the program skips the catch caluse entirely and continues with the next statement.
WARMING: whenever we write a try statement, we must think carefully about side effects and when they occur. We must assume that anything between try and catch might throw an exception. If it does, so then any computation that would have been executed after the exception is skipped. What is important to realize is that a computation that might have followed an expcetion in time does not necessarily follow it in the program text. 
[from the program /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter04/main1.cc]

	// compute and generate the final grade, if possible
	try {
		double final_grade = grade(midterm, final, homework);
		streamsize prec = cout.precision();
		cout << "Your final grade is " << setprecision(3)
		     << final_grade << setprecision(prec) << endl;
	} catch (domain_error) {
		cout << endl << "You must enter your grades.  "
			"Please try again." << endl;
		return 1;
	}

	return 0;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TIME CLASS 
[pag379deitel]
prevents multiple definition errors.
The class definition is enclosed in the following include guard
	// prevent multiple inclusions of header
	#ifndef TIME_H
	#define TIME_H
	...
	#endif
[Extract from Deitel-CppWebResources/Code_Examples/ch09/fig09_01_03/Time.h]
When  we build larger programs, other definitions and declarations will also be placed in headers. The preceding include guard prevents the code between #ifndef (which means if not defined) and #endif from being included if the name TIME_H has been defined. If the header has not been included previously in a file, the name TIME_H is defined by the #define directive and the header statements are included. 
Use #ifndef, #define and #endif preprocessing directives to form an include guard that prevents headers from being included more than once in a source-code file.
NOTE: by convention, use the name of the header in uppercase with the period (= il punto) replaced by an undescore in the #ifndef and #define preprocessing directives of a header. (cioe' ex al posto di time.h use TIME_H) 

>> TIME print 
[pag382deitel]
extract from Deitel-Code_Examples/ch09/fig09_01_03/Time.cpp
/*
questa function takes no arguments and outputs the date in stadard time format, consistinng of the hour, minute and second values separated by colons and followed by an AM or PO indicator.
*/
void Time::printStandard() const
{
   cout << ( ( hour == 0 || hour == 12 ) ? 12 : hour % 12 ) << ":" 
      << setfill( '0' ) << setw( 2 ) << minute << ":" << setw( 2 )
      << second << ( hour < 12 ? " AM" : " PM" );
} // end function printStandard
////////////////////////////////////////

>> this Pointer / >> "this" Pointer
[pag412deitel]
We've seen that an object's member functions can manipulate the object's data. There can be namy objects of a class, so how do member functions know which object's data members to manipulate ? Every object has access to its own address trough a pointer called "this" (a C++ keyword). The "this" pointer is not part of the object itself (cioe' the memory occupied by the "this" pointer is not reflected in the result of a "sizeof" operation on the object). Rather, the "this" pointer is passed (by the compiler) as an implicit argument to each of the object's non-static member function. [on the contrary the "this" pointer is not implicitly passed to "static" member functions]
[pag34 mike game programming] The this pointer is a pointer that all non static member functions automatically have; it points to the object that was used to call the function.
>> this pointer explicit use example pag 412 deitel:
A common explicit use of the "this" pointer is to avoid naming conflicts between a class's data members and member function parameters (or other local variables). 
[tag >> conflict name avoid how to: using the "this" Pointer]
Se per esempio al posto dell'originale Time.cpp ch09/fig09_04_09
	// set hour value
	void Time::setHour( int h )
	{
	   if ( h >= 0 && h < 24 )
	      hour = h;
	   else
	      throw invalid_argument( "hour must be 0-23" );
	} // end function setHour
Mettessimo: 
	// set hour value
	void Time::setHour( int hour )
	{
	   if ( hour >= 0 && hour < 24 )
	      this->hour = hour;
	   else
	      throw invalid_argument( "hour must be 0-23" );
	} // end function setHour
rispetto all'originale nel precedente spezzone abbiamo settato il nome del parametro di setHour a "hour" al posto di "h". E sorge cosi' il problema che il data member "hour" che prima veniva aggiornato con un "= h;" ora viene aggiornato con un parametro che ha il suo stesso nome. In setHour's scope, the parameter "hour" hides the data member. However you can still access the data member "hour" by qualifying its name with "this->" . So the following statement assigns the hour parameter's value to the data member "hour"
	this->hour = hour; // si usa il pointer this to access the data member hour (quello a sinistra dell'uguale) e gli si assegna il parametro hour (a destra dell'uguale).
ADVICE: to make your code clearer and more maintanable, never hide data with member with local variables names.
NOTE1: the type of the "this" pointer depends on the type of the object and whether the member function in which this is used is declared const. see pag 413deitel
NOTE2: Implicitly and >> explicitly using the "this" pointer to access an Objct's data member.
see pag 413 deitel
Example fig 9.23 demonstrates the implicit and explicit use of the "this" pointer to enable a member function of class "Test" to print the "private" data "x" of a "Test" object.
	// print x using implicit and explicit this pointers;
	// the parentheses around *this are required
	void Test::print() const   
	{
	   // implicitly use the this pointer to access the member x
	   cout << "        x = " << x;
	   // explicitly use the this pointer and the arrow operator
	   // to access the member x
	   cout << "\n  this->x = " << this->x;
	   // explicitly use the dereferenced this pointer and 
	   // the dot operator to access the member x
	   cout << "\n(*this).x = " << ( *this ).x << endl;   // le parentesi attorno a *this sono obbligatorie. Le parentesi sono richieste perche' the dot operator has higher precedence than the * operator. Without the parentheses, the expression *this.x would be evaluated like *(this.x) which is a compilation error, because the dot operator cannot be used with a pointer.
	} // end function print
Ed otterrai printato su schermo:
	x = 12
	this-> = 12
	(*this).x = 12
NOTE: one interesting use of the "this" pointer is to prevent an object from being assigned to itself. Self-assignment can cause serious erros when the object contains pointers to dynamically allocated storage.
//////////////////////////////////////////////////////////////////////
Un altra bella spiegazione di "this->" la trovi qui
				// http://www.learncpp.com/cpp-tutorial/87-the-hidden-this-pointer/
				// te ne ho salvato anche copia della pagina in 
				// blackbird WebKaraDocs  thisPointer-8.7 The hidden-this-pointer-Learn C++
E ti ricopio il contenuto anche qui sotto:
	The hidden \81gthis\81h pointer
	One of the questions about classes that new object-oriented programmers often ask is, \81gWhen a member function is called, how does C++ keep track of which object it was called on?\81h. The answer is that C++ utilizes a hidden pointer named \81gthis\81h! Let\81fs take a look at \81gthis\81h in more detail.
	
	The following is a simple class that holds an integer and provides a constructor and access functions. Note that no destructor is needed because C++ can clean up integer member variables for us.
	class Simple
	{
	private:
	    int m_id;
	 
	public:
	    Simple(int id)
	    {
	        setID(id);
	    }
	 
	    void setID(int id) { m_id = id; }
	    int getID() { return m_id; }
	};
	
	Here\81fs a sample program that uses this class:
	   
	int main()
	{
	    Simple simple(1);
	    simple.setID(2);
	    std::cout << simple.getID() << '\n';
	 
	    return 0;
	}
	As you would expect, this program produces the result:
	
	2
	
	Somehow, when we call simple.setID(2);, C++ knows that function setID() should operate on object simple, and that m_id actually refers to simple.m_id. Let\81fs examine the mechanics behind how this works.
	
	The hidden *this pointer
	
	Take a look at the following line of code from the example above:
	   
	    simple.setID(2);
	
	Although the call to function setID() looks like it only has one argument, it actually has two! When compiled, the compiler converts simple.setID(2); into the following:
	   
	    setID(&simple, 2); // note that simple has been changed from an object prefix to a function argument!
	
	Note that this is now just a standard function call, and the object simple (which was formerly an object prefix) is now passed by address as an argument to the function.
	
	But that\81fs only half of the answer. Since the function call now has an added argument, the member function definition needs to be modified to accept (and use) this argument as a parameter. Consequently, the following member function:
	   
	    void setID(int id) { m_id = id; }
	
	is converted by the compiler into:
	  
	    void setID(Simple* const this, int id) { this->m_id = id; }
	
	When the compiler compiles a normal member function, it implicitly adds a new parameter to the function named \81gthis\81h. The this pointer is a hidden const pointer that holds the address of the object the member function was called on.
	
	There\81fs just one more detail to take care of. Inside the member function, any class members (functions and variables) also need to be updated so they refer to the object the member function was called on. This is easily done by adding a \81gthis->\81h prefix to each of them. Thus, in the body of function setID(),m_id (which is a class member variable) has been converted to this->m_id. Thus, when *this points to the address of simple, this->m_id will resolve to simple.m_id.
	
	Putting it all together:
	1) When we call simple.setID(2), the compiler actually calls setID(&simple, 2).
	2) Inside setID(), the *this pointer holds the address of object simple.
	3) Any member variables inside setID() are prefixed with \81gthis->\81h. So when we say m_id = id, the compiler is actually executing this->m_id = id, which in this case updates simple.m_id to id.
	
	The good news is that all of this happens transparently to you as a programmer, and it doesn\81ft really matter whether you remember how it works or not. All you need to remember is that all normal member functions have a *this pointer that refers to the object the function was called on.
	
	*this always points to the object being operated on
	
	New programmers are sometimes confused about how many *this pointers exist. Each member function has a *this pointer parameter that is set to the address of the object being operated on. Consider:
	
	int main()
	{
	    Simple A(1); // *this = &A inside the Simple constructor
	    Simple B(2); // *this = &B inside the Simple constructor
	    A.setID(3); // *this = &A inside member function setID
	    B.setID(4); // *this = &B inside member function setID
	 
	    return 0;
	}
	
	Note that the *this pointer alternately holds the address of object A or B depending on whether we\81fve called a member function on object A or B.
	
	Because *this is just a function parameter, it doesn\81ft add any memory usage to your class (just to the member function call, since that parameter goes on the stack while the function is executing).
	
	Explicitly referencing *this
	
	Most of the time, you never need to explicitly reference the \81gthis\81h pointer. However, there are a few occasions where doing so can be useful:
	
	First, if you have a constructor (or member function) that has a parameter with the same name as a member variable, you can disambiguate them by using \81gthis\81h:
	class Something
	{
	private:
	    int data;
	 
	public:
	    Something(int data)
	    {
	        this->data = data;
	    }
	};
	
	Note that our constructor is taking a parameter of the same name as a member variable. In this case, \81gdata\81h refers to the parameter, and \81gthis->data\81h refers to the member variable. Although this is acceptable coding practice, we find using the \81gm_\81h prefix on all member variable names provides a better solution by preventing duplicate names altogether!
	
	Chaining objects
	
	Second, it can sometimes be useful to have a class member function return the object it was working with as a return value. The primary reason to do this is to allow a series of functions to be \81gchained\81h together, so several functions can be called on the same object! You\81fve actually been doing this for a long time. Consider this common example where you\81fre outputting more than one bit of text using std::cout:
	
	std::cout << "Hello, " << userName;
	
	In this case, std::cout is an object, and operator<< is a member function that operates on that object. The compiler evaluates the above snippet like this:
	
	(std::cout << "Hello, ") << userName;
	
	First, operator<< uses std::cout and the string literal \81gHello, \81h to print \81gHello, \81h to the console. However, since this is part of an expression, operator<< also need to return a value (or void). If operator<< returned void, you\81fd end up with this:
	
	(void) << userName;
	
	which clearly doesn\81ft make any sense (and the compiler would throw an error). However, instead, operator<< returns *this, which in this context is just std::cout. That way, after the first operator<< has been evaluated, we get:
	
	(std::cout) << userName;
	
	which then prints the user\81fs name.
	
	In this way, we only need to specify the object (in this case, std::cout) once, and each function call passes it on to the next function to work with, allowing us to chain multiple commands together.
	
	We can implement this kind of behavior ourselves. Consider the following class:
	   
	class Calc
	{
	private:
	    int m_value;
	 
	public:
	    Calc() { m_value = 0; }
	 
	    void add(int value) { m_value += value; }
	    void sub(int value) { m_value -= value; }
	    void mult(int value) { m_value *= value; }
	 
	    int getValue() { return m_value; }
	};
	
	If you wanted to add 5, subtract 3, and multiply by 4, you\81fd have to do this:
	   
	#include <iostream>
	int main()
	{
	    Calc calc;
	    calc.add(5); // returns void
	    calc.sub(3); // returns void
	    calc.mult(4); // returns void
	 
	    std::cout << calc.getValue() << '\n';
	    return 0;
	}
	
	However, if we make each function return *this, we can chain the calls together. Here is the new version of Calc with \81gchainable\81h functions:
	   
	class Calc
	{
	private:
	    int m_value;
	 
	public:
	    Calc() { m_value = 0; }
	 
	    Calc& add(int value) { m_value += value; return *this; }
	    Calc& sub(int value) { m_value -= value; return *this; }
	    Calc& mult(int value) { m_value *= value; return *this; }
	 
	    int getValue() { return m_value; }
	};
	
	Note that add(), sub() and mult() are now returning *this. Consequently, this allows us to do the following:
	#include <iostream>
	int main()
	{
	    Calc calc;
	    calc.add(5).sub(3).mult(4);
	 
	    std::cout << calc.getValue() << '\n';
	    return 0;
	}
	
	We have effectively condensed three lines into one expression! Let\81fs take a closer look at how this works.
	
	First, calc.add(5) is called, which adds 5 to our m_value. add() then returns *this, which is a reference to calc. Our expression is now calc.sub(3).mult(4). calc.sub(3) subtracts 3 from m_value and returns calc. Our expression is now calc.mult(4). calc.mult(4) multiplies m_value by 4 and returns calc, which is then ignored. However, since each function modified calc as it was executed, calc\81fs m_value now contains the value ((0 + 5) - 3) * 4), which is 8.
	
	Summary
	
	The \81gthis\81h pointer is a hidden parameter implicitly added to any member function. Most of the time, you will not need to access it directly, but you can if needed. It\81fs worth noting that \81gthis\81h is a const pointer -- you can change the value of the underlying object it points to, but you can not make it point to something else!
	
	By having functions that would otherwise return void return *this instead, you can make those functions chainable. This is most often used when overloading operators for your classes (something we\81fll talk about more in chapter 9).
	//////////////////////////////////////////////////////////////////////

>> this [pag 198 moo book]
The "this" keyword is valid only inside a member function, where it denotes a pointer to the object on which the member function is operating.
We use "this" to determine whether the right and left hand sides of the assignment refer to the same object. If they do, then they will have the same address.

>> this pointer to enable cascaded functions calls / >> cascaded member function calls 
[pag414 deitel]
Another use of the this pointer is to enable cascaded member-function calls, that is invoking multiple functions in the same statement
Example from fig9.26 /home/dia/Deitel-Code_Examples/ch09/fig09_24_26/fig09_26.cpp
   // cascaded function calls
   t.setHour( 18 ).setMinute( 30 ).setSecond( 22 );

>> TOP DOWN REFINEMENT /STEPWISE REFINEMENT
[pag125deitel]
cioe' si parte dalla overall representation of the program e si raffina a poco a poco. Helpful technique to develop well-structured programs.  

>> TRAILING RETURN TYPES for functions
[pag248deitel]
Example 
	template < typename T >
	auto maximum( T x, T y, T z ) -> T
to specify a trailing return type you place the keyword auto before the function name, then follow the function's parameter list with -> and the return type.  

>> TREE 
[pag803 deitel]
A tree is a nonlinear, two-dimensional data structure. 
At pag 803 e segg are discussed the >> binary tree = trees whose nodes all contain two links (none, one or both of which may have the value of nullptr  see fig19.18 pag803 bel graphico esplicativo.)
Nomenclature / Terminology
>> root node is the first node of a tree (da non confondere con il root node pointer, che semplicemente punta al primo elemento del tree - se il presente linguaggio ti sembra un poco astruso, see fig19.18 pag 803, bella raffigurazione. Anche tutte le definizioni che seguono qui sotto sono riferite a tale figura)
>> child / node child [pag803 deitel]
>> left subtree [pag803 deitel]
>> right subtree [pag803 deitel]
>> siblings nodes  [pag803 deitel]
>> leaf node = node with no children [pag803 deitel]
---------------------------------------------------
>> binary search tree [pag803 deitel]
A binary search tree (with no duplicate node values) has the characteristic that 
1) the values in any left subtree are less than the value in its >> parent node
2) the values in any right subtree are greater than the value in its parent node 
[see esempio pag 804 deitel]
>> TreeNode / >> tree node class [pag806 deitel]
----------------------------------------------------
START REPETITA IUVANT
>> binary trees facilitate searching and sorting data, duplicate elimination and compiling expressions into machine code. [see pag803deitel]
NOTE: from pag 780 deitel: stacks and queues are linear data structures and they can be viewed as constrained versions of linked lists. Trees are nonlinear data structures.
NOTE2: basic terminology dei trees structures [from pag803 deitel]
	>> root node	deitel p803
	>> child node 	deitel p803
	>> siblings 	deitel p803
	>> leaf node 	deitel p803
	>> left child	deitel p803  non nel senso di bambino lasciato solo, ma di "bambino sul lato sinistro
	>> right subtree deitel p803
	>> left subtree	deitel p803
FINE REPETITA IUVANT
----------------------------------------------------
>> inorder traversal	deitel p804  / >> in order 
	NOTE: [pag810deitel] inorder traversal of a binary search tree prints the node values in ascending order. The process of creating a binary serach tree actually sorts the data - thus this process is called the >> binary tree sort.
>> preorder traversal 	deitel p804  / >> pre order 
	>> preorder traversal algorithm [pag810deitel]
>> postorder traversal	deitel p804  / >> post order
>> duplication elimination / >> eliminate duplicate [pag811 deitel]
	searching a binary gree for a value that matches a key value is fast. If the tree is balanced, then each branch contains about half the number of nodes in the tree. Each comparison of a node to the search key eliminates half the nodes. This is called a 0(logn) algorithm.
So a binary serach tree with n elements would require a maximum of log_2 n comparisons either to find a mathc or to determine that no match exists. This means for example, that when searching a balanced 1000 element binary search tree, no more than 10 comparisons need to be made, because 2^10 > 1000.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> TRUNCATION vs ROUNDING in integer division 
[pag123deitel]
the integer division TRUNCATES does means 
7:4 = 1 
anche se aritmeticamente 7:4 = 1.75
suppore che dividendo tra interi 7:4 = 2 no ti taglia secco tutto il 0.75 e ti lascia con 1 e tanti saluti.
Da qui mi viene il mente furbo il nostro trick di aggiungere 0.5 prima di effettuare il troncamento.

>> TYPE CASTING OPERATOR
Type casting operators allow you to convert a datum of a given type to another. 
- Way 1: precede the expression to be converted by the new type enclosed between parentheses (); ex:
	int i;
	float f = 3.14;
	i = (int) f;
The previous code converts the float number 3.14 to an integer value (3), the remainder is lost. Here the typecasting operator was int. 
- Way2: using the functional notation: preceding the expression to be converted by the type and enclosing the expression between parenthesis: 
	i = int (f);

>> typeid / >> type_info 
[pag556 deitel]
Operator typeid returns a reference to an object fo class type_info that contains the information about the bype of its operand, including the name of that type. To use typeid the program must include header <typeinfo>
NOTE: portability
The string returned by type_info member function name may vary by compiler.

>> TYPE FIELDS and switch STATEMENTS
[pag533deitel]
One way to determine the type of an object is to use a switch statement to check the value of a field in the object. This allows us to distinguish amon object types, then invoke an appropriate action for a particular object. For example, in a hierarchy of shapes in which each shape object has a shapeType attribute, a switch statement could check the object's shapeType to determine which print function to call.
But using switch logic exposes programs to a variety of potential problems. For example, you might forget to include a type test or might forget to test all possible cases in a switch statement. Tracking these statements down can be time consuming and error prone. 
SOLUTION : use polymorphic programming instead. Polymorphic programming can eliminate the need for switch logic. By using the polymorphism mechanism to perform the equivalent logic, you can avoid the kinds of errors typically associated with switch logic.
An interesting consequence of using polymorphism is that programs take on a simplified appearance. They contain less branching logic and simpler sequential code.

>> UUUUUUUU

>> UML 
Unified Modeling Language
[pag16deitel]
In the UML, each class is modeled in a UML class diagram as a rectangle with three compartements.
1) the top compartement contains the class's name centered horinzontally and in boldface type.
2) the middle compartment contains the class's attributes, which correspond to data members in C++.
3) the bottom compartment contains the class's operations, which correspond to member functions in C++
- the plus sign (+) in front of the operation name indicates that the function is a public operation in the UML (i.e. a public member function in C++)
[pag50deitel]
- ROMBO : il segno romboidale / diamond indica una decision symbol, which indicates that a decision is to be made [pag111deitel]
- il ROMBO puo' anche indicare un MERGE symbol which joins two flows of activity into one flow of activity [see example pag117deitel con il while loop] anche se graficamente sono rappresentati dallo stesso simbolo li puoi differenziare considerando che 
> il decision symbol ha una freccia in entrata e due o piu' frecce in uscita 
> il merge symbol ha due o piu' frecce in entrata e una sola freccia in uscita
- l'italic (caratteri in corsivo) e' utilizzato per indicare le classi astratte [pag535 deitel: the abstract class name is italicized as per the convertion of the UML]

un tipico esempio grafico da pag 260 mike game programming 
	                        -----------------------------
	                        |                           |
	nome della classe       |          Critter          |       
	                        -----------------------------
	                        |                           |
	                        |      -m_Hunger:int        |
	data members            |      -m_Boredom:int       |
	                        |                           |
	                        -----------------------------     
	                        |                           |
	                        |      +Talk()              |
	                        |      +Eat()               |       
	member functions        |      +Play()              |
	                        |      -PassTime()          |
	                        |                           |
	                        -----------------------------      


examples [notazione grafica i tre blocchi li rapresentiamo con 1) 2) 3) se non scriviamo nulla significa che il campo e' vuoto]
1) GradeBook 
2)
3) + displayMessage( courseName : String )
GradeBook class contains public member function displayMessage with 1 parameter di nome courseName e type String. 
NB: the UML is language indipendent, so its terminology does not exactly match that of C++ . For example UML type String corresponds to the C++ type string. 
[pag73]
- Example UML diagram with a data member and set and get Functions
[pag79deitel]
1) GradeBook
2) -courseName : String
3) + setCourseName( name * String )
   + getCourseName( ) : String
   + displayMessage()
The UML represents data members as attributes by listing the attribute name, followed by a colon and the attribute type  [nell'esempio sopra -courseName : String]. The minus sign in front of the attribute's name indicate that data member courseName is private 
----------------------------------------------------
UML nice UML diagrams for / for UML / do...while UML / if..else UML / switch UML 
- sequence
- if
- if...else
- switch 
- while
- do...while
- for
statements li trovi a pag 187deitel
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unformatted I/O using read write and gcount
[pag 573 deitel]
Unformatted input/output is perfromed using the read and write member functions of istream and ostream, respectively. Member function read inputs bytes to a built-in array of chars in memory; member function write outputs bytes from a built-in array of chars. These bytes are not formatted in any way. They're input or output as raw bytes.
>> read member function inputs a designated number of characters into a built-in array of chars. 
>> gcount is a member function that reports the number of characters read by the last input operation.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unget [pag217 moo book]
unget : the unget function undoes the most recent get by backspacing the input stream by one character.

>> uppercase  lowercase conversion / >> lowercase uppercase conversion / >> toupper() [pag135 mike programming game]
use 
	#include<cctype>
it's part of the standard library and it includes functions for converting characters to uppercase.
example 
	/home/dia/Beginning_Cpp_Through_game_programming_by_Micheal_Dawson/chapter04/hangman.cpp
By using #include<cctype> then you can use line like 
	        guess = toupper(guess); 
this function take as input guess (che contiene a character inputtato dallo user) and the function toupper returns the uppercase version of it. 
///////////////////////////////////////////////////////////////////////////////////////

>> update sequential files / >> sequential files update / >> updating sequential files / >> sequential file update
[pag611 deitel]
Se avessi un file in cui vuoi cambiare giusto una parola, per esempio mettere "Enterprise" al posto di "Nostromo", il problema e' che se lo si effettua in maniera sequenziale, il fatto che Enterprise abbia 3 caratteri in piu' rispetto a Nostromo, fa si che i 3 caratteri che seguono la parola nostromo verranno sovrascritti dalla "ise" di Enterprise [detto in maniera tecnica: i caratteri aggiuntivi "ise" will overwrite the beginning of the next sequential record in the file], e il file dopo l'"update sequenziale" risultera' cosi' corrotto. 
La soluzione quindi se si vuole effettuare un update sequenziale e' di fatto di creare un file nuovo
- nel nuovo file prima si copiera' tutto cio' che precede la porzione che si vuole modificare
- quindi (sempre nel nuovo file) si copiera' la porzione modificata
- infine si copiera tutto cio' che segue alla porzione modificata
Quindi si potra' eliminare il vecchio file e rinominare il nuovo con il nome di quello appena cancellato.
This requires processing every reconrd in the file to update one record. Quindi non molto efficiente ma accettabile nei casi in cui many records are being updated in one pass of the file.
NOTE: anche se e' vero che valori come
	7
	14
	-117
	2074
	27383
are all ints which store the same number of "raw data" bytes internally (typically four bytes on 32 bit machines and 8 bytes on 64-bits machines), however these integers become different-sized fields, depending on their actual values, when ouput as formatted text (character sequences). Therefore, the formatted input/output model usually is not used to update records in place.
L'alternativa e' di usare il 
>> RANDOM ACCESS FILE [pag611deitel]
Sequential files are inappropriate for >> instant access application, in which a particular record must be located immediately. Common instant access applications are airline reservation system, >> ATM (automated Teller Machines), and other kinds of transaction processing systems that require rapid access to specific data. A bank might have hundreds of thousands (or even millions) of other customers, yet, when a customer usees an automated teller machine, the program checks that customer's account in a few seconds or less for sufficient funds. This kind of instant access is made possible with random access files. Individual records of a random-access file can be accessed directly (and quickly) witohout having to search other records.
As we've said, C++ does not impose structure on a file. So the application that wnats to use random-access files must create them 
A variaty of techniques can be used. Perhaps the easiest method is to require that all records in a file be of the same fixed length. 
Using same-size fixed-length records makes it easy for a program to quickly calculate (as function of the record size and the record key) the exact location of any record relative to the beginning of the file. 
A random-access file is like a railroad train with many same-size cars, some empty, some with contents.
Data can be inserted into a random access file without destroying other data in the file. Data stored previously also can be updated or deleted without rewriting the entire file.
CICCIO analogia [>> LIBRARY BOXES ANALOGY]: eccoti qui un altra bella analogia per toccare con mano la differenza tra random access file e sequential file. 
Puoi veder ciascun record come un libro di una biblioteca. In una biblioteca sequeziale si hanno i libri tutti ammassati senza ordine in degli scaffali uno accanto all'altro, senza spazio tra di essi. Il risultato e' che quando ti chiedono di trovare un libro devi sequenzialmente scannare tutti i libri finche' non trovi quello voluto. Se puo la richiesta e' di sostituire un libro trovato con un altro che e' magari piu' spesso, e' l'inferno perche' visto che i volumi sono tutti ammassati gli uni accanto agli altri, allora devi spostare tutti la fila degli altri libri limitrofi.
Invece in una biblioteca che permette un random access sarebbe come avere i libri tutti ordinati in una schiera di boxes tutte uguali. Ad ogni libro e' associato un numero, quindi se ti dicono libro 12342 basta che vai alla box 12342 e op lo trovi subito. Se poi devi modificarlo, o sostituirlo con la nuova edizione piu' spessa, nessun problema, basta che nella box 12342 togli il vecchio libro ed inserisci quello nuovo piu' spesso. Le boxes vicine non ne sono per nulla affettate dalla modifica della box 12342. 
NOTE: nota come in entrambi gli approcci esiste il disordine non scompare. Ma in un caso (sequential access) cerchi in maniera ordinata/sequenziale un ammasso disordinato ed anarchico di dati, nell'altro caso (random access) puoi cercare in una maniera non sequenziale/anarchica un ammasso ben ordinato e strutturato di dati 
>> random access file creation 
[pag612 deitel]
- The >> ostream member function write outputs to the specified stream a fixed number of bytes, beginning at a specific location in memory. When the stream is associated with a file, function write writes the data at the location in the file specified by the put file-position pointer. 
- The >> istream meber function read inputs a fixed number of bytes from the specified stream to an area in meory beginning at a specified address. If the stream is associated with a file, function read inputs bytes at the location in the file specified by the "get" file-position pointer.
WRITING BYTES WITH ostream MEMBER FUNCTION write [pag612 deitel]
When writing the integer number to a file, instead of using the statement
	outFile << number;
which for a four-byte ineger could poinrt as few digits as one or as many as 11  (10 digits plus a sign, each requiring byte of storage), we can use the statement
	outFile.write( reinterpret_cast< const char * >( &number ),
		sizeof( number ) );
[>> cast : tra l'altro nel precedente comando mi sembra di poter intuide il significato di castare una variabile, e' come se la variabile fosse un metallo fuso e la si castasse, forgiasse imponendogli una determinata forma/formato]
which always writes the binary version of  the integer numbr's four bytes (on a machine with four-byte integers). Function write treats its first argument as a group ob bytes by viewing the object in memory as a "const char *", which is a pointer to a byte. Starting from that location, function write outputs the number of bytes specified by its second argurment (= an integer of type size_t). As we'll see, istream function read can subsequently be used to read the fout bytes back into integer variable number 
>> REINTERPRET_CAST operator / converting between pointer types with the reinterpret_cast operator.
[pag613 deitel]
Unfortunately, most pointers that we pass to function write as the first argument are not of type const char *. To output objects of other types, we must convert the pointers to those objects to type const char *; otherwise, the compiler will not compile calls to function write. C++ provides the reinterpret_cast operator for cases like this in which a pointer of one type must be cast to an unrelated pointer type. Without a reinterpret_cast, the write statement that outputs the integer number will not compile because the compiler does not allow a pointer of type int * (the type returned by the expression &number) to be passed to a function that expects an argument of type const char * (as far as the compiler is concerned, these types are incosistent).
NOTE1: reinterpret_cast is compiler dependent and can cause programs to behave differently on different platforms. Use this operator only if it's absolutely necessary.
NOTE2: a program that read unformatted data (written by "write") must be compiled and executed on a system compatible with the program that wrote the data, becuse different systems may represent internal data differently.
pag 614 e segg trovi un simpatico CREDIT CARD PROCESSING PROGRAM [see also Deitel-Code_Examples/ch14/fig14_09_11]
NOTE3: from Deitel-Code_Examples/ch14/fig14_09_11/fig14_11.cpp line 11
	ofstream outCredit( "credit.dat", ios::out | ios::binary );
the use of ios::binary indicates that we are opening the file for output in binary mode, which is required if we are to write fixed-length records.
//////////////////////
>> write data randomly to a random-access file / >> RANDOM write to random access file
[pag 617 deitel]
see example /home/dia/Deitel-Code_Examples/ch14/fig14_12/Fig14_12.cpp
fig14_12 writes data to the file credit.dat and uses the combination of fstream functions seekp and write to store data at exact locations in the file. Function seekp sets the put file position pointer to a specific position in the file, then function write outputs the data. 
>> open a file for input and output in binary mode / >> binary mode input output / >> opening  a file for input and output in binary mode / >> open file in binary mode / >> opening file in binary mode.
[pag619 deitel]
	fstream outCredit( "credit.dat", ios::in | ios::out | ios::binary );
from line 16 /home/dia/Deitel-Code_Examples/ch14/fig14_12/Fig14_12.cpp
>> reading from Random Access file sequentially
[pag619]
we develop a program that reads the file sequentially and points only those records that contain data.
In this example, by storing the records in the file using direct-access technique you get the following advantage: the records are listed in sorted order. [pag621deitel] 
The speed is achieved by making the file large enough to hold every possible record that might be created. This, of coarse, means that the file could be occupied sparsely most of the time, resulting in a waste of storage. This is an example of the >> space-time trade-off: by using large amounts of space, we can develop a much faster sorting algorithm. Fortunately, the continuous reduction in price of storage units has made this less of an issue.
>> INSTANT ACCESS PROCESSING CASE STUDY 
[pag 621 deitel]
you will find there a transaction processing program. The program maintains a bank's account information, it updates existing accounts, adds new accounts, deletes accounts and stores a formatted listing of all current accounts ia text file.
see /home/dia/Deitel-Code_Examples/ch14/fig14_14/Fig14_14.cpp
[un popo di 300 linee di codice ben fatto!]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> uppercase 
[pag585 deitel]
stream manipulator uppercase ouptput an uppercase X or E with hexadecimal integer values or with scientific  notation floating-point values, respectively.
Example from pag 585
	   cout << uppercase << 4.345e10 << endl 
donera in print
	4.345E+010
NOTE: by default the letters for hexadecimal values and the exponents in scientific notation floating-point values appear in lowercase. To reset the uppercase setting, output the stream manipulator nouppercase.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> UNARY SCOPE RESOLUTION OPERATOR 
	::
- it's possible to declare local and lobal variables of the same name.
- C++ provides the unary scope resolution operator (::) to access a global variable when a local variable of the same name is in scope (cioe' quando all'interno di un blocco di una funzione, trovi una variable locale che ha lo stesso nome di una variable globale, puoi far riferimento ad essa usando :: ). 
- the unary scope resolution operator cannot be used to access a local variable of the same name in an outer block.	
- a global variable can be accessed directly without the unary scope resolution operator if the name of the global variable is not the same as that of a local variable in scope.
Good programming practice 
Always using the unary scope resolution operator (::) to refer to a global variable makes it clear that you're intending to access a global variable rather than a nonglobal variable.
Example:
	// Unary scope resolution operator.
	#include <iostream>
	using namespace std;

	int number = 7; // global variable named number

	int main()
	{
	   double number = 10.5; // local variable named number
	
	   // display values of local and global variables
	   cout << "Local double value of number = " << number
	      << "\nGlobal int value of number = " << ::number << endl;
	} // end main	
E questo ti donera' 
Local double value of number = 10.5
Global int value of number = 7
OSSERVAZIONI: always using the unary scope resolution operator (::) to refer to a global variable eliminates logic errors that might occur if a nonglobal variable hides the global variable.
[vedi anche voce >> :: ]	
[pag242deitel]	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> unique_ptr 
[pag465deitel]

>> UNSIGNED INT
when a variable is declared as unsigned int, it can store only non-negative values (that is 0, or higher)
Utile per esempio per dichiarare variables usate come contatori (per esempio in cicli while) example 
	unsigned int levelCounter = 1;
[pag121deitel]
Variables of unsigned integer types can represent values from 0 to approximately twice the positive range of the corresponding signed integer types. (cioe' se sul nostro computer quando si usano gli integer ammettesse tipo range -25millions, + 25millions allora quando usi unsigned il range diventa 0, 50millions) 
[pag 134deitel]
NOTE: [from pag48 moo book] whenever ordinary integers and unsigned integers combine in an expression, the ordinary integer is converted to unsigned. 

>> using namespace std;
std stands for standard. All the elements of the standard C++ library are declared within what is called a namespace, the namespace with the name std. So in order to access its functionality scriviamo ad inizio programma "using namespace std;"

>> UTILITY FUNCTIONS
[pag386deitel]
they are also called >> helper function
A utility function is a "private" member function that supports the operation of a class's other member functions.
Utility functions are declared "privite" because ther're not intended for use by the class's clients.
A common use of a utility function would be to place in a function some common code that would otherwise be duplicated in several other member functions.



>> VVVVVVV

>> VALIDATION 
in industrial-strength code, always validate all inputs.
[pag110deitel] 

>> VALIDITY CHECKING 
[pag93deitel]
the validity checking is performed to ensure that the parameter format received by a certain member function is correct. see example pag 94deitel di solito involve una condizione if (ad esempio per testare che il nome immesso in input abbia un numero di caratteri inferiore ad un certo limite)

>> VARIABLE = variable is a place to store information. A variable is a locatio in your computer's memory in which you can store a value and from which you can later retrieve that value.
[pag41 jesse book]

>> VARIABLE = a portion of memory to store a determined value. Each variable needs an identifier that distinguishes it from the others, for example 
	a = 1;
We can give a variable any name we want as long as they are valid identifiers.
see IDENTIFIER for further info
NB: each variable has a 
- name
- type 
- size
- value
[pag48deitel]

>> variable / >> object [pag10 moo book]
A variable is an object that has a name. An object is a part of the computer's memory that has a type. 
NOTE: it is possible to have objects that not have names. (quindi possiamo dedurre tutte le variabili sono oggetti, ma non tutti gli oggetti sono variabili.)
>> variable definition example:
---------------------------------------------------- start example
int main()
{                                                                                                  ----------
	// ask for the person's name                                                                  /          \
	std::cout << "Please enter your first name: ";   // << = (ciccio trick)   diffuse expand to <<   SCREEN   |
                                                                                                  \          / 
	// read the name                                                                               ---------- 
	std::string name;     // define `name'                                                                        ----------\
	std::cin >> name;     // read into `name'        // >> = (ciccio trick) from keyboard  focused and save into  ----------->> VARIABLE
                                                                                                                  ----------/
	// write a greeting
	std::cout << "Hello, " << name  << "!" << std::endl;
	return 0;
}
---------------------------------------------------- end example	
////////////////////////////////////////////////////////////////////////////////

>> variable initialization / >> initializing variable / >> declare variable / >> declaration variable [pag15 mike] 
A variable represents a particular piece of your computer's memory that has been set aside for you to use to store, retrieve, and manipulate data.
NOTE1: every variable you create has a type, which represents the kind of information you can store in the variable. It tells your compiler how much memory to set aside for the variable and it defines exactly what you can legally do with the variable.
NOTE2: puoi dichiarare piu' variabili dello stesso tipo in un singolo statement example 
	int numberVessel, numberEngines;
this lines establishes two int variables "numberVessel" and "numberEngines". Visto che e' uno statement deve terminare con una ;
NOTE3: to declare a variable you must provide a name, known as >> identifier. There are only a few rules you have to folow to create a legal identifier:
	- an identifier can contain only number, letters and underscores
	- an identifier can't start with a number
	- an identifier can't be a C++ keyword.
inoltre e' consigliato di:
	- choose descriptive names. Variable names should be clear to another programmer. One exception to this rule involves variables used for a brief period.  In that case, single letter variable names such as x, are fine.
	- be consistent: se scegli di usare lo style con le capital letter (ex highScore => questo stile di mettere in maiscolo la lettera iniziale delle parole che compongono la variabile e' chiamato >> Camel style ) anziche quello con gli underscore (ex high_score) stitch to it!
	- follow the tradition: si solito le variable names start with a lowercase letter. Inoltre si evita di usare l'underscore come first character. Names that begin with an underscore can have special meaning. 
	- keep the length in check. Even though powerLevelOfMainEngineOfNostromoCarrier is descriptive, it can make code hard to read. Plus long names increase the risk of a typo. As a guideline try to limit your variable names to fewer than 15 characters. 
TRICK: >> self documenting code is written in such a way that it's easy to understand what is happening in the program independent of any comments. Choosing good variable names is an excellent step toward this kind of code.
NOTE4: >> fundamental types (those built into the language) include 
bool 	for Boolean values (true or false), 
char 	for single character values, int 	for integers, 
float 	for single precision floating point numbers, and 
double 	for double precision floating point numbers.
NOTE3: >> modifiers : you can use modifiers to alter a type.
	short int       	-32768  to 32767
	unsigned short int	0 to 65535
	int 				-2147483648 to -2147483647
	unsigned int        0 to 4294967295
	long int 			-2147483648 to -2147483647
	unsigned long int	0 to 4294967295
	float				3.4E +/-38 (seven significant digits)
	double    			1.7E +/-308 (15 significant digits)
	long double 		1.7E +/-308 (15 significant digits)
	char 				256 character values
	bool 				true or false
For brevity "short int" can be written as just "short" and "long int" can be written as just "long".
>> type which is the best choice between int unsigned int double ect 
- If you need an integer type, you're probably best off using int. That's because int is generally implemented so that it occupies an amount of memory that is most efficienly handled by the computer. 
- If you need to represent integer value greater than the maximum int or values that will never be negative, feel free (U2) to use an unsigned int.
- If you need a floating point number you're probably best off using float, which again is likely to be implemented so that it occupies an amount of memory that is most efficiently handled by the computer.
Example
---------------------------------------------------------------------------------------- 
// Game Stats
// Demonstrates declaring and initializing variables

#include <iostream>
using namespace std;

int main()
{
	int score;				
	double distance;		
	char playAgain;			
	bool shieldsUp;			

	short lives, aliensKilled;

	score = 0;
	distance = 1200.76;
	playAgain = 'y';
	shieldsUp = true;
	lives = 3;
	aliensKilled = 10;
		
	double engineTemp = 6572.89;

	cout << "\nscore: "		<< score << endl;
	cout << "distance: "	<< distance << endl;
	cout << "playAgain: "	<< playAgain << endl;
	//skipping shieldsUp since you don't generally print Boolean values
	cout << "lives: "		<< lives << endl;
	cout << "aliensKilled: "<< aliensKilled << endl;
	cout << "engineTemp: "	<< engineTemp << endl;

	int fuel;
	cout << "\nHow much fuel? ";
	cin >> fuel;
	cout << "fuel: " << fuel << endl;

	typedef unsigned short int ushort;
	ushort bonus = 10;
	cout << "\nbonus: " << bonus << endl;

	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> declare multiple variable on the same line 
[pag51 jesse]
a patto di dichiarare variables of the same type, le puoi concatenare una dietro l'altra separandole con una virgola
	long width = 5, length = 7;
Non e' necessario che le inizializzi tutte, potresti anche per esempio giusto limitarti a dichiarne una senza inizializzarla, example:
	long width = 5, length;
---------------------------------- here's a little example of declaration and initialization 
// Demonstration of variables
#include <iostream>
// questo programma computes the >> AREA computation  
int main()
{
   using std::cout;
   using std::endl;
  
   unsigned short int Width = 5, Length;
   Length = 10;
  
   // create  an unsigned short and initialize with result
   // of multiplying Width by Length
   unsigned short int Area  = (Width * Length);
  
   cout << "Width:" << Width << "\n";
   cout << "Length: "  << Length << endl;
   cout << "Area: " << Area << endl;
   return 0;
}
/////////////////////////////////////////////////////////////////////////////////

>> VECTOR operation summary [from pag 48 moo book]
vector<T>::size_type    a type guaranteed to be able to hold the number of elements in the largest possible vector
v.begin()               return a value that denotes the first element in v
v.end()                 return a value that denotes (one past) the last element in v
vector<T> v;            creates an empty vector that can hold elements of type T
v.push_bash(e)          grows the vector by one element initialized to e
v[i]                    returns the value stored in position i
v.size()                returns the number of elements in v
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////  

>> Vector vs list [pag84 moo book]
For small input using vectors and indexes to removes some elements from the vector works fine. But for HUGE vectors, using "erase" to remove an element from the vector is not a good idea. The library optimizes the vector data strcutuer for fast access to arbitrary elements. Moreover vectors performs well when growing a vector one element at time, as long as elements are added at the end of the vector. 
Inserting or removing element from the interior of a vecto is another story. Doing so requires that all lements after the one inserted or meoved be moved in order to preserve fast random access. Moving elements means that the run time of the code might be as slow as quadratic in the number of elements in the vector. 
For better performance we need a new type of data container, that does not support random access thought indices but let's as insert and delete elments efficiently anywhere in the container: this container is called LIST [pag 85 moo book]
Just as vectors are optimized for fast random access, list are optimzed for fast insertion and deletion anywhere within the container. 
Because list have to maintain a more complicated structure, they are slower than vectors if the container is accessed only sequentially. That is if the container grows and shrinks only or primarily from the end, a vector will outperform a list. However, if a program deletes many elements from the middelle of the container then listswill be faster for larger inputs, becoming much faster as the inputs grow. 
Lists and vectors share many operations. As a result, we can often translate programs that operate on vectors into programs that operate on lists, and vice versa.
/////////////////////////////////////////////////////////////////////////////////////////////

>> string analysis / >> white space presence check [pag 89 moo book]
[from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/split.cc]
extract:
		while (i != s.size() && isspace(s[i]))    // i != s.size() to check that we have still not reach the end of the string
			++i;
NOTE: isspace function is a predicate that takes a char and returns a value that indicates whether that char is whitespace.
Quindi la precedente condizione diventa vera se non siamo alla fine della stringa e se s[i] is a whitespace character.


>> VECTOR vs arrays [pag110 mike game programming]
See also below la voce >> VECTOR Deitel (per una presentazione dal libro Deitel C++)
- Vectors can grow as needed while arrays cannot.
- Vectors can be used with the standard library algorithms while arrays cannot. This means that by using vectors you get complex functionality like searching and sorting, built-in. 
BUT
- vectors require a bit of extra memory as overhead.
- there can be a performance cost when a vector grows in size. 
Necessary steps before using vectors
1) include the file that contains its definition:
	#include <vector>
2) >> declare vector
	vector<string> inventory;  // this declares an empty vector named inventory, which can contain string object elements. It will grow in size when you add new elements 
TO declare a vector of your own wrtie vector followed by the type of objects you want to use with the vector (surrounded by <>), followed by the vector name.
Alternatives ways of declaration
	vector<string> inventory(10); // declares a vector to hold string object elements with a starting size of 10.
O anche 
	vector<string> inventory(10, "nothing"); // initialize all of the vector's element to the same value when you declare it. Nell'esempio si ha un vettore with a size of 10 and initilized all 10 elements to "nothing".
O infine 
>> VECTOR MEMBER FUNCTIONS 
>> push_back = add a new element to the end of a vector / >> add element
ex
	inventory.push_back("sword");
adds a new element "sword" to the end of the vector inventory.
>> size vector = returns the size of a vector
ex
	inventory.size()
ci dona il size del vector "inventory"
>> vector loop / >> loop vector
	cout << "\nYour items:\n";
	for (unsigned int i = 0; i < inventory.size(); ++i)
	{
		cout << inventory[i] << endl;
	}
NOTE: the type of the variable "i" is "unsigned int" because the value returned by size() is an unsigned integer type. 
NOTE TRAP: although vectors are dynamic you can't increase a vector's size by applying the subscripting operator. For example, the following  HIGHLY DANGEROUS  code snippet does not increase the size of the vector inventory 
	vector<string> inventory; // creating an empty vector
	inventory[0] = "sword";  // may cause your program crash!
Just as with arrays, you can attempt to access a nonexistent element position but with potentially disastrous results. The preceding code changed some unknown section of your computer' memory and could cause your program to crash. To add a new element at the end of a vector, use the push_back() member function.
>> MEMBER FUNCTION CALL OF AN ELEMENT [pag115 mike game programming]
	cout << "\nThe item name '" << inventory[0] << "' has ";
	cout << inventory[0].size() << " letters in it.\n";
>> pop_back member function [pag115 mike game programming]
the pop_back() member function removes the last element of avector and reduces the vector size by one. 
	inventory.pop_back();
>> CLEAR VECTOR 
	inventory.clear();
the clear() member function removes all of the items of a vector and sets its size to 0. 	
>> EMPTY member function [pag116 mike game programming]
	if (inventory.empty())
	{
		cout << "\nYou have nothing.\n";
	}
	else
	{
		cout << "\nYou have at least one item.\n";
	}
the vector member function empty() returns true if the vector object is empty; otherwise it returns false.   
>> INSERT ELEMENT AT THE BEGINNING OF VECTOR / >> REMOVE ELEMENT FROM MIDDLE OF VECTOR -> pag 118 mike game programming
>> ITERATOR DECLARATION / >> DECLARATION ITERATOR [pag118 mike game programming]
	vector<string>::iterator myIterator;
the preceding line declares an iterator named "myIterator" for a vector that contains "string" objects.
To declare an iterator of your own follow the same pattern:
	vector             <string>                ::         iterator      myIterator
      |                   |                    |                           |
    container type    type of objects        scope                      name for  
                      that the container     resolution                 your new
                      will hold              operator                   iterator
>> ITERATOR = iterators are values that identify a particular element in a container. Given an iterator, you can access the value of the element. Given the right kind of iterator, you can change the value. Iterators are like Post-it notes that you can sitck on a specific element in a container. An iterator is not one of the elements, but a way to refer to one. After you stick your iterator post-it on a specific element of a vector, you can access the element or even change it through the iterator.
[pag119 mike programming game]
>> CONSTANT ITERATOR / >> const_iterator [pag119 mike game programming]
	 vector<string>::const_iterator iter;
A constant iterator is just like a regular iterator except that you can't use it to change the element to which it refers; the element must remain constant. You can think of a constant iterator as providing read-only access. However the iterator itself can change. This means you can move the iterator all around the vector.
TRAP: using push_back() might invalidate all iterators referencing the vector
[pag119 mike programming game]
>> LOOP VECTOR / >> VECTOR LOOP using iterator [pag120 mike programming]
    myIterator = inventory.begin(); // >> begin() member function returns an iterator that refers to a container's first element.
    *myIterator = "battle axe";  // we change the value of the first element. Remember by >> dereferencing myIterator with *, the preceding assignment statement says, "Assign "battle axe" to the element that myIterator references". It does not change myIterator. 
    cout << "\nYour items:\n";
    for (iter = inventory.begin(); iter != inventory.end(); ++iter)  // >> end() [pag121 mike programming game] = the end() member function returns an iterator one past the last element in a container [cioe' un iteratore that refers to the element successivo all'ultimo elemento del vettore]. This means the loop will continue untili iter has moved through all the elements in inventory.   
    {
        cout << *iter << endl;  // here we are using the >> dereference operator (*) in front of iter. In this way we display the value of the element to which the iterator refers (not the iterator itself)
	}
NOTE: [pag122 mike programming] ciccio spiega 
	>> REFERENCE an iterator to the n-element of a vector = attaccare/riferire l'iterator all'elemento n del vettore.
	>> DEREFERENCE an iterator = get the value dell'elemento a cui l'iterator si riferisce. 
NOTE: >> end() vector member function returns an iterator that's one past the last element in the vector (not the last element). Therefore you can't get a value from the iterator returned by end(). 
NOTE: >> accessing member function of a vector element. // >> -> [pag122 mike game programming]
	cout << "\nThe item name '" << *myIterator << "' has ";
    cout << (*myIterator).size() << " letters in it.\n";
(*myIterator).size() says : "take the result of dereferencing myIterator and call that object's size() member function. Because myIterator refers to the string object equal to "battle axe", the code returns 10.
HINT: whenever you dereference an iterator to access a data member  or member function, surround the dereferenced iterator by a pair of parenthesis. This ensures that the dot operator will by applied to the object the iterator references. 
The code (*myIterator).size() is not the the pretties, so C++ offers an alternative, more intuitive way to express the same thing: 
	cout << "\nThe item name '" << *myIterator << "' has ";
    cout << myIterator->size() << " letters in it.\n";
(*myIterator).size() and myIterator->size() mean exactly the same thing to the computer, but this new version is easier for humans to use. In general, you can use the >> indirect member selection operator "->" to access the member function or data members of an object that an iterator references. 
///////////////////////////////////////////////////////////////////////////////////////////////

>> iterator adaptors / >> insert_iterators [pag121 moo book]
The most common are adaptors that generate insert_iterators, which are iterators that frow the associated container dynamically.
Such iterators can be used safely as the destination of a copying algorithm. 
They are defined in the header <iterator>
	>> back_inserter(c)   yields an iterator on the container c that appends elements to c. The container must support push_back, which the list, vector and the string types all do.
	>> front_inserter 	= like back_inserter, but inserts at the front of the container. The container must support push_front, which list does, but string and vector do not. 
	>> inserter(c, it)
		like back_inserter, but inserts elements before the iterator it.

>> INSERT() vector member function [pag123 mike programming game]
    cout << "\nYou recover a crossbow from a slain enemy.";
    inventory.insert(inventory.begin(), "crossbow"); // this >> insert a new element at the beginning of the vector
NOTE: insert() member function INSERTS a new element into a vector just BEFORE the element referred to by a given iterator. 
NOTE: you supply two arguments to this version of insert() the first is an iterator, and the second is the element to be inserted. 
NOTE: in the example above we insert "crossbow" into "inventory" just before the first element. As a result, all of the other elements will move down by one. 
NOTE: questo insert non e' che overwrite il contenuto dell'elemento a cui l'iteratore sta puntando. Inserire il nuovo elemento nella posizione in cui l'iteratore punta, spingendo giu' tutti gli altri elementi del vettore. 
TRAP: calling the insert() member function on a vector invalidates all of the iterators that reference elements after the insertion point because all of the elements after the insertion point are shifted down by one  

>> REMOVE ELEMENT from the middle of a vector // >> erase() member function [pag124 mike programming] / 
	inventory.erase((inventory.begin() + 2));
NOTE: erase() member function ermoves an element from a vector. erase() requires as argument the iterator that references the element you want to remove. Nell'esempio sopra we passed (inventory.begin() + 2), which is equal to the iterator that references the third element in inventory. As a result all of the following elements will move up by one. 
This version of erase() member function returns an iterator that references the element after the element that has been removed. In the example above, we did not assign the returned iterator to a variable.
TRAP : calling the erase() member function on a vector invalidates all of the iterators that reference elements after the removal point because all of the elements after the removal point are shifted up by one.
>> VECTOR PERFORMANCE / >> PERFORMANCE VECTOR [pag129]
Vectors and other STL containers are incredibly efficient. However these containers have their strengths and weaknesses; a game programmer needs to understand the performance characteristics of the various containers types so that he can choose the right one for the job. 
Although vectors grow dynamically as needed, every vector has a specific size. When a new element added to a vector pushes the vector beyond its current size, the computer reallocates memory and might even copy ALL of the vector elements to this newly seized chunk of memory real estate. This can cause a performance hit!
The most important tihng to keep in mind about program performance is  whether you need to care. For example, vector memory reallocation might not occur at a performance critical part of your program. In that case, you can safely ignore the cost of reallocation. Also, with small vectors, the reallocation cost might be insignificant, so again, you can safely ignore it. 
If you need greater control over these memory allocation you can use 
	>> capacity() member function [pag129 mike game programming] 
	>> reserve() member function [pag130 mike game programming]  
The capacity() vector member function returns the capacity of a vector (>> capacity of a vector = the number of elements that a vector can hold before a program must reallocate more memory for it). Note: a vector's capacity is not the same thing as its size. >> capacity vs >> size : 
>> capacity of a vector = the number of elements that a vector can hold before a program must reallocate more memory for it
>> size of a vector = the number of elements a vector currently holds
Example 
	cout <<"Creating a 10 element vector to hold scores. \n";
	vector<int> scores(10,0); // initialize all 10 elements to 0
	cout <<"Vector size is :" << scores.size() << endl;  // size is 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity is 10
	
	cout <<"Adding a score.\n";
	scores.push_back(0); // memory is reallocated to accommodate growth
	cout <<"Vector size is :" << scores.size() << endl; // size is 11
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity is 20
Right after I declare and initialize the vector, this code reports that its size and capacity are both 10. However, after an element is added the code reports that the vector's size is 11 while its capacity is 20. That's because the capacity of a vector doubles every time a program reallocates additional memory for it. In this case, when a new score was added, memory was reallocated, and the capacity of the vector doubled from 10 to 20.
Example 2 using the reserve() member function. 
The reserve() member function increases the capacity of a vector to the number supplied as an argument. Using reserve() gives you control over when a reallocation of additional memory occurs. Here's an example:
	cout <<"Creating a 10 element vector to hold scores. \n";
	vector<int> scores(10,0); // initialize all 10 elements to 0
	cout <<"Vector size is :" << scores.size() << endl;  // size is 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl;  // capacity is 10 
	
	cout <<"Reserving more memory.\n";
	scores.reserve(20); // reserve memory for 10 additional elements
	cout <<"Vector size is :" << scores.size() << endl;  // size is still 10
	cout <<"Vector capacity is:" >> scores.capacity() << endl; // capacity has become 20
By using reserve() to keep a vector's capacity large enough for your purposes, you can delay memory reallocation ot a time of your choosing. 
HINT: as a beginner game programmer, it's good to be aware of how vector memory allocation works; however, don't obsess over it. The first game programs you'll write probably won't benefit from a more manual process of vector memory allocation. 
NOTE: >> performance hit expression significa "colpo alla performance, perdita non trascurabile di performance
NOTE: >> overhead = sopra testa, che sta al di sopra l'overhead di un operazione mi sembra voglia dire il tempo e risorse che richiede l'operazione in se', che si aggiunge al tempo di esecuzione del resto del programma. 
>> ERASE PERFORMANCE [pag130 mike programming game]
push_bash() and pop_back() member functions are extremely efficient. 
Adding or removing an element from the end of a vector using the push_bash() or pop_back() member functions is extremely efficient. 
However adding or removing an element at any other point in a vector (for example using insert() or erase() ) can require more work becuase you might need have to move multiple elements to accommodate the insertion deletion. With small vectors the overhead is usually insignificant, but with larger vectors (with, say, thousands of elements), inserting or erasing elements from the middle of a vector can cause a performance hit.
Fortunately the STL offers another sequence container type, list, which allows for efficient insertion adn deletion regardless of the sequence size. The important thing to remember is that one container type isn't the solution for every problem. Although vector is versatile and perhaps the most popular STL container type, there are times when another container type might make more sense. 
TRAP: just because you want to insert or delete elements from the middle of a sequence, that doesn't mean you should abandon the vector. It might still be a good choice for your game program. It really depends on how you use the sequence. If your sequence is small or there are only a few insertions and deletions, then a vector might still be your best bet. 
>> SEQUENTIAL CONTAINER pag 131 mike game programming 
	you can retrieve values in sequence. example: vector is a sequential container
>> ASSOCIATIVE CONTAINER pag 131 mike game programming 
	let's you retrive values based on keys. example: "map" is an associative container, is a collection of key/value pairs in which each key is associated with exactly one value
WHEN should I use SEQUENTIAL and when ASSOCIATIVE?
Consider an online, turn-based strategy game. You could use a sequential container to store a group of players that you wnat to cycle through in sequence. On the other hand, you could use an associative container to retrieve player information in a random-access fashion by looking up a unique identifier, such as a player's IP address.

STL CONTAINERS 
CONTAINER        TYPE           DESCRIPTION
deque            sequential     double-ended queue
list             sequential     linear list
map              associative    collection of key/value pairs in which each key is associated with exactly one value
multimap         associative    collection of key/value pairs in which each key may be associated with more then one value
multiset         associative    collection in which each element is not necessarily unique
priority_queue   adaptor        priority queue
queue            adaptor        queue
set              associative    collection in which each element is unique
stack            adaptor        stack
vector           sequential     dynamic array
 
NOTE: type adaptor: >> container adaptors represent standard computer science data structures. Although they are not official containers, they look and feel just like them.
//////////////////////////////////////////////////////////////////////////////////////

---------------------------------------------------------------------------------------------------------------------------
>> VECTOR 
[pag314deitel]
C++ Standard Library class template "vector" is similar to class template "array", but also support dynamic resizing.
One of the key differences between a vector and an array s that a vector can dynamically grow to accommodate more elements. 
Per usare vector nei tuoi programmi scrivi all'inizio 
	#include <vector>
	using namespace std;
EXAMPLE extracted from fig07_25.cpp [pag315deitel]
   vector< int > integers( 10 ); // 10-element vector< int >
Crea un vector object that store 10 values of type int. By default all the elements are set to 0.
Like arrays, vectors can be defined to store most data types, by replacing int in vector<int> with the appropriate type.
EXAMPLE2 from line 88 fig07_25.cpp 
	integers3.push_back( 7 ); // add 7 to the end of the vector
this command add the element "7" to the end of the vector. [intendiamo aggiungere l'elemento 7, non aggiungere 7 elementi]
To add an element at the end of a vector we use the member function 
	push_back
NOTE1: The C++ standard library class template vector allows you to create a new vector object that's initialized with the contents of an existing vector.
eccoti un example from line 44-46 fig07_25.cpp
   // create vector integers3 using integers1 as an
   // initializer; print size and contents
   vector< int > integers3( integers1 ); // copy constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> visual studio compile program tutorial pag 356 et seguenti mike book C++ game programming
Note anche se Mike consigliava visual studio express 2013 for windows desktop for windows
www.visualstudio.com/downloads/download-visual-studio-vs.
Con il nostro Microsoft Visual Studio Community 2013 funziona benissimo in OrionI
Seguendo le istruzioni di pagina 356 e seguenti, una volta compilato, la finestra resta aperta
Ti riscrivo qui i principali passaggi
- from the application menu -> File -> New Project. In the left pane of the new project dialog that appears select Visual C++. 
- In the middle pane select "win32 console application"
- in the name field type the name of the project. 
- in the location field, browse to the location to save your project by clicking the browse button
- make sure that the check box is checked for "create directory for solution"
- click OK and you will see the win 32 application wizard click next button 
- under Additional options check the check box for empty project. 
- in the win32 application wizard application settings dialog, click the Finish button 
- in the solution explorer right click the source files folder -> Add -> New Item 
- in the add new item that appears select C++ file (.cpp).
- in the name field, type nomeDelTuoProgramma.cpp
- scrivi il programma
- from the application menu, select File, save nomeDelTuoProgramma.cpp
- -> questo l'avevamo saltato (from the application menu, select Build, Build Solution 
- press Ctrl + 5 to run the project and enjoy the fruits of your labor!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> VECTOR ELEMENT-MANIPULATION FUNCTIONS
[pag654 deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp]
line 16
	vector< int > integers( values.begin(), values.end() );
the previous line initializes integers with the contents of the array values  from beginning of values up to (but not including) values.cend()
Altertivamente alla linea 16, si sarebbe anche potuto iniziale il vettore usando la forma:
	vector <int> integers{1, 2, 3 ,4, 5, 6 };
o anche 
	vector <int> integers = {1, 2, 3 ,4, 5, 6 };
Ma these are not fully supported across all compilers [@2015] For this reason the chapter 15 deitel uses line 16 style
////////
Altre parole chiave che si trovano all'interno del programma:
>> ostream_iterator [pag 656 deitel]
example line 20 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   cout << "Vector integers contains: ";
   copy( integers.cbegin(), integers.cend(), output );
line 20 uses standard library algorithm copy (from header <algorithm>) to ouptu the entire contenst of integers to the standard output.
The algorithm copies each element in a range from the location specified by the iterator in its first argument and up to, but not including, the  location specified by the iterator in its second argument.
>> front and >> back vector member functions
Functions front and back (available for most sequence containers) are used to determine the vector's first and last elements respectively.
example line 22 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   cout << "\nFirst element of integers: " << integers.front()
      << "\nLast element of integers: " << integers.back();
NOTE: Notive the difference between functions front and begin. 
	- Function front returns a reference to the first element in the vector, while 
	- function begin returns a random access iterator pointing to the first element in the vector.
Similmente sussiste una differenza tra back and end
	- function back returns a reference to the vector's last element
	- function end returns a random access iterator pointing to the location after the last element 
Attention: the vector must not be empty; otherwise, the results of front and back are undefined.
>> VECTOR ELEMENT ACCESS
[pag 657 deitel] 
Qui di seguito mostriamo due modi per accedere agli elementi di un vettore:
example line 25-26 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   integers[ 0 ] = 7; // set first element to 7
   integers.at( 2 ) = 10; // set element at position 2 to 10
Le due precenti righe sono del tutto equivalenti, la seconda performs la stessa operazione but with bounds checking. The function at first checks the value supplied as an argument and determines whether it's in the vector's bounds. If not, function "at" throws an out_of_range exception. Ecco qui si seguito listate alcune delle Standard Library exception types:
[pag 657 deitel - some execption in the header <stdexcept>]
>> out_of_range     : indicates when subscript is out of range (e.g. when an invalid subscript is specified to vector member function at)
>> invalid_arugment : indicates an invalid argument was passed to a function
>> length_error     : indicates an attempt to create  too long a container, string, etc
>> bad_alloc        : indicates that an attempt to allocate memory with new (or with an allocator) failed because not enough memory was available
//////////////////
>> INSERT element / >> vector member function insert 
[pag657 deitel]
example line 29 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
con la seguente riga inseriamo il valore 22 before the element at the location specified by the iterator in the first argument. 
	integers.insert( integers.cbegin() + 1, 22 );  
in this example the iterator is pointing to the vector's second element, so 22 is inserted as the second element and the original second element becomes the third element.
/////////////
>> insert with three argument (>> range insert)
[pag658 deitel]
line 55 demonstratest the version of function insert that uses the second and third aruments to specify the starting location and ending location in a sequence of values (in this case from the array values) that should be inserted into the vector.

example line 55 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
	integers.insert( integers.cbegin(), values.cbegin(), values.cend() );
NOTE: remembe that the ending location specfied the positon in the sequence after the last element to be inserted;
/////////////////////////////////////////
>> ERASE member function / >> vector MEMBER FUNCTION erase
[pag657 deitel]
Lines 45 and 50 use the tow erase functions that are available in all first-class containers. Line 45 erases the element at the location specified by the iterator arugument (in this example the first element). Line 50 specified that all elements in the range specified by the two iterator arguments should be erased.
example line 45-50 /home/dia/Deitel-Code_Examples/ch15/fig15_11/Fig15_11.cpp
   // erase first element
   integers.erase( integers.cbegin() );     // line 45 
   cout << "\n\nVector integers after erasing first element: ";
   copy( integers.cbegin(), integers.cend(), output );
   // erase remaining elements
   integers.erase( integers.cbegin(), integers.cend() );    // line 50
   cout << "\nAfter erasing all elements, vector integers " 
      << ( integers.empty() ? "is" : "is not" ) << " empty";  // line 52
line 52 uses function empty (available for all containers and adapters) to confirm that the vector is empty.
NOTE: normally erase destroys the objects that are erased from a container. However, erasing an element that contains apointer to a dynamically allocated object does not delete the dynamically allocated memory -> this can lead to a memory leak. If the element is a unique_ptr, the unique_ptr would be destroyed and the dynamically allocated memory would be deleted. If the element is a shared_ptr, the reference count to the dynamically allocated object would be decremented and the memory would be deleted only if the reference count reached 0. 
/////////////////
>> clear member function / >> vector member function clear
[pag 658 deitel]
line 60 uses function clear (found in all first clas containers execpt array) to empty the vector (this does not necessaily return any ofthe vector's memory to the system.)
	integers.clear(); 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> vector concatenation / >> concatenation vector a pag94 moo book, trovi un esempio di concatenazione vettori.
[extract from /home/dia/AcceleratedCpp-practicalProgrammingbyExample/unix-source/chapter05/pics.cc]
		vector<string> vcat(const vector<string>& top,
		                    const vector<string>& bottom)
		{
			// copy the `top' picture
			vector<string> ret = top;
		
			// copy entire `bottom' picture
			for (vector<string>::const_iterator it = bottom.begin();
			     it != bottom.end(); ++it)
				ret.push_back(*it);
		
			return ret;
		}
When you need to append elements at the end of a vector [>> append elements into a vector]
instead of 
			for (vector<string>::const_iterator it = bottom.begin();
			     it != bottom.end(); ++it)
				ret.push_back(*it);
you can also use the library function "insert", funziona cosi':
			ret.insert(ret.end()), bottom.begin(), bottom.end()); // same meaning, and more compact

>> VECTOR SEQUENCE CONTAINER
[pag650 deitel]
Class template vector, provides a data structure with contiguous memory locations. This enables efficient, direct access to any element of a vector via the subscript operator [], exactly as with a built-in array. 
Like class template array, template vector is most commonly used when the data in the container must be easily accessible via a subscript or will be sorted, and when the number of elements may need to grow.
When a vector's memory is exhausted
	1) the "vector" allocates a larger built-in array, 
	2) copies (or moves) the original elements into the new built-in array 
	3) deallocates the old-built-in array
NOTE1: performance: choose the vector container for the best random-access performance in a container that can grow.
NOTE2: You must include header <vector> to use class template vector.
>> VECTOR CREATION 
[commenti notevoli from /home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]
extract1:
   vector< int > integers; // create vector of ints
the previous line defines an instance called integers of class template vector that stores int values. 
Whe thi sobject is instantiated, an empty vector is created with size 0 (i.e. the number of elements stored in the vector) and capacity 0 (i.e. the number of elements that can be stored without allocating more memory to the vector).
extract2 lines 16-17
   cout << "The initial size of integers is: " << integers.size()
      << "\nThe initial capacity of integers is: " << integers.capacity();
le due righe precedenti dimostrano the size and capacity functions; 
>> size vector function [pag 652 deitel]
- Function size returns the number of elements currently stored in the container.
>> capacity vector function [pag 652 deitel]
- Function capacity returns the number of elements that can be stored in the vector before the vector need to dynamically resize itself to accommodate more elements. [in parole spicciole: un vettore ha inizialmente una certo size. Certo e' possibile se necessario aumentare tale size in maniera' dinamica (un po come in un hangar dove ci si ritrovasse a dover ospitare troppe merci, e si passasse allora a costruire nuovi hangar per alloggiare le merci che non potevano piu' rientrare nell'hangar originale ormai pieno)]
>> push_back vector member function 
[pag652 deitel [commenti notevoli from /home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]]
	   integers.push_back( 2 );  
       integers.push_back( 3 );  
the previous lines use function push_back available in sequence containers other than array and forward_list to add an element to the end of the vector. If an element is added to a full vector, the vector increases the size. Some implementations have the vector double its capacity [see esempio pratico e nostro disegno nel basso di pag652 deitel]. Sequence containers other than array and vector also provide a push_front function.
NOTE: it can be wasteful to double a vector's size when more space is needed. For example, a full vector of 1000000 elements resizes to accommodate 2000000 elements when a new element is added. This leaves 999999 unused elements. You can use "resize" and "reserve" to control space usage better.
>> VECTOR GROWTH / >> space time trade off [pag653 deitel]
[detto in parole spicciole : lo space-time trade off significa 
1) se allochi tanto spazio per un vettore, sarai molto veloce nel momento in cui devi aggiungere dei nuovi elementi visto che lo spazio e' gia' allocato, ma ahime' rischi di sprecare molto spazio che poi magari non sara' riempito da alcun elemento
2) se allochi giusto lo spazio necessario al numero di elementi presenti, sara' economo nello spazio da allocare al vettore, ma qualora dovessi aggiungere dei nuovi elementi, sarai meno veloce (more time required) visto che dovrai prima allocare del nuovo spazio.]
//////////
>> outputting built-in array contents with pointers
[pag653deitel]
   // display values using pointer notation
   for ( const int *ptr = begin( values ); ptr != end( values ); ++ptr )
      cout << *ptr << ' ';
/////////////
Function "begin" returns an iterator pointing to the built-in array's first element and function
Function "end"  returns an iterator representing the position one element after the end of the built-in array.
Note in the previous for loop the use of != 
When iterating using pointers to built-in array elments, it's common for the loop-continuation condition to test whether the pointer has reached the end of the built-inarray. This techinque is commonly used by the standard library algorithms.
//////////////
>> outputting vector contents with iterators [pag653deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]
	// function template for outputting vector elements
	template < typename T > void printVector( const vector< T > &integers2 )
	{
	   // display vector elements using const_iterator
	   for ( auto constIterator = integers2.cbegin(); 
	      constIterator != integers2.cend(); ++constIterator )   // l'espressione ++constIterator positions the iterator to the vector's next element. 
	      cout << *constIterator << ' ';    // in questa linea  we >> dereference constIterator to get the current element's value. Remember that the iterator acts like a pointer to the lement and that operator * is overloaded to return a reference to the element.
	} // end function printVector 
////////
the loop continues as long as constIterator has not reached the end of the vector.
nota il metodo >> cend : cend e' una member function which returns a const_iterator indicating the location past the last element of the vector.
>> reverse display vector / >> display vector's contents in reverse [pag654 deitel]
[/home/dia/Deitel-Code_Examples/ch15/fig15_10/Fig15_10.cpp]   
	// display vector in reverse order using const_reverse_iterator
    for ( auto reverseIterator = integers.crbegin();               
      reverseIterator!= integers.crend(); ++reverseIterator )
      cout << *reverseIterator << ' ';
C++11 includes vector member function >> crbegin and >> crend which return cont_reverse_iterators that represent the starting and ending points when iterating through a container in reverse.
>> shrink_to_fit [pag654 deitel] / >> memory back / >> memory performance / >> memory optimization 
As of C++11, you can ask a vecto or deque to return unneeded memory to the system by calling member function shrink_to_fit. This requests that the container reduce its capacity to the number of elements in the container.  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> VIRTUAL DESTRUCTORS 
[source http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html]
To build an object the constructor must be of the same type as the object and because of this a constructor cannot be a virtual function. But the same thing does not apply to destructors. A destructor can be defined as virtual or even pure virtual. You would use a virtual destructor if you ever expect a derived class to be destroyed through a pointer to the base class. This will ensure that the destructor of the most derived classes will get called.
see http://www.cprogramming.com/tutorial/constructor_destructor_ordering.html
for more info

>> VIRTUAL FUNCTIONS 
[pag 526 deitel]
example 
	virtual void nameFunction() const;
the preceding portotype declares that function nameFunction is a virtual function that takes no arguments and return nothing. 
Note: anche se nell'esempio precedente abbiamo dichiarato la funzione const, e' giusto un esempio, virtual functions do not have to be const functions.
NOTE [from pag532]:  if a class has virtual functions, always provide a virtual destructor, even if one is not required for the class. This ensures that a custom derived-class destructor (if there is one) will be invoked when a derived-class object is deleted via a base class pointer. 
Common programming error: constructors cannot be virtual, declaring a constructor virtual is a compilation error.

>> void * operator
[pag604 deitel]
the operator void * is anotheroverloaded ios member function that converts the stream to a pointer, so it can be tested as 0 (i.e. the null pointer) or nonzero (i.e. any other pointer value). 
When a pointer value is used as a condition, C++ interprets:
-  a null pointer in a condition as the bool value "false" 
	and interprets 
- a non-null pointer as the bool value "true".
The operator void * function can be used to test an input object for end-of-file, but you can also call member function "eof" on the input object.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

>> WWWWWWW

>> warning  this decimal constant is unsigned [pag25 mike] the warning is the result of something called integer wrap around that you'll probably want to avoid in your own programs; however, the wrap around is intentional in the program at pag24 mike to show the result of the event. You'll learn about integer wrap around in the discussion of this program, in the section "Dealing with Integer Wrap Around".

>> wchar_t : wide character 
size 2 or 4 bytes
range: 1 wide character

>> WHILE repetition statement 
[mike pag51]
generic form of the loop
	while (expression)
		statement;
if expression is false, the program moves on to the statement after the loop. If expression is true, the program executes statement and loops back to test expression again. This cycle repeats until expression tests false, at which point the loop ends.
Example 
// Play Again
// Demonstrates while loops

#include <iostream>
using namespace std;

int main() 
{
	char again = 'y';   // the variable again has to be inizialized before the loop expression
	while (again == 'y')
	{
		cout << "\n**Played an exciting game**";
		cout << "\nDo you want to play it again Sam? (y/n): ";
		cin >> again;
	}

	cout << "\nOkay, bye.";

    return 0;
}
-------------------------------------------------------------------------------------------------------------
[pag116 deitel]
Example 
Consider a program designed to find the power of 3 larger than 100. 
	int product = 3;
	while ( product <= 100 )
		product = 3 * product;
When the while statement begins execution, product's value is 3. Each repetitiion multiplies product by 3, so product takes on the values 9, 27, 81, and 243 successively. When product becomes 243, the while statement condition (product <= 100) becomes false. This terminates the repetition, so the final value of product is 243. 
see also voce >> DO...WHILE REPETITION STATEMENT [from pag168deitel] 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> while statement [pag 19 moo book]
while (condition)
	{
		statement1
		statement2
		ect
	}
that loosely speaking means : "as long as the condition is true do whatever is within the {}"
La vita designata dal demiurgo in un certo senso e' un while loop
As long as they are alive throw a lot of shit on them.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


>> LOOP DO / >> DO LOOP [pag53 mike]
Like while loops, do loops let you repeat a section of code based on an expression. The difference is htat a do loop tests its expression after each loop iteration. This means that the loop body is always executed at least once. Here's a generic form of a do loop
	do
		statement;
	while (expression)
the program executes statement and then, as long as expression tests true, the loop repeats. Once expression tests false, the loop ends.
Example:
	// Play Again 2.0
	// Demonstrates do loops
	
	#include <iostream>
	using namespace std;
	
	int main() 
	{
		char again;
		do 
		{
			cout << "\n**Played an exciting game**";
			cout << "\nDo you want to play again? (y/n): ";
			cin >> again;
		} while (again == 'y');
	
		cout << "\nOkay, bye.";
	
		return 0;
	}
//
---------------------------------------------
NOTE: even though you can use while and do loops pretty interchangeably, most programmers use the while loop. Alghough a do loop might seem more natural in some cases, the advantage of a while loop is that its expression appears right at the top of the loop; you don't have to go hunting to the bottom of the loop to find it. 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> LOOPS overview [jesse book pag 176]
>> LABELS [jesse book pag 176]
In the primitive days of early computer science loops consisted of a label, some statements and a jump that went to the label. 
In C++ a label is just a name followed by a colon. The label is placed to the left of a legal C++ statement. [cioe' metti la label a sinistra dello statement che vuoi labellizzare. E' a partire da questo statement che il loop comincera']
>> goto statement : write "goto" followed by a label name. This causes an inconditioned jump to the label. 
EXAMPLE
	// Listing 7.1
	// Looping with goto
	#include <iostream>
	
	int main()
	{
	     using namespace std;
	     int counter = 0;        // initialize counter
	loop:   // ecco la label messa "a sinistra" = "prima" dello statement a partire dal quale vuoi far cominciare il loop.
	     counter ++;             // top of the loop
	     cout << "counter: " << counter << endl;   // printa to screen the value of counter
	     if (counter < 5)        // test the value
	        goto loop;           // jump to the top
	  
	     cout << "Complete. Counter: " << counter << endl;
	     return 0;
	}
/////////////////////////////
AS A RULE AVOID "goto". The indiscriminate use of goto statements can create tanled, miserable, impossible to read programs known as "spaghetti code"
To avoid the use of goto, more sophisticad, tighlty controlled looping commands have been introduced: for, while, do...while
>> WHILE LOOP 
Let's rewrite the above "Listing 7.1" using a while loop. 
	// Listing 7.2
	// Looping with while
	#include <iostream>
	  
	int main()
	{
	   using namespace std;
	   int counter = 0;           // initialize the condition
	  
	   while(counter < 5)         // test condition still true
	   {
	      counter++;              // body of the loop
	      cout << "counter: " << counter << endl;
	   }
	  
	   cout << "Complete. Counter: " << counter << endl;
	   return 0;
	}
///////////////////////////////
NOTE gergo: si dice ">> fall through the loop" per indicare che la condizione del loop non e' piu' soddisfatta, quindi si esce dal loop e si esegue l'istruzione successiva, cioe' si cade giu'fuori dal loop.  
------------------------------- Altro while loop example;
// Listing 7.3
// Complex while statements
#include <iostream>

int main()
{
   using namespace std;
   unsigned short small;
   unsigned long  large;
   const unsigned short MAXSMALL=65535;
  
   cout << "Enter a small number: ";
   cin >> small;
   cout << "Enter a large number: ";
   cin >> large;
  
   cout << "small: " << small << "...";
     
	// for each iteration, test two conditions
   while (small < large  && small < MAXSMALL)  // true se sia "small < large" che "small < MAXSMALL" son veri.
   {
      if (small % 5000 == 0)  // write a dot every 5k lines  // questa condizione returns the value of zero only when small is an exact multiple of 500.
         cout << ".";
  
      small++;
      large-=2;
   }
  
   cout << "\nSmall: " << small << " Large: " << large << endl;
   return 0;
}
---------------------------------------------------------------------------
>> CONTINUE and >> BREAK loop [pag180 jesse book]
The "continue" statement  jumps back to the top of the loop 
The "break" statement immediately exists the loop and programm execution resumes after the closing brace. 
NOTE: Bith "continue" and "break" should be used with caution. They are the next most dangerous commands after goto, for much the same reason. Programs that suddenly chnge direction are harder to understand and liberal use of continue and break can render even a small white loop unreadable. A need for breaking within a loop often indicates that the terminating condition of the loop has not been set up with the appropriate Boolean expression. It is often better to use an if statement within a loop to skip some lines than to use a breaking statement.
Example 
---------------------------------------------------------------------------
	// Listing 7.4 -  Demonstrates break and continue
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	
	   unsigned short small;
	   unsigned long  large;
	   unsigned long  skip;
	   unsigned long target;
	   const unsigned short MAXSMALL=65535;
	
	   cout << "Enter a small number: ";
	   cin >> small;
	   cout << "Enter a large number: ";
	   cin >> large;
	   cout << "Enter a skip number: ";
	   cin >> skip;
	   cout << "Enter a target number: ";
	   cin >> target;
	
	   cout << "\n";
	
	   // set up 3 stop conditions for the loop
	   while (small < large && large > 0 && small < MAXSMALL)
	   {
	      small++;
	
	      if (small % skip == 0)  // skip the decrement?
	      {
	         cout << "skipping on " << small << endl;
	         continue;    // si ritorna immediatamente alla while condition e si riprende da li'
	      }
	
	      if (large == target)    // exact match for the target?
	      {
	         cout << "Target reached!";
	         break;  // si esce immediatamente dal while loop
	      }
	
	      large-=2;
	   }                   // end of while loop
	
	   cout << "\nSmall: " << small << " Large: " << large << endl;
	   return 0;
	}
------------------------------------------------------------------
>> INFINITE LOOP / >> never end loop 
[pag183 jesse]
As long as the condition remains true, the while loop continues so if you write "while (true) {}" continuera' a loopare forever a meno che gli metti dentro un break o stacchi la spina del computer.
Example
	// Listing 7.5
	// Demonstrates a while true loop
	
	#include <iostream>
	
	int main()
	{
	   int counter = 0;
	
	   while (true)
	   {
	      counter ++;
	      if (counter > 10)
	         break;
	   }
	   std::cout << "Counter: " << counter << std::endl;
	   return 0;
	}
-------------------------------------------------
NOTE: This program works, but it isn't pretty. This is a good example of using the wrong tool for the job. The same thing can be accomplished by putting the test of counter's value where it belongs, in the while condition. 
C++ gives you many ways to accomplish the same task. The real trick is picking the right tool for the particular job.
-------------------------------------------------
>> do while loop [pag186 jesse]
The do.. while loop executes the body of the loop before its condition is tested, thus ensuring that the body alsways executes at least once. 
Here's an example:
	// Listing 7.7
	// Demonstrates do while
	 
	#include <iostream>
	 
	int main()
	{
	   using namespace std;
	   int counter;
	   cout << "How many hellos? ";
	   cin >> counter;
	   do
	   {
	      cout << "Hello\n";
	      counter--;
	   }  while (counter >0 );
	   cout << "Counter is: " << counter << endl;
	   return 0;
	}
-------------------------------------------------------------------
>> for loop vs >> while loop [pag188 jesse]

// Listing 7.8
// Looping with while
 
#include <iostream>
 
int main()
{
    int counter = 0;     //  1) starting condition
 
    while(counter < 5)   //  2) test of the condition
    {
       counter++;        //  3) action (incrementing the counter variable)
       std::cout << "Looping!  ";
    }
 
    std::cout << "\nCounter: " << counter << std::endl;
    return 0;
}
-----------------------------
With a for loop, the 1) 2) 3) steps above are combined into a single statement. 

// Listing 7.9
// Looping with for
  
#include <iostream>
  
int main()
{
   int counter;
   for (counter = 0; counter < 5; counter++)   // 1) initialization / 2) test of the condition / 3) action (incrementing counter variable)
      std::cout << "Looping! ";
  
   std::cout << "\nCounter: " << counter << std::endl;
   return 0;
}
-----------------------------------------------------------
NOTE: abount "3) action": non si deve limitare necessariamente solo a "increamenting counter variable" in realta dentro ci puoi mettere anche altre istruzioni tipo printare il counter to screen. See @actionStatementLongHauler@ below 
-----------------------------------------------------------
>> FOR LOOPS with multiple initialization and increments 
>> MULTIPLE variable initialization in for loop.
[pag190 jesse]
It is not uncommon to initialize more than one variable, to test a compound logical expression and to execute more than one statement. 
The initialization and the action can be replaced by multiple C++ statements, each separated by a comma.
EXAMPLE :
	//listing 7.10
	// demonstrates multiple statements in
	// for loops
	#include <iostream>
	  
	int main()
	{
	  
	   for (int i=0, j=0; i<3; i++, j++)
	      std::cout << "i: " << i << " j: " << j << std::endl;
	   return 0;
	}
--------------------------------------------------------------
NOTE on the for cycle above: when the program executes, the test i<3 is evaluated, and because it is true, the body of the for statement is executed, where the values are printed. Finally, the third clause in the for statement is executed (i++ e j++ both i and j are incremented). 
--------------------------------------------------------------
>> Null Statements in for loops [pag191 jesse book]
Any or all the statements in a for loop can be left out. To accomplish this, you use a null statement. A null statement is simply the use of a semicolon (;) to mark where the statement would have been. Using a null statement, you can create a for loop that acts exactly like a "while" loop by leaving out the first and third statements. 
Example 
	// Listing 7.11
	// For loops with null statements
	 
	#include <iostream>
	 
	int main()
	{
	    int counter = 0;
	 
	    for( ; counter < 5; )      // vedi il ";" che precede counter, e' questo il semicolon used to mark where the statements would have been.
	    {
	       counter++;
	       std::cout << "Looping!  ";
	    }
	 
	    std::cout << "\nCounter: " << counter << std::endl;
	    return 0;
	}
----------------------------------------------------------
NOTE: for( ; counter < 5; )  behaves exactly like "while (counter < 5)"
NOTE2: no experienced C++ programmer would use a for loop in this way, but it illustrate the flexibility of the for statement. 
In fact, it is possible, using break and continue, to create a for loop with none of the three statements. The following example illustrates how: 
	//Listing 7.12 illustrating
	//empty for loop statement
	
	#include <iostream>
	
	int main()
	{
	   int counter=0;      // initialization
	   int max;
	   std::cout << "How many hellos?";
	   std::cin >> max;
	   for (;;)            // a for loop that doesn't end: initialization, test and action have all been taken out of the for statement. 
	   {
	      if (counter < max)     // test
	      {
	         std::cout << "Hello! " << std::endl;
	         counter++;          // increment
	      }
	      else
	         break;
	   }
	   return 0;
	}
-----------------------------------------------------------------
Although thsi particular program is somewhat absurd, sometimes a for(;;) loop or a while(true) loop is just what you'll want. 
-----------------------------------------------------------------
>> EMPTY for loops [pag192 jesse]
Because so much can be done in the header of a "for" statement, at times you won't need the body to do anything at all. In that case, be certain to put a >> null statement (;) as the body of the loop. The semicolon can be on the same line as the header, but this is easy to overlook. Ecco perche' nell'esempio seguente, il semicolon viene messo in una linea separata. 

	//Listing 7.13
	//Demonstrates null statement
	// as body of for loop
	  
	#include <iostream>
	int main()
	{
	   for (int i = 0; i<5; std::cout << "i: " << i++ << std::endl)   // @actionStatementLongHauler@
	      ;     // ecco vedi, qui mette il ";" che fa da null statement, cosicche' il body del for loop non fa nulla. E' nell'header stesso dove si ha tutta l'action.
	   return 0;
	}
---------------------------------------------------
NOTE: this is not a well-designed for loop. The action statement is doing too much. This would be better rewritten as 
	for (int i = 0; i<5; i++)
		cout << "i: " << i << endl;
Although both do the same thing, this example is easier to understand.
//////////////////////////////////////////////////////////////////////
>> Nesting Loops [pag193 jesse book]
Any of the loop can be nested within the body of another. The inner loop will be executed in full every execution of the outer loop. 
Example: 
	//Listing 7.14
	//Illustrates nested for loops
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	   int rows, columns;
	   char theChar;
	   cout << "How many rows? ";
	   cin >> rows;
	   cout << "How many columns? ";
	   cin >> columns;
	   cout << "What character? ";
	   cin >> theChar;
	   for (int i = 0; i<rows; i++)
	   {
	      for (int j = 0; j<columns; j++)   // this inner loop is executed for each iteration of the outer loop.
	         cout << theChar;
	      cout << endl;
	   }
	   return 0;
	}
//--------------------------------------------------------------------------------
NOTE: many C++ preogrammers use the letters i and j as counting variables. This traidition goes all the way back to FORTRAN, in which the letters i, j, k, l, m, n were the only counting variables.
Although thsi might seem innocuous, readers of you program can become confused by the purpose of the counter and might use it improperly. 
It is better to indicate the use of the index variable in its name (for instance CustomerIndex or InputCounter)
----------------------------------------------------------------------------------
>> SCOPE in FOR LOOPS / >> SCOPING IN FOR LOOPS [pag195 jesse]
In the past variables delcared in  the for loop were scoped to the outer block. The  Amerinca National Standards Institute (ANSI) standard changes this to scope these variables only to the block of the for loop itself. However not every compiler supports this change. 
You can test your compiler with the following code 
	#include <iostream>
	int main()
	{
		// i scoped to the for loop?
		for (int i = 0; i<5; i++)
		{
			std::cout << "i: " << i << std::endl;
		}
		
		i = 7; // should not be in scope!
		return 0; 
	}
// si' testato con DEVC++ on windows 7 orion dona errore a segno che DEVC++ 5.11 does support the new ANSI standard. On order to write code that will compile on either compiler (old and newer) we need to declare "i" outside of the loop, as shown here:
	#include <iostream>
	int main()
	{
		int i; // dichiariamo la "i" counter outside the for loop
		for (i = 0; i<5; i++)  // la dichiarazione e' gia' avvenuta al di fuori del loop header, qui non ci resta che inizializzare la "i"
		{
			std::cout << "i: " << i << std::endl;
		}
		
		i = 7; // should not be in scope!
		return 0; 
	}
------------------------------------------------------------------------------------------
>> SUMMING UP LOOPS / >> FIBONACCI SERIES using iteration ( = i.e. using for loops) [pag196 jesse] 
	// Listing 7.15 -  Demonstrates solving the nth
	// Fibonacci number using iteration
	
	#include <iostream>
	
	unsigned int fib(unsigned int position);
	int main()
	{
	   using namespace std;
	   unsigned int answer, position;
	   cout << "Which position? ";
	   cin >> position;
	   cout << endl;
	
	   answer = fib(position);
	   cout << answer << " is the ";
	   cout << position << "th Fibonacci number. " << endl;
	   return 0;
	}
	
	unsigned int fib(unsigned int n)
	{
	   unsigned int minusTwo=1, minusOne=1, answer=2;
	
	   if (n < 3)
	      return 1;
	
	   for (n -= 3; n != 0; n--)
	   {
	      minusTwo = minusOne;
	      minusOne = answer;
	      answer = minusOne + minusTwo;
	   }
	
	   return answer;
	}
------------------------------------------------
NOTE1 : This approach is faster and uses less memory than the recursive solution [la quale era stata presentata a pag124 128jesse book]
NOTE2 : Instead of  
	for (n -= 3; n != 0; n--)
you could also write 
	for (n -= 3; n ; n--)
Cioe' al posto di usare a relational condition (n != 0) utilizziamo semplicemente il valore di n. Using just n relies in the fact that when "n" reaches 0, it will evaluate false, because 0 has been considered as false in C++
-----------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////// 
>> SWITCH  / >> CONTROL FLOW with switch statements [pag198 jesse]
If...else statements can become quite confusing when nested too deeply, and C++ offers an alternative. Unlike "if", which evaluates one value, "switch" statements enable you to branch on any of several values. The general form of the switch statement is 

 	switch (expression)
	{
		case valueOne: statement;
					   break;
		case valueTwo: statement;
					   break;
		...

		case valueN: statement;
					   break;
		default      statement;

	}

"expression" is any legal C++ expression and the statements are any legal C++ statements or block of statements that evaluate (or can be unambiguously converted to) an integer value. 
Note however, that the evaluation is for equality only; relational operators cannot be used here, nor Boolean operations. 
If one of the "case" values matches the expression, program execution jumps to those statements and continues to the end of the "switch" block unless a break statement is encountered [cioe' supponi che "valueOne" matcha l'"expression", allora eseguira gli statement relativi a valueOne e appena incontra il "break" esci dal blocco switch, se non matcha continuera ad evaluare tutti gli altri case che hai elencato fino ad eseguire default se nessuno dei cases precedenti ha matchato] 
SUMMARY 
The switch statement allows for branching on multiple values of expressions. The expression is evaluated, and if it matches any of the case values, execution jumps to that line. Execution continues until either the end of the switch statement or a break statement is encountered.
If "expression" does not match any of the case statements, and if there is a default statement, execution swithces to the default statement, otherwise the switch statement ends.
TIP
	It is almost always a good idea to have a "default" case in "switch" statements. If you have no other need for the default, use it to test for the supposedly impossible case, and print out an error message; this can be a tremendous aid in debugging.
EXAMPLE :
	//Listing 7.16
	// Demonstrates switch statement
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	   unsigned short int number;
	   cout << "Enter a number between 1 and 5: ";
	   cin >> number;
	   switch (number)   // l'espressione data in pasto a switch e' il numero immesso dall'utente
	   {
	     case 0:   cout << "Too small, sorry!";
	               break;
	     case 5:   cout << "Good job!"   << endl; // fall through
	     case 4:   cout << "Nice Pick!"  << endl; // fall through
	     case 3:   cout << "Excellent!"  << endl; // fall through
	     case 2:   cout << "Masterful!"  << endl; // fall through
	     case 1:   cout << "Incredible!" << endl;
	               break;
	     default:  cout << "Too large!" << endl;
	               break;
	   }
	   cout << endl << endl;
	   return 0;
	}
----------------------------------------------------------------------------------------------
NOTE:
Che cosa succede se dimenticassimo di scrivere "break" dopo lo statement di un case?
Ciccio anwer: l'abbiamo testato con il seguente programma: cio' che succede e' che se il primo caso matcha l'espressione, e tale caso non ha il break, allora non solo eseguira' il primo caso, ma pure tutti gli altri casi che seguono finche non incontra un break
Exempio 
	// Demonstrates switch statement
	#include <iostream>
	
	int main()
	{
	   using namespace std;
	   unsigned short int number;
	   cout << "Enter a number between 1 and 5: ";
	   cin >> number;
	   switch (number)
	   {
	     case 0:   cout << "Too small, sorry!";
	               //break;                            // DIMENTICATO PER INADVERTENZA 
	     case 5:   cout << "Good job!"   << endl; // fall through  continua ad eseguire
	     case 4:   cout << "Nice Pick!"  << endl; // fall through  continua ad eseguire
	     case 3:   cout << "Excellent!"  << endl; // fall through  continua ad eseguire
	     case 2:   cout << "Masterful!"  << endl; // fall through  continua ad eseguire
	     case 1:   cout << "Incredible!" << endl;
	               break;                         // qui finalmente si stoppa
	     default:  cout << "Too large!" << endl;
	               break;
	   }
	   cout << endl << endl;
	   return 0;
	}
------------------------ in console input 0 e otterrai 
	Enter a number between 1 and 5: 0
	Too small, sorry!Good job!
	Nice Pick!
	Excellent!
	Masterful!
	Incredible!
-------------------------------------------------------
vedi ha eseguito tutti i casi seguenti fino al caso "1" che aveva il break, quindi si stoppa e non esegue piu' il default. Ecco perche' non vedi comparire il messaggio "too large"
Jesse answer
If no break statement is at the end of a case statement, execution falls through to the next "case" statement. This is sometimes necessary bu usually is an error. If you decide to let execution fall through, be certain to put a comment indicating that you didn't just forget the break.
------------------------------------------------------- 
>> Forever loop with switch statement / >> switch statement  with forever loop / >> menu input from user with infinite loop until he decides to exit [pag201 jesse]
The following program use for(;;) to create a forever loop that will loop forever unless a break is encountered. In this program the forever loop is used to put up a menu, solicit a choice from the user, act on the choice, and then return to the menu. This continues until the user chooses to exit.
EXAMPLE 
	//Listing 7.17
	//Using a forever loop to manage user interaction
	#include <iostream>
	
	// prototypes
	int menu();
	void DoTaskOne();
	void DoTaskMany(int);
	
	using namespace std;
	
	int main()
	{
	   bool exit = false;
	   for (;;)
	   {
	      int choice = menu();   // the menu function is called. It prints the menu to the screen and returns the user's selection
	      switch(choice)
	      {
	        case (1):
	            DoTaskOne();
	            break;
	        case (2):
	            DoTaskMany(2);
	            break;
	        case (3):
	            DoTaskMany(3);
	            break;
	        case (4):
	            continue;  // redundant!
	            break;
	        case (5):
	            exit=true;
	            break;
	        default:
	            cout << "Please select again! " << endl;
	            break;
	      }             // end switch
	
	      if (exit == true)
	         break;
	   }                // end forever
	   return 0;
	}                   // end main()
	
	int menu()
	{
	   int choice;
	
	   cout << " **** Menu **** "   << endl << endl;
	   cout << "(1) Choice one. "   << endl;
	   cout << "(2) Choice two. "   << endl;
	   cout << "(3) Choice three. " << endl;
	   cout << "(4) Redisplay menu. " << endl;
	   cout << "(5) Quit. "    << endl << endl;
	   cout << ": ";
	   cin >> choice;
	   return choice;
	}
	
	void DoTaskOne()
	{
	   cout << "Task One! " << endl;
	}
	
	void DoTaskMany(int which)
	{
	   if (which == 2)
	      cout << "Task Two! " << endl;
	   else
	      cout << "Task Three! " << endl;
	}
----------------------------------------------------------------------------------------------------------------
NOTE:
A forever loop is a loop that does not have an exit condition. To exit the loop, a break statement must be used. Forever loops are also known as eternal or infinite loops. Some programmers instead of for(;;) like to write 
#define EVER ;;  // qui definisci "EVER" come equivalente a ";;"
for (EVER)   // itsumademoooo beach boys!
{
	// statements ...
}
----------------------------------------------------- Q&A loops [from pag 205 peugeut jesse book]
- How do I choose between if...else and switch?
If more than just one or two else clauses are used, and all are testing the same value, consider using a swithc statement. 
- How do I choose between while and do...while?
If the body of the loop should always execute at least once, consider a do...while loop; otherwise, try to use the while loop. 
- How do I choose beween while and for?
If you are initializing a counting variable, testing that variable, and incrementing it each time through the loop, consider the "for" loop. If your variable is already initialized and is not incremented on each loop,  a "while" loop might be the better choice. Experienced programmers look for this usage and will find your program harder to understand if you violate this expectation.   
------------------------------------------------------------------------------------------------
>> REVIEW WEEK 1 Jesse Book / >> WEEK 1 REVIEW 
/* Listing: WR01.cpp
 * Description: Week in Review listing for week 1
 *===============================================*/
#include <iostream>
using namespace std;

enum CHOICE { 
      DrawRect = 1, 
      GetArea, 
      GetPerim, 
      ChangeDimensions, 
      Quit  };

// Rectangle class declaration
class Rectangle
{
  public:
     // constructors
     Rectangle(int width, int height);
     ~Rectangle();

     // accessors
     int GetHeight() const { return itsHeight; }
     int GetWidth() const { return itsWidth; }
     int GetArea() const { return itsHeight * itsWidth; }
     int GetPerim() const { return 2*itsHeight + 2*itsWidth; }
     void SetSize(int newWidth, int newHeight);

     // Misc. methods

  private:
     int itsWidth;
     int itsHeight;
};

// Class method implementations
void Rectangle::SetSize(int newWidth, int newHeight)
{
   itsWidth = newWidth;
   itsHeight = newHeight;
}

Rectangle::Rectangle(int width, int height)
{
   itsWidth = width;
   itsHeight = height;
}

Rectangle::~Rectangle() {}

int DoMenu();
void DoDrawRect(Rectangle);
void DoGetArea(Rectangle);
void DoGetPerim(Rectangle);

/*===============================================*/
int main()
{
   // initialize a rectangle to 30,5
   Rectangle theRect(30,5);

   int choice = DrawRect;
   int fQuit = false;

   while (!fQuit)
   {
     choice = DoMenu();
     if (choice < DrawRect || choice >  Quit)
     {
        cout << "\nInvalid Choice, try again. ";
        cout << endl << endl;
        continue;
     }
     switch (choice)
     {
       case  DrawRect:
          DoDrawRect(theRect);
          break;
       case GetArea:
          DoGetArea(theRect);
          break;
       case GetPerim:
          DoGetPerim(theRect);
          break;
       case ChangeDimensions:
          int newLength, newWidth;
          cout << "\nNew width: ";
          cin >> newWidth;
          cout << "New height: ";
          cin >> newLength;
          theRect.SetSize(newWidth, newLength);
          DoDrawRect(theRect);
          break;
       case Quit:
          fQuit = true;
          cout << "\nExiting... " << endl << endl;
          break;
       default:
          cout << "Error in choice!" << endl;
          fQuit = true;
          break;
     }   // end switch
   }     // end while
   return 0;
}       // end main

int DoMenu()
{
   int choice;
   cout << endl << endl;   // create two new lines
   cout << "   *** Menu *** "   << endl;
   cout << "(1) Draw Rectangle" << endl;
   cout << "(2) Area"           << endl;
   cout << "(3) Perimeter"      << endl;
   cout << "(4) Resize"         << endl;
   cout << "(5) Quit"           << endl;

  cin >> choice;
  return choice;
}

 void DoDrawRect(Rectangle theRect)
 {
   int height = theRect.GetHeight();
   int width = theRect.GetWidth();

   for (int i = 0; i<height; i++)
   {
     for (int j = 0; j< width; j++)
        cout << "*";
     cout << endl;
   }
 }


 void DoGetArea(Rectangle theRect)
 {
   cout << "Area: " <<  theRect.GetArea() << endl;
 }

 void DoGetPerim(Rectangle theRect)
 {
   cout << "Perimeter: " <<  theRect.GetPerim() << endl;
 }
// ==========   End of Listing   ==========

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



>> WIDTH / >> setw
[pag576 deitel]
The width member function (of base class ios_base) sets th field width (i.e. the number of character positions in which a value should be output or the maximum number of characters  positions in which a value should be output or the maximum number of characters that should be input) and returns the previous width
- If values output are narrower than the field width, fill characters are inserted as padding.
- the width setting applies only for the next insertion or extraction (i.e. the width setting is not sticky) 


>> WRAP / >> new line avoid / >> avoid new line creation when 80 column is reached:
Edit -> File settings -> Text width
e metti 0 al posto di 80 in tal modo non andra' piu' a capo automaticamente una volta che superi l'80 esima colonna.

>> WRITE TO A TEXT FILE 
// writing on a text file
#include <iostream>
#include <fstream>
using namespace std;

int main () {
  ofstream myfile ("example.txt")
  if (myfile.is_open())
  {
    myfile << "This is a line.\n";
    myfile << "This is another line.\n";
    myfile.close();
  }
  else cout << "Unable to open file";
  return 0;
}
[source http://www.cplusplus.com/doc/tutorial/files/
salvato anche in blackbird as : Input_output with files - C++ Tutorials]

>> WRITE STANDARD STRING TO FILE / >> BINARY ISSUE 
You're currently writing the binary data in the string-object to your file. This binary data will probably only consist of a pointer to the actual data, and an integer representing the length of the string.
If you want to write to a text file, the best way to do this would probably be with an ofstream, an "out-file-stream". It behaves exactly like std::cout, but the output is written to a file.

The following example reads one string from stdin, and then writes this string to the file output.txt.

#include <fstream>
#include <string>
#include <iostream>

int main()
{
    std::string input;
    std::cin >> input;
    std::ofstream out("output.txt");
    out << input;
    out.close();
    return 0;
}

Note that out.close() isn't strictly neccessary here: the deconstructor of ofstream can handle this for us as soon as out goes out of scope.

For more information, see the C++-reference: http://cplusplus.com/reference/fstream/ofstream/ofstream/

Now if you need to write to a file in binary form, you should do this using the actual data in the string. The easiest way to acquire this data would be using string::c_str(). So you could use:
write.write( studentPassword.c_str(), sizeof(char)*studentPassword.size() );
[http://stackoverflow.com/questions/15388041/how-to-write-stdstring-to-file]
//////////////////////////////////////////////////////////////

>> out of scope [pag175 mike programming game]
A variable goes out of scope when the scope in which it was created ends. Variable going out of scope means the variable ceased to exist. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

>> WRITE TO FILE nostro esempio tratto
	#include <fstream>
	#include <string>
	#include <iostream>

	int main()
	{
		std::string input = "Eri and Yui Queen of Fairies" ;
		std::ofstream out("output.txt");
		out << input;
		out.close();
		return 0;
	}
///////////////////////////////////////
NOTE: [tag]  >> .write( 
non devi usare 
	nomeFile.write(input) 
bensi 
	out << input
///////////////////////////////////////


>> WRITE TO FILE string + variable + string
// obtaining file size
#include <iostream>
#include <fstream>
using namespace std;

int main () {
  streampos begin,end;
  ifstream myfile ("example.bin", ios::binary);
  begin = myfile.tellg();
  myfile.seekg (0, ios::end);
  end = myfile.tellg();
  myfile.close();
  cout << "size is: " << (end-begin) << " bytes.\n";    //    <---- il succo
  return 0;
}
///////////////////////////////////////////////////
il precedente donera' in output 
size is: 40 bytes.
NOTE: quindi cio' che in python si scriveva con dei piu'
	cout "testa della stringa " + nomeVariabile + " codaDellaStringa\n"
in C++ diventa
	cout "testa della stringa " << nomeVariabile << " codaDellaStringa\n";
NOTE2: nel caso tu non voglia outputtare nello screen bensi' scrivere su file puoi 
	ofstream ciccioFile;
	ciccioFile.open ("output127.txt");  
	ciccioFile << "testa della stringa " << nomeVariabile << " codaDellaStringa\n";
e ti scrivera' il tutto in ciccioFile
Nota come "ciccioFile" da un punto di vista ontologico altri non e' che un ofstream object a cui viene associato il file output127.txt
"ciccioFile" e' un object a cui puoi applicare metodi come .open
[source http://www.cplusplus.com/doc/tutorial/files/]


>> XXXXXXX

>> YYYYYYY

>> ZZZZZZZ


------------------------------------------------
SEZIONE ECLIPSE IDE 
vedi il file ECLIpse nella stessa directory di questo Cplusplus file.
------------------------------------------------
SEZIONE Qt IDE
[installation:
il seguente e' fallito in opensuse usiamo allora KDevelop che tra l'altro e' costruito su Qt 
- entra nella cartella che contiene il .run file
- se necessario lo rendiamo eseguibile con 
	chmod +x filename ]
- quindi 
	sh nomefile.run [in alcuni casi e' necessario essere root]
------------------------------------------------
SEZIONE KDevelop4
------------------------------------------------
====
zxcv
====  
